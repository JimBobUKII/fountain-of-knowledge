<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Debug Node.js within a container | Fountain of Knowledge </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Debug Node.js within a container | Fountain of Knowledge ">
    <meta name="generator" content="docfx 2.57.2.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    <meta property="docfx:rel" content="../../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../../index.html">
                <img id="logo" class="svg" src="../../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="debug-nodejs-within-a-container">Debug Node.js within a container</h1>

<p>When adding Docker files to a Node.js project, tasks and launch configurations are added to enable debugging that application within a Docker container. However, due to the large ecosystem surrounding Node.js, those tasks cannot accommodate every application framework or library, which means that some applications will require additional configuration.</p>
<h2 id="configuring-the-docker-container-entry-point">Configuring the Docker container entry point</h2>
<p>The Docker extension infers the entry point of the Docker container--that is, the command line for starting the application in a debug mode within the Docker container--via properties of <code>package.json</code>.  The extension first looks for the <code>start</code> script in the <code>scripts</code> object; if found and, if it starts with a <code>node</code> or <code>nodejs</code> command, it uses that to build the command line for starting the application in debug mode.  If not found or, if not a recognized <code>node</code> command, the <code>main</code> property in the <code>package.json</code> is used.  If neither is found or recognized, then you need to explicitly set the <code>dockerRun.command</code> property of the <code>docker-run</code> task used to start the Docker container.</p>
<p>Some Node.js application frameworks include CLIs for managing the application and are used to start the application in the <code>start</code> script, which obscure the underlying <code>node</code> commands. In these cases, the Docker extension cannot infer the start command and you must  explicitly configure the start command.</p>
<h3 id="example-configuring-the-entry-point-for-a-nestjs-application">Example: Configuring the entry point for a <a href="https://nestjs.com/">Nest.js</a> application</h3>
<pre><code class="lang-json">{
    &quot;tasks&quot;: [
        {
            &quot;type&quot;: &quot;docker-run&quot;,
            &quot;label&quot;: &quot;docker-run: debug&quot;,
            &quot;dependsOn&quot;: [
                &quot;docker-build&quot;
            ],
            &quot;dockerRun&quot;: {
                &quot;command&quot;: &quot;nest start --debug 0.0.0.0:9229&quot;,
            },
            &quot;node&quot;: {
                &quot;enableDebugging&quot;: true
            }
        }
    ]
}
</code></pre>
<h3 id="example-configuring-the-entry-point-for-a-meteor-application">Example: Configuring the entry point for a <a href="https://www.meteor.com/">Meteor</a> application</h3>
<pre><code class="lang-json">{
    &quot;tasks&quot;: [
        {
            &quot;type&quot;: &quot;docker-run&quot;,
            &quot;label&quot;: &quot;docker-run: debug&quot;,
            &quot;dependsOn&quot;: [
                &quot;docker-build&quot;
            ],
            &quot;dockerRun&quot;: {
                &quot;command&quot;: &quot;node --inspect=0.0.0.0:9229 main.js&quot;,
            },
            &quot;node&quot;: {
                &quot;enableDebugging&quot;: true
            }
        }
    ]
}
</code></pre>
<h2 id="automatically-launching-the-browser-to-the-entry-page-of-the-application">Automatically launching the browser to the entry page of the application</h2>
<p>The Docker extension can automatically launch the browser to the entry point of the application after it has started in the debugger. This feature is enabled by default and configured via the <code>dockerServerReadyAction</code> object of the debug configuration in <code>launch.json</code>.</p>
<p>This feature depends on several aspects of the application:</p>
<ul>
<li>The application must output logs to the debug console.</li>
<li>The application must log a &quot;server ready&quot; message.</li>
<li>The application must serve a browsable page.</li>
</ul>
<p>While the default settings may work for an Express.js based application, other Node.js frameworks may require explicit configuration of one or more of those aspects.</p>
<h3 id="ensuring-application-logs-are-written-to-the-debug-console">Ensuring application logs are written to the debug console</h3>
<p>This feature depends on the application writing its logs to the debug console of the attached debugger.  However, not all logging frameworks write to the debug console, even when configured to use a console-based logger (as some &quot;console&quot; loggers actually bypass the console and write directly to <code>stdout</code>).</p>
<p>The solution varies depending on the logging framework, but it generally requires creating/adding a logger that <em>actually</em> writes to the console.</p>
<h3 id="example-configuring-express-applications-to-write-to-the-debug-console">Example: Configuring Express applications to write to the debug console</h3>
<p>By default, <a href="https://expressjs.com/">Express.js</a> uses the <a href="https://github.com/visionmedia/debug">debug</a> logging module, which can bypass the console.  This can be resolved by explicitly binding the log function to the console's <code>debug()</code> method.</p>
<pre><code class="lang-js">var app = require('../app');
var debug = require('debug')('my-express-app:server');
var http = require('http');

// Force logging to the debug console.
debug.log = console.debug.bind(console);
</code></pre>
<p>Also note that the <code>debug</code> logger writes logs only when enabled via the <code>DEBUG</code> environment variable, which can be set in the <code>docker-run</code> task. (This environment variable is set to <code>*</code> by default when Docker files are added to the application.)</p>
<pre><code class="lang-json">{
    &quot;tasks&quot;: [
        {
            &quot;type&quot;: &quot;docker-run&quot;,
            &quot;label&quot;: &quot;docker-run: debug&quot;,
            &quot;dependsOn&quot;: [
                &quot;docker-build&quot;
            ],
            &quot;dockerRun&quot;: {
                &quot;env&quot;: {
                    &quot;DEBUG&quot;: &quot;*&quot;
                }
            },
            &quot;node&quot;: {
                &quot;enableDebugging&quot;: true
            }
        }
    ]
}
</code></pre>
<h3 id="configuring-when-the-application-is-ready">Configuring when the application is &quot;ready&quot;</h3>
<p>The extension determines the application is &quot;ready&quot; to receive HTTP connections when it writes a message of the form <code>Listening on port &lt;number&gt;</code> to the debug console, as Express.js does by default.  If the application logs a different
message, then you should set the <code>pattern</code> property of the <a href="debug-common.html#dockerserverreadyaction-object-properties">dockerServerReadyAction</a> object of the debug launch configuration to a <a href="https://developer.mozilla.org../Web/JavaScript/Guide/Regular_Expressions">JavaScript regular expression</a> that matches that message. The regular expression should include a capture group that corresponds to the port on which the application is listening.</p>
<p>For example, suppose the application logs the following message:</p>
<pre><code class="lang-js">function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Application has started on ' + bind);
}
</code></pre>
<p>The corresponding <code>pattern</code> in the debug launch configuration (in <code>launch.json</code>) is:</p>
<pre><code class="lang-json">{
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Docker Node.js Launch&quot;,
            &quot;type&quot;: &quot;docker&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;preLaunchTask&quot;: &quot;docker-run: debug&quot;,
            &quot;platform&quot;: &quot;node&quot;,
            &quot;dockerServerReadyAction&quot;: {
                &quot;pattern&quot;: &quot;Application has started on port (\\d+)&quot;
            }
        }
    ]
}
</code></pre>
<blockquote>
<p>Note the <code>(\\d+)</code> capture group for the port number, and the use of <code>\</code> as a JSON escape character for the backslash in the <code>\d</code> character class.</p>
</blockquote>
<h3 id="configuring-the-application-entry-page">Configuring the application entry page</h3>
<p>By default, the Docker extension will open the &quot;main&quot; page of the browser (however that is determined by the application).  If the browser should be opened to a specific page, the <code>uriFormat</code> property of the <a href="debug-common.html#dockerserverreadyaction-object-properties">dockerServerReadyAction</a> object of the debug launch configuration should be set to a Node.js format string, with one string token that indicates where the port should be substituted.</p>
<p>The corresponding <code>uriFormat</code> in the debug launch configuration (in <code>launch.json</code>) to open the <code>about.html</code> page instead of the main page would be:</p>
<pre><code class="lang-json">{
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Docker Node.js Launch&quot;,
            &quot;type&quot;: &quot;docker&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;preLaunchTask&quot;: &quot;docker-run: debug&quot;,
            &quot;platform&quot;: &quot;node&quot;,
            &quot;dockerServerReadyAction&quot;: {
                &quot;uriFormat&quot;: &quot;http://localhost:%s/about.html&quot;
            }
        }
    ]
}
</code></pre>
<h2 id="mapping-docker-container-source-files-to-the-local-workspace">Mapping Docker container source files to the local workspace</h2>
<p>By default, the Docker extension assumes the application source files in the running Docker container are located in an <code>/usr/src/app</code> folder, and the debugger then maps those files back to the root of the opened workspace, in order to translate breakpoints from the container back to Visual Studio Code.</p>
<p>If the application source files are in a different location (for example, different Node.js frameworks have different conventions), either within the Docker container or within the opened workspace, then one or both of the <code>localRoot</code> and <code>remoteRoot</code> properties of the <a href="debug-node.html#node-object-properties">node</a> object of the debug launch configuration should be set the root source locations within the workspace and the Docker container, respectively.</p>
<p>For example, if the application instead resides in <code>/usr/my-custom-location</code>, the corresponding <code>remoteRoot</code> property would be:</p>
<pre><code class="lang-json">{
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Docker Node.js Launch&quot;,
            &quot;type&quot;: &quot;docker&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;preLaunchTask&quot;: &quot;docker-run: debug&quot;,
            &quot;platform&quot;: &quot;node&quot;,
            &quot;node&quot;: {
                &quot;remoteRoot&quot;: &quot;/usr/my-custom-location&quot;
            }
        }
    ]
}
</code></pre>
<h1 id="troubleshooting">Troubleshooting</h1>
<h2 id="docker-image-fails-to-build-or-start-due-to-missing-node_modules">Docker image fails to build or start due to missing node_modules</h2>
<p>Dockerfiles are often arranged in such a way as to optimize either image build time, image size, or both.  However, not every Node.js application framework supports all of the typical Node.js Dockerfile optimizations. In particular, for some frameworks, the <code>node_modules</code> folder must be an immediate subfolder of the application root folder, whereas, the Docker extension scaffolds a Dockerfile where the <code>node_modules</code> folder exists at a parent or ancestor level (which is generally allowed by Node.js).</p>
<p>The solution is to remove that optimization from the <code>Dockerfile</code>:</p>
<pre><code class="lang-dockerfile">FROM node:10.13-alpine
ENV NODE_ENV=production
WORKDIR /usr/src/app
COPY [&quot;package.json&quot;, &quot;package-lock.json*&quot;, &quot;npm-shrinkwrap.json*&quot;, &quot;./&quot;]
# Remove the `&amp;&amp; mv node_modules ../` from the RUN command:
# RUN npm install --production --silent &amp;&amp; mv node_modules ../
RUN npm install --production --silent
COPY . .
EXPOSE 3000
CMD npm start
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            &#0169; 2021 Jason Rose
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
