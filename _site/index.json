{
  "archive/index.html": {
    "href": "archive/index.html",
    "title": "| Fountain of Knowledge",
    "keywords": ""
  },
  "archive/intune/application-deployment-with-the-help-of-mobile-application-management.html": {
    "href": "archive/intune/application-deployment-with-the-help-of-mobile-application-management.html",
    "title": "Application Deployment with the help of Mobile Application Management (MAM) | Fountain of Knowledge",
    "keywords": "Application Deployment with the help of Mobile Application Management (MAM) Understanding the Office 365 Subscriptions before Deployment Customizing the Office 365 Deployment with ODT and OCT Assigning Apps using Intune Deploying Apps to a Group of Devices using Intune Deploying Apps using Microsoft Store for Business Managing and implementing MAM App Protection policies with Intune"
  },
  "archive/intune/implementing-conditional-access-and-compliance-policies.html": {
    "href": "archive/intune/implementing-conditional-access-and-compliance-policies.html",
    "title": "Implementing Conditional Access and Compliance Policies | Fountain of Knowledge",
    "keywords": "Implementing Conditional Access and Compliance Policies Understanding conditional access policies Using AzureAD to Implement conditional access policies Understanding Device Compliance Policies Implementing and Managing Compliance Policies"
  },
  "archive/intune/index.html": {
    "href": "archive/intune/index.html",
    "title": "Intune Introduction | Fountain of Knowledge",
    "keywords": "Intune Introduction A Foundation of Active Directory Domains So I would start out by doing a drawing to help everybody understand some of the fundamentals of where the industry was, where it is, and kind of where things are flowing right now, especially from the standpoint of Microsoft. So I want to I want to kind of take you back in time a little bit and help you understand it, really help you understand where things are moving right now. If you can also sort of look at where things were at one time. So if you went back far enough, course, I'm not going to go back too far. You had the 1960s, you had mainframes and you had is moved into the 1970s. You also had mainframes, these massive computers that were like room size or at least refrigerator size in most cases. And then as we moved into the 1980s and standardization occurred, computers, the pricing of computers went down and companies could actually afford to get what is called a personal computer. And of course, with the invention of that concept, you had what was called peer to peer networking. Few personal computers, let's say that in your in your organization, your company has a thousand computers. Because it's going to draw a bunch of things and it kind of gets overwhelming when there's a bunch of things on the screen. OK, so we start out with a bunch of computers that say we have a thousand computers now from a from an I.T. person standpoint is we moved in the 1980s and computer in companies wanted to share resources with each other. There was different companies that played a role in this. Microsoft played a role in it with DOFFS and the land manager. Then a company called Novell played a huge role in it. Course, it was also Unix. Then we moved into the 1990s and this became more and more popular as time went on and as companies grew and started needing to be able to manage more and more computers, they needed a system for doing that. And at the time, all we had was what was known as a peer to peer network, which meant every computer is sort of on its own. And that meant that you had to sit down and configure each computer individually. Imagine doing that with a thousand computers. One solution to that was to create scripts, log on scripts that would would automate the process of set things computers up. But it was still a lot of work. And if you had to change one thing on one machine, you had to change it on the others and you had to every computer had to have usernames and passwords that were separate from the others and it just got crazy. So what Microsoft did and again, we were kind of focused on Microsoft here, is they created the concept of of what is called a domain and in their concept was based on some concepts that Novell had implemented and Unix had implemented. And by the time we reached the Nate, the late 1990s, by the time we reached the late 1990s, Microsoft had released in 84 and had domains and the goal of a domain with centralization. Microsoft created a new directory service and a new concept for domains. In fact, the symbol of what is called a Microsoft domain is the symbol of a triangle. So they created this triangle, this domain and the domain would act sort of as the security boundary for your company. So your computers would go inside the security boundary. You had a thousand computers here, part of the security boundary course, something that you did need to to deal with all this if you needed servers that could help you manage these computers. So with that, Microsoft had what was called a domain controller. A domain controller is a server that has a special database. This little cylinder looking thing that I'm drawing is going to be a symbol of a database right here. And that database is called Active Directory. Aidi Active Directory is the directory services structure that manages are Microsoft domains. Now, that directory service is where your user accounts, passwords, groups, all of that stuff is is going to live. And with the creation of domain controllers also came these things called a group policy objects. GPOs allow us to deploy restrictions and settings out to all these machines. So I have the ability to implement this thing called a GPO and the geos can deploy it can apply to all of these computers and they get configured based on the GPO. And of course, generally speaking, when it comes to a domain controller ADC, you want to have more than one of those. So what do you want to have more than one domain controller to manage everything? Well, it's kind of the same reason that we want. If you go to a grocery store and you get a cart load of groceries and you're you're checking out and in, you're taking your cart load of the groceries to the front of the store to check out, the last thing you want to see is for there to be one cashier open, one cash register open to check you out. What do you want to see when you get up there? You want to see a lot of open aisles of cash registers with people work in those cash registers where I can check out and buy my stuff and leave. What I don't want to do is get to the front and there are only to be one cash register open and there's a line of people waiting to get out. All of these computers right here, these 1000 computers that I have need to talk to these domain controllers if I've only got one. Then you've got you've got one machine that's basically having to manage everybody. So you want to more than one. There's basically two main reasons why we have more than one of anything. Redundancy also known as fault tolerance and load balancing. So if one domain controller fails, we've got another one run in. The other reason is for performance. We don't want all of these clients, all of these machines having to just go to. One dimensional, we prefer them to go to multiple now. The other great thing about domain controllers, when you when you think about domain chores is domain controllers replicate. So anything I do to one domain controller, like let's say that this little smiley face guy here that This guy is a user account. So what's going to end up happening is your user account. You create this user account on this domain controller. Guess what it's going to replicate to this other domain controller over here. And it synchronizes that way through what is known as active directory replication. So if you were to come to me and you were to to say, why am I needing. To have a domain, why not just stick with the old style, which was peer to peer networking? This is what I would tell you. I would say centralization. That's why I can tell you why act directory is so important in one word, centralization. A lot of people would say security, security is important, but centralization is why this is so such a key thing we use in our environments. I can manage everything using these domain controllers. I want my company can actually have multiple domains. There's these things called trees and forest. I'm not going to get into that right now, but I can manage my infrastructure using active directory. Now, there are some other key fundamentals to understand about Active Directory. First off, the naming system that Active Directory uses that domains used for managing everything is based upon DNS domain name system. Your domain name will have to be named based upon a DNS style name. So, for example, if I work for a company called Exam Lab Practice and my web presence is exam lab practice dot com, then my domain name may also be called exam lab practice dot com. That might be the name of my DNS name. OK, and all my computers will be based on that DNS name. So if I had a computer called Client One, his his DNS name had fully qualified domain name as it's called, might be called client one dot exam, lab practice, dot com inside this domain. But on top of that you have to have a server that's going to manage all that. So we have to have something called a DNS server domain name system server. What's that going to do? Well, we need domain name servers for the same reason you have an address book with your phone. You don't you don't really like having to memorize lots of phone numbers. So you have an address book. You're able to type somebody's name and their phone number in. And then later you can access their name and get access to the phone number and make the call. Well, DNS does that, except it does it for IP addresses. All these devices have IP addresses and they're going to be registered into your DNS database. Now bring and saying that database, that means that there's also got to be a database on that DNS server. The DNS database is often called a zone database. It's often called a namespace database. And from there, I'm just gonna kind of color code. This will say that exam lab practice, dot com being the company's name in this database you see here is going to manage that, some highlighting it in red, just like it is basically bordered it in red as well. So we got to have DNS. Now, what's going to happen is these computers are all gonna boot up, including if I heads a server. These computers are all gonna boot up and they're going to register with DNS, including this file server guy here that I'm making him. I call him file server. So they're gonna boot up and they're all going to register their names in DNS. The domain controllers are gonna register, the file servers are going to register. Everything's going to register inside DNS. This is what this is a topic known as Dynamic DNS. And this is going to allow computers to all register. Now, what happens is every one of these machines, your client computers, your servers, they all have to locate DNS by their IP settings and they're gonna ask DNS who these guys right here are so that they can all authenticate. So these clients, when they boot up, they're going to say, hey, DNS. Do you happen to know who my domain controllers are for my environment? And DNS is going to reply back with this this information known as service records as arvi information. And it's going to point the client to these domain controllers. The other great thing about Active Directory Active Directory supports the ability to point people to the nearest domain controller so that they can log on and get authenticated. The authentication system that Active Directory uses is based on a protocol called Kerberos. When you hear that name protocol, I want you to think language. It's basically like a language. They speak in an active directory. Security and querying language is built off of two two protocols, really. One of them is called LDAP. Lightweight Directory Access Protocol, which is basically a query language. And Kerberos, which is going to be your security authentication language that it uses. So as we moved into the year 2000, Active Directory was released and this was the big thing everybody's doing. And of course, you know, the big thing, too, is we also have to have an Internet connection. So this little this little cloud thing that I that I just made here, this is gonna be my my Internet connection. And so we've got an Internet connection coming into our company here. And we're also gonna have to protect our Internet. So we're gonna have a firewall. So this little guy right here be my firewall and my firewall is connected to. My internal network, as well as my outside world Internet connection, of course. You know, it's routing is involved there. And and all that stuff as well. So the Internet is the big thing. Everybody's want to be on the Internet and be secure and build access resources. And so Microsoft is making technologies that are available to do this, though. LDAP and Kerberos are both internal based technologies that are not really stuff, something that you exposed to the Internet, which is why you got to have protection and and all of that. A Foundation of RAS, DMZ, and Virtualization A Foundation of the Microsoft Cloud Services Creating a free Microsoft 365 Azure AD Account Introduction to Intune Using the Endpoint Manager Portal to manage Intune"
  },
  "archive/intune/manage-intune-device-enrollment-and-inventory.html": {
    "href": "archive/intune/manage-intune-device-enrollment-and-inventory.html",
    "title": "Manage Intune device enrollment and inventory | Fountain of Knowledge",
    "keywords": "Manage Intune device enrollment and inventory Configuring enrollment settings How to configure device enrollment restrictions Enrolling Windows devices Enrolling Apple, Android as well as understanding Device Enrollment Managers Generating device inventory reports"
  },
  "archive/intune/managing-and-implementing-updates-using-intune.html": {
    "href": "archive/intune/managing-and-implementing-updates-using-intune.html",
    "title": "Managing and Implementing Updates using Intune | Fountain of Knowledge",
    "keywords": "Managing and Implementing Updates using Intune"
  },
  "archive/intune/plan-and-implement-windows-10-by-using-windows-autopilot.html": {
    "href": "archive/intune/plan-and-implement-windows-10-by-using-windows-autopilot.html",
    "title": "Plan and implement Windows 10 by using Windows Autopilot | Fountain of Knowledge",
    "keywords": "Plan and implement Windows 10 by using Windows Autopilot Introduction to Autopilot Extracting and importing Autopilot Hardware IDs Creating autopilot deployment profiles"
  },
  "archive/intune/working-with-device-profiles.html": {
    "href": "archive/intune/working-with-device-profiles.html",
    "title": "Working with Device Profiles | Fountain of Knowledge",
    "keywords": "Working with Device Profiles Understanding and Planning Device Profiles Implementing Device Profiles Managing Device Profiles Deploying Powershell Scripts with Intune"
  },
  "guides/github/create-a-repo.html": {
    "href": "guides/github/create-a-repo.html",
    "title": "Create a repository | Fountain of Knowledge",
    "keywords": "Create a repository To put your project up on GitHub, you'll need to create a repository for it to live in. s Create a repo You can store a variety of projects in GitHub repositories, including open source projects. With open source projects, you can share code to make better, more reliable software. You can use repositories to collaborate with others and track your work. For more information, see \"About repositories.\" Note Note: You can create public repositories for an open source project. When creating your public repository, make sure to include a license file that determines how you want your project to be shared with others. For more information on open source, specifically how to create and grow an open source project, we've created Open Source Guides that will help you foster a healthy open source community by recommending best practices for creating and maintaining repositories for your open source project. You can also take a free GitHub Learning Lab course on maintaining open source communities. In the upper-right corner of any page, use the '+' drop-down menu, and select New repository . Type a short, memorable name for your repository. For example, \"hello-world\". Optionally, add a description of your repository. For example, \"My first repository on GitHub.\" Choose a repository visibility. Select Initialize this repository with a README. Click Create repository. Tip Tip: You can also create repositories using the GitHub CLI. For more information, see \"gh repo create\" in the GitHub CLI documentation. Commit your first change A commit is like a snapshot of all the files in your project at a particular point in time. When you created your new repository, you initialized it with a README file. README files are a great place to describe your project in more detail, or add some documentation such as how to install or use your project. The contents of your README file are automatically shown on the front page of your repository. Let's commit a change to the README file. In your repository's list of files, click README.md . On the Edit file tab, type some information about yourself. Above the new content, click Preview changes . Review the changes you made to the file. You'll see the new content in green. At the bottom of the page, type a short, meaningful commit message that describes the change you made to the file. You can attribute the commit to more than one author in the commit message. For more information, see \"Creating a commit with multiple co-authors.\" Below the commit message fields, decide whether to add your commit to the current branch or to a new branch. If your current branch is the default branch, you should choose to create a new branch for your commit and then create a pull request. Click Propose file change ."
  },
  "guides/github/fork-a-repo.html": {
    "href": "guides/github/fork-a-repo.html",
    "title": "Forking a repository | Fountain of Knowledge",
    "keywords": "Forking a repository A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project. About forks Most commonly, forks are used to either propose changes to someone else's project or to use someone else's project as a starting point for your own idea. You can fork a repository to create a copy of the repository and make changes without affecting the upstream repository. For more information, see \"Working with forks.\" Propose changes to someone else's project For example, you can use forks to propose changes related to fixing a bug. Rather than logging an issue for a bug you've found, you can: Fork the repository. Make the fix. Submit a pull request to the project owner. Use someone else's project as a starting point for your own idea. Open source software is based on the idea that by sharing code, we can make better, more reliable software. For more information, see the \"About the Open Source Initiative\" on the Open Source Initiative. For more information about applying open source principles to your organization's development work on GitHub, see GitHub's white paper \"An introduction to innersource.\" When creating your public repository from a fork of someone's project, make sure to include a license file that determines how you want your project to be shared with others. For more information, see \"Choose an open source license\" at choosealicense.com. For more information on open source, specifically how to create and grow an open source project, we've created Open Source Guides that will help you foster a healthy open source community by recommending best practices for creating and maintaining repositories for your open source project. You can also take a free GitHub Learning Lab course on maintaining open source communities. Prerequisites If you haven't yet, you should first set up Git. Don't forget to set up authentication to GitHub from Git as well. You might fork a project to propose changes to the upstream, or original, repository. In this case, it's good practice to regularly sync your fork with the upstream repository. To do this, you'll need to use Git on the command line. You can practice setting the upstream repository using the same octocat/Spoon-Knife repository you just forked. On GitHub, navigate to the octocat/Spoon-Knife repository. In the top-right corner of the page, click Fork. Cloning your forked repository Right now, you have a fork of the Spoon-Knife repository, but you don't have the files in that repository locally your computer. On GitHub, navigate to your fork of the Spoon-Knife repository. Above the list of files, click Code. To clone the repository using HTTPS, under \"Clone with HTTPS\", click . To clone the repository using an SSH key, including a certificate issued by your organization's SSH certificate authority, click Use SSH, then click . To clone a repository using GitHub CLI, click Use GitHub CLI, then click . Open Git Bash. Change the current working directory to the location where you want the cloned directory. Type git clone, and then paste the URL you copied earlier. It will look like this, with your GitHub username instead of YOUR-USERNAME: $ git clone https://github.com/YOUR-USERNAME/Spoon-Knife Press Enter. Your local clone will be created. $ git clone https://github.com/YOUR-USERNAME/Spoon-Knife > Cloning into `Spoon-Knife`... > remote: Counting objects: 10, done. > remote: Compressing objects: 100% (8/8), done. > remove: Total 10 (delta 1), reused 10 (delta 1) > Unpacking objects: 100% (10/10), done. Configuring Git to sync your fork with the original repository When you fork a project in order to propose changes to the original repository, you can configure Git to pull changes from the original, or upstream, repository into the local clone of your fork. On GitHub, navigate to the octocat/Spoon-Knife repository. Above the list of files, click Code. To clone the repository using HTTPS, under \"Clone with HTTPS\", click . To clone the repository using an SSH key, including a certificate issued by your organization's SSH certificate authority, click Use SSH, then click . To clone a repository using GitHub CLI, click Use GitHub CLI, then click . Open Git Bash. Change directories to the location of the fork you cloned. To go to your home directory, type just cd with no other text. To list the files and folders in your current directory, type ls. To go into one of your listed directories, type cd your_listed_directory. To go up one directory, type cd ... Type git remote -v and press Enter. You'll see the current configured remote repository for your fork. $ git remote -v > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) Type git remote add upstream, and then paste the URL you copied in Step 2 and press Enter. It will look like this: $ git remote add upstream https://github.com/octocat/Spoon-Knife.git To verify the new upstream repository you've specified for your fork, type git remote -v again. You should see the URL for your fork as origin, and the URL for the original repository as upstream. $ git remote -v > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) > upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) > upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) Now, you can keep your fork synced with the upstream repository with a few Git commands. For more information, see \"Syncing a fork.\" Next steps You can make any changes to a fork, including: Creating branches: Branches allow you to build new features or test out ideas without putting your main project at risk. Opening pull requests: If you are hoping to contribute back to the original repository, you can send a request to the original author to pull your fork into their repository by submitting a pull request. Find another repository to fork Fork a repository to start contributing to a project. You can fork a repository to your user account or any organization where you have repository creation permissions. For more information, see \"Permission levels for an organization.\" If you have access to a private repository and the owner permits forking, you can fork the repository to your user account or any organization on GitHub Team where you have repository creation permissions. You cannot fork a private repository to an organization using GitHub Free. For more information, see \"GitHub's products.\" You can browse Explore to find projects and start contributing to open source repositories. For more information, see \"Finding ways to contribute to open source on GitHub.\""
  },
  "guides/github/git-cheatsheats.html": {
    "href": "guides/github/git-cheatsheats.html",
    "title": "Git Cheat Sheets | Fountain of Knowledge",
    "keywords": "Git Cheat Sheets Reference sheets covering Git commands, features, SVN migrations, and bash. Using Git Using Git SVN migration SVN migration Submodules vs. Subtrees Submodules vs. Subtrees Manuals GitHub for Developers Manual GitHub Administrator Manual SAML Implementation Preparation InnerSource Theory"
  },
  "guides/github/index.html": {
    "href": "guides/github/index.html",
    "title": "Github | Fountain of Knowledge",
    "keywords": "Github Quickstart Get started using GitHub to manage Git repositories and collaborate with others. Set up Git Create a repository Forking a repository GitHub flow Be social Communicating on GitHub GitHub glossary Git cheatsheets Git and GitHub learning resources"
  },
  "guides/github/set-up-git.html": {
    "href": "guides/github/set-up-git.html",
    "title": "Set up Git | Fountain of Knowledge",
    "keywords": "Set up Git To use Git on the command line, you'll need to download, install, and configure Git on your computer. {% ifversion fpt or ghes or ghae %} You can also install GitHub CLI to use {% data variables.product.product_name %} from the command line. For more information on GitHub CLI, see the GitHub CLI documentation If you want to work with Git locally, but don't want to use the command line, you can instead download and install the [{% data GitHub configuring Desktop]({% data variables.product.desktop_link %}) client. For more information, see \" Installing and configuring GitHub Desktop .\" If you don't need to work with files locally, {% data variables.product.product_name %} lets you complete many Git-related actions directly in the browser, including: Creating a repository Forking a repository Git Cheat Sheets Setting up Git Download and install the latest version of Git . Set your username in Git . Set your commit email address in Git . Next steps: Authenticating with GitHub from Git When you connect to a {% data variables.product.product_name %} repository from Git, you'll need to authenticate with {% data variables.product.product_name %} using either HTTPS or SSH. Connecting over HTTPS (recommended) If you clone with HTTPS , you can cache your {% data variables.product.prodname_dotcom %} credentials in Git using a credential helper. Connecting over SSH If you clone with SSH , you must generate SSH keys on each computer you use to push or pull from {% data variables.product.product_name %}."
  },
  "guides/index.html": {
    "href": "guides/index.html",
    "title": "| Fountain of Knowledge",
    "keywords": ""
  },
  "guides/vscode/azure/deployment.html": {
    "href": "guides/vscode/azure/deployment.html",
    "title": "Deploying Applications to Azure | Fountain of Knowledge",
    "keywords": "Deploying Applications to Azure Visual Studio Code makes it easy to deploy your applications to the cloud with Azure and we've created walkthroughs to help you get started. Whether your workflow is through the Azure CLI or Azure App Service , using a Docker container, or creating serverless Azure Functions , you'll find the deployment steps you need. Deployment tutorials The tutorials below, hosted on the Microsoft Docs platform, walk you through different ways of creating and deploying apps to Azure using Visual Studio Code: Tutorial Description CI/CD setup with the Deploy to Azure extension Set up a Continuous Integration and Delivery (CI/CD) pipeline with GitHub Actions or Azure Pipelines. Supports services including Azure Web Apps, Azure Functions, and Azure Kubernetes Service. Deploy Azure Functions Build and manage Azure Functions serverless apps directly in VS Code with the Azure Functions extension. Deploy using the App Service extension Manage Azure resources directly in VS Code with the Azure App Service extension. Deploy using Docker Deploy your website using a Docker container. Deploy using the Azure CLI Create, deploy, and update a website using a terminal and the Azure CLI. Deploy a static website Create, deploy, and update a static website on Azure Storage. You can find additional tutorials and walkthroughs on the Azure Developer Center , including language-specific articles for JavaScript and Node.js, Python, Java, and .NET. Next steps Azure Extensions - The VS Code Marketplace has hundreds of extensions for Azure and the cloud. Working with Docker - Put your application in a Docker container for easy reuse and deployment. Working with MongoDB - Create, manage and query MongoDB databases from within VS Code."
  },
  "guides/vscode/azure/docker.html": {
    "href": "guides/vscode/azure/docker.html",
    "title": "Working with Docker | Fountain of Knowledge",
    "keywords": "Working with Docker This page is redirected to /docs/containers/overview.md and only exists to keep the \"Docker\" TOC item."
  },
  "guides/vscode/azure/extensions.html": {
    "href": "guides/vscode/azure/extensions.html",
    "title": "Azure Extensions | Fountain of Knowledge",
    "keywords": "Azure Extensions You can use Azure directly from Visual Studio Code through extensions. Using either the Azure CLI or the Azure App Service extension, you can have your application running in Azure in minutes. Visual Studio Code Marketplace There are many VS Code extensions on the Marketplace that make it easy to build and host applications on Azure. Tip: Click on an extension tile above to read the description and reviews in the Marketplace. There is also a Node Pack for Azure extension pack which bundles useful Azure extensions for Node.js developers into a single installation. Searching for extensions You can also search for Azure or cloud extensions in the VS Code Extensions view ( kb(workbench.view.extensions) ) and type 'azure'. Next steps Deploying to Azure - Learn step-by-step how to deploy your application to Azure. Working with Docker - Put your application in a Docker container for easy reuse and deployment."
  },
  "guides/vscode/azure/kubernetes.html": {
    "href": "guides/vscode/azure/kubernetes.html",
    "title": "Working with Kubernetes in VS Code | Fountain of Knowledge",
    "keywords": "Working with Kubernetes in VS Code This document will walk you through the process of deploying an application to Kubernetes with Visual Studio Code. Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications. We will show you how to create a Kubernetes cluster, write a Kubernetes manifest file (usually written in YAML), which tells Kubernetes everything it needs to know about the application, and then finally deploy the application to the Kubernetes cluster. Before you begin You will need to have tools for Docker and kubectl . See the Install Docker documentation for details on setting up Docker on your machine and Install kubectl . Before proceeding further, verify you can run Docker and kubectl commands from the shell. You can create a local Kubernetes cluster with minikube or an Azure Kubernetes cluster in Azure Kubernetes Service (AKS) . In this tutorial, we will use Azure Kubernetes Service (AKS) and you will need to have your Azure account ready for the deployment steps. In addition, if you want to iteratively run and debug containers directly in MiniKube, Azure Kubernetes Service (AKS), or another Kubernetes provider, you can install the Bridge to Kubernetes extension. To get started, see Use Bridge to Kubernetes . Install the Kubernetes extension For a fully integrated Kubernetes experience, you can install the Kubernetes Tools extension, which lets you quickly develop Kubernetes manifests and HELM charts. With the extension, you can also deploy containerized micro-service based applications to local or Azure Kubernetes clusters and debug your live applications running in containers on Kubernetes clusters. It also makes it easy to browse and manage your Kubernetes clusters in VS Code and provides seamless integration with Draft to streamline Kubernetes development. To install the Kubernetes extension, open the Extensions view ( kb(workbench.view.extensions) ) and search for \"kubernetes\". Select the Microsoft Kubernetes extension. Containerize and publish the application You can follow the Working with Docker tutorial to build your project, generate a Docker image, and push it to a public or private container registry through the Microsoft Docker Extension . Create and config a Kubernetes cluster You can create a Kubernetes cluster running on Azure using the Kubernetes extension in VS Code. Once you have installed the Kubernetes extension, you will see KUBERNETES in the Explorer. Click on More and choose Create Cluster . Follow the instructions to choose the cluster type (here we choose Azure Kubernetes Service ), select your subscription, and set up the Azure cluster and Azure agent settings. It will take a few minutes to complete the whole workflow. Important : To create a Kubernetes cluster on Azure, you need to install the Azure CLI and sign in. Tip : You will encounter an error if you don't have an available RSA key file. Follow create SSH public-private key to create your key before creating an Azure Kubernetes cluster. Tip : You might encounter an error indicating conflicting location and VM size when creating an Azure Kubernetes cluster. Pay attention to choose proper location and VM size. Deploy the application to Azure Kubernetes Service The Kubernetes extension provides autocompletion, code snippets, and verification for the Kubernetes manifest file. For example, once you type 'Deployment' in an empty YAML file, a manifest file with fundamental structure is autogenerated for you. You only need to enter your app name, image, and port manually. Below is an example manifest file: Once your manifest file is ready, you only need one command to start a deployment. Open the Command Palette ( kb(workbench.action.showCommands) ) and run Kubernetes: Create . It will deploy the application to your Kubernetes cluster and create objects according to the configuration in the open Kubernetes manifest file. Checking on your deployment After deployment, the Kubernetes extension can help you check the status of your application. From the Explorer, click on Workloads , right click on Pods and then choose Get to see whether the application has started. To view the status of your app, select Services , right click on your app, and then click Get . The status will be printed to the Integrated Terminal. Once your application has an EXTERNAL_IP , you can open a browser and see your web app running. Congratulations! Now your app is successfully running in Azure Kubernetes Service! Next steps Overview of Bridge to Kubernetes - Learn more about Bridge to Kubernetes, a rapid, iterative Kubernetes development experience for teams. Azure Extensions - The VS Code Marketplace has hundreds of extensions for Azure and the cloud. Deploying to Azure - Learn step-by-step how to deploy your application to Azure."
  },
  "guides/vscode/azure/mongodb.html": {
    "href": "guides/vscode/azure/mongodb.html",
    "title": "Working with MongoDB | Fountain of Knowledge",
    "keywords": "Working with MongoDB Visual Studio Code has great support for working with MongoDB databases, whether your own instance or in Azure with MongoDB Atlas . With the MongoDB for VS Code extension, you can create, manage, and query MongoDB databases from within VS Code. Install the extension MongoDB support for VS Code is provided by the MongoDB for VS Code extension. To install the MongoDB for VS Code extension, open the Extensions view by pressing kb(workbench.view.extensions) and search for 'MongoDB' to filter the results. Select the MongoDB for VS Code extension. Connect to MongoDB Once you've installed the MongoDB for VS Code extension, you'll notice there is a new MongoDB Activity Bar view. Select the MongoDB view and you'll see the MongoDB Explorer. To connect to a MongoDB database, select Add Connection and enter the connection details for the database then Connect , the default is a local MongoDB server at mongodb://127.0.0.1:27017 . You can also enter a connection string, click the \"connect with a connection string\" link and paste the connection string. Note : Make sure your MongoDB server (mongod.exe) is running if you are connecting to a local MongoDB server. Once attached, you can work with the MongoDB server, managing MongoDB Databases, Collections, and Documents. You can expand databases to view their collections with their schema and indexes and you can select individual MongoDB Documents to view their JSON. You can also attach a MongoDB shell to the active connection, simply by right-clicking on the connection itself. Note : Make sure the MongoDB shell ( mongo or mongosh ) is installed and is on your path. In the extension's settings, you can choose which shell you are using. MongoDB Commands There are MongoDB specific commands available in the VS Code Command Palette ( kb(workbench.action.showCommands) ) as well as through Explorer context menus. Using Playgrounds One of the most powerful features of the VS Code MongoDB integration is Mongo Playgrounds . Playgrounds let you create, run, and save MongoDB commands from a VS Code editor. Create a new playground with the MongoDB: Create MongoDB Playground command. In a playground, you can reference MongoDB entities and commands and you get rich IntelliSense as you type. Playgrounds are useful for prototyping database operations and queries. Execute selected lines in the playground queries with the MongoDB: Run Selected Lines From Playground command. MongoDB on Azure You can easily create a MongoDB cluster on Azure for Free with MongoDB Atlas . Choose Create a New Cluster from the dashboard and choose Azure as the Cloud Provider. Once the cluster is created, connect to using the connection string provided by MongoDB Atlas . Next steps Azure Extensions - The VS Code Marketplace has hundreds of extensions for Azure and the cloud. Deploying to Azure - Learn step-by-step how to deploy your application to Azure. Working with Docker - Put your application in a Docker container for easy reuse and deployment."
  },
  "guides/vscode/azure/remote-debugging.html": {
    "href": "guides/vscode/azure/remote-debugging.html",
    "title": "Azure Remote Debugging for Node.js | Fountain of Knowledge",
    "keywords": "Azure Remote Debugging for Node.js Connect the Visual Studio Code debugger to your Node.js applications running on Azure App Service on Linux . The debugger works the same as when it's connected to a local Node.js process - including the use of Breakpoints and Logpoints. Install the extension Remote debugging support for VS Code is provided by the Azure App Service extension for apps deployed to Azure. To install the Azure App Service extension, open the Extensions view by pressing kb(workbench.view.extensions) and search for 'app service' to filter the results. Select the Microsoft Azure App Service extension. Connect to Azure Once you've installed the Azure App Service extension, you'll notice there is a new Azure Activity Bar view. Select the Azure view and you'll see the Azure App Service Explorer. Select Sign in to Azure in the App Service Explorer or Azure: Sign In from the Command Palette ( kb(workbench.action.showCommands) ) to sign in to your Azure Account. If you don't have an account, select Create a Free Azure Account... to create a free account and get $200 in Azure Credits to try out any combination of Azure services. Tip: If you don't have an app deployed to Azure App Service, start by following this tutorial to get an app deployed. Start a remote debugging session Right-click your app in the App Service explorer and select Start Remote Debugging . This process requires that the app be restarted with the debugger enabled - you'll be prompted to confirm the restart. Once restarted, VS Code will connect to the app's debugging port via an SSH tunnel. It may take a little time to establish the connection. Once connected, VS Code will switch into debugging mode and work the same as it does when debugging an app locally. When you're ready to end your remote debugging session, disconnect from the debugger as you would normally and confirm that you want to restart the app. Next steps Logpoints - Use Logpoints to log to the console without \"breaking\" in the debugger. Azure Extensions - The VS Code Marketplace has hundreds of extensions for Azure and the cloud. Deploying to Azure - Learn step-by-step how to deploy your application to Azure."
  },
  "guides/vscode/containers/app-service.html": {
    "href": "guides/vscode/containers/app-service.html",
    "title": "Deploy to Azure App Service | Fountain of Knowledge",
    "keywords": "Deploy to Azure App Service In this guide you will learn how to: Create a container image for your application. Push the image to a container registry. Deploy the image to Azure App Service. Deploy the image to Azure Container Instances (ACI). Prerequisites An Azure subscription. Docker and Azure App Service extensions must be installed. A web application that produces a docker image. You could also follow Create a sample ASP .NET Core application to create such application. You need a Docker Hub account or an instance of Azure Container Registry (ACR) . Create the application image If you already have an image, skip this step and proceed to Push the image to a container registry step. Open the application folder in VS Code. Open Command Palette ( kb(workbench.action.showCommands) ) and use Docker Images: Build Image... command to build the image. You can find the image name in the output of the Build Image command, the same can be found in the Images pane of the Docker Explorer. Push the image to a container registry Before deploying the image to an App Service, the image must be uploaded to a container registry. The image can be uploaded to either Azure Container Registry (ACR) or Docker Hub . Open the Docker Explorer and select Connect Registry... icon under Registries group and follow the prompt. Choose the provider (Azure or Docker Hub) and provide the credential to connect to the registry. Now the registry will be visible under Registries. Optionally, tag the image. In order to upload an image to a registry, the image needs to be tagged with registry name so that the docker push will upload it to the right registry. The image built in previous section will appear in the Docker Explorer under Images section. Right-click and choose Tag... . Specify the new name <your registry or username>/<image name>:<tag> and complete the tag action. For example, new image name for ACR would be 'mainacr.azurecr.io/webapp6:latest' and for Docker Hub it would be 'myusername/webapp6:latest'. The image will show up in the Docker Explorer under the registry that the image tag points to. Select this image and choose Push . If the image has not yet been tagged, you will be prompted to choose a registry to push to, and the image will be tagged based on the selection. Once the push command is completed. Refresh the registry node where the image is pushed to and the uploaded image will show up. Deploy the image to Azure App Service In the previous section, the image is pushed to a remote container registry. Now deploy this image to Azure App Service. In Docker Explorer, navigate to your image under Registries, right-click on the tag, and select Deploy Image To Azure App Service... . When prompted, provide the values for the App Service. New web app name: The name must be unique across Azure. Resource group: Select an existing resource group or create a new one. App Service plan: Select an existing App Service Plan or create a new one. (An App Service Plan defines the physical resources that host the website. You can use a basic or free plan tier for this tutorial.). When deployment is complete, Visual Studio Code shows a notification with the website URL. You can also see the results in the Output panel of Visual Studio Code, in the Docker section. To browse the deployed website, you can use kbstyle(Ctrl+click) to open the URL in the Output panel. The new App Service also appears in the Azure view in Visual Studio Code under the App Service section, where you can right-click the website and select Browse Website. Deploy to ACI In the previous section, the image was deployed to Azure App Service. Another option is to deploy the image to Azure Container Instances (ACI) . First, deploy the container to a container registry, such as Docker Hub or ACR, as described earlier in this article. Then, find the container in the Registries section of the Docker Explorer. Use the Refresh button if you don't see it there. Right-click the entry for the image you want, and choose Deploy image to Azure Container Instances . Choose an existing context, or use Create new ACI Context , and then choose the resource group. The container is started in ACI. The context you created is displayed in the Contexts pane in the Docker Explorer and selected as the active context. Whichever context is the active one affects the images shown in the Containers pane. When the image finishes the start-up process and becomes available, an entry for the image appears in the Containers pane. You can then manage the container instance by right-clicking on the entry. For example, to monitor the logs, choose View Logs . If it's a web app, you can use Open in Browser to navigate to the app's homepage. When you're done with the instance, right-click the instance name, and choose Remove . Because billing in ACI is by the second and only when the container is running, as soon as you remove it, you are no longer accruing charges. Next steps Read on to learn more about Azure Extensions - The VS Code Marketplace has hundreds of extensions for Azure and the cloud. Deploying to Azure - Learn step-by-step how to deploy your application to Azure. Working with MongoDB - Create, manage, and query MongoDB databases from within VS Code."
  },
  "guides/vscode/containers/bridge-to-kubernetes.html": {
    "href": "guides/vscode/containers/bridge-to-kubernetes.html",
    "title": "Use Bridge to Kubernetes | Fountain of Knowledge",
    "keywords": "Use Bridge to Kubernetes Bridge to Kubernetes allows you to run and debug code on your development computer, while still connected to your Kubernetes cluster with the rest of your application or services. This type of debugging is often called local tunnel debugging . For example, if you have a large microservices architecture with many interdependent services and databases, replicating those dependencies on your development computer can be difficult. Additionally, building and deploying code to your Kubernetes cluster for each code change during inner-loop development can be slow, time consuming, and difficult to use with a debugger. Bridge to Kubernetes avoids having to build and deploy your code to your cluster by instead creating a connection directly between your development computer and your cluster. Connecting your development computer to your cluster while debugging allows you to quickly test and develop your service in the context of the full application without creating any Docker or Kubernetes configuration. Bridge to Kubernetes redirects traffic between your connected Kubernetes cluster and your development computer. This traffic redirection allows code on your development computer and services running in your Kubernetes cluster to communicate as if they are in the same Kubernetes cluster. Bridge to Kubernetes also provides a way to replicate environment variables and mounted volumes available to pods in your Kubernetes cluster in your development computer. Providing access to environment variables and mounted volumes on your development computer allows you to quickly work on your code without having to replicate those dependencies manually. In this guide, you will learn how to use Bridge to Kubernetes to redirect traffic between your Kubernetes cluster and code running on your development computer. Before you begin This article assumes you already have your own cluster with a microservices architecture and you want to debug one of the pods in your cluster. If you want to learn how to use Bridge to Kubernetes with an existing sample application, see Use Bridge to Kubernetes with a sample . If you are using Azure Kubernetes service and want to use an existing sample application, see Bridge to Kubernetes (AKS) . Prerequisites A Kubernetes cluster with an app that you want to debug. Visual Studio Code running on macOS, Windows 10, or Linux (currently in preview). Connect to your cluster and debug a service There are a couple of different ways of starting the process of debugging with Bridge to Kubernetes. If you're starting from the open source Kubernetes extension, without Bridge to Kubernetes installed, go to Install and use local tunnel debugging . If you already have Bridge to Kubernetes installed, continue with the following steps: On your development computer, make sure your current context is set to the cluster and namespace in which your application is running. Open the workspace for the app you want to debug in Visual Studio Code. In the Kubernetes extension view under Clusters , make sure your cluster and namespace are selected. Open the Command Palette ( kb(workbench.action.showCommands) ), and run the command Bridge to Kubernetes: Configure to start the configuration process. Choose the Kubernetes service you want to redirect to your local version. All traffic in the Kubernetes cluster is redirected for your service to the version of your application running in your development computer. Bridge to Kubernetes also routes all outbound traffic from the application back to your Kubernetes cluster. Important : You can only redirect services that have a single pod. After you select your service, skip the next section and continue by following the steps in Configure the debugger for local tunnel debugging with Bridge to Kubernetes . Install and use local tunnel debugging Follow these steps to start using local tunnel debugging when you have the open-source Kubernetes extension installed and have a Kubernetes cluster with services you want to debug. The steps in this section will take you through the installation of Bridge to Kubernetes and start the configuration process for local tunnel debugging. Note : The Kubernetes extension for VS Code provides an API entry point that allows extension authors to contribute other local tunnel solutions from the VS Code Marketplace. Bridge to Kubernetes is one possible implementation of the Local Tunnel Debug capability. There are two ways of starting to use local tunnel debugging in VS Code. The first way is to open the Command Palette ( kb(workbench.action.showCommands) ) and type Kubernetes: Debug (Local Tunnel) . Alternatively, navigate to your Kubernetes cluster explorer. Open the active cluster's resources and locate a service or pod you wish to debug, then right-click on the service and select Debug: Local Tunnel . At this point, if you don't have any VS Code extension installed that offers local debugging capabilities, you'll be redirected to the Marketplace to select an extension that provides local debugging. Select the Bridge to Kubernetes extension. After the Bridge to Kubernetes extension is installed, the next time you choose Debug: Local Tunnel , you'll skip the installation step and proceed directly to the next step, Configure the debugger for local tunnel debugging with Bridge to Kubernetes . Configure the debugger for local tunnel debugging with Bridge to Kubernetes The first step in configuring the debugger for local tunnel debugging is that you're prompted to enter the TCP port that your application uses to run locally: Choose a debug launch configuration that you normally use when running your application locally. If you don't have a launch configuration, you can either let Bridge to Kubernetes create one, or choose not to create one, in which case you have to start your application or service manually. Learn more at Launch configurations . You have the option of running isolated or not isolated. If you run isolated, only your requests are routed to your local process; other developers can use the cluster without being affected. If you don't run isolated, all traffic is redirected to your local process. For more information on this option, see Using routing capabilities for developing in isolation . Select the Debug icon on the left and select the newly added Kubernetes launch configuration, such as Launch via NPM with Kubernetes , at the top. This launch configuration is created by Bridge to Kubernetes, if you choose that option. Note : You will be prompted to allow the EndpointManager to run elevated and modify your hosts file. Your development computer is connected when the VS Code Status bar turns orange and the Kubernetes extension shows you are connected. Once your development computer is connected, traffic starts redirecting to your development computer for the service you are replacing. Note : On subsequent launches, you will not be prompted for the service name, port, launch task, or whether to run isolated. These values are saved in .vscode/tasks.json . To change these settings later, open the Command Palette ( kb(workbench.action.showCommands) ), and run the command Bridge to Kubernetes: Configure . You can open .vscode/launch.json and .vscode/tasks.json to see the specific configuration settings that Bridge to Kubernetes adds to your launch profile. If your cluster uses gRPC C core , an implementation of gRPC that uses c-ares , an environment variable is added to your launch profile, GRPC_DNS_RESOLVER, with the value native . This variable specifies to use a workaround to avoid a 2-minute time delay when connecting. For more information, see this gRPC issue . Set a break point Set a breakpoint with kb(editor.debug.action.toggleBreakpoint) or selecting Run then Toggle Breakpoint . Navigate to the sample application by opening the public URL. When your code reaches the breakpoint, it should open in the debugger. To resume the service, hit kb(workbench.action.debug.run) or select Run then Continue . Return to your browser and verify you see a placeholder image for the bike. Update your application When you make code changes locally, whether or not they are visible to others who are using the cluster depends on whether you are running isolated or not. If you're running isolated, you can make changes that don't affect other users. Edit your code, save your changes, and press kb(workbench.action.debug.restart) or select Run then Restart Debugging . After you are reconnected, refresh your browser and validate your changes. Select Run then Stop Debugging or press kb(workbench.action.debug.stop) to stop the debugger. Note : By default, stopping the debugging task also disconnects your development computer from your Kubernetes cluster. You can change this behavior by searching for Bridge to Kubernetes: Disconnect After Debugging in the Visual Studio Code settings and removing the check next to Disconnect automatically when debugging stops . After updating this setting, your development computer will remain connected when you stop and start debugging. To disconnect your development computer from your cluster, click on the Bridge to Kubernetes extension on the status bar then choose Disconnect current session . Additional configuration Bridge to Kubernetes can handle routing traffic and replicating environment variables without any additional configuration. If you need to download any files that are mounted to the container in your Kubernetes cluster, such as a ConfigMap file, you can create a KubernetesLocalProcessConfig.yaml to download those files to your development computer. For more information, see Configure Bridge to Kubernetes . If you're using an AKS cluster that uses managed identity, a security feature provided by Azure Active Directory, see Use managed identity with Bridge to Kubernetes for information about how to configure Bridge to Kubernetes for this scenario. Using logging and diagnostics Logging output is written to the Bridge to Kubernetes window after your development computer is connected to your Kubernetes cluster. Click on the Kubernetes Status bar and choose Show connection diagnostics information . This command prints the current environment variables and DNS entires in the logging output. Additionally, you can find the diagnostic logs in the Bridge to Kubernetes directory in your development computer's TEMP directory. On Windows 10, that's in %TEMP%\\Bridge to Kubernetes . On a Mac, the TEMP directory can be found by running echo $TMPDIR from a terminal window. On Linux, it is /tmp/Bridge to Kubernetes . Running in isolation mode With Bridge to Kubernetes, you can also set up an isolated version the services you're working on, meaning that others who are using the cluster won't be affected by your changes. This isolation mode is accomplished by routing your requests to your copy of each affected service, but routing all other traffic normally. To access the local endpoint URL for the isolated app, launch the debugger in isolation mode, open the Kubernetes menu on the status bar, and choose the endpoint entry. You can find more about how routing works in isolation mode at How Bridge to Kubernetes Works . Header propagation To use Bridge to Kubernetes the way it is designed, you need to make sure to propagate the Bridge to Kubernetes header from incoming requests to any requests that your services make to other services in the cluster. All HTTP request APIs, regardless of language, provide some framework-specific way to do this. For example, for .NET code in C#, you can use code similar to the following: var request = new HttpRequestMessage(); request.RequestUri = new Uri(\"http://mywebapi/api/values/1\"); if (this.Request.Headers.ContainsKey(\"kubernetes-route-as\")) { // Propagate the dev space routing header request.Headers.Add(\"kubernetes-route-as\", this.Request.Headers[\"kubernetes-route-as\"] as IEnumerable<string>); } var response = await client.SendAsync(request); Note : To avoid affecting code at every request, you can create a class that inherits from System.Net.Http.DelegatingHandler and override the SendAsync method with code similar to the preceding example. You can find code using this technique on the web; one example is Properly Propagating \"kubernetes-route-as\" in Bridge to Kubernetes . For Node.js services, you can use code similar to the following, taken from the todo-app sample in the mindaro repo : server.get(\"/api/stats\", function (req, res) { var options = { host: process.env.STATS_API_HOST, path: '/stats', method: 'GET' }; const val = req.get('kubernetes-route-as'); if (val) { console.log('Forwarding kubernetes-route-as header value - %s', val); options.headers = { 'kubernetes-route-as': val } } var req = http.request(options, function(statResponse) { res.setHeader('Content-Type', 'application/json'); var responseString = ''; //another chunk of data has been received, so append it to `responseString` statResponse.on('data', function (chunk) { responseString += chunk; }); statResponse.on('end', function () { res.send(responseString); }); }); req.on('error', function(e) { console.log('problem with request: ' + e.message); }); req.end(); }); Communicating with other services When you communicate with another service in the same Kubernetes cluster, for example with an HTTP request, you typically use the hardcoded service name in the URL for the request, but that won't work in some scenarios, such as when using Remote SSH, WSL, and Codespaces. This article describes how to use the Kubernetes service environment variables to specify the connection URL for these scenarios. Troubleshooting If you get this error when activating the Bridge to Kubernetes extension: \"Failed to update dependencies: maximum number of retries exceeded\" First, retry the activation using the button. If it repeatedly does not succeed, see https://github.com/microsoft/mindaro/issues/32 . When you are using Bridge to Kubernetes in a remote SSH session, if EndpointManager fails, the issue might be that Bridge to Kubernetes cannot modify the hosts file due to a permissions issue. To enable remote SSH or running as non-elevated user, you should update your code to use Kubernetes service environment variables, and configure VS Code to use them, as described in the Service environment variables topic. Next steps Learn more about Bridge to Kubernetes at How Bridge to Kubernetes works . If you need to debug multiple services at the same time in parallel, see Debug multiple services at the same time . Information about the currently supported features and a future roadmap for Bridge to Kubernetes may be found at Bridge to Kubernetes roadmap ."
  },
  "guides/vscode/containers/bridge-to-kubernetes-aks.html": {
    "href": "guides/vscode/containers/bridge-to-kubernetes-aks.html",
    "title": "Use Bridge to Kubernetes with AKS | Fountain of Knowledge",
    "keywords": "Use Bridge to Kubernetes with AKS In this tutorial, you'll use a specific AKS sample microservices web app to learn how to use Bridge to Kubernetes to debug locally in a single pod that's part of an Azure Kubernetes Service (AKS) cluster. Before you begin This guide uses the Bike Sharing sample application to demonstrate connecting your development computer to a Kubernetes cluster running in AKS. If you already have your own application running on a Kubernetes cluster, see Develop with Kubernetes . If you are using another cluster, such as MiniKube running locally, see Use Bridge to Kubernetes with a sample . Prerequisites An Azure subscription. If you don't have an Azure subscription, you can create a free account . Azure CLI installed . Visual Studio Code running on macOS, Windows 10, or Linux (currently in preview). The Bridge to Kubernetes extension installed in Visual Studio Code. Create a Kubernetes cluster Create an AKS cluster in a supported region . The below commands create a resource group called MyResourceGroup and an AKS cluster called MyAKS . az group create \\ --name MyResourceGroup \\ --location eastus az aks create \\ --resource-group MyResourceGroup \\ --name MyAKS \\ --location eastus \\ --node-count 3 \\ --generate-ssh-keys Install the sample application Install the sample application on your cluster using the provided script. You can run this script on your development computer or using the Azure Cloud Shell . Use the name of your cluster and resource group. Important : You must have Owner or Contributor access to your cluster in order to run the script. git clone https://github.com/Microsoft/mindaro cd mindaro/ chmod +x ./bridge-quickstart.sh ./bridge-quickstart.sh -g MyResourceGroup -n MyAKS Navigate to the sample application running your cluster by opening its public URL, which is displayed in the output of the installation script. $ ./bridge-quickstart.sh -g MyResourceGroup -n MyAKS Checking directory /home/<user>/mindaro for GIT repo Microsoft/Mindaro Setting the Kube context ... To try out the app, open the url: bikeapp.bikesharingweb.EXTERNAL_IP.nip.io In the above sample, the public URL is bikeapp.bikesharingweb.EXTERNAL_IP.nip.io . Connect to your cluster and debug a service On your development computer, download and configure the Kubernetes CLI to connect to your Kubernetes cluster using az aks get-credentials . az aks get-credentials --resource-group MyResourceGroup --name MyAKS Open mindaro/samples/BikeSharingApp/Bikes from the Bike Sharing sample application in Visual Studio Code. Open the Azure Kubernetes Service extension and select the bikeapp namespace in the MyAKS cluster. Right-click the bikeapp node, and choose Use Namespace . Open a terminal window ( Terminal > New Terminal ), and in the terminal window in the Bikes folder, use the npm install command to install the dependencies for the application. npm install Open the Command Palette ( kb(workbench.action.showCommands) ), and run the command Bridge to Kubernetes: Configure to start the configuration process. Choose the bikes service. All traffic in the Kubernetes cluster is redirected for the bikes service to the version of your application running in your development computer. Bridge to Kubernetes also routes all outbound traffic from the application back to your Kubernetes cluster. Important : You can only redirect services that have a single pod. After you select your service, you are prompted to enter the TCP port for your local application. For this example, enter \"3000\". Choose Launch via NPM as the launch task. Note : You will be prompted to allow the EndpointManager to run elevated and modify your hosts file. You have the option of running isolated or not isolated. If you run isolated, only your requests are routed to your local process; other developers can use the cluster without being affected. If you don't run isolated, all traffic is redirected to your local process. For more information on this option, see Using routing capabilities for developing in isolation . Select the Debug icon on the left and select Launch via NPM with Kubernetes at the top. Your development computer is connected when the VS Code status bar turns orange and the Kubernetes extension shows you are connected. Note : On subsequent launches, you will not be prompted for the service name, port, launch task, or whether to run isolated. These values are saved in .vscode/tasks.json . To change these settings later, open the Command Palette ( kb(workbench.action.showCommands) ), and run the command Bridge to Kubernetes: Configure . Once your development computer is connected, traffic starts redirecting to your development computer for the service you are replacing. Set a break point Open server.js and put your cursor somewhere on line 233. Set a breakpoint with kb(editor.debug.action.toggleBreakpoint) or selecting Run then Toggle Breakpoint . Navigate to the sample application by opening the public URL. Select Aurelia Briggs (customer) as the user, then select a bike to rent. Notice the image for the bike does not load. Return to Visual Studio Code and observe line 233 is highlighted. The breakpoint you set has paused the service at line 233. To resume the service, hit kb(workbench.action.debug.run) or select Run then Continue . Return to your browser and verify you see a placeholder image for the bike. Remove the breakpoint by putting your cursor on line 233 in server.js and hitting kb(editor.debug.action.toggleBreakpoint) . Update your application Edit server.js to remove lines 234 and 235: // Hard code image url *FIX ME* theBike.imageUrl = \"/static/logo.svg\"; The section should now look like: var theBike = result; theBike.id = theBike._id; delete theBike._id; Save your changes and press kb(workbench.action.debug.restart) or select Run then Restart Debugging . After you are reconnected, refresh your browser and verify that you no longer see a placeholder image for the bike. Select Run then Stop Debugging or press kb(workbench.action.debug.stop) to stop the debugger. Note : By default, stopping the debugging task also disconnects your development computer from your Kubernetes cluster. You can change this behavior by searching for Bridge to Kubernetes: Disconnect After Debugging in the Visual Studio Code settings and removing the check next to Disconnect automatically when Debugging ends . After updating this setting, your development computer will remain connected when you stop and start debugging. To disconnect your development computer from your cluster, click on the Bridge to Kubernetes extension on the status bar then choose Disconnect current session . Additional configuration Bridge to Kubernetes can handle routing traffic and replicating environment variables without any additional configuration. If you need to download any files that are mounted to the container in your Kubernetes cluster, such as a ConfigMap file, you can create a KubernetesLocalProcessConfig.yaml to download those files to your development computer. For more information, see Configure Bridge to Kubernetes . Using logging and diagnostics Logging output is written to the Bridge to Kubernetes window after your development computer is connected to your Kubernetes cluster. Click on the Kubernetes Status bar and choose Show connection diagnostics information . This command prints the current environment variables and DNS entires in the logging output. Additionally, you can find the diagnostic logs in the Bridge to Kubernetes directory in your development computer's TEMP directory. On Windows 10, that's in %TEMP%\\Bridge to Kubernetes . On a Mac, the TEMP directory can be found by running echo $TMPDIR from a terminal window. On Linux, it is /tmp/Bridge to Kubernetes . Running in isolation mode With Bridge to Kubernetes, you can also set up an isolated version the services you're working on, meaning that others who are using the cluster won't be affected by your changes. This isolation mode is accomplished by routing your requests to your copy of each affected service, but routing all other traffic normally. More explanation on how this is done can be found at How Bridge to Kubernetes Works . Remove the sample application from your cluster Use the provided script to remove the sample application from your cluster. ./bridge-quickstart.sh -c -g MyResourceGroup -n MyAKS Troubleshooting If you get this error when activating the Bridge to Kubernetes extension: \"Failed to update dependencies: maximum number of retries exceeded\" First, retry the activation using the button. If it repeatedly does not succeed, see https://github.com/microsoft/mindaro/issues/32 . Next steps Learn more about Bridge to Kubernetes at How Bridge to Kubernetes works ."
  },
  "guides/vscode/containers/bridge-to-kubernetes-sample.html": {
    "href": "guides/vscode/containers/bridge-to-kubernetes-sample.html",
    "title": "Use Bridge to Kubernetes with a sample | Fountain of Knowledge",
    "keywords": "Use Bridge to Kubernetes with a sample This sample illustrates how Bridge to Kubernetes can be used to develop a microservice version of a simple TODO application on any Kubernetes cluster. This sample, using Visual Studio Code, has been adapted from code provided by TodoMVC . In this example, we use MiniKube to host the application, but these steps should work with any Kubernetes cluster. The TODO application sample is composed of a frontend and a backend that provides persistent storage. This extended sample adds a statistics component and breaks the application into a number of microservices, specifically: The frontend calls the database-api to persist and update TODO items; The database-api service relies on a Mongo database to persist TODO items; The frontend writes add, complete, and delete events to a RabbitMQ queue; A statistics worker receives events from the RabbitMQ queue and updates a Redis cache; A statistics API exposes the cached statistics for the frontend to show. In all, this extended TODO application is composed of six interrelated components. Prerequisites MiniKube or another Kubernetes cluster installed Chocolatey package manager, to install MiniKube On Windows 10, Hyper-V Kubectl installed and on the path in a command-line environment of your choice Bridge to Kubernetes Visual Studio Code extension Install MiniKube You can use any Kubernetes provider with Bridge to Kubernetes. In this article, we use MiniKube. MiniKube is a lightweight Kubernetes provider that lets you host Kubernetes on your local machine. Follow the installation instructions to install MiniKube on Windows 10, Linux, or macOS. For best results on Windows 10, you should use the Hyper-V VM manager and create a virtual switch . Once installed, start MiniKube, specify to use Hyper-V, and provide the name of the primary virtual switch. This command must be run from a command prompt with Administrator privileges. minikube start --vm-driver hyperv --hyperv-virtual-switch \"Primary Virtual Switch\" Deploy the application Clone the mindaro repo and open a command window with the current working folder to samples/todo-app . Create a namespace for the sample. kubectl create namespace todo-app Then, apply the deployment manifest: kubectl apply -n todo-app -f deployment.yaml This is a simple deployment that exposes the frontend using a service of type LoadBalancer . Wait for all the pods to be running and for the external IP of the frontend service to become available. If you are testing with MiniKube, you will need to use minikube tunnel to resolve an external IP. kubectl get services -n todo-app NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE frontend LoadBalancer 10.0.49.177 127.0.0.1 80:30145/TCP 18h Browse to the application using the external IP and local port (the first number in the PORT(S) column). http://{external-ip}:{local-port} Test the running app in the browser. As you add, complete and delete todo items, notice that the stats page updates with the expected metrics. Debug the stats-api service You can now use the Bridge to Kubernetes extension to demonstrate how traffic from the Kubernetes cluster can be redirected to a locally running version of the stats-api. cd stats-api/ Open the source code for the stats-api in VS Code. code . Once VS Code has launched, open the Kubernetes pane from the left sidebar of VS Code, and then select the todo-app namespace in your MiniKube cluster. Right-click the todo-app node, and choose Use Namespace . Install dependencies by running npm install in a terminal window (CTRL + ~). npm install Next, place a breakpoint on line 17 of server.js . Open the Command Palette ( kb(workbench.action.showCommands) ) and type Bridge to Kubernetes. Select the Bridge to Kubernetes: Configure option. You are prompted to configure the service you want to replace, the port to forward from your development computer, and the launch task to use. Choose the stats-api service. After you select your service, you are prompted to enter the TCP port for your local application. For this example, enter 3001. Choose Run Script: dev as the launch task. You have the option of running isolated or not isolated. If you run isolated, only your requests are routed to your local process; other developers can use the cluster without being affected. If you don't run isolated, all traffic is redirected to your local process. For more information on this option, see Using routing capabilities for developing in isolation . For this example, we will proceed with non-isolated. Note : You will be prompted to allow the EndpointManager to run elevated and modify your hosts file. The Bridge to Kubernetes debugging profile has been successfully configured. Select the Debug icon on the left and select Run Script: dev with Bridge to Kubernetes . Click the start button next to Run Script: dev with Kubernetes . Your development computer is connected when the VS Code status bar turns orange and the Kubernetes extension shows you are connected. Once your development computer is connected, traffic starts redirecting to your development computer for the stats-api you are replacing. Navigate to the frontend entry point of your todo-app. For minikube, we'll be using 127.0.0.1 . To access the local endpoint URL for your app, open the Kubernetes menu on the status bar and choose the endpoint entry. Make a request to the stats-api by choosing the stats link. Notice the traffic that initially started in your cluster was redirected to your locally running version (outside of the cluster) where the breakpoint was triggered. Press play and let the request continue complete transparently. This is just one example on how to use Bridge to Kubernetes on non-AKS clusters. Try it on your own project next! Clean up To clean up the assets produced by this sample, run: kubectl delete namespace todo-app Next steps You can also deploy your app to Azure Kubernetes Service (AKS) with Bridge to Kubernetes. See Use Bridge to Kubernetes with AKS"
  },
  "guides/vscode/containers/choosing-dev-environment.html": {
    "href": "guides/vscode/containers/choosing-dev-environment.html",
    "title": "Your development environment | Fountain of Knowledge",
    "keywords": "Your development environment You can choose whether to develop a container-based service in the local environment , or in a remote environment . The local environment is the operating system of your developer workstation; using the local environment means you build and run your service container(s) using Docker installed on your workstation. Docker is supported on Windows, macOS, and various Linux distributions; for system and hardware requirements, refer to Docker installation page . A remote development environment is different from your developer workstation. It can be a remote machine accessible via SSH, a virtual machine running on your developer workstation, or a development container. A remote environment can have advantages over the local environment, the main one being the ability to use the same operating system during development, and when your service is running in production. To use a remote environment, you need to ensure that docker command (Docker CLI) is available and functional within that environment . The second important choice is whether to debug your service running as an ordinary process, or debug your service running in a container. Guidelines for choosing a development environment Use the local environment when you are not concerned about: Using the same OS for development and inside the service container. Installing necessary tools and dependencies on top of your local environment. Consider using a development container first, if you need a remote environment. On Windows, using Windows Subsystem for Linux (WSL) is good option. Debugging your service running in a container is possible, but brings additional complexity. Use normal debugging by default, and debugging in the container when you need it. The Docker extension natively supports container debugging for .NET-, Node.js-, and Python-based services. Enabling Docker CLI inside a remote development environment The way to enable Docker CLI inside a remote development environment varies depending on the type of remote environment you choose. Development container For a development container, you should redirect the Docker CLI inside the container to the Docker daemon running on the local machine. First, make sure Docker CLI is installed into your development container. The exact steps depend on the Linux distribution the container is using . Here is an example for Ubuntu-based distros (from a .devcontainer/Dockerfile ): ... && apt-get -y install software-properties-common \\ && curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - 2>/dev/null \\ && add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\" \\ && apt-get update -y \\ && apt-get install -y docker-ce-cli \\ && apt-get install -y python python-pip \\ && pip install docker-compose \\ ... Next, ensure that Docker socket is mapped into the development container (in .devcontainer/devcontainer.json ): ... \"runArgs\": [ \"-v\", \"/var/run/docker.sock:/var/run/docker.sock\"] ... Windows Subsystem for Linux Windows Subsystem for Linux represents a great choice for container-based service development on Windows. Windows Subsystem for Linux version 2 (WSL 2) is strongly recommended. Docker Desktop for Windows has been updated to work with WSL 2 and has a graphical setting to enable Docker CLI inside WSL 2 distribution(s): To use WSL 2 for Docker development you will need Windows 10 version 2004 or newer, and Docker Desktop for Windows version 2.2.0.5 or newer. The old version of WSL (WSL 1) does not provide an easy way to connect to the Docker daemon on the host. Remote machine The recommended way to enable container development with a remote machine is to do a full Docker installation on the machine, including Docker daemon. Note : Docker Desktop product is supported only on physical Windows and macOS machines, not virtual machines. If you want to use a virtual machine as a remote development environment, we recommend to use a Linux VM with Docker Engine . After Docker is installed and working on the remote machine, you can use VS Code's Remote - SSH extension from the Remote Development extension pack to connect to your remote machine and work there. Open VS Code Command Palette ( kb(workbench.action.showCommands) ) and run command Remote-SSH: Add new SSH host... . Follow the prompts to set up a connection to the target host. Run command Remote-SSH: Connect to host... and connect to the host. A new VS Code window opens, running in the context of the target machine. If you're using password authentication, the password will be prompted here. We strongly recommend that you set up SSH key authentication , for ease of use. In the Extensions view, install the Docker extension (on the remote host) (a reload may be required after this step): NOTE : If you are using the Docker extension to build Docker images and have source code, the approach above probably means you have your source enlistment on the remote host, rather than on your developer workstation. If you are just using the Docker extension for the Docker Explorer features, then you can disregard this. Local Linux VM To use a Linux virtual machine running on your developer workstation, you should install Docker on the VM in the same way as you would install it on a remote machine, and use the VS Code Remote-SSH extension to connect to the VM. Alternatively, you can install just the Docker CLI inside your development environment and point the CLI to the Docker host (engine) running on the developer workstation using the Docker context mechanism . The main concern with this approach is to ensure network connectivity from the VM to the Docker engine on the host, and to do so in a secure way. One option is to use SSH tunneling to the developer workstation. Another option is to have the Docker engine listen on an HTTPS port . You need to be proficient with SSH and public-key infrastructure (PKI) to use the host Docker engine from the Docker CLI running inside the VM. For most users, we recommend full Docker installation inside the virtual machine. Debugging in a container The Docker extension supports debugging .NET Core-based and Node.js-based services running inside a container. Other programming languages are not supported at this time. Debugging in a container may be harder to set up than regular debugging because a container is a stronger isolation mechanism than a process. In particular: The debug engine running inside VS Code process needs to communicate with the service process being debugged. In the case of a service running inside a container, this implies network communication via a common network (typically Docker host network). The container needs to have appropriate ports exposed via the Docker host network for the debug engine to connect to the service process (Node.js), or debugger proxy running inside the container (.NET Core). Source file information generated during build time is valid in the context of the build environment (where VS Code is running). The container filesystem is different from the build environment filesystem, and paths to source files need to be re-mapped in order for the debugger to display correct source file when a breakpoint is hit. Because of the concerns above, it is generally recommended to use regular debugging, and employ debugging in a container when necessary. For more information about how to set up debugging inside a container see ASP.NET Core quickstart , Node.js quickstart , and Docker extension task properties ( docker-build and docker-run tasks). Next steps Read on to learn more about Build and run a Node.js app in a container Build and run a .NET Core app in a container"
  },
  "guides/vscode/containers/debug-common.html": {
    "href": "guides/vscode/containers/debug-common.html",
    "title": "Debug containerized apps | Fountain of Knowledge",
    "keywords": "Debug containerized apps With version 0.9.0 and later, the Docker extension provides more support for debugging applications within Docker containers, such as scaffolding launch.json configurations for attaching a debugger to applications running within a container. The Docker extension provides a docker debug configuration provider that manages how VS Code will launch an application and/or attach a debugger to the application in a running Docker container. This provider is configured via entries within launch.json , with configuration being specific to each application platform supported by the provider. The Docker extension currently supports debugging Node.js , Python , and .NET Core applications within Docker containers. Requirements Scaffolding or pasting a launch configuration into launch.json is not sufficient to build and debug a Docker container. To successfully run a Docker launch configuration, you must have: A Dockerfile. docker-build and docker-run tasks in tasks.json . A launch configuration that invokes these tasks. We recommend using the Docker: Add Docker Files to Workspace... command to create these items, if none of these assets already exist. If you already have a functional Dockerfile, we recommend using the Docker: Initialize for Docker debugging command to scaffold a launch configuration and Docker-related tasks. Node.js More information about debugging Node.js applications within Docker containers can be found at Debug Node.js within a container . Example launch.json configuration for debugging a Node.js application: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Launch Node.js in Docker\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"Run Docker Container\", \"platform\": \"node\" } ] } Python More information about debugging Python applications within Docker containers can be found at Debug Python within a container . Example launch.json configuration for debugging a Python application: { \"configurations\": [ { \"name\": \"Docker: Python - Django\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"docker-run: debug\", \"python\": { \"pathMappings\": [ { \"localRoot\": \"${workspaceFolder}\", \"remoteRoot\": \"/app\" } ], \"projectType\": \"django\" } } ] } .NET Core More information about debugging .NET Core applications within Docker containers can be found in Debug .NET Core within Docker containers . The previous (Preview) .NET Core Docker debugging support (utilizing \"type\": \"docker-coreclr\" instead of the current preview's \"type\": \"docker\" ) is being deprecated. You can still find documentation on that support at Debug .NET Core - Deprecated . Example launch.json configuration for debugging a .NET Core application: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Launch .NET Core in Docker\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"Run Docker Container\", \"netCore\": { \"appProject\": \"${workspaceFolder}/project.csproj\" } } ] } Configuration reference Property Description containerName Name of the container used for debugging. dockerServerReadyAction Options for launching a browser to the Docker container. Similar to serverReadyAction, but replaces container ports with host ports. removeContainerAfterDebug Whether to remove the debug container after debugging. platform The target platform for the application. Can be netCore or node . netCore Options for debugging .NET Core projects in Docker. node Options for debugging Node.js projects in Docker. python Options for debugging Python projects in Docker. dockerServerReadyAction object properties Property Description action The action to take when the pattern is found. Can be debugWithChrome or openExternally . containerName The container name to match the host port. pattern The regex pattern to look for in Debug console output. uriFormat The URI format to launch. webRoot The root folder from which web pages are served. Used only when action is set to debugWithChrome . node object properties These properties are the same as those described in the VS Code documentation for attaching a debugger to Node.js applications. All properties passed in the node object will be passed on to the Node.js debug adaptor, even if not specifically listed below. Property Description Default port Optional. The debug port to use. 9229 address Optional. TCP/IP address of the debug port. sourceMaps Optional. Enable source maps by setting this to true . outFiles Optional. Array of glob patterns for locating generated JavaScript files. autoAttachChildProcesses Optional. Track all subprocesses of debuggee and automatically attach to those that are launched in debug mode. timeout Optional. When restarting a session, give up after this number of milliseconds. stopOnEntry Optional. Break immediately when the program launches. localRoot Optional. VS Code's root directory. The root workspace folder. remoteRoot Optional. Node's root directory within the Docker container. /usr/src/app smartStep Optional. Try to automatically step over code that doesn't map to source files. skipFiles Optional. Automatically skip files covered by these glob patterns. trace Optional. Enable diagnostic output. python object properties Property Description Default host The host for remote debugging. port The port for remote debugging. 5678 pathMappings Maps the project path between local machine and remote host. projectType Type of Python app. justMyCode Debug only user-written code. django Django debugging. false jinja Jinja template debugging (such as Flask). false netCore object properties Properties passed in the netCore object are generally passed on to the .NET Core debug adaptor, even if not specifically listed below. The complete list of debugger properties is in the OmniSharp VS Code extension documentation . Property Description appProject The .NET Core project (.csproj, .fsproj, etc.) to debug. Next steps Read on to learn more about: Debugging Node.js within Docker containers Debugging Python within Docker containers Debugging .NET Core within Docker containers Debugging with Docker Compose Troubleshooting"
  },
  "guides/vscode/containers/debug-netcore.html": {
    "href": "guides/vscode/containers/debug-netcore.html",
    "title": "Debug .NET Core within a container | Fountain of Knowledge",
    "keywords": "Debug .NET Core within a container Prerequisites Install the .NET Core SDK , which includes support for attaching to the .NET Core debugger. Install the Visual Studio Code C# extension , which includes support for attaching to the .NET Core debugger with VS Code. macOS users only: Add /usr/local/share/dotnet/sdk/NuGetFallbackFolder as a shared folder in your Docker preferences. Walkthrough If needed, create a .NET Core project with dotnet new . Open the project folder in VS Code. Wait until a notification appears asking if you want to add required assets for debugging. Select Yes : Open the Command Palette ( kb(workbench.action.showCommands) ) and enter Docker: Add Docker Files to Workspace... . If you have already dockerized your app, you can instead do Docker: Initialize for Docker debugging . Follow the prompts. Switch to the Run view ( kb(workbench.view.debug) ). Select the Docker .NET Core Launch launch configuration. Optionally, set a breakpoint. Start debugging! ( kb(workbench.action.debug.start) ) Running and debugging with SSL support To enable SSL (using the HTTPS protocol), you will need to make a few changes to your configuration. In the Dockerfile, add an EXPOSE line to the base section to define a separate port for HTTPS / SSL. Keep a separate EXPOSE line with a different port for HTTP requests. FROM mcr.microsoft.com/dotnet/aspnet:5.0 AS base WORKDIR /app EXPOSE 5000 EXPOSE 5001 In the .vscode/tasks.json file, add configureSsl: true to the netCore section. Also, add an environment variable ASPNETCORE_URLS in the dockerRun section of the docker-run: debug task, with the same port numbers you defined in the Dockerfile: dockerRun: { \"env\": { \"ASPNETCORE_URLS\": \"https://+:5001;http://+:5000\" } } netCore: { \"appProject\": \"${workspacefolder}/MyProject.csproj\", \"enableDebugging\": true, \"configureSsl\": true } For additional customization options, see the documentation on Tasks and Debug containerized apps ."
  },
  "guides/vscode/containers/debug-node.html": {
    "href": "guides/vscode/containers/debug-node.html",
    "title": "Debug Node.js within a container | Fountain of Knowledge",
    "keywords": "Debug Node.js within a container When adding Docker files to a Node.js project, tasks and launch configurations are added to enable debugging that application within a Docker container. However, due to the large ecosystem surrounding Node.js, those tasks cannot accommodate every application framework or library, which means that some applications will require additional configuration. Configuring the Docker container entry point The Docker extension infers the entry point of the Docker container--that is, the command line for starting the application in a debug mode within the Docker container--via properties of package.json . The extension first looks for the start script in the scripts object; if found and, if it starts with a node or nodejs command, it uses that to build the command line for starting the application in debug mode. If not found or, if not a recognized node command, the main property in the package.json is used. If neither is found or recognized, then you need to explicitly set the dockerRun.command property of the docker-run task used to start the Docker container. Some Node.js application frameworks include CLIs for managing the application and are used to start the application in the start script, which obscure the underlying node commands. In these cases, the Docker extension cannot infer the start command and you must explicitly configure the start command. Example: Configuring the entry point for a Nest.js application { \"tasks\": [ { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"command\": \"nest start --debug 0.0.0.0:9229\", }, \"node\": { \"enableDebugging\": true } } ] } Example: Configuring the entry point for a Meteor application { \"tasks\": [ { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"command\": \"node --inspect=0.0.0.0:9229 main.js\", }, \"node\": { \"enableDebugging\": true } } ] } Automatically launching the browser to the entry page of the application The Docker extension can automatically launch the browser to the entry point of the application after it has started in the debugger. This feature is enabled by default and configured via the dockerServerReadyAction object of the debug configuration in launch.json . This feature depends on several aspects of the application: The application must output logs to the debug console. The application must log a \"server ready\" message. The application must serve a browsable page. While the default settings may work for an Express.js based application, other Node.js frameworks may require explicit configuration of one or more of those aspects. Ensuring application logs are written to the debug console This feature depends on the application writing its logs to the debug console of the attached debugger. However, not all logging frameworks write to the debug console, even when configured to use a console-based logger (as some \"console\" loggers actually bypass the console and write directly to stdout ). The solution varies depending on the logging framework, but it generally requires creating/adding a logger that actually writes to the console. Example: Configuring Express applications to write to the debug console By default, Express.js uses the debug logging module, which can bypass the console. This can be resolved by explicitly binding the log function to the console's debug() method. var app = require('../app'); var debug = require('debug')('my-express-app:server'); var http = require('http'); // Force logging to the debug console. debug.log = console.debug.bind(console); Also note that the debug logger writes logs only when enabled via the DEBUG environment variable, which can be set in the docker-run task. (This environment variable is set to * by default when Docker files are added to the application.) { \"tasks\": [ { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"env\": { \"DEBUG\": \"*\" } }, \"node\": { \"enableDebugging\": true } } ] } Configuring when the application is \"ready\" The extension determines the application is \"ready\" to receive HTTP connections when it writes a message of the form Listening on port <number> to the debug console, as Express.js does by default. If the application logs a different message, then you should set the pattern property of the dockerServerReadyAction object of the debug launch configuration to a JavaScript regular expression that matches that message. The regular expression should include a capture group that corresponds to the port on which the application is listening. For example, suppose the application logs the following message: function onListening() { var addr = server.address(); var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port; debug('Application has started on ' + bind); } The corresponding pattern in the debug launch configuration (in launch.json ) is: { \"configurations\": [ { \"name\": \"Docker Node.js Launch\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"docker-run: debug\", \"platform\": \"node\", \"dockerServerReadyAction\": { \"pattern\": \"Application has started on port (\\\\d+)\" } } ] } Note the (\\\\d+) capture group for the port number, and the use of \\ as a JSON escape character for the backslash in the \\d character class. Configuring the application entry page By default, the Docker extension will open the \"main\" page of the browser (however that is determined by the application). If the browser should be opened to a specific page, the uriFormat property of the dockerServerReadyAction object of the debug launch configuration should be set to a Node.js format string, with one string token that indicates where the port should be substituted. The corresponding uriFormat in the debug launch configuration (in launch.json ) to open the about.html page instead of the main page would be: { \"configurations\": [ { \"name\": \"Docker Node.js Launch\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"docker-run: debug\", \"platform\": \"node\", \"dockerServerReadyAction\": { \"uriFormat\": \"http://localhost:%s/about.html\" } } ] } Mapping Docker container source files to the local workspace By default, the Docker extension assumes the application source files in the running Docker container are located in an /usr/src/app folder, and the debugger then maps those files back to the root of the opened workspace, in order to translate breakpoints from the container back to Visual Studio Code. If the application source files are in a different location (for example, different Node.js frameworks have different conventions), either within the Docker container or within the opened workspace, then one or both of the localRoot and remoteRoot properties of the node object of the debug launch configuration should be set the root source locations within the workspace and the Docker container, respectively. For example, if the application instead resides in /usr/my-custom-location , the corresponding remoteRoot property would be: { \"configurations\": [ { \"name\": \"Docker Node.js Launch\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"docker-run: debug\", \"platform\": \"node\", \"node\": { \"remoteRoot\": \"/usr/my-custom-location\" } } ] } Troubleshooting Docker image fails to build or start due to missing node_modules Dockerfiles are often arranged in such a way as to optimize either image build time, image size, or both. However, not every Node.js application framework supports all of the typical Node.js Dockerfile optimizations. In particular, for some frameworks, the node_modules folder must be an immediate subfolder of the application root folder, whereas, the Docker extension scaffolds a Dockerfile where the node_modules folder exists at a parent or ancestor level (which is generally allowed by Node.js). The solution is to remove that optimization from the Dockerfile : FROM node:10.13-alpine ENV NODE_ENV=production WORKDIR /usr/src/app COPY [\"package.json\", \"package-lock.json*\", \"npm-shrinkwrap.json*\", \"./\"] # Remove the `&& mv node_modules ../` from the RUN command: # RUN npm install --production --silent && mv node_modules ../ RUN npm install --production --silent COPY . . EXPOSE 3000 CMD npm start"
  },
  "guides/vscode/containers/debug-python.html": {
    "href": "guides/vscode/containers/debug-python.html",
    "title": "Debug Python within a container | Fountain of Knowledge",
    "keywords": "Debug Python within a container When adding Docker files to a Python project, tasks and launch configurations are added to enable debugging the application within a Docker container. To accommodate the various scenarios of Python projects, some apps may require additional configuration. Configuring the Docker container entry point You can configure the entry point of the Docker container by setting properties in tasks.json . VS Code automatically configures the container entry point when you first use the Docker: Add Docker Files to Workspace... command. Example: Configuring the entry point for a Python module { \"tasks\": [ { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"python\": { \"module\": \"myapp\" } } ] } Example: Configuring the entry point for a Python file { \"tasks\": [ { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"python\": { \"args\": [ \"runserver\", \"0.0.0.0:8000\", \"--nothreading\", \"--noreload\" ], \"file\": \"manage.py\" } } ] } Automatically launching the browser to the entry page of the application You can select the Docker: Python - Django or Docker: Python - Flask launch configurations to automatically launch the browser to the main page of the app. This feature is enabled by default, but you can configure this behavior explicitly by setting the dockerServerReadyAction object in launch.json . This feature depends on several aspects of the application: The application must output to the debug console or Docker logs . The application must log a \"server ready\" message. The application must serve a browsable page. Here is an example of using dockerServerReadyAction to launch the browser to open the about.html page based on a specific server message pattern: { \"configurations\": [ { \"name\": \"Docker: Python - Django\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"docker-run: debug\", \"python\": { \"pathMappings\": [ { \"localRoot\": \"${workspaceFolder}\", \"remoteRoot\": \"/app\" } ], \"projectType\": \"django\" }, \"dockerServerReadyAction\": { \"action\": \"openExternally\", \"pattern\": \"Starting development server at (https?://\\\\S+|[0-9]+)\", \"uriFormat\": \"%s://localhost:%s/about.html\" } } ] } Note : The regex found in the pattern attribute simply attempts to capture a logged message similar to \"Starting development server at http://localhost:8000 \". It accommodates variations in the url for http or https, any host name, and any port. Important dockerServerReadyAction object properties action : The action to take when the pattern is found. Can be debugWithChrome or openExternally . pattern : If the application logs a different message than shown above, set the pattern property of the dockerServerReadyAction object to a JavaScript regular expression that matches that message. The regular expression should include a capture group that corresponds to the port on which the application is listening. uriFormat : By default, the Docker extension will open the main page of the browser (however that is determined by the application). If you want the browser to open a specific page like the example above, the uriFormat property of the dockerServerReadyAction object should be set to a format string with two string tokens to indicate the protocol and port substitution. How to enable hot reloading in Django or Flask apps When you select Docker: Add Docker Files to Workspace for Django or Flask, we provide you a Dockerfile and tasks.json configured for static deployment. Each time you make changes to your app code, you need to rebuild and re-run your container. Hot reloading allows you to visualize changes in your app code as your container continues to run. Enable hot reloading with these steps: For Django Apps In the Dockerfile, comment out the line that adds app code to the container. #ADD . /app Within the docker-run task in the tasks.json file, create a new dockerRun attribute with a volumes property. This will create a mapping from the current workspace folder (app code) to the /app folder in the container. { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"volumes\": [ { \"containerPath\": \"/app\", \"localPath\": \"${workspaceFolder}\" } ] }, ... } Edit the python attribute by removing --noreload and --nothreading . { ... \"dockerRun\": { \"volumes\": [ { \"containerPath\": \"/app\", \"localPath\": \"${workspaceFolder}\" } ] }, \"python\": { \"args\": [ \"runserver\", \"0.0.0.0:8000\", ], \"file\": \"manage.py\" } } Select the Docker: Python – Django launch configuration and hit kb(workbench.action.debug.start) to build and run your container. Modify and save any file. Refresh the browser and validate changes have been made. For Flask Apps In the Dockerfile, comment out the line that adds app code to the container. #ADD . /app Within the docker-run task in the tasks.json file, edit the existing dockerRun attribute by adding a FLASK_ENV in the env property as well as a volumes property. This will create a mapping from the current workspace folder (app code) to the /app folder in the container. { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"env\": { \"FLASK_APP\": \"path_to/flask_entry_point.py\", \"FLASK_ENV\": \"development\" }, \"volumes\": [ { \"containerPath\": \"/app\", \"localPath\": \"${workspaceFolder}\" } ] }, ... } Edit the python attribute by removing --no-reload and --no-debugger . { ... \"dockerRun\": { \"env\": { \"FLASK_APP\": \"path_to/flask_entry_point.py\", \"FLASK_ENV\": \"development\" }, \"volumes\": [ { \"containerPath\": \"/app\", \"localPath\": \"${workspaceFolder}\" } ] }, \"python\": { \"args\": [ \"run\", \"--host\", \"0.0.0.0\", \"--port\", \"5000\" ], \"module\": \"flask\" } } Select the Docker: Python – Flask launch configuration and hit kb(workbench.action.debug.start) to build and run your container. Modify and save any file. Refresh the browser and validate changes have been made. How to build and run a container together In the previously mentioned tasks.json file, there is a dependency on the docker-build task. The task is part of the tasks array in tasks.json . For example: \"tasks\": [ { ... }, { \"label\": \"docker-build\", \"type\": \"docker-build\", \"dockerBuild\": { \"context\": \"${workspaceFolder}\", \"dockerfile\": \"${workspaceFolder}/Dockerfile\", \"tag\": \"YOUR_IMAGE_NAME:YOUR_IMAGE_TAG\" } } ] Tip: As the dependency clearly states docker-build as its dependency, the name has to match this task. It can be changed to anything though. The dockerBuild object in the JSON allows for the following parameters: context: The docker build context, from which your Dockerfile is called dockerfile: The path to the Dockerfile to execute tag: The name of the image to be built, with its version tag Overall, a VS Code setup for building and debugging your Flask application can be: launch.json { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug Flask App\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"docker-run: debug\", \"python\": { \"pathMappings\": [ { \"localRoot\": \"${workspaceFolder}\", \"remoteRoot\": \"/app\" } ], \"projectType\": \"flask\" }, \"dockerServerReadyAction\": { \"action\": \"openExternally\", \"pattern\": \"Running on (http?://\\\\S+|[0-9]+)\", \"uriFormat\": \"%s://localhost:%s/\" } } ] } tasks.json { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"containerName\": \"YOUR_IMAGE_NAME\", \"image\": \"YOUR_IMAGE_NAME:YOUR_IMAGE_TAG\", \"env\": { \"FLASK_APP\": \"path_to/flask_entry_point.py\", \"FLASK_ENV\": \"development\" }, \"volumes\": [ { \"containerPath\": \"/app\", \"localPath\": \"${workspaceFolder}\" } ], \"ports\": [ { \"containerPort\": 5000, \"hostPort\": 5000 } ] }, \"python\": { \"args\": [ \"run\", \"--host\", \"0.0.0.0\", \"--port\", \"5000\" ], \"module\": \"flask\" } }, { \"label\": \"docker-build\", \"type\": \"docker-build\", \"dockerBuild\": { \"context\": \"${workspaceFolder}\", \"dockerfile\": \"${workspaceFolder}/Dockerfile\", \"tag\": \"YOUR_IMAGE_NAME:YOUR_IMAGE_TAG\" } } ] } Next steps Learn more about: Configuring a non-root user in your container"
  },
  "guides/vscode/containers/docker-compose.html": {
    "href": "guides/vscode/containers/docker-compose.html",
    "title": "Use Docker Compose | Fountain of Knowledge",
    "keywords": "Use Docker Compose Docker Compose provides a way to orchestrate multiple containers that work together. Examples include a service that processes requests and a front-end web site, or a service that uses a supporting function such as a Redis cache. If you are using the microservices model for your app development, you can use Docker Compose to factor the app code into several independently running services that communicate using web requests. This article helps you enable Docker Compose for your apps, whether they are Node.js, Python, or .NET Core, and also helps you configure debugging in Visual Studio Code for these scenarios. Also, for single-container scenarios, using Docker Compose provides tool-independent configuration in a way that a single Dockerfile does not. Configuration settings such as volume mounts for the container, port mappings, and environment variables can be declared in the docker-compose YML files. To use Docker Compose in VS Code using the Docker extension, you should already be familiar with the basics of Docker Compose . Adding Docker Compose support to your project If you already have one or more Dockerfiles, you can add Docker Compose files by opening the Command Palette ( kb(workbench.action.showCommands) ), and using the Docker: Add Docker Compose Files to Workspace command. Follow the prompts. You can add Docker Compose files to your workspace at the same time you add a Dockerfile by opening the Command Palette ( kb(workbench.action.showCommands) ) and using the Docker: Add Docker Files to Workspace command. You'll be asked if you want to add Docker Compose files. If you want to keep your existing Dockerfile, choose No when prompted to overwrite the Dockerfile. The Docker extension adds the docker-compose.yml file to your workspace. This file contains the configuration to bring up the containers as expected in production. In some cases, a docker-compose.debug.yml is also generated. This file provides a simplified mode for starting that enables the debugger. The VS Code Docker extension generates files that work out of the box, but you can also customize them to optimize for your scenario. You can then use the Docker Compose Up command (right-click on the docker-compose.yml file, or find the command in the Command Palette ) to get everything started at once. You can also use the docker-compose up command from the command prompt or terminal window in VS Code to start the containers. Refer to the Docker Compose documentation about how to configure the Docker Compose behavior and what command-line options are available. With the docker-compose files, you can now specify port mappings in the docker-compose files, rather than in the .json configuration files. For examples, see the Docker Compose documentation . Tip : When using Docker Compose, don't specify a host port. Instead, let the Docker pick a random available port to automatically avoid port conflict issues. Add new containers to your projects If you want to add another app or service, you can run Add Docker Compose Files to Workspace again, and choose to overwrite the existing docker-compose files, but you'll lose any customization in those files. If you want to preserve changes to the compose files, you can manually modify the docker-compose.yml file to add the new service. Typically, you can cut and paste the existing service section and change the names as appropriate for the new service. You can run the Add Docker Files to Workspace command again to generate the Dockerfile for a new app. While each app or service has its own Dockerfile, there's typically one docker-compose.yml and one docker-compose.debug.yml file per workspace. In Python projects, you have the Dockerfile , .dockerignore , docker-compose*.yml files all in the root folder of the workspace. When you add another app or service, move the Dockerfile into the app's folder. In Node.js projects, the Dockerfile and .dockerignore files will be next to the package.json for that service. For .NET, the folder structure is already set up to handle multiple projects when you create the Docker Compose files, .dockerignore and docker-compose*.yml are placed in the workspace root (for example, if the project is in src/project1 , then the files are in src ), so when you add another service, you create another project in a folder, say project2 , and recreate or modify the docker-compose files as described previously. Debug First, refer to the debugging documentation for your target platform, to understand the basics on debugging in containers with VS Code: Node.js debugging Python Docker debugging .NET Core debugging If you want to debug in Docker Compose, run the command Docker Compose Up using one of the two Docker Compose files as described in the previous section, and then attach using the appropriate Attach launch configuration. Launching directly using the normal launch configuration does not use Docker Compose. Create an Attach launch configuration . This is a section in launch.json . The process is mostly manual, but in some cases, the Docker extension can help by adding a pre-configured launch configuration that you can use as a template and customize. The process for each platform (Node.js, Python, and .NET Core) is described in the following sections. Node.js On the Debug tab, choose the Configuration dropdown, choose New Configuration and select the Docker Attach configuration template Node.js Docker Attach (Preview) . Configure the debugging port in docker-compose.debug.yml . This is set when you create the file, so you might not need to change it. In the example below, port 9229 is used for debugging on both the host and the container. version: '3.4' services: node-hello: image: node-hello build: . environment: NODE_ENV: development ports: - 3000 - 9229:9229 command: node --inspect=0.0.0.0:9229 ./bin/www If you have multiple apps, you need to change the port for one of them, so that each app has a unique port. You can point to the right debugging port in the launch.json , and save the file. If you omit this, the port will be chosen automatically. Here's an example that shows the Node.js launch configuration - Attach: \"configurations\": [ { \"type\": \"node\", \"request\": \"attach\", \"name\": \"Docker: Attach to Node\", \"remoteRoot\": \"/usr/src/app\", \"port\": 9229 // Optional; otherwise inferred from the docker-compose.debug.yml. }, // ... ] When done editing the Attach configuration, save launch.json , and select your new launch configuration as the active configuration. In the Debug tab, find the new configuration in the Configuration dropdown. Right-click on the docker-compose.debug.yml file and choose Compose Up . When you attach to a service that exposes an HTTP endpoint that returns HTML, the web browser doesn't open automatically. To open the app in the browser, choose the container in the sidebar, right-click and choose Open in Browser . If multiple ports are configured, you'll be asked to choose the port. Launch the debugger in the usual way. From the Debug tab, choose the green arrow ( Start button) or use kb(workbench.action.debug.start) . Python For debugging Python with Docker Compose, follow these steps: On the Debug tab, choose the Configuration dropdown, choose New Configuration , choose Python , and select the Remote Attach configuration template. You'll be prompted to choose the host machine (for example, localhost) and port you want to use for debugging. The default debugging port for Python is 5678. If you have multiple apps, you need to change the port for one of them, so that each app has a unique port. You can point to the right debugging port in the launch.json , and save the file. If you omit this, the port will be chosen automatically. \"configurations\": [ { \"name\": \"Python: Remote Attach\", \"type\": \"python\", \"request\": \"attach\", \"port\": 5678, \"host\": \"localhost\", \"pathMappings\": [ { \"localRoot\": \"${workspaceFolder}\", \"remoteRoot\": \"/app\" } ] } When done editing the Attach configuration, save the launch.json . Navigate to the Debug tab and select Python: Remote Attach as the active configuration. If you already have a valid Dockerfile, we recommend running the command Docker: Add Docker Compose Files to Workspace . This will create a docker-compose.yml file and also a docker-compose.debug.yml , which volume maps and starts the Python debugger in the container. If you do not have a Dockerfile already, we recommend running Docker: Add Docker Files to Workspace and selecting Yes to include Docker Compose files. Note : By default, when using Docker: Add Docker Files to Workspace , choosing the Django and Flask options will scaffold a Dockerfile configured for Gunicorn. Follow the instructions in the Python in a container quickstart to ensure it is configured properly before proceeding. Right-click on the docker-compose.debug.yml file (example shown below) and choose Compose Up . version: '3.4' services: pythonsamplevscodedjangotutorial: image: pythonsamplevscodedjangotutorial build: context: . dockerfile: ./Dockerfile command: [\"sh\", \"-c\", \"pip install debugpy -t /tmp && python /tmp/debugpy --wait-for-client --listen 0.0.0.0:5678 manage.py runserver 0.0.0.0:8000 --nothreading --noreload\"] ports: - 8000:8000 - 5678:5678 Once your container is built and running, attach the debugger by hitting kb(workbench.action.debug.start) with the Python: Remote Attach launch configuration selected. Note: If you would like to import the Python debugger into a specific file, more information can be found in the debugpy README . When you attach to a service that exposes an HTTP endpoint and returns HTML, the web browser may not open automatically. To open the app in the browser, right-click the container in the Docker Explorer and choose Open in Browser . If multiple ports are configured, you'll be asked to choose the port. You're now debugging your running app in the container. .NET On the Debug tab, choose the Configuration dropdown, choose New Configuration and select the Docker Attach configuration template .NET Core Docker Attach (Preview) . VS Code tries to copy vsdbg from the host machine to the target container using a default path. You can also provide a path to an existing instance of vsdbg in the Attach configuration. \"netCore\": { \"debuggerPath\": \"/remote_debugger/vsdbg\" } When done editing the Attach configuration, save launch.json , and select your new launch configuration as the active configuration. In the Debug tab, find the new configuration in the Configuration dropdown. Right-click on the docker-compose.debug.yml file and choose Compose Up . When you attach to a service that exposes an HTTP endpoint that returns HTML, the web browser doesn't open automatically. To open the app in the browser, choose the container in the sidebar, right-click and choose Open in Browser . If multiple ports are configured, you'll be asked to choose the port. Launch the debugger in the usual way. From the Debug tab, choose the green arrow ( Start button) or use kb(workbench.action.debug.start) . If you try to attach to a .NET Core app running in a container, you'll see a prompt ask to select your app's container. To skip this step, specify the container name in the Attach configuration in launch.json: \"containerName\": \"Your ContainerName\" Next, you're asked if you want to copy the debugger ( vsdbg ) into the container. Choose Yes . If everything is configured correctly, the debugger should be attached to your .NET Core app. Volume mounts By default, the Docker extension does not do any volume mounting for debugging components. There's no need for it in .NET Core or Node.js, since the required components are built into the runtime. If your app requires volume mounts, specify them by using the volumes tag in the docker-compose*.yml files. volumes: - /host-folder-path:/container-folder-path Docker Compose with multiple Compose files Workspaces can have multiple docker-compose files to handle different environments like development, test, and production. The content of the configuration can be split into multiple files. For example, a base compose file that defines the common information for all environments and separate override files that define environment-specific information. When these files are passed as input to the docker-compose command, it combines these files into a single configuration. By default, the Docker: Compose Up command passes a single file as input to the compose command, but you can customize the compose up command to pass in multiple files using command customization . Or, you can use a custom task to invoke the docker-compose command with the desired parameters. Note : If your workspace has docker-compose.yml and docker-compose.override.yml and no other compose files, then the docker-compose command is invoked with no input files and it implicitly uses these files. In this case, no customization is needed. Command customization Command customization provides various ways to customize the compose up command based on your requirements. The following are few sample command customization for the compose up command. Base file and an override file Let's assume your workspace has a base compose file ( docker-compose.yml ) and an override file for each environment ( docker-compose.dev.yml , docker-compose.test.yml and docker-compose.prod.yml ) and you always compose up with the base file and an override file. In this case, the compose up command can be customized as in the following example. When the compose up command is invoked, the ${configurationFile} is replaced by the selected file. \"docker.commands.composeUp\": [ { \"label\": \"override\", \"template\": \"docker-compose -f docker-compose.yml ${configurationFile} up -d --build\", } ] Template matching Let's assume you have different set of input files for each environment. You could define multiple templates with regular expression match, and the selected file name will be matched against this match property and the corresponding template will be used. \"docker.commands.composeUp\": [ { \"label\": \"dev-match\", \"template\": \"docker-compose -f docker-compose.yml -f docker-compose.debug.yml -f docker-compose.dev.yml up -d --build\", \"match\": \"dev\" }, { \"label\": \"test-match\", \"template\": \"docker-compose -f docker-compose.yml -f docker-compose.debug.yml -f docker-compose.test.yml up -d --build\", \"match\": \"test\" }, { \"label\": \"prod-match\", \"template\": \"docker-compose -f docker-compose.yml -f docker-compose.release.yml -f docker-compose.prod.yml up -d --build\", \"match\": \"prod\" } ] Pick a template when the command is invoked If you omit the match property from command templates, you will be asked which template to use each time compose up command is invoked. For example: \"docker.commands.composeUp\": [ { \"label\": \"dev\", \"template\": \"docker-compose -f docker-compose.yml -f docker-compose.common.dev.yml ${configurationFile} up -d --build\" }, { \"label\": \"test\", \"template\": \"docker-compose -f docker-compose.yml -f docker-compose.common.test.yml ${configurationFile} up -d --build\" }, { \"label\": \"prod\", \"template\": \"docker-compose -f docker-compose.yml -f docker-compose.common.prod.yml ${configurationFile} up -d --build\" }, ], Custom tasks Rather than use command customization, you can also define a task like the following to invoke a docker-compose command. Please refer custom task for more detail on this. { \"type\": \"shell\", \"label\": \"compose-up-dev\", \"command\": \"docker-compose -f docker-compose.yml -f docker-compose.Common.yml -f docker-compose.dev.yml up -d --build\", \"presentation\": { \"reveal\": \"always\", \"panel\": \"new\" } } Next steps Overview of Docker Compose in the Docker documentation Troubleshooting"
  },
  "guides/vscode/containers/kubernetes-env-vars.html": {
    "href": "guides/vscode/containers/kubernetes-env-vars.html",
    "title": "Kubernetes service environment variables | Fountain of Knowledge",
    "keywords": "Kubernetes service environment variables When you communicate with another service in the same Kubernetes cluster, for example with an HTTP request, you typically use the hardcoded service name in the URL for the request, but that won't work in some scenarios with Bridge to Kubernetes. This article describes how to use the Kubernetes service environment variables to specify the connection URL. Avoid redirection failures Bridge to Kubernetes reroutes traffic by modifying the host name resolution to redirect network traffic to its own version of the services. The redirection works in most scenarios, but fails in the case where the Bridge to Kubernetes process has restricted privilege, such as when the request originates from a non-elevated user account or when using VS Code Remote SSH. This is because in order to enable the name resolution for redirected services, Bridge to Kubernetes needs to modify the hosts file, but that is not possible when Bridge to Kubernetes runs from a non-elevated user account. To work around this issue, you can write your code to use the Kubernetes service environment variables instead of a hardcoded service name. Environment variables table The following table shows the Kubernetes service environment variables that are available from any service in the cluster, for an example service using the TCP protocol on a port. The servicename is the name of the service, converted to uppercase, and with hyphens converted to underscores, so for example, a service named web-api yields an environment variable named WEB_API_SERVICE_HOST. Name Example Description servicename _SERVICE_HOST 10.0.0.11 The name of the service host servicename _SERVICE_PORT 6379 The port for the service servicename _PORT tcp://10.0.0.11:6379 The URL with protocol, IP address, and port. servicename _PORT_ portnumber _ protocol tcp://10.0.0.11:6379 The URL with protocol, IP address and port. servicename _PORT_ portnumber _ protocol _PROTO tcp The protocol identifier. servicename _PORT_ portnumber _ protocol _PORT 6379 The port number for TCP. servicename _PORT_ portnumber _ protocol _ADDR 10.0.0.11 The IP address for TCP. So if the service is named web-api, the variables are WEB_API_SERVICE_HOST and WEB_API_SERVICE_PORT, and so on. The default environment variables created by Kubernetes are described in the Kubernetes documentation . For information about the supported protocols, see Supported protocols . Environment variables in source code To enable your services to run in Bridge to Kubernetes without elevated privileges, replace any hardcoded references to the hostname with the environment variable. The following example shows this in a .NET service named mywebapi written in C#: using var client = new HttpClient(); var host = Environment.GetEnvironmentVariable(\"MYWEBAPI_SERVICE_HOST\"); var port = Environment.GetEnvironmentVariable(\"MYWEBAPI_SERVICE_PORT\"); var request = new HttpRequestMessage(); request.RequestUri = new Uri($\"http://{host}:{port}/api/data\"); var response = await client.SendAsync(request); An example in Node.js looks like this: server.get(\"/api/data\", function (req, res) { var options = { host: process.env.MYWEBAPI_SERVICE_HOST, port: process.env.MYWEBAPI_SERVICE_PORT, path: '/api/data', method: 'GET' }; var req = http.request(options, function(response) { res.setHeader('Content-Type', 'application/json'); var responseString = ''; //another chunk of data has been received, so append it to `responseString` response.on('data', function (chunk) { responseString += chunk; }); response.on('end', function () { res.send(responseString); }); }); req.on('error', function(e) { console.log('problem with request: ' + e.message); }); req.end(); }); To update your code to use the environment variables, look for any occurrences of the hostname and update to use the value obtained from the environment variable servicename _SERVICE_HOST. Even if you usually don't specify the port used by the target service when calling it, you will need to use the servicename _SERVICE_PORT environment variable. Specifying the port allows Bridge to Kubernetes to avoid the conflicts happening when a specific port isn't available on the development machine. You don't need to change the port on which your service listens for this to work: you just need to make sure that when your service calls other services, it calls them using both the servicename _SERVICE_HOST and servicename _SERVICE_PORT environment variables. If you reuse the same code elsewhere in the cluster, that is fine, because these environment variables are available in every pod in the cluster. If you reuse the same code outside of a Kubernetes cluster, you either have to set up the equivalent environment variables or modify the code appropriately for the new platform or hosting service. Set VS Code to use Kubernetes service environment variables If you're using VS Code with a remote computer or running VS Code as a normal user, you also need to configure VS Code to use the Kubernetes service environment variables. Open tasks.json, find the task with the label bridge-to-kubernetes.service and add the property usekubernetesServiceEnvironmentVariables with the value true , as shown in the following code: \"tasks\": [ { \"label\": \"bridge-to-kubernetes.service\", \"type\": \"bridge-to-kubernetes.service\", \"service\": \"bikes\", \"ports\": [ 3000 ], \"useKubernetesServiceEnvironmentVariables\": true } ] The setting is only needed if you are running VS Code as a normal user, or if you are using a remote session, but if you have modified your code as described in this article, there is no harm in setting this property. Next steps Read more about Bridge to Kubernetes configuration at How to configure Bridge to Kubernetes ."
  },
  "guides/vscode/containers/overview.html": {
    "href": "guides/vscode/containers/overview.html",
    "title": "Working with containers | Fountain of Knowledge",
    "keywords": "Working with containers The Docker extension makes it easy to build, manage, and deploy containerized applications from Visual Studio Code. This page provides an overview of the Docker extension capabilities; use the side menu to learn more about topics of interest. If you are just getting started with Docker development, try the Docker tutorial first to understand key Docker concepts. Installation Install Docker on your machine and add it to the system path. On Linux, you should also enable Docker CLI for the non-root user account that will be used to run VS Code. To install the extension, open the Extensions view ( kb(workbench.view.extensions) ), search for docker to filter results and select Docker extension authored by Microsoft. Editing Docker files You can get IntelliSense when editing your Dockerfile and docker-compose.yml files, with completions and syntax help for common commands. In addition, you can use the Problems panel ( kb(workbench.actions.view.problems) ) to view common errors for Dockerfile and docker-compose.yml files. Generating Docker files You can add Docker files to your workspace by opening the Command Palette ( kb(workbench.action.showCommands) ) and using Docker: Add Docker Files to Workspace command. The command will generate Dockerfile and .dockerignore files and add them to your workspace. The command will also query you if you want the Docker Compose files added as well; this is optional. The extension recognizes workspaces that use most popular development languages (C#, Node.js, Python, Ruby, Go, and Java) and customizes generated Docker files accordingly. Docker Explorer The Docker extension contributes a Docker Explorer view to VS Code. The Docker Explorer lets you examine and manage Docker assets: containers, images, volumes, networks, and container registries. If the Azure Account extension is installed, you can browse your Azure Container Registries as well. The right-click menu provides access to commonly used commands for each type of asset. You can rearrange the Docker Explorer panes by dragging them up or down with a mouse and use the context menu to hide or show them. Docker commands Many of the most common Docker commands are built right into the Command Palette: You can run Docker commands to manage images , networks , volumes , image registries , and Docker Compose . In addition, the Docker: Prune System command will remove stopped containers, dangling images, and unused networks and volumes. Using image registries You can display the content and push/pull/delete images from Azure Container Registry , Docker Hub , GitLab , and more: An image in an Azure Container Registry can be deployed to Azure App Service directly from VS Code; see Deploy images to Azure App Service page. For more information about how to authenticate to and work with registries see Using container registries page. Debugging services running inside a container You can debug services built using .NET (C#) and Node.js that are running inside a container. The extension offers custom tasks that help with launching a service under the debugger and with attaching the debugger to a running service instance. For more information see Debug container application and Extension Properties and Tasks pages. Azure CLI integration You can start Azure CLI (command-line interface) in a standalone, Linux-based container with Docker Images: Run Azure CLI command. This allows access to full Azure CLI command set in an isolated environment. See Get started with Azure CLI page for more information on available commands. Docker Compose Docker Compose lets you define and run multi-container applications with Docker. You can define what shape these containers look like with a file called docker-compose.yml . Visual Studio Code's experience for authoring docker-compose.yml is also very rich, providing IntelliSense for valid Docker compose directives and it will query Docker Hub for metadata on public Docker images. Create a new file in your workspace called docker-compose.yml Define a new service called web: On the second line, bring up IntelliSense by pressing kb(editor.action.triggerSuggest) to see a list of all valid compose directives. For the image directive, you can press kb(editor.action.triggerSuggest) again and VS Code will query the Docker Hub index for public images. VS Code will first show a list of popular images along with metadata such as the number of stars and description. If you continue typing, VS Code will query the Docker Hub index for matching images, including searching public profiles. For example, searching for 'Microsoft' will show you all the public Microsoft images. Next steps Read on to learn more about Choosing your development environment Build and run a Node.js app in a container Build and run a .NET Core app in a container Debug apps within Docker containers Docker application development Troubleshooting"
  },
  "guides/vscode/containers/parallel-services.html": {
    "href": "guides/vscode/containers/parallel-services.html",
    "title": "Debug multiple services | Fountain of Knowledge",
    "keywords": "Debug multiple services Bridge to Kubernetes provides the ability to debug your Kubernetes services in a local environment, as described in Use Bridge to Kubernetes . With Bridge to Kubernetes, you redirect traffic to a locally running instance of a service and can debug using VS Code's debugger. However, in some scenarios, you want to work with more than one service and debug into them all at the same time. You can debug multiple services in parallel by following these steps. To debug multiple services at the same time Make sure that your services listen on different ports locally. The port numbers are service-specific, so look to the service code to determine what ports it listens on. If multiple services you want to debug listen on the same ports, you won't be able to debug them at the same time. Open the folder corresponding to your first service in VS Code. In VS Code, select File > Add Folder to Workspace… , and pick the folder corresponding to your other service. Open the Command Palette ( kb(workbench.action.showCommands) ), and run the command Bridge to Kubernetes: Configure and, for each of your services, go through the configuration steps. Warning : If you configured your services to run isolated, make sure that they're using the same isolateAs value in their .vscode/tasks.json files. This value is the prefix that Bridge to Kubernetes uses to direct traffic for an isolated service. By default, when configuring them, they will have different values. You can choose one of the values and hand-edit the tasks.json files for the other services to give them all the same value. \"tasks\": [ { \"label\": \"bridge-to-kubernetes.service\", \"type\": \"bridge-to-kubernetes.service\", \"service\": \"service-name\", \"ports\": [ 3000 ], \"isolateAs\": \"<copy-same-value-for-all-debugged-services>\", \"useKubernetesServiceEnvironmentVariables\": false } ] Set up any breakpoints that you need in each service. Start debugging ( kb(workbench.action.debug.start) ) with Bridge for each of the services by launching the debugger in each service's folder. The previous step created launch configurations for each service, which VS Code's debugger uses when you start the VS Code debugger from that workspace. Next steps Learn more about how Bridge to Kubernetes works at How Bridge to Kubernetes works ."
  },
  "guides/vscode/containers/python-configure-containers.html": {
    "href": "guides/vscode/containers/python-configure-containers.html",
    "title": "Configure your Python containers | Fountain of Knowledge",
    "keywords": "Configure your Python containers When containerizing an application for production, your goal should be to port existing code into a separate runtime environment without introducing unforeseen security concerns. For this reason, we recommend selecting the default port for Python: Django (8000) or Python: Flask (5000) when executing the Add Dockerfiles to Workspace command, or opting for a port greater than 1023. This will allow VS Code to configure the Dockerfile with non-root access and prevent a malicious user from elevating permissions in the container, ultimately obtaining host machine root access . When you choose Python: General , there is no port selection, so the Docker extension configures non-root access by default. In all cases, you must ensure each resource (such as ports and files) modified or used by your application can be accessed by a non-root user in your container. If a user selects ports less than 1024 when adding Dockerfiles to workspace, by default, we cannot scaffold a Dockerfile that will run the container as a non-root user. This is because ports in this range are called well-known or system ports and must execute with root privileges in order to bind a network socket to an IP address. This guide will help you to: Configure a non-root user in your application by modifying your Dockerfile and tasks.json . Fix potential errors due to running as a non-root user. Running your containerized app as a non-root user The Add Dockerfiles to Workspace command for Django and Flask automatically sets up non-root privileges if you choose a non-system port. If your current Dockerfile and tasks.json is not setup for non-root usage, follow these steps: Run Add Dockerfiles to Workspace . Choose Python: Django or Python: Flask . Select a port greater than 1023. Overwrite your current Dockerfile and tasks.json . If you chose Python: General , non-root privileges will be set up by default, but you may want to modify your Dockerfile and tasks.json as described below to add port access. Docker file changes Within the Dockerfile, you must expose a non-system port , create a working directory for your app code, and then add a non-root user with access to the app directory. Lastly, ensure your exposed port matches the port binding of the Gunicorn command. The CMD command below configures Gunicorn for a Django container. For more information on configuring Gunicorn, refer to the documentation on Gunicorn configuration for Django/Flask apps . # 1024 or higher EXPOSE 1024 # ... other directives such as installing requirements.txt file # Creates /app in container if it does not already exist # Ports code into /app WORKDIR /app ADD . /app # Creates a non-root user and adds permission to access the /app folder RUN useradd appuser && chown -R appuser /app USER appuser CMD [\"gunicorn\", \"--bind\", \"0.0.0.0:1024\", \"pythonPath.to.wsgi\"] Modifications to tasks.json for Django\\Flask apps After choosing a non-system port and setting up the container to run as a non-root user, we must ensure the docker run task within tasks.json also expects the same port. Django apps { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"python\": { \"args\": [ \"runserver\", \"0.0.0.0:1024\", //<- Change the number after the colon \"--nothreading\", \"--noreload\" ], \"file\": \"manage.py\" } } Flask apps { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"env\": { \"FLASK_APP\": \"path_to/flask_entry_point.py\" } }, \"python\": { \"args\": [ \"run\", \"--no-debugger\", \"--no-reload\", \"--host\", \"0.0.0.0\", \"--port\", \"1024\" //<- Change this port number ], \"module\": \"flask\" } } Potential errors when running as a non-root user Following the guide up to this point should eliminate most configuration issues caused by running as a non-root user. However, we have compiled a non-exhaustive list of common errors you may run into. If you encounter any other problems due to running as a non-root user, please report the issue in the Docker extension repository. We love your feedback! Invalid file permissions in the container If you are reading, writing, or creating a file within your container, a non-root user might not have access to folders or files in specific directories unless directly given. For example, if you added to your Dockerfile: RUN mkdir /extra The /extra folder will be created in the root directory of your container outside of the /app folder. Therefore, if you tried to create and write to a file named file.txt with: f = open(\"/extra/file.txt\", \"a\") f.write(\"We wrote some text\") f.close() You will see the error: Exception has occurred: PermissionError [Errno 13] Permission denied: '/extra/file.txt' To solve this issue, we need to correctly add permissions to the non-root user to gain access to this specific file or directory in the container. Within your Dockerfile, add: # Creates a non-root user with an explicit UID and adds permission to access the /app folder RUN useradd -u 5678 appuser && chown -R appuser /app # Adds permission for appuser (non-root) to access the /extra folder RUN chown -R appuser /extra Note : This is just one example of how to add permissions in a container. There are many ways to do so, and it is your responsibility give the least permission possible to specific files and folders. Invalid file permissions on the host (Linux) In the previous example, we showed you how to add permissions to a file or folder on the container as a non-root user. However, if you are trying to access a folder on the host machine from within the container as a non-root user, the user ID or group ID in the container must have access to the files on the host. To solve this issue in Linux, you might need to set file access control lists (setfacl). If you have a folder named /share on your host machine and try to access this folder before the access control list is properly set, you will likely receive this error: PermissionError: [Errno 13] Permission denied: '/share/logs/log.txt' In order to give access to a non-root user appuser from within the container, follow these steps: Copy the explicit UID from your Dockerfile ( 5678 in the example above). From the host machine's command line, run one of these commands: # Example of giving a User ID with the value of 5678 access to the /share folder on the host machine setfacl -m u:5678:rwx /share # Example of giving a Group ID with the value of 6789 access to the /share folder on the host machine setfacl -m g:6789:rwx /share Binding to a low-range port If you hit kb(workbench.action.debug.start) to start your container and it immediately stops without producing any logs in the Debug Console , this error could mean you are exposing a system-port (ports less than 1024) while attempting to run as a non-root user. This may be hard to catch because, by default, containers are removed after debugging is stopped. To diagnose this port error, follow these steps: Open and modify your launch.json file: { \"name\": \"Docker: {Configuration Name}\", \"type\": \"docker\", \"request\": \"launch\", \"preLaunchTask\": \"docker-run: debug\", \"removeContainerAfterDebug\": false, //<- add this line // ... the rest of the launch configuration } Hit kb(workbench.action.debug.start) to run your container again. After the container exits once more, navigate to the Docker extension, right-click the container, and select View Logs . In a Django app, you may see the error: Error: You don't have permission to access that port. In a Flask app, you may see the error: self.socket.bind(self.server_address) PermissionError: [Errno 13] Permission denied The image above is a problematic configuration because a port less than 1024 was selected. To solve this issue, modify your Dockerfile and tasks.json file in the manner shown in the Running your containerized app as a non-root user section."
  },
  "guides/vscode/containers/quickstart-aspnet-core.html": {
    "href": "guides/vscode/containers/quickstart-aspnet-core.html",
    "title": "ASP.NET Core in a container | Fountain of Knowledge",
    "keywords": "ASP.NET Core in a container In this guide you will learn how to: Create a Dockerfile file describing a simple .NET Core service container. Build, run, and verify the functionality of the service. Debug the service running as a container. Prerequisites Docker and the VS Code Docker extension must be installed as described on the overview . For .NET development, install .NET Core SDK . Microsoft C# for Visual Studio Code extension. Create a .NET Core Web API project Create a folder for the project. Open developer command prompt in the project folder and initialize the project: dotnet new webapi --no-https Add Docker files to the project Open the project folder in VS Code. Wait for the C# extension to prompt you to add required assets for build and debug, and choose Yes . You can also open the Command Palette ( kb(workbench.action.showCommands) ) and use the .NET: Generate Assets for Build and Debug command. Open Command Palette ( kb(workbench.action.showCommands) ) and use Docker: Add Docker Files to Workspace... command: Use .NET: ASP.NET Core when prompted for application platform. Choose Windows or Linux when prompted to choose the operating system. Windows is only applicable if your Docker installation is configured to use Windows containers. You will be asked if you want to add Docker Compose files. We will not use Docker Compose in this tutorial, so both \"Yes\" and \"No\" answers are fine. Change the port for application endpoint to 5000 . Dockerfile and .dockerignore files are added to the workspace. The extension will also create a set of VS Code tasks for building and running the container (in both debug- and release configuration, four tasks in total), and a debugging configuration for launching the container in debug mode. Build the application Open terminal prompt ( kb(workbench.action.terminal.toggleTerminal) ). Issue dotnet build command to build the application: ~/code/scratch/netcorerest$ dotnet build Microsoft (R) Build Engine version 16.3.0+0f4c62fea for .NET Core Copyright (C) Microsoft Corporation. All rights reserved. Restore completed in 18.97 ms for ~/code/scratch/netcorerest/netcorerest.csproj. netcorerest -> ~/code/scratch/netcorerest/bin/Debug/netcoreapp3.0/netcorerest.dll Build succeeded. 0 Warning(s) 0 Error(s) Add an environment variable to the image You can use the Docker extension to author Docker files. The extension provides completions and contextual help. To see these capabilities add an environment variable to your service image by following these: Open the Dockerfile file. Use ENV instruction to add an environment variable to the service container image. The instruction should be placed in the base stage of the Dockerfile (the first stage in the file). Set the ASPNETCORE_URLS variable to http://*:5000 : Note how the Docker extension lists all available Dockerfile instructions and describes the syntax. The Docker extension uses the base stage of the Dockerfile to create a debug version of the container image for your service. Put the ASPNETCORE_URLS environment variable definition in the base stage to have this variable available in both debug and release versions of the container image. Save the Dockerfile file. Build the image Open Command Palette ( kb(workbench.action.showCommands) ) and issue Docker Images: Build Image... command. Open Docker Explorer and verify that the new image is visible in the Images tree: Test the service container Right-click on the image built in previous step and choose Run or Run Interactive . The container should start and you should be able to see it in the \"Containers\" pane of the Docker Explorer: Open the web browser and navigate to http://localhost:5000/WeatherForecast . You should see weather data in JSON format, similar to following: [ {\"date\":\"2019-11-07T23:31:57.0527092+00:00\",\"temperatureC\":4,\"temperatureF\":39,\"summary\":\"Bracing\"}, {\"date\":\"2019-11-08T23:31:57.0539243+00:00\",\"temperatureC\":-19,\"temperatureF\":-2,\"summary\":\"Freezing\"}, {\"date\":\"2019-11-09T23:31:57.0539269+00:00\",\"temperatureC\":2,\"temperatureF\":35,\"summary\":\"Freezing\"}, {\"date\":\"2019-11-10T23:31:57.0539275+00:00\",\"temperatureC\":-4,\"temperatureF\":25,\"summary\":\"Freezing\"}, {\"date\":\"2019-11-11T23:31:57.053928+00:00\",\"temperatureC\":9,\"temperatureF\":48,\"summary\":\"Bracing\"} ] By default Docker will assign a randomly chosen host port to a port exposed by a container (the container port ). In our application the exposed (container) port is 5000. When you issue Run command for an image, VS Code will try to use the same port number for the host port and container port. This makes it easy to remember which port to use to communicate with the container, but it won't work if the host port is already in use. If you cannot see the data from the container in your browser, make sure there are no errors reported by the docker run command (look at the command output in the terminal window). You can also verify which host port is using by the container by right-clicking the container in the Docker Explorer and choosing Inspect . This will open a JSON document that describes the container in detail. Search for PortBindings element, for example: \"PortBindings\": { \"5000/tcp\": [ { \"HostIp\": \"\", \"HostPort\": \"5000\" } ] }, When done testing, right-click the container in the Docker Explorer and choose Stop . Debug in container When Docker files were added to the application, the Docker extension also added a VS Code debugger configuration for debugging the service when it is running inside a container. The extension will automatically detect the protocol and port that the service is using and point the browser to the service, but we need to tell it what URL path to use. Set a breakpoint at the beginning of the code for the Get() method of the Controllers/WeatherForecastController.cs file. Open .vscode/launch.json file and find Docker .NET Core Launch debug configuration. Add dockerServerReadyAction to Docker .NET Core Launch configuration: \"dockerServerReadyAction\": { \"uriFormat\": \"%s://localhost:%s/WeatherForecast\" } Make sure the configuration is selected as active: Start debugging ( kb(workbench.action.debug.start) ). The debug version of the service container builds and starts. The browser opens to request a new weather forecast. The breakpoint in the WeatherForecastController is hit. You can use specific port on the host by changing the Docker run options used by docker-run: debug task (defined in .vscode/tasks.json file). For example, if you want to use the same port (5000) to expose the service, the docker-run: debug task definition would look like this: { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build: debug\" ], \"dockerRun\": { \"ports\": [ { \"hostPort\": 5000, \"containerPort\": 5000 } ] }, \"netCore\": { \"appProject\": \"${workspaceFolder}/netcorerest.csproj\", \"enableDebugging\": true } Next steps You're done! Now that your container is ready, you may want to: Learn about debugging .NET Core in a container Customize your Docker build and run tasks Deploy a containerized app to Azure App Service Learn about using Docker Compose"
  },
  "guides/vscode/containers/quickstart-container-registries.html": {
    "href": "guides/vscode/containers/quickstart-container-registries.html",
    "title": "Using container registries | Fountain of Knowledge",
    "keywords": "Using container registries A container registry is a storage and content delivery system, holding named Docker images, available in different tagged versions. Users can connect to Docker registries from the following sources: Azure Container Registry Docker Hub GitLab container registry Any generic private registry that supports the Docker V2 api Azure Container Registry This option requires the Azure Account extension to be able to connect to your Azure account and display all of the different subscriptions and registries. Once authenticated, the node Azure will display the subscriptions along with registries each have: For each registry, users have different actions that can be performed using the context menu: Delete registry : deletes the registry permanently Open in portal : opens the browser and navigates to the registry in Azure Portal View properties : opens the registry properties in a json format Refresh : refreshes the registry to reflect changes For each repository in a given registry, here are the actions that can be performed: Pull repository : copies all of the images in a given repository locally Delete repository : deletes the repository permanently Refresh : refreshes the repository to reflect changes For each tagged image in a repository, here are the actions that can be performed: Pull image : copies the latest version of the image locally Copy image digest : copies the image digest, which is a SHA256 hash identifier that Docker uses, to the clipboard. See Docker Docs for more info on image digests Deploy image to Azure App Service : deploys the image to Azure App Service, see Deploy images to Azure App Service page Untag image : untags the image Delete image : deletes the image permanently Docker Hub This connects to Docker Hub and lists all of the repositories and images under the given account. Once you select this option, you will be required to type in your Docker Hub credentials. For each repository in the Docker Hub registry, here are the actions that can be performed: Pull repository : copies all of the images in a given repository locally Open in browser : opens the browser and navigates to the given repository on Docker Hub Refresh : refreshes the repository to reflect changes For each tagged image in a repository, here are the actions that can be performed: Pull image : copies the latest version of the image locally Open in browser : opens the browser and navigates to the given image on Docker Hub GitLab This connects to Docker registries in your GitLab account. Once you select this option, you will be required to type in your GitLab account credentials. For each repository in the GitLab registry, here are the actions that can be performed: Pull repository : copies all of the images in a given repository locally Refresh : refreshes the repository to reflect changes For each tagged image in a repository, here are the actions that can be performed: Pull image : copies the latest version of the image locally"
  },
  "guides/vscode/containers/quickstart-node.html": {
    "href": "guides/vscode/containers/quickstart-node.html",
    "title": "Node.js in a container | Fountain of Knowledge",
    "keywords": "Node.js in a container In this guide you will learn how to: Create a Dockerfile file for an Express Node.js service container Build, run, and verify the functionality of the service Debug the service running within a container Prerequisites Both Docker and the VS Code Docker extension must be installed as described in the overview Node.js version 10 or later Create an Express Node.js application Create a folder for the project. Open a development command prompt in the project folder and create the project: npx express-generator npm install Add Docker files to the project Open the project folder in VS Code. Open the Command Palette ( kb(workbench.action.showCommands) ) and use Docker: Add Docker Files to Workspace... command: Select Node.js when prompted for the application platform. Select either Yes or No when prompted to include Docker Compose files. Compose is typically used when running multiple containers at once. Enter 3000 when prompted for the application port. The extension creates Dockerfile and .dockerignore files. If you elected to include Docker Compose files, docker-compose.yml and docker-compose.debug.yml will be generated as well. Finally, the extension will create a set of VS Code tasks in .vscode/tasks.json for building and running the container (in both debug- and release-configurations) and a launch debug configuration in .vscode/launch.json for debugging the service within the container. Add an environment variable to the image The Docker extension helps you author Dockerfiles by using IntelliSense to provide auto-completions and contextual help. To see this feature in action, add an environment variable to your service image by following these steps: Open the Dockerfile file. Use ENV instruction to add an environment variable to the service container image. Note how the Docker extension lists all available Dockerfile instructions and describes the syntax. The Docker extension uses the base stage of the Dockerfile to create a debug version of the container image for your service. Put the environment variable definition in the base stage to have this variable available in both debug and release versions of the container image. Save the Dockerfile file. Run the service locally Open a terminal ( kb(workbench.action.terminal.toggleTerminal) ). Enter npm run start to start the application: > express-app@0.0.0 start /Users/user/code/scratch/express-app > node ./bin/www Open the web browser and navigate to http://localhost:3000 . You should see a page similar to the following: When done testing, type kbstyle(Ctrl+C) in the terminal. Build the service image Open the Command Palette ( kb(workbench.action.showCommands) ) and select the Docker Images: Build Image... command. Open the Docker Explorer and verify that the new image is visible in the Images tree: Run the service container Right-click on the image built in the previous section and select Run or Run Interactive . The container should start and you should be able to see it in the Docker Containers tree: Open the web browser and navigate to http://localhost:3000 . You should see a page similar to the following: When done testing, right-click the container in the Containers tree and select Stop . Debug in the service container When the Docker extension adds files to the application, it also adds a VS Code debugger configuration in .vscode/launch.json for debugging the service when running inside a container. The extension detects the protocol and port used by the service and points the browser to the service. Set a breakpoint in the get() handler for the '/' route in routes/index.js . Make sure the Docker Node.js Launch debugger configuration is selected. Start debugging (use the kb(workbench.action.debug.start) key). The Docker image for the service builds. The Docker container for the service runs. The browser opens to the (random) port mapped to the service container. The debugger stops at the breakpoint in index.js . Note that, because the debugger attaches after the application starts, the breakpoint may missed the first time around; you might have to refresh the browser to see the debugger break on the second try. You can configure the application to wait for the debugger to attach before starting execution by setting the inspectMode property to break in the docker-run: debug task in tasks.json under the node object. View the application logs You can view the logs in VS Code by using the View Logs command on the container: Navigate to the Docker Explorer. In the Containers tab, right-click on your container and choose View Logs . The output will be displayed in the terminal. Next steps You're done! Now that your container is ready, you may want to: Learn about debugging Node.js in a container Customize your Docker build and run tasks Learn about using Docker Compose"
  },
  "guides/vscode/containers/quickstart-python.html": {
    "href": "guides/vscode/containers/quickstart-python.html",
    "title": "Python in a container | Fountain of Knowledge",
    "keywords": "Python in a container In this guide you will learn how to: Create a Dockerfile file describing a simple Python container. Build, run, and verify the functionality of a Django , Flask , or General Python app. Debug the app running in a container. Prerequisites Docker Desktop and the VS Code Docker extension must be installed as described in the overview . For Python development, complete all Getting started with Python steps A runnable Python application Create a Python project If you don't have a Python project already, follow these commands sequentially from the terminal: pip install django django-admin startproject helloworld cd helloworld code . If you want to containerize a complete Django or Flask web app, you can use one of the following samples: python-sample-vscode-django-tutorial , which is the result of following the Django Tutorial python-sample-vscode-flask-tutorial , which is the result of following the Flask Tutorial After verifying your app runs properly, you can now Dockerize your application. Add Docker files to the project Open the project folder in VS Code. Open the Command Palette ( kb(workbench.action.showCommands) ) and use the Docker: Add Docker Files to Workspace... command: When the prompt appears, select Python: Django , Python: Flask , or Python: General as the app type. For this tutorial, we will select Python: Django . Enter the relative path to the app's entry point. This excludes the workspace folder you start from. According to official Django documentation , this path is commonly manage.py (root folder) or subfolder_name/manage.py . According to official Flask documentation , this is the path to where you create your Flask instance. Tip : You may also enter the path to a folder name as long as this folder includes a __main__.py file. If Python: Django or Python: Flask was selected, specify app port for local development. Django defaults to port 8000, while Flask defaults to port 5000; however, any unused port will work. We recommend selecting port 1024 or above to mitigate security concerns from running as a root user . Select either Yes or No when prompted to include Docker Compose files. If you select Yes , you will need to verify the path to your wsgi.py file in the Dockerfile to run the Compose Up command successfully. Compose is typically used when running multiple containers at once. With all of this information, the Docker extension creates the following files: A Dockerfile . To learn more about IntelliSense in this file, refer to the overview . A .dockerignore file to reduce the image size by excluding files and folders that aren't needed such as .git , .vscode , and __pycache__ . If Docker Compose was selected, a docker-compose.yml and docker-compose.debug.yml file. If one does not already exist, a requirements.txt file for capturing all app dependencies. Important note : To use our setup, the Python framework (Django/Flask) and Gunicorn must be included in the requirements.txt file. If the virtual environment/host machine already has these prerequisites installed and is supposed to be identical to the container environment, ensure app dependencies are ported over by running pip freeze > requirements.txt in the terminal. This will overwrite your current requirements.txt file. Add an environment variable to the image The Docker Extension helps you author Dockerfiles by using IntelliSense to provide auto-completions and contextual help. To see this feature in action: Open the Dockerfile . Underneath the EXPOSE statement, type kb(editor.action.triggerSuggest) to trigger IntelliSense and scroll to ENV . Press kbstyle(Tab) or kbstyle(Enter) to complete the statement, then set the key to VAR1 and the value to 10. Gunicorn modifications for Django/Flask apps To give Python Web Developers a great starting point, we chose to use Gunicorn as the default web server. Since it is referenced in the default Dockerfile, it is included as a dependency in the requirements.txt file. Note : To use Gunicorn as your web server, it must be included in the requirements.txt file as an app dependency. It does not need to be installed in your virtual environment/host machine. The Gunicorn entry point is overridden locally if your app is run with Python: Django or Python: Flask . Django apps To use Gunicorn, it must bind to an application callable (what the application server uses to communicate with your code) as an entry point. This callable is declared in the wsgi.py file of a Django application. To accomplish this binding, the final line in the Dockerfile says: CMD [\"gunicorn\", \"--bind\", \"0.0.0.0:8000\", \"{workspace_folder_name}.wsgi\"]` If your project does not follow Django's default project structure (that is, a workspace folder and a wsgi.py file within a subfolder named the same as the workspace) you must overwrite the Gunicorn entry point in the Dockerfile to locate the correct wsgi.py file. Tip : If your wsgi.py file is in the root folder, the final argument in the command above will be \"wsgi\" . Within subfolders, the argument would be \"subfolder1_name.subfolder2_name.wsgi\" . Flask apps To use Gunicorn, it must bind to an application callable (what the application server uses to communicate with your code) as an entry point. This callable corresponds with the file location and variable name of your created Flask instance. According to official Flask Documentation , users generally create a Flask instance in the main module or in the __init__.py file of their package in this manner: from flask import Flask app = Flask(__name__) # Flask instance named app To accomplish this binding, the final line in the Dockerfile says: CMD [\"gunicorn\", \"--bind\", \"0.0.0.0:5000\", \"{subfolder}.{module_file}:app\"] During the Docker: Add Docker Files to Workspace... command, you configure the path to the Flask instance, however, the Docker extension assumes your Flask instance variable is named app . If this is not the case, you must change the variable name in the Dockerfile. Tip : If your main module was in the root folder as a file named main.py and had a Flask instance variable was named myapp , the final argument in the command above will be \"main:myapp\" . Within subfolders, the argument would be \"subfolder1_name.subfolder2_name.main:myapp\" . Build, run, and debug the container The Docker: Add Docker Files to Workspace... command automatically creates a Docker launch configuration to build and run your container in debug mode. To debug your Python app container: Navigate to the manage.py file and set a breakpoint on this line: os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'helloworld.settings') Note : If you have created an app project as shown in the Create a Django app section of the Django tutorial, you can also set a breakpoint in views.py or wherever you choose. Navigate to Run and Debug and select Docker: Python - Django . Start debugging using the kb(workbench.action.debug.start) key. The Docker image builds. The Docker container runs. The python debugger stops at the breakpoint in manage.py . Step over this line once. Navigate to the Debug Console and type os.environ[\"DJANGO_SETTINGS_MODULE\"] Once you view the output, press continue. The Docker extension will launch your browser to a randomly mapped port: Tip : To modify your Docker build settings, such as changing the image tag, navigate to .vscode -> tasks.json under the dockerBuild attribute in the docker-build task. Use IntelliSense within the file ( kb(editor.action.triggerSuggest) ) to display all other valid directives. Use the Docker Explorer The Docker Explorer provides an interactive experience to examine and manage Docker assets such as containers, images, and so on. To see an example: Navigate to the Docker Explorer. In the Containers tab, right-click on your container and choose View Logs . The output will be displayed in the terminal. Next steps You're done! Now that your container is ready, you may want to: Debug with Docker Compose Customize how you debug Python apps in a container Customize your Docker build and run tasks Push your Django image to an Azure Container Registry Create a container registry using the Azure portal Deploy a containerized app to Azure App Service Learn about using Docker Compose"
  },
  "guides/vscode/containers/reference.html": {
    "href": "guides/vscode/containers/reference.html",
    "title": "Customize the Docker extension | Fountain of Knowledge",
    "keywords": "Customize the Docker extension The Docker extension includes several Visual Studio Code tasks to control the behavior of Docker build and run , and form the basis of container startup for debugging. The tasks allow for a great deal of control and customization. The final configuration is a combination of general defaults, platform-specific defaults (such as Node.js, Python, or .NET Core), and user input. User input takes precedence when it conflicts with defaults. All common features of Visual Studio Code tasks (for example, grouping tasks into compound tasks) are supported by Docker extension tasks. For more information on common task features and properties, see the Visual Studio Code custom task documentation. Docker build task The docker-build task builds Docker images using the Docker command line (CLI). The task can be used by itself, or as part of a chain of tasks to run and/or debug an application within a Docker container. The most important configuration settings for the docker-build task are dockerBuild and platform : The dockerBuild object specifies parameters for the Docker build command. Values specified by this object are applied directly to Docker build CLI invocation. The platform property is a hint that changes how the docker-build task determines Docker build defaults. See property reference for full list of all task properties. Platform support While the docker-build task in tasks.json can be used to build any Docker image, the extension has explicit support (and simplified configuration) for Node.js, Python, and .NET Core. Node.js (docker-build) Minimal configuration using defaults A Node.js based Docker image with no specific platform options can just set the platform property to node : { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Build Node Image\", \"type\": \"docker-build\", \"platform\": \"node\" } ] } Platform defaults For Node.js Docker images, the docker-build task infers the following options: Property Inferred Value dockerBuild.context The same directory in which the package.json resides. dockerBuild.dockerfile The file Dockerfile in the same directory as the package.json resides. dockerBuild.tag The application's name property in package.json (if defined), else the base name of the folder in which package.json resides. Python (docker-build) Minimal configuration using defaults A Python based Docker image with no specific platform options can just set the platform property to python : { \"tasks\": [ { \"type\": \"docker-build\", \"label\": \"docker-build\", \"platform\": \"python\" } ] } Platform defaults For Python Docker images, the docker-build task infers the following options: Property Inferred Value dockerBuild.context The default context is the workspace folder. dockerBuild.dockerfile The default Dockerfile path will be in the root of the workspace folder. dockerBuild.tag The base name of the root workspace folder. dockerBuild.pull Defaults to true in order to pull new base images before building. .NET Core (docker-build) Minimal configuration using defaults When you build a .NET Core-based Docker image, you can omit the platform property and just set the netCore object ( platform is implicitly set to netcore when netCore object is present). Note that appProject is a required property: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Build Node Image\", \"type\": \"docker-build\", \"netCore\": { \"appProject\": \"${workspaceFolder}/project.csproj\" } } ] } Platform defaults For .NET Core-based images, the docker-build task infers the following options: Property Inferred Value dockerBuild.context The root workspace folder. dockerBuild.dockerfile The file Dockerfile in the root workspace folder. dockerBuild.tag The base name of the root workspace folder. Build task reference Here are all properties available for configuring docker-build task. All properties are optional unless indicated otherwise. Property Description dockerBuild Options for controlling the docker build command executed ( see below ). Required unless platform is set. platform Determines the platform: .NET Core ( netcore ) or Node.js ( node ) and default settings for docker build command. node Determines options specific for Node.js projects ( see below ). python There are no object properties for Python in the docker-build task. netCore Determines options specific for .NET Core projects ( see below ). dockerBuild object properties Property Description docker build CLI Equivalent context The path to the Docker build context. Required, unless inferred from the platform. PATH dockerfile The path to the Dockerfile. Required, unless inferred from the platform. -f or --file tag The tag applied to the Docker image. Required, unless inferred from the platform. -t or --tag buildArgs Build arguments applied to the command line. This is a list of key-value pairs. --build-arg labels Labels added to the Docker image. This is a list of key-value pairs (a JSON object). In addition to labels specified here, a label com.microsoft.created-by , set to visual-studio-code is added to the image. This behavior can be turned off by setting includeDefaults property of the labels object to false. --label target The target in the Dockerfile to build to. --target pull Whether or not to pull new base images before building. --pull customOptions Any extra parameters to add before the context argument. No attempt is made to resolve conflicts with other options or validate this option. (any) node object properties ( docker-build task) Property Description Default package The path to the package.json file associated with the Dockerfile and docker-build task. The file package.json in the root workspace folder. netCore object properties ( docker-build task) Property Description appProject The .NET Core project file ( .csproj , .fsproj , etc.) associated with the Dockerfile and docker-build task. Required always. Docker run task The docker-run task in tasks.json creates and starts a Docker container using the Docker command line (CLI). The task can be used by itself, or as part of a chain of tasks to debug an application within a Docker container. The most important configuration settings for the docker-run task are dockerRun and platform : The dockerRun object specifies parameters for the Docker run command. Values specified by this object are applied directly to Docker run CLI invocation. The platform property is a hint that changes how the docker-run task determines Docker run defaults. See property reference for full list of all task properties. Platform support While the docker-run task can be used to run any Docker image, the extension has explicit support (and simplified configuration) for Node.js, Python, and .NET Core. Node.js (docker-run) Minimal configuration using defaults A Node.js based Docker image with no specific platform options can just set the platform property to node . { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Run Node Image\", \"node\": \"docker-run\", \"platform\": \"node\" } ] } Platform defaults For Node.js-based Docker images, the docker-run task infers the following options: Property Inferred Value dockerRun.command Generated from the npm start script in the package.json (if it exists), else generated from the main property in the package.json . dockerRun.containerName Derived from the application package name. dockerRun.image The tag from a dependent docker-build task (if one exists) or derived from the application package name, itself derived from the name property within package.json or the base name of the folder in which it resides. Python (docker-run) When building a Python-based Docker image, you can omit the platform property and just set the python object ( platform is implicitly set to python when python object is present) Minimal configuration for Django Apps { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"python\": { \"args\": [ \"runserver\", \"0.0.0.0:8000\", \"--nothreading\", \"--noreload\" ], \"file\": \"path_to/manage.py\" } } Minimal configuration for Flask Apps { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"dockerRun\": { \"env\": { \"FLASK_APP\": \"path_to/flask_entry_point.py\" } }, \"python\": { \"args\": [ \"run\", \"--no-debugger\", \"--no-reload\", \"--host\", \"0.0.0.0\", \"--port\", \"5000\" ], \"module\": \"flask\" } } Minimal configuration for General Apps { \"type\": \"docker-run\", \"label\": \"docker-run: debug\", \"dependsOn\": [ \"docker-build\" ], \"python\": { \"file\": \"path_to/app_entry_point.py\" } } Platform defaults For Python-based Docker images, the docker-run task infers the following options: Property Inferred Value dockerRun.command Generated by the Python object and is called by the Python Debugger. dockerRun.containerName Derived from the base name of the root workspace folder. dockerRun.image The tag from a dependent docker-build task (if one exists) or derived from the base name of the root workspace folder. .NET Core (docker-run) Minimal configuration using defaults When building a .NET Core-based Docker image, you can omit the platform property and just set the netCore object ( platform is implicitly set to netcore when netCore object is present). Note that appProject is a required property: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Run .NET Core Image\", \"type\": \"docker-run\", \"netCore\": { \"appProject\": \"${workspaceFolder}/project.csproj\" } } ] } Platform defaults For .NET Core-based images, the docker-run task infers the following options: Property Inferred Value dockerRun.containerName Derived from the base name of the root workspace folder. dockerRun.env Adds the following environment variables as required: ASPNETCORE_ENVIRONMENT , ASPNETCORE_URLS , and DOTNET_USE_POLLING_FILE_WATCHER . dockerRun.image The tag from a dependent docker-build task (if one exists) or derived from the base name of the root workspace folder. dockerRun.os Linux dockerRun.volumes Adds the following volumes as required: the local application folder, the source folder, the debugger folder, the NuGet package folder, and NuGet fallback folder. Run task reference Here are all properties available for configuring docker-run task. All properties are optional unless indicated otherwise. Property Description dockerRun Options for controlling the docker run command executed ( see below ). Required unless platform is set. platform Determines the platform: .NET Core ( netcore ) or Node.js ( node ) and default settings for docker run command. node For Node.js projects, this controls various options ( see below ). python For Python projects, this controls various options ( see below ). netCore For .NET Core projects, this controls various options ( see below ). dockerRun object properties Property Description CLI Equivalent image The name (tag) of the image to run. Required unless inferred from the platform. IMAGE command The command to run upon starting the container. Required, unless inferred from the platform. COMMAND [ARG...] containerName The name given to the started container. Required, unless inferred from the platform. --name env Environment variables set in the container. This is a list of key-value pairs. -e or --env envFiles This is a list of .env files. --env-file labels Labels given to the started container. This is a list of key-value pairs. --label network The name of the network to which the container will be connected. --network networkAlias The network-scoped alias for the started container. --network-alias os Default is Linux , the other option is Windows . The container operating system used. N/A ports The ports to publish (map) from container to host. This is a list of objects ( see below ). -p or --publish portsPublishAll Whether to publish all ports exposed by the Docker image. Defaults to true if no ports are explicitly published. -P extraHosts The hosts to add to the container for DNS resolution. This is a list of objects ( see below ). --add-host volumes The volumes to map into the started container. This is a list of objects ( see below ). -v or --volume remove Whether or not to remove the container after it stops. --rm customOptions Any extra parameters to add before the image argument. No attempt is made to resolve conflicts with other options or validate this option. (any) ports object properties Property Description Default containerPort The port number bound on the container. Required. hostPort The port number bound on the host. (randomly selected by Docker) protocol The protocol for the binding ( tcp or udp ). tcp extraHosts object properties Property Description hostname The hostname for DNS resolution. Required. ip The IP address associated with the above hostname. Required. volumes object properties Property Description Default localPath The path on the local machine that will be mapped. Required. containerPath The path in the container to which the local path will be mapped. Required. permissions Permissions the container has on the mapped path. Can be ro (read-only) or rw (read-write). Container dependent. node object properties ( docker-run task) Property Description Default package The path to the package.json file associated with the docker-run task. The file package.json in the root workspace folder. enableDebugging Whether or not to enable debugging within the container. false inspectMode Defines the initial interaction between the application and the debugger ( default or break ). The value default allows the application to run until the debugger attaches. The value break prevents the application from running until the debugger attaches. default inspectPort The port on which debugging should occur. 9229 python object properties ( docker-run task) Property Description Default args Arguments passed to the Python app. Platform dependent. Defaults of scaffolding shown above debugPort The port that the debugger will listen on. 5678 wait Whether to wait for debugger to attach. true module The Python module to run (only module or file should be chosen). file The Python file to run (only module or file should be chosen). netCore object properties ( docker-run task) Property Description appProject The .NET Core project file ( .csproj , .fsproj , etc.) associated with docker-run task. Required. configureSsl Whether to configure ASP.NET Core SSL certificates and other settings to enable SSL on the service in the container. enableDebugging Whether to enable the started container for debugging. This will infer additional volume mappings and other options necessary for debugging. Docker Compose task The docker-compose task in tasks.json creates and starts Docker containers using the Docker Compose command line (CLI). The task can be used by itself, or as part of a chain of tasks to debug an application within a Docker container. The most important configuration setting for the docker-compose task is dockerCompose : The dockerCompose object specifies parameters for the Docker Compose command. Values specified by this object are applied directly to Docker Compose CLI invocation. See property reference for full list of all task properties. Example configuration { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Run docker-compose up\", \"type\": \"docker-compose\", \"dockerCompose\": { \"up\": { \"detached\": true, \"build\": true, \"services\": [ \"myservice\" ] }, \"files\": [ \"${workspaceFolder}/docker-compose.yml\", \"${workspaceFolder}/docker-compose.debug.yml\" ] } } ] } Compose task reference Here are all properties available for configuring docker-compose task. All properties are optional unless indicated otherwise. Property Description dockerCompose Options for controlling the docker-compose command executed ( see below ). Required. dockerCompose object properties Property Description CLI Equivalent up Run a docker-compose up command. Either this or down must be specified, but not both. docker-compose up down Run a docker-compose down command. Either this or up must be specified, but not both. docker-compose down files The list of Docker Compose YAML files to use in the docker-compose command. If not specified, the Docker Compose CLI looks for docker-compose.yml and docker-compose.override.yml . -f <file> up object properties Property Description CLI Equivalent Default detached Whether or not to run detached. -d true build Whether or not to build before running. --build true scale Number of instances of each service to run. This is a list of key-value pairs. --scale SERVICE=NUM services A subset of the services to start. [SERVICE...] (all) customOptions Any extra parameters to add after the up argument. No attempt is made to resolve conflicts with other options or validate this option. (any) down object properties Property Description CLI Equivalent Default removeImages Whether to remove images, and which. all will remove all images used by any service, local will remove only images without a custom tag. Leaving this unset will remove no images. --rmi removeVolumes Whether or not to remove named volumes. -v false customOptions Any extra parameters to add after the down argument. No attempt is made to resolve conflicts with other options or validate this option. (any) Command customization The Docker extension executes a number of Docker CLI commands when you perform various operations, such as to build images, run containers, attach to containers, and view container logs. Some of these commands have a large number of optional arguments, often used in very specific scenarios. Many of these commands can be customized. For example, the token ${serviceList} in the Compose Up command allows for easily starting a subset of the services within your Docker Compose YAML file(s). For each of these customizable Docker commands, a configuration setting is available to set the template of what to execute. Alternatively, you can define multiple templates, optionally with a regular expression, which when matched, hints the context in which a template should be used. The templates support some tokens similar to launch.json and tasks.json , for example, ${workspaceFolder} . Settings JSON schema You have two options for configuring each of the templates (listed below). The first option is a single template that overrides the default behavior: { \"docker.commands.build\": \"docker build --rm -f \\\"${dockerfile}\\\" -t ${tag} \\\"${context}\\\"\" } The second option is multiple templates that will be chosen based on the match regular expression, the contextTypes in which it is applicable, as well as user input. The contextTypes property is a list of Docker context types in which a command template applies. If it is undefined or empty, the template is applicable in all Docker contexts. For example, three templates are shown in the following example: { \"docker.commands.build\": [ { \"label\": \"Default build command\", \"template\": \"docker build --rm -f \\\"${dockerfile}\\\" -t ${tag} \\\"${context}\\\"\" }, { \"label\": \"Alpine-specific build command\", \"template\": \"docker build -p 1234:1234 -f \\\"${dockerfile}\\\" -t ${tag} \\\"${context}\\\"\", \"match\": \"alpine\" }, { \"label\": \"Context-specific build command\", \"template\": \"docker build -f \\\"${dockerfile}\\\" .\", \"contextTypes\": [\"moby\"] } ] } Selection behavior The command template chosen to execute is selected based on the following rules: If no setting is configured, the default command template is chosen. If only a single template is configured (the first example above), that template is chosen. If multiple templates are configured: Constrained templates are checked. A constrained template has either match or contextTypes , or both. The match regular expression is compared against contextual hints--for example, image name, container name, etc. The contextTypes property causes the template to apply only in certain context types, for example, moby or aci (or both). If multiple constrained templates apply, the user will be prompted to choose. If only one applies, the user will not be prompted. If there no applicable constrained templates, unconstrained templates are checked. An unconstrained template has neither match nor contextTypes , and is therefore always applicable. If multiple unconstrained templates apply, the user will be prompted to choose. If only one applies, the user will not be prompted. Docker Build Configuration Setting Default Value docker.commands.build docker build --rm -f \"${dockerfile}\" -t ${tag} \"${context}\" Supported tokens: Token Description ${dockerfile} The workspace-relative path of the selected Dockerfile . ${tag} The value entered/confirmed by the user upon invoking the build command. If previously built, defaults to the previously entered value for that Dockerfile . ${context} If set, the value of the docker.imageBuildContextPath configuration setting. Otherwise, the workspace-relative folder in which the Dockerfile resides. Note : If the docker.commands.build setting does not contain the ${tag} token, the user will not be prompted to enter/confirm a tag. Note : The match regular expression will be compared against the selected Dockerfile name and the workspace folder name. Docker Run Configuration Setting Default Value docker.commands.run docker run --rm -d ${exposedPorts} ${tag} docker.commands.runInteractive docker run --rm -it ${exposedPorts} ${tag} Supported tokens: Token Description ${exposedPorts} Generated from the list of exposed ports in the image (ultimately from the Dockerfile ), where each exposed port is mapped to the same port on the local machine. For example, \"EXPOSE 5000 5001\" would generate \"-p 5000:5000 -p 5001:5001\" . ${tag} The full tag of the selected image. Note : The match regular expression will be compared against the full tag of the selected image. Docker Attach Configuration Setting Default Value docker.commands.attach docker exec -it ${containerId} ${shellCommand} Supported tokens: Token Description ${containerId} The ID of the container to attach to. ${shellCommand} If bash is present in the container, it is substituted here, otherwise sh . In Windows containers, cmd is always used. Note : The match regular expression will be compared against the container name and full tag of the container image. Docker Logs Configuration Setting Default Value docker.commands.logs docker logs -f ${containerId} Supported tokens: Token Description ${containerId} The ID of the container to view the logs for. Note : The match regular expression will be compared against the container name and full tag of the container image. Docker Compose Up Configuration Setting Default Value docker.commands.composeUp docker-compose ${configurationFile} up ${detached} ${build} Supported tokens: Token Description ${configurationFile} Set to -f plus the workspace-relative path to the selected Docker Compose YAML file. ${detached} Set to -d if the configuration setting docker.dockerComposeDetached is set to true . Otherwise, set to \"\" . ${build} Set to --build if the configuration setting docker.dockerComposeBuild is set to true . Otherwise, set to \"\" . ${serviceList} If specified, prompts for a subset of the services to start when the command is run. Docker Compose Down Configuration Setting Default Value docker.commands.composeDown docker-compose ${configurationFile} down Supported tokens: Token Description ${configurationFile} Set to -f plus the workspace-relative path to the selected Docker Compose YAML file. Additional supported tokens In addition to the command-specific supported tokens, the following tokens are supported in all command templates: Token Description ${workspaceFolder} The selected workspace folder path. ${config:some.setting.identifier} The value of any configuration setting, as long as it is a string, number, or boolean. These setting identifiers can be arbitrarily defined and do not need to belong to Visual Studio Code or to any extension. ${env:Name} The value of an environment variable. ${command:commandID} The string return value of a command."
  },
  "guides/vscode/containers/ssh.html": {
    "href": "guides/vscode/containers/ssh.html",
    "title": "Connect to remote Docker over SSH | Fountain of Knowledge",
    "keywords": "Connect to remote Docker over SSH We recommend using the Visual Studio Code Remote-SSH extension to connect to a remote machine running Docker engine, but it also possible to connect to the remote Docker engine directly, using SSH tunneling. Set up SSH Tunneling Use ssh-keygen or similar to get and configure a public/private key pair for SSH authentication. Password authentication is not supported by Docker and not possible with a DOCKER_HOST -based configuration. If a key pair has already been set up, it can be used. Configure ssh-agent on the local system with the private key file produced above. Windows (OpenSSH): The latest version(s) of Windows 10 include OpenSSH by default. There is a Windows service, ssh-agent that is disabled by default, and needs to be re-enabled and set to automatic start. From an admin command prompt, run sc config ssh-agent start=auto and net start ssh-agent . Then, do ssh-add <keyfile> . Windows (Pageant): You can use Pageant instead of OpenSSH, in which case it is necessary to set the environment variable SSH_AUTH_SOCK=pageant . Making that a user or system environment variable will be easiest. Linux: ssh-agent is present by default. Do ssh-add <keyfile> . Ubuntu was tested; you might have different results on other distributions. macOS: ssh-agent is present by default, but ssh-add does not persist across logins. Do ssh-add <keyfile> . We recommend configuring VS Code to run this command on terminal startup with terminal.integrated.shellArgs.osx or otherwise configuring a startup script. You can also manually run that command each login. Verify that your identity is available to the agent with ssh-add -l . It should list one or more identities that look something like 2048 SHA256:abcdefghijk somethingsomething (RSA) . If it does not list any identity, you will not be able to connect. Also, it needs to have the right identity. The Docker CLI working does not mean that the Explorer window will work. The Explorer window uses dockerode (which in turn uses ssh2 ), whereas the Docker CLI uses the ssh command, and benefits from an automatically inferred configuration. Create a Docker context that points to the remote machine running Docker. Use ssh://username@host:port as the Docker endpoint (replace \"host\" with your remote machine name, or the remote machine IP address). Issue the following command from terminal window: docker context create my-remote-docker-machine --docker \"host=ssh://username@host:port\" Always include the user name in the Docker endpoint address, even if it is the same as the local user name. If you omit the port, it defaults to 22. Use the Command Palette ( kb(workbench.action.showCommands) ) to issue the Docker Context: Use command to activate the Docker context pointing to the remote machine. This command causes both VS Code and Docker CLI to use the remote machine context. It is recommended to change the refresh rate to something longer than the default with the docker.explorerRefreshInterval setting. The connection over SSH is slow, and it can result in trying to refresh again before the previous refresh even finished. We recommend at least 3000 ms. Tips The \"host\" part in the Docker endpoint string ( ssh://username@host:port ) must be either a globally-resolvable DNS machine name, or an IP address. Docker extension will not be able to use host aliases defined in the SSH configuration file . Make sure the remote machine host key is already memorized in the known_hosts file . The simplest way to ensure this is to connect to the machine via ssh client program (run ssh username@host:port from the command line). Upon first-time connection, the ssh program will display the host key and let you approve it, updating the known_hosts file automatically. There is an issue with ssh-keygen utility that comes with Windows 10 build 1909 and older that prevents it from working properly with newer SSH daemons (for example, the one that comes with Ubuntu 20.04 LTS and newer). The workaround is to use ECDSA-type key, not RSA-type key, for the SSH connection. You can generate an ECDSA SSH key and add it to SSH agent with following commands: ssh-keygen -t ecdsa -b 521 ssh-add id_ecdsa Windows 10 build 1909 and older are affected by an issue that prevents SSH from getting to your identities after Windows OS update . The workaround is to add a dummy service entry to system configuration. Run the following from administrative command prompt window: sc create sshd binPath=C:\\Windows\\System32\\OpenSSH\\ssh.exe"
  },
  "guides/vscode/containers/troubleshooting.html": {
    "href": "guides/vscode/containers/troubleshooting.html",
    "title": "Docker Tools Tips and Tricks | Fountain of Knowledge",
    "keywords": "Docker Tools Tips and Tricks This article covers troubleshooting tips and tricks for the Visual Studio Code Docker extension. See the Overview and quickstart articles for Node.js , Python , or ASP.NET for details on setting up and working with Docker. Error \"connect EACCES /var/run/docker.sock\" on Linux Since VS Code runs as a non-root user, you will need to follow the steps in \"Manage Docker as a non-root user\" from Post-installation steps for Linux to access Docker from the extension. Docker containers and images have disappeared from Docker view This is most likely caused by a conflict with another extension called Docker Explorer (not authored by Microsoft). To resolve this issue, use a workaround described vscode-docker issue #1609 . The extension does not find Docker on a remote machine Error message \"Failed to connect. Is Docker installed and running?\" Make sure Docker engine is installed on the remote machine and that Docker CLI works (run docker ps from the terminal and ensure it does not return any errors). If you are using a remote development environment (remote machine via SSH, WSL subsystem, GitHub Codespace), make sure the Docker extension is installed remotely as well as locally. Invalid URL errors If you have a need to connect to a remote Docker daemon, we recommend using Docker contexts instead of a docker.host attribute in the settings. Check out this guide to learn how to create and use a context to communicate with a remote Docker daemon. If you still need to override the Docker context you are currently using, make sure your DOCKER_HOST environment variable or docker.host attribute includes a protocol in the URL (for example, ssh://myuser@mymachine or tcp://1.2.3.4 ). Note: Keep in mind that your docker.host attribute will override your Docker context and the DOCKER_HOST environment variable will override both the docker.host attribute and your Docker context. Tip : In Powershell you can change your Docker environment variable with $ENV:DOCKER_HOST = 'ssh://username@1.2.3.4' Questions and feedback We love your feedback! If you have any ideas or suggestions, report an issue ."
  },
  "guides/vscode/containers/tutorial-django-push-to-registry.html": {
    "href": "guides/vscode/containers/tutorial-django-push-to-registry.html",
    "title": "Push Django images to a registry | Fountain of Knowledge",
    "keywords": "Push Django images to a registry Create a container registry Create a container registry to push images to. For more information about how to authenticate to and work with registries, see Using container registries . Make sure that the registry endpoint you created is visible under Registries in the Docker Explorer of VS Code: Settings for Django apps In your Django project's settings.py file, modify the ALLOWED_HOSTS list to include the root URL to which you intend to deploy the app. For example, the following code assumes deployment to an Azure App Service (azurewebsites.net) named \"vsdocs-django-sample-container\": ALLOWED_HOSTS = [ # Example host name only; customize to your specific host \"vsdocs-django-sample-container.azurewebsites.net\" ] Without this entry, you'll see a \"DisallowedHost\" message after deployment that instructs to you add the website domain to ALLOWED_HOSTS . This will require you to rebuild, push, and redeploy the image once again. On the Command Palette ( kb(workbench.action.showCommands) ), select Docker: Build Image to rebuild image with new settings. Tip : If you want to test your image in production on multiple hosting services, you can simply input \"*\" in ALLOWED_HOSTS. Push the image to a registry Once ALLOWED_HOSTS have been declared, the next step is to push your Django image to a container registry: Open the Command Palette ( kb(workbench.action.showCommands) ) and select Docker: Push . Choose the image you just built to push into the registry. Choose the registry you created to push into. This will help with correctly tagging the image. Once a registry and full tag have been chosen, the image will be pushed. Upload progress will appear in the Terminal window. Once completed, expand the Registries > Azure (or DockerHub ) node in the Docker Explorer , then expand the registry and image name to see the exact image. (You may need to refresh the Docker Explorer .) Tip : The first time you push an image, you will see that VS Code uploads each layer the image is comprised of. Subsequent push operations, however, will only update layers starting from the first that has been changed. Since you app code is usually what changes most often, this is typically why app code is copied in the final lines of a Dockerfile. To see this inner loop in action, make a small change to your code, rebuild the image, and then push again to the registry. Now that you've pushed your image to a registry, you're ready to deploy it to any container-ready cloud service. For details on deploying to Azure App Service, see Deploy a container ."
  },
  "guides/vscode/cpp/c-cpp-properties-schema-reference.html": {
    "href": "guides/vscode/cpp/c-cpp-properties-schema-reference.html",
    "title": "c_cpp_properties.json reference | Fountain of Knowledge",
    "keywords": "c_cpp_properties.json reference This article explains the scheme for the c_cpp_properties.json settings file. For more information about changing these settings, see Customizing Default Settings and Configure IntelliSense for cross-compiling . Example { \"env\" : { \"myDefaultIncludePath\": [ \"${workspaceFolder}\", \"${workspaceFolder}/include\" ], \"myCompilerPath\": \"/usr/local/bin/gcc-7\" }, \"configurations\": [ { \"name\": \"Mac\", \"intelliSenseMode\": \"clang-x64\", \"includePath\": [ \"${myDefaultIncludePath}\", \"/another/path\" ], \"macFrameworkPath\": [ \"/System/Library/Frameworks\" ], \"defines\": [ \"FOO\", \"BAR=100\" ], \"forcedInclude\": [ \"${workspaceFolder}/include/config.h\" ], \"compilerPath\": \"/usr/bin/clang\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"compileCommands\": \"/path/to/compile_commands.json\", \"browse\": { \"path\": [ \"${workspaceFolder}\" ], \"limitSymbolsToIncludedHeaders\": true, \"databaseFilename\": \"\" } } ], \"version\": 4 } Top-level properties env An array of user-defined variables that will be available for substitution in the configurations via the standard environment variable syntax: ${<var>} or ${env:<var>} . Strings and arrays of strings are accepted. configurations An array of configuration objects that provide the IntelliSense engine with information about your project and your preferences. By default, the extension creates a configuration for you based on your operating system. You may also add additional configurations. version We recommend you don't edit this field. It tracks the current version of the c_cpp_properties.json file so that the extension knows what properties and settings should be present and how to upgrade this file to the latest version. Configuration properties name A friendly name that identifies a configuration. Linux , Mac , and Win32 are special identifiers for configurations that will be autoselected on those platforms. The status bar in VS Code will show you which configuration is active. You can also click on the label in the status bar to change the active configuration. compilerPath (optional) The full path to the compiler you use to build your project, for example /usr/bin/gcc , to enable more accurate IntelliSense. The extension will query the compiler to determine the system include paths and default defines to use for IntelliSense. Putting \"compilerPath\": \"\" (empty string) will skip querying a compiler. This is useful if a specified compiler doesn't support the arguments that are used for the query, as the extension will default back to any compiler it can find (like Visual C). Leaving out the compilerPath property does not skip the query. compilerArgs (optional) Compiler arguments to modify the includes or defines used, for example -nostdinc++ , -m32 , etc. intelliSenseMode The IntelliSense mode to use that maps to an architecture-specific variant of MSVC, gcc, or Clang. If not set or if set to ${default} , the extension will choose the default for that platform. Platform defaults: Windows: msvc-x64 Linux: gcc-x64 macOS: clang-x64 includePath An include path is a folder that contains header files (such as #include \"myHeaderFile.h\" ) that are included in a source file. Specify a list of paths for the IntelliSense engine to use while searching for included header files. Searching on these paths is not recursive. Specify ** to indicate recursive search. For example, ${workspaceFolder}/** will search through all subdirectories while ${workspaceFolder} will not. If on Windows with Visual Studio installed, or if a compiler is specified in the compilerPath setting, it is not necessary to list the system include paths in this list. defines A list of preprocessor definitions for the IntelliSense engine to use while parsing files. Optionally, use = to set a value, for example VERSION=1 . cStandard The version of the C language standard to use for IntelliSense. cppStandard The version of the C++ language standard to use for IntelliSense. configurationProvider The ID of a VS Code extension that can provide IntelliSense configuration information for source files. For example, use the VS Code extension ID ms-vscode.cmake-tools to provide configuration information from the CMake Tools extension. windowsSdkVersion The versions of the Windows SDK include path to use on Windows, for example 10.0.17134.0 . macFrameworkPath A list of paths for the IntelliSense engine to use while searching for included headers from Mac frameworks. Only supported on configurations for macOS. forcedInclude (optional) A list of files that should be included before any other characters in the source file are processed. Files are included in the order listed. compileCommands (optional) The full path to the compile_commands.json file for the workspace. The include paths and defines discovered in this file will be used instead of the values set for includePath and defines settings. If the compile commands database does not contain an entry for the translation unit that corresponds to the file you opened in the editor, then a warning message will appear and the extension will use the includePath and defines settings instead. For more information about the file format, see the Clang documentation . Some build systems, such as CMake, simplify generating this file . browse The set of properties used when \"C_Cpp.intelliSenseEngine\" is set to \"Tag Parser\" (also referred to as \"fuzzy\" IntelliSense, or the \"browse\" engine). These properties are also used by the Go To Definition/Declaration features, or when the \"Default\" IntelliSense engine is unable to resolve the #includes in your source files. Browse properties path A list of paths for the Tag Parser to search for headers included by your source files. If omitted, includePath will be used as the path . Searching on these paths is recursive by default. Specify * to indicate non-recursive search. For example: ${workspaceFolder} will search through all subdirectories while ${workspaceFolder}/* will not. limitSymbolsToIncludedHeaders When true, the Tag Parser will only parse code files that have been directly or indirectly included by a source file in ${workspaceFolder} . When false, the Tag Parser will parse all code files found in the paths specified in the browse.path list. databaseFilename The path to the generated symbol database. This property instructs the extension to save the Tag Parser's symbol database somewhere other than the workspace's default storage location. If a relative path is specified, it will be made relative to the workspace's default storage location, not the workspace folder itself. The ${workspaceFolder} variable can be used to specify a path relative to the workspace folder (for example ${workspaceFolder}/.vscode/browse.vc.db ) Supported variables You can allow tasks.json or launch.json to query the current active configuration from c_cpp_properties.json . To do this, use the variable ${command:cpptools.activeConfigName} as an argument in a tasks.json or launch.json script."
  },
  "guides/vscode/cpp/cmake-linux.html": {
    "href": "guides/vscode/cpp/cmake-linux.html",
    "title": "Get started with CMake Tools on Linux | Fountain of Knowledge",
    "keywords": "Get started with CMake Tools on Linux CMake is an open-source, cross-platform tool that uses compiler and platform independent configuration files to generate native build tool files specific to your compiler and platform. The CMake Tools extension integrates Visual Studio Code and CMake to make it easy to configure, build, and debug your C++ project. In this tutorial, you'll use the CMake Tools extension for Visual Studio Code to configure, build, and debug a simple C++ CMake project on Linux. Aside from installing CMake, your compiler, debugger, and build tools, the steps in this tutorial apply generally to how you'd use CMake on other platforms, like Windows. If you have any trouble, please file an issue for this tutorial in the VS Code documentation repository . Prerequisites To complete this tutorial on Ubuntu, install the following: Visual Studio Code . C++ extension for VS Code . Install the C/C++ extension by searching for 'c++' in the Extensions view ( kb(workbench.view.extensions) ). CMake Tools extension for VS Code . Install the CMake Tools extension by searching for 'CMake tools' in the Extensions view ( kb(workbench.view.extensions) ). You'll also need to install CMake, a compiler, a debugger, and build tools. Ensure that CMake is installed The VS Code CMake Tools extension does its work by using CMake installed on your system. For best results, use CMake version 3.15 or greater. See if CMake is already installed on your system. Open a Terminal window and enter the following command: cmake --version To install CMake, or to get a later version if you don't at least have version 3.15, see the instructions for your platform at Kitware APT Repository . Install version 3.15 or greater. Ensure that development tools are installed Although you'll use VS Code to edit your source code, you'll compile and debug the source code using the compiler, debugger, and build tools (such as make ) installed on your system. For this tutorial on Ubuntu, we'll use the GCC compiler, GDB to debug, and make to build the project. These tools are not installed by default on Ubuntu, so you need to install them. Fortunately, that's easy. Check if GCC is installed To see if GCC is already installed on your system, open a Terminal window and enter the following command: gcc -v If GCC isn't installed, run the following command from the Terminal window to update the Ubuntu package lists. An out-of-date Linux distribution can interfere with getting the latest packages. sudo apt-get update Next, install the GNU compiler, make , and the GDB debugger with this command: sudo apt-get install build-essential gdb Create a CMake project If you have an existing CMake project that already has a CMakeLists.txt file in the root directory, you can skip to Select a kit to configure your existing project. Otherwise, create a folder for a new project. From the Terminal window, create an empty folder called cmakeQuickStart , navigate into it, and open VS Code in that folder by entering the following commands: mkdir cmakeQuickStart cd cmakeQuickStart code . The code . command opens VS Code in the current working folder, which becomes your \"workspace\". Create a CMake hello world project The CMake Tools extension can create the files for a basic CMake project for you. Open the Command Palette ( kb(workbench.action.showCommands) ) and run the CMake: Quick Start command: Enter a project name. This will be written to CMakeLists.txt and a few initial source files. Next, select Executable as the project type to create a basic source file ( main.cpp ) that includes a basic main() function. Note: If you had wanted to create a basic source and header file, you would have selected Library instead. But for this tutorial, Executable will do. If you are prompted to configure IntelliSense for the folder, select Allow . This creates a hello world CMake project containing main.cpp , CMakeLists.txt (which tells the CMake tools how to build your project), and a folder named build for your build files: Select a kit Before you can use the CMake Tools extension to build a project, you need to configure it to know about the compilers on your system. Do that by scanning for 'kits'. A kit represents a toolchain, which is the compiler, linker, and other tools used to build your project. To scan for kits: Open the Command Palette ( kb(workbench.action.showCommands) ) and run CMake: Select a Kit . The extension will automatically scan for kits on your computer and create a list of compilers found on your system. Select the compiler you want to use. For example, depending on the compilers you have installed, you might see something like: Configure Hello World There are two things you must do to configure your CMake project: select a kit (which you just did) and select a variant. The kit you selected previously is shown in the Status bar. For example: To change the kit, you can click on the kit in the Status bar, or run the CMake: Select a kit command again from the Command Palette. If you don't see the compiler you're looking for, you can edit the cmake-tools-kits.json file in your project. To edit the file, open the Command Palette ( kb(workbench.action.showCommands) ) and run the CMake: Edit User-Local CMake Kits command. Select a variant A variant contains instructions for how to build your project. By default, the CMake Tools extension provides four variants, each corresponding to a default build type: Debug , Release , MinRelSize , and RelWithDebInfo . These options do the following: Debug : disables optimizations and includes debug info. Release : Includes optimizations but no debug info. MinRelSize : Optimizes for size. No debug info. RelWithDebInfo : Optimizes for speed and includes debug info. To select a variant, open the Command Palette ( kb(workbench.action.showCommands) ) run the CMake: Select Variant command. Select Debug to include debug information with your build. The selected variant will appear in the Status bar next to the active kit. CMake: Configure Now that you've selected a kit and a variant, open the Command Palette ( kb(workbench.action.showCommands) ) and run the CMake: Configure command to configure your project. This generates build files in the project's build folder using the kit and variant you selected. Build hello world After configuring your project, you're ready to build. Open the Command Palette ( kb(workbench.action.showCommands) ) and run the CMake: Build command, or select the Build button from the Status bar. You can select which targets you'd like to build by selecting CMake: Set Build Target from the Command Palette. By default, CMake Tools builds all targets. The selected target will appear in the Status bar next to the Build button. Debug hello world To run and debug your project, open main.cpp and put a breakpoint on the std::cout line. Then open the Command Palette ( kb(workbench.action.showCommands) ) and run CMake: Debug . The debugger will stop on the std::cout line: Go ahead and press kb(workbench.action.debug.start) to continue. You've now used the VS Code CMake Tools extension to use CMake to build and debug a C++ app on Ubuntu. The steps are the same for other platforms; the difference being how you install CMake and the compiler/debugger for the platform of your choice. For instructions on setting up compilers/debuggers for other platforms, see the following: Microsoft C++ on Windows Clang on macOS GCC on Windows Subsystem for Linux Next steps Explore the CMake Tools documentation Review the Overview of the C++ extension"
  },
  "guides/vscode/cpp/colorization-cpp.html": {
    "href": "guides/vscode/cpp/colorization-cpp.html",
    "title": "Enhanced colorization | Fountain of Knowledge",
    "keywords": "Enhanced colorization The Visual Studio Code C/C++ extension now supports semantic colorization, when IntelliSense is enabled. Use of enhanced colorization is controlled by the C_Cpp.enhancedColorization setting. This setting is enabled by default. \"C_Cpp.enhancedColorization\": \"Enabled\" Themes Colors can be associated using the existing support for theming and color customization in VS Code. See the VS Code Themes documentation for more information. Colors are associated with semantic tokens as well as TextMate scopes . C/C++ Themes Extension We've created a set of VS Code themes that closely resemble the default Light and Dark themes in Visual Studio, and include colors for semantic tokens. These themes can be found here . IntelliSense Tokens and Scopes Token Semantic Token name Fallback TextMate Scope Class Template templateType entity.name.type.class.templated Enumerator enumMember variable.other.enummember Event (C++/CLI) event variable.other.event Function function entity.name.function Function Template templateFunction entity.name.function.templated Generic Type (C++/CLI) genericType entity.name.type.class.generic Global Variable variable.global variable.other.global Label label entity.name.label Local Variable variable.local variable.other.local Macro macro entity.name.function.preprocessor Member Field property variable.other.property Member Function member entity.name.function.member Namespace namespace entity.name.namespace New / Delete newOperator keyword.operator.new Operator Overload Function operatorOverload entity.name.function.operator Operator Overload Member memberOperatorOverload entity.name.function.operator.member Parameter parameter variable.parameter Property (C++/CLI) cliProperty variable.other.property.cli Reference Type (C++/CLI) referenceType entity.name.type.class.reference Static Member Field property.static variable.other.property.static Static Member Function member.static entity.name.function.member.static Type type entity.name.type User-Defined Literal - Number numberLiteral entity.name.operator.custom-literal.number User-Defined Literal - Raw customLiteral entity.name.operator.custom-literal User-Defined Literal - String stringLiteral entity.name.operator.custom-literal.string Value Type (C++/CLI) valueType entity.name.type.class.value Customizing Colors in Settings Colors can also be overridden globally, in settings: \"editor.semanticTokenColorCustomizations\": { \"rules\": { \"templateType\": { \"foreground\": \"#ff0000\", \"fontStyle\": \"italic bold underline\" } } } Or, overridden on a per-theme basis: \"editor.semanticTokenColorCustomizations\": { \"[Visual Studio Dark]\": { \"rules\": { \"templateType\": { \"foreground\": \"#ff0000\", \"fontStyle\": \"italic bold underline\" } } } }"
  },
  "guides/vscode/cpp/config-clang-mac.html": {
    "href": "guides/vscode/cpp/config-clang-mac.html",
    "title": "Using Clang in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Using Clang in Visual Studio Code In this tutorial, you configure Visual Studio Code on macOS to use the Clang/LLVM compiler and debugger. After configuring VS Code, you will compile and debug a simple C++ program in VS Code. This tutorial does not teach you about Clang or the C++ language. For those subjects, there are many good resources available on the Web. If you have any trouble, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this tutorial, you must do the following: Install Visual Studio Code on macOS . Install the C++ extension for VS Code . You can install the C/C++ extension by searching for 'c++' in the Extensions view ( kb(workbench.view.extensions) ). Ensure Clang is installed Clang may already be installed on your Mac. To verify that it is, open a macOS Terminal window and enter the following command: clang --version If Clang isn't installed, enter the following command to install the command line developer tools: xcode-select --install Create Hello World From the macOS Terminal, create an empty folder called projects where you can store all your VS Code projects, then create a subfolder called helloworld , navigate into it, and open VS Code in that folder by entering the following commands: mkdir projects cd projects mkdir helloworld cd helloworld code . The code . command opens VS Code in the current working folder, which becomes your \"workspace\". As you go through the tutorial, you will create three files in a .vscode folder in the workspace: tasks.json (compiler build settings) launch.json (debugger settings) c_cpp_properties.json (compiler path and IntelliSense settings) Add hello world source code file In the File Explorer title bar, select New File and name the file helloworld.cpp . Paste in the following source code: #include <iostream> #include <vector> #include <string> using namespace std; int main() { vector<string> msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"}; for (const string& word : msg) { cout << word << \" \"; } cout << endl; } Now press kb(workbench.action.files.save) to save the file. Notice that your files are listed in the File Explorer view ( kb(workbench.view.explorer) ) in the side bar of VS Code: You can also enable Auto Save to automatically save your file changes, by checking Auto Save in the main File menu. The Activity Bar on the edge of Visual Studio Code lets you open different views such as Search , Source Control , and Run . You'll look at the Run view later in this tutorial. You can find out more about the other views in the VS Code User Interface documentation . Note : When you save or open a C++ file, you may see a notification from the C/C++ extension about the availability of an Insiders version, which lets you test new features and fixes. You can ignore this notification by selecting the X ( Clear Notification ). Explore IntelliSense In the helloworld.cpp file, hover over vector or string to see type information. After the declaration of the msg variable, start typing msg. as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window that shows the type information for the msg object: You can press the kbstyle(Tab) key to insert the selected member. Then, when you add the opening parenthesis, you'll see information about arguments that the function requires. Build helloworld.cpp Next, you'll create a tasks.json file to tell VS Code how to build (compile) the program. This task will invoke the Clang C++ compiler to create an executable file from the source code. It's important to have helloworld.cpp open in the editor because the next step uses the active file in the editor as context to create the build task in the next step. From the main menu, choose Terminal > Configure Default Build Task . A dropdown will appear listing various predefined build tasks for the compilers that VS Code found on your machine. Choose C/C++ clang++ build active file to build the file that is currently displayed (active) in the editor. This will create a tasks.json file in the .vscode folder and open it in the editor. Replace the contents of that file with the following: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"shell\", \"label\": \"clang++ build active file\", \"command\": \"/usr/bin/clang++\", \"args\": [ \"-std=c++17\", \"-stdlib=libc++\", \"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\" ], \"options\": { \"cwd\": \"${workspaceFolder}\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } The JSON above differs from the default template JSON in the following ways: \"args\" is updated to compile with C++17 because our helloworld.cpp uses C++17 language features. Changes the current working directory directive ( \"cwd\" ) to the folder where helloworld.cpp is. The command setting specifies the program to run. In this case, \"clang++\" is the driver that causes the Clang compiler to expect C++ code and link against the C++ standard library. The args array specifies the command-line arguments that will be passed to clang++. These arguments must be specified in the order expected by the compiler. This task tells the C++ compiler to compile the active file ( ${file} ), and create an output file ( -o switch) in the current directory ( ${fileDirname} ) with the same name as the active file ( ${fileBasenameNoExtension} ), resulting in helloworld for our example. The label value is what you will see in the tasks list. Name this whatever you like. The problemMatcher value selects the output parser to use for finding errors and warnings in the compiler output. For clang++, you'll get the best results if you use the $gcc problem matcher. The \"isDefault\": true value in the group object specifies that this task will be run when you press kb(workbench.action.tasks.build) . This property is for convenience only; if you set it to false , you can still build from the Terminal menu with Terminal > Run Build Task . Note : You can learn more about tasks.json variables in the variables reference . Running the build Go back to helloworld.cpp . Because we want to build helloworld.cpp it is important that this file be the one that is active in the editor for the next step. To run the build task that you defined in tasks.json, press kb(workbench.action.tasks.build) or from the Terminal main menu choose Run Build Task . When the task starts, you should see the Integrated Terminal window appear below the code editor. After the task completes, the terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful Clang build, the output looks something like this: Create a new terminal using the + button and you'll have a new terminal with the helloworld folder as the working directory. Run ls and you should now see the executable helloworld along with the debugging file ( helloworld.dSYM ). You can run helloworld in the terminal by typing ./helloworld . Modifying tasks.json You can modify your tasks.json to build multiple C++ files by using an argument like \"${workspaceFolder}/*.cpp\" instead of ${file} . This will build all .cpp files in your current folder. You can also modify the output filename by replacing \"${fileDirname}/${fileBasenameNoExtension}\" with a hard-coded filename (for example \"${workspaceFolder}/myProgram.out\" ). Debug helloworld.cpp Next, you'll create a launch.json file to configure VS Code to launch the LLDB debugger when you press kb(workbench.action.debug.start) to debug the program. From the main menu, choose Run > Add Configuration... and then choose C++ (GDB/LLDB) . You'll then see a dropdown for predefined debugging configurations. Choose clang++ build and debug active file . VS Code creates a launch.json file, opens it in the editor, and builds and runs 'helloworld'. Your launch.json file will look something like this: { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"clang++ - Build and debug active file\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}\", \"args\": [], \"stopAtEntry\": true, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"lldb\", \"preLaunchTask\": \"clang++ build active file\" } ] } The program setting specifies the program you want to debug. Here it is set to the active file folder ${fileDirname} and active filename ${fileBasenameNoExtension} , which if helloworld.cpp is the active file will be helloworld . By default, the C++ extension won't add any breakpoints to your source code and the stopAtEntry value is set to false . Change the stopAtEntry value to true to cause the debugger to stop on the main method when you start debugging. Ensure that the preLaunchTask value matches the label of the build task in the tasks.json file. Start a debugging session Go back to helloworld.cpp so that it is the active file in the editor. This is important because VS Code uses the active file to determine what you want to debug. Press kb(workbench.action.debug.start) or from the main menu choose Run > Start Debugging . Before you start stepping through the source code, let's take a moment to notice several changes in the user interface: The Integrated Terminal appears at the bottom of the source code editor. In the Debug Output tab, you see output that indicates the debugger is up and running. The editor highlights the first statement in the main method. This is a breakpoint that the C++ extension automatically sets for you: The Run view on the left shows debugging information. You'll see an example later in the tutorial. At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side. Step through the code Now you're ready to start stepping through the code. Click or press the Step over icon in the debugging control panel so that the for (const string& word : msg) statement is highlighted. The Step Over command skips over all the internal function calls within the vector and string classes that are invoked when the msg variable is created and initialized. Notice the change in the Variables window. The contents of msg are visible because that statement has completed. Press Step over again to advance to the next statement (skipping over all the internal code that is executed to initialize the loop). Now, the Variables window shows information about the loop variable. Press Step over again to execute the cout statement. Note As of the March 2019 version of the extension, no output will appear in the DEBUG CONSOLE until the last cout completes. Set a watch You might want to keep track of the value of a variable as your program executes. You can do this by setting a watch on the variable. Place the insertion point inside the loop. In the Watch window, click the plus sign and in the text box, type word , which is the name of the loop variable. Now view the Watch window as you step through the loop. To quickly view the value of any variable while execution is paused, you can hover over it with the mouse pointer. C/C++ configuration For more control over the C/C++ extension, create a c_cpp_properties.json file, which allows you to change settings such as the path to the compiler, include paths, which C++ standard to compile against (such as C++17), and more. View the C/C++ configuration UI by running the command C/C++: Edit Configurations (UI) from the Command Palette ( kb(workbench.action.showCommands) ). This opens the C/C++ Configurations page. Visual Studio Code places these settings in .vscode/c_cpp_properties.json . If you open that file directly, it should look something like this: { \"configurations\": [ { \"name\": \"Mac\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [], \"macFrameworkPath\": [ \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks\" ], \"compilerPath\": \"/usr/bin/clang\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x64\" } ], \"version\": 4 } You only need to modify the Include path setting if your program includes header files that are not in your workspace or the standard library path. Compiler path compilerPath is an important configuration setting. The extension uses it to infer the path to the C++ standard library header files. When the extension knows where to find those files, it can provide useful features like smart completions and Go to Definition navigation. The C/C++ extension attempts to populate compilerPath with the default compiler location based on what it finds on your system. The compilerPath search order is: Your PATH for the names of known compilers. The order the compilers appear in the list depends on your PATH. Then hard-coded Xcode paths are searched, such as /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ Mac framework path On the C/C++ Configuration screen, scroll down and expand Advanced Settings and ensure that Mac framework path points to the system header files. For example: /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks Reusing your C++ configuration VS Code is now configured to use Clang on macOS. The configuration applies to the current workspace. To reuse the configuration, just copy the JSON files to a .vscode folder in a new project folder (workspace) and change the names of the source file(s) and executable as needed. Troubleshooting Compiler and linking errors The most common cause of errors (such as undefined _main , or attempting to link with file built for unknown-unsupported file format , and so on) occurs when helloworld.cpp is not the active file when you start a build or start debugging. This is because the compiler is trying to compile something that isn't source code, like your launch.json , tasks.json , or c_cpp_properties.json file. If you see build errors mentioning \"C++11 extensions\", you may not have updated your tasks.json build task to use the clang++ argument --std=c++17 . By default, clang++ uses the C++98 standard, which doesn't support the initialization used in helloworld.cpp . Make sure to replace the entire contents of your tasks.json file with the code block provided in the Build helloworld.cpp section. Terminal won't launch For input On macOS Catalina and onwards, you might have a issue where you are unable to enter input, even after setting \"externalConsole\": true . A terminal window opens, but it does not actually allow you type any input. The issue is currently tracked #5079 . The workaround is to have VS Code launch the terminal once. You can do this by adding and running this task in your tasks.json : { \"label\": \"Open Terminal\", \"type\": \"shell\", \"command\": \"osascript -e 'tell application \\\"Terminal\\\"\\ndo script \\\"echo hello\\\"\\nend tell'\", \"problemMatcher\": [] } You can run this specific task using Terminal > Run Task... and select Open Terminal . Once you accept the permission request, then the external console should appear when you debug. Next steps Explore the VS Code User Guide . Review the Overview of the C++ extension Create a new workspace, copy your .json files to it, adjust the necessary settings for the new workspace path, program name, and so on, and start coding!"
  },
  "guides/vscode/cpp/config-linux.html": {
    "href": "guides/vscode/cpp/config-linux.html",
    "title": "Using C++ on Linux in VS Code | Fountain of Knowledge",
    "keywords": "Using C++ on Linux in VS Code In this tutorial, you will configure Visual Studio Code to use the GCC C++ compiler (g++) and GDB debugger on Linux. GCC stands for GNU Compiler Collection; GDB is the GNU debugger. After configuring VS Code, you will compile and debug a simple C++ program in VS Code. This tutorial does not teach you GCC, GDB, Ubuntu or the C++ language. For those subjects, there are many good resources available on the Web. If you have trouble, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this tutorial, you must do the following: Install Visual Studio Code . Install the C++ extension for VS Code . You can install the C/C++ extension by searching for 'c++' in the Extensions view ( kb(workbench.view.extensions) ). Ensure GCC is installed Although you'll use VS Code to edit your source code, you'll compile the source code on Linux using the g++ compiler. You'll also use GDB to debug. These tools are not installed by default on Ubuntu, so you have to install them. Fortunately, that's easy. First, check to see whether GCC is already installed. To verify whether it is, open a Terminal window and enter the following command: gcc -v If GCC isn't installed, run the following command from the terminal window to update the Ubuntu package lists. An out-of-date Linux distribution can sometimes interfere with attempts to install new packages. sudo apt-get update Next install the GNU compiler tools and the GDB debugger with this command: sudo apt-get install build-essential gdb Create Hello World From the terminal window, create an empty folder called projects to store your VS Code projects. Then create a subfolder called helloworld , navigate into it, and open VS Code in that folder by entering the following commands: mkdir projects cd projects mkdir helloworld cd helloworld code . The code . command opens VS Code in the current working folder, which becomes your \"workspace\". As you go through the tutorial, you will create three files in a .vscode folder in the workspace: tasks.json (compiler build settings) launch.json (debugger settings) c_cpp_properties.json (compiler path and IntelliSense settings) Add hello world source code file In the File Explorer title bar, select New File and name the file helloworld.cpp . Paste in the following source code: #include <iostream> #include <vector> #include <string> using namespace std; int main() { vector<string> msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"}; for (const string& word : msg) { cout << word << \" \"; } cout << endl; } Now press kb(workbench.action.files.save) to save the file. Notice that your files are listed in the File Explorer view ( kb(workbench.view.explorer) ) in the side bar of VS Code: You can also enable Auto Save to automatically save your file changes, by checking Auto Save in the main File menu. The Activity Bar on the edge of Visual Studio Code lets you open different views such as Search , Source Control , and Run . You'll look at the Run view later in this tutorial. You can find out more about the other views in the VS Code User Interface documentation . Note : When you save or open a C++ file, you may see a notification from the C/C++ extension about the availability of an Insiders version, which lets you test new features and fixes. You can ignore this notification by selecting the X ( Clear Notification ). Explore IntelliSense In the helloworld.cpp file, hover over vector or string to see type information. After the declaration of the msg variable, start typing msg. as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window that shows the type information for the msg object: You can press the kbstyle(Tab) key to insert the selected member. Then, when you add the opening parenthesis, you'll see information about arguments that the function requires. Build helloworld.cpp Next, you'll create a tasks.json file to tell VS Code how to build (compile) the program. This task will invoke the g++ compiler to create an executable file from the source code. It's important to have helloworld.cpp open in the editor because the next step uses the active file in the editor for context to create the build task in the next step. From the main menu, choose Terminal > Configure Default Build Task . A dropdown appears showing various predefined build tasks for C++ compilers. Choose C/C++: g++ build active file . This will create a tasks.json file in a .vscode folder and open it in the editor. Your new tasks.json file should look similar to the JSON below: { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"shell\", \"label\": \"g++ build active file\", \"command\": \"/usr/bin/g++\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\" ], \"options\": { \"cwd\": \"/usr/bin\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } Note : You can learn more about tasks.json variables in the variables reference . The command setting specifies the program to run; in this case that is g++. The args array specifies the command-line arguments that will be passed to g++. These arguments must be specified in the order expected by the compiler. This task tells g++ to take the active file ( ${file} ), compile it, and create an executable file in the current directory ( ${fileDirname} ) with the same name as the active file but without an extension ( ${fileBasenameNoExtension} ), resulting in helloworld for our example. The label value is what you will see in the tasks list; you can name this whatever you like. The \"isDefault\": true value in the group object specifies that this task will be run when you press kb(workbench.action.tasks.build) . This property is for convenience only; if you set it to false, you can still run it from the Terminal menu with Tasks: Run Build Task . Running the build Go back to helloworld.cpp . Your task builds the active file and you want to build helloworld.cpp . To run the build task defined in tasks.json , press kb(workbench.action.tasks.build) or from the Terminal main menu choose Run Build Task . When the task starts, you should see the Integrated Terminal panel appear below the source code editor. After the task completes, the terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful g++ build, the output looks something like this: Create a new terminal using the + button and you'll have a terminal running your default shell with the helloworld folder as the working directory. Run ls and you should now see the executable helloworld (no file extension). You can run helloworld in the terminal by typing ./helloworld . Modifying tasks.json You can modify your tasks.json to build multiple C++ files by using an argument like \"${workspaceFolder}/*.cpp\" instead of ${file} . You can also modify the output filename by replacing \"${fileDirname}/${fileBasenameNoExtension}\" with a hard-coded filename (for example 'helloworld.out'). Debug helloworld.cpp Next, you'll create a launch.json file to configure VS Code to launch the GDB debugger when you press kb(workbench.action.debug.start) to debug the program. From the main menu, choose Run > Add Configuration... and then choose C++ (GDB/LLDB) . You'll then see a dropdown for various predefined debugging configurations. Choose g++ build and debug active file . VS Code creates a launch.json file, opens it in the editor, and builds and runs 'helloworld'. { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"g++ build and debug active file\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"g++ build active file\", \"miDebuggerPath\": \"/usr/bin/gdb\" } ] } In the JSON above, program specifies the program you want to debug. Here it is set to the active file folder ${fileDirname} and active filename without an extension ${fileBasenameNoExtension} , which if helloworld.cpp is the active file will be helloworld . By default, the C++ extension won't add any breakpoints to your source code and the stopAtEntry value is set to false . Change the stopAtEntry value to true to cause the debugger to stop on the main method when you start debugging. Start a debugging session Go back to helloworld.cpp so that it is the active file. Press kb(workbench.action.debug.start) or from the main menu choose Run > Start Debugging . Before you start stepping through the code, let's take a moment to notice several changes in the user interface: The Integrated Terminal appears at the bottom of the source code editor. In the Debug Output tab, you see output that indicates the debugger is up and running. The editor highlights the first statement in the main method. This is a breakpoint that the C++ extension automatically sets for you: The Run view on the left shows debugging information. You'll see an example later in the tutorial. At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side. Step through the code Now you're ready to start stepping through the code. Click or press the Step over icon in the debugging control panel. This will advance program execution to the first line of the for loop, and skip over all the internal function calls within the vector and string classes that are invoked when the msg variable is created and initialized. Notice the change in the Variables window on the side. Press Step over again to advance to the next statement in this program (skipping over all the internal code that is executed to initialize the loop). Now, the Variables window shows information about the loop variables. Press Step over again to execute the cout statement. (Note that as of the March 2019 release, the C++ extension does not print any output to the Debug Console until the last cout executes.) If you like, you can keep pressing Step over until all the words in the vector have been printed to the console. But if you are curious, try pressing the Step Into button to step through source code in the C++ standard library! To return to your own code, one way is to keep pressing Step over . Another way is to set a breakpoint in your code by switching to the helloworld.cpp tab in the code editor, putting the insertion point somewhere on the cout statement inside the loop, and pressing kb(editor.debug.action.toggleBreakpoint) . A red dot appears in the gutter on the left to indicate that a breakpoint has been set on this line. Then press kb(workbench.action.debug.start) to start execution from the current line in the standard library header. Execution will break on cout . If you like, you can press kb(editor.debug.action.toggleBreakpoint) again to toggle off the breakpoint. When the loop has completed, you can see the output in the Debug Console tab of the integrated terminal, along with some other diagnostic information that is output by GDB. Set a watch To keep track of the value of a variable as your program executes, set a watch on the variable. Place the insertion point inside the loop. In the Watch window, click the plus sign and in the text box, type word , which is the name of the loop variable. Now view the Watch window as you step through the loop. To quickly view the value of any variable while execution is paused on a breakpoint, you can hover over it with the mouse pointer. C/C++ configurations If you want more control over the C/C++ extension, you can create a c_cpp_properties.json file, which will allow you to change settings such as the path to the compiler, include paths, C++ standard (default is C++17), and more. You can view the C/C++ configuration UI by running the command C/C++: Edit Configurations (UI) from the Command Palette ( kb(workbench.action.showCommands) ). This opens the C/C++ Configurations page. When you make changes here, VS Code writes them to a file called c_cpp_properties.json in the .vscode folder. You only need to modify the Include path setting if your program includes header files that are not in your workspace or in the standard library path. Visual Studio Code places these settings in .vscode/c_cpp_properties.json . If you open that file directly, it should look something like this: { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [], \"compilerPath\": \"/usr/bin/gcc\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x64\" } ], \"version\": 4 } Reusing your C++ configuration VS Code is now configured to use gcc on Linux. The configuration applies to the current workspace. To reuse the configuration, just copy the JSON files to a .vscode folder in a new project folder (workspace) and change the names of the source file(s) and executable as needed. Troubleshooting Compiler and linking errors The most common cause of errors (such as undefined _main , or attempting to link with file built for unknown-unsupported file format , and so on) occurs when helloworld.cpp is not the active file when you start a build or start debugging. This is because the compiler is trying to compile something that isn't source code, like your launch.json , tasks.json , or c_cpp_properties.json file. Next steps Explore the VS Code User Guide . Review the Overview of the C++ extension . Create a new workspace, copy your .json files to it, adjust the necessary settings for the new workspace path, program name, and so on, and start coding!"
  },
  "guides/vscode/cpp/config-mingw.html": {
    "href": "guides/vscode/cpp/config-mingw.html",
    "title": "Using GCC with MinGW | Fountain of Knowledge",
    "keywords": "Using GCC with MinGW In this tutorial, you configure Visual Studio Code to use the GCC C++ compiler (g++) and GDB debugger from mingw-w64 to create programs that run on Windows. After configuring VS Code, you will compile and debug a simple Hello World program in VS Code. This tutorial does not teach you about GCC, GDB, Mingw-w64, or the C++ language. For those subjects, there are many good resources available on the Web. If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this tutorial, you must do the following steps: Install Visual Studio Code . Install the C/C++ extension for VS Code . You can install the C/C++ extension by searching for 'c++' in the Extensions view ( kb(workbench.view.extensions) ). Get the latest version of Mingw-w64 via MSYS2 , which provides up-to-date native builds of GCC, Mingw-w64, and other helpful C++ tools and libraries. Click here to download the MSYS2 installer. Then follow the instructions on the MSYS2 website to install Mingw-w64. Add the path to your Mingw-w64 bin folder to the Windows PATH environment variable by using the following steps: In the Windows search bar, type 'settings' to open your Windows Settings. Search for Edit environment variables for your account . Choose the Path variable and then select Edit . Select New and add the Mingw-w64 destination folder path to the system path. The exact path depends on which version of Mingw-w64 you have installed and where you installed it. If you used the settings above to install Mingw-w64, then add this to the path: C:\\msys64\\mingw64\\bin . Select OK to save the updated PATH. You will need to reopen any console windows for the new PATH location to be available. Check your MinGW installation To check that your Mingw-w64 tools are correctly installed and available, open a new Command Prompt and type: g++ --version gdb --version If you don't see the expected output or g++ or gdb is not a recognized command, make sure your PATH entry matches the Mingw-w64 binary location where the compilers are located. Create Hello World From a Windows command prompt, create an empty folder called projects where you can place all your VS Code projects. Then create a sub-folder called helloworld , navigate into it, and open VS Code in that folder by entering the following commands: mkdir projects cd projects mkdir helloworld cd helloworld code . The \"code .\" command opens VS Code in the current working folder, which becomes your \"workspace\". As you go through the tutorial, you will see three files created in a .vscode folder in the workspace: tasks.json (build instructions) launch.json (debugger settings) c_cpp_properties.json (compiler path and IntelliSense settings) Add a source code file In the File Explorer title bar, select the New File button and name the file helloworld.cpp . Add hello world source code Now paste in this source code: #include <iostream> #include <vector> #include <string> using namespace std; int main() { vector<string> msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"}; for (const string& word : msg) { cout << word << \" \"; } cout << endl; } Now press kb(workbench.action.files.save) to save the file. Notice how the file you just added appears in the File Explorer view ( kb(workbench.view.explorer) ) in the side bar of VS Code: You can also enable Auto Save to automatically save your file changes, by checking Auto Save in the main File menu. The Activity Bar on the far left lets you open different views such as Search , Source Control , and Run . You'll look at the Run view later in this tutorial. You can find out more about the other views in the VS Code User Interface documentation . Note : When you save or open a C++ file, you may see a notification from the C/C++ extension about the availability of an Insiders version, which lets you test new features and fixes. You can ignore this notification by selecting the X ( Clear Notification ). Explore IntelliSense In your new helloworld.cpp file, hover over vector or string to see type information. After the declaration of the msg variable, start typing msg. as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window that shows the type information for the msg object: You can press the kbstyle(Tab) key to insert the selected member; then, when you add the opening parenthesis, you will see information about any arguments that the function requires. Build helloworld.cpp Next, you'll create a tasks.json file to tell VS Code how to build (compile) the program. This task will invoke the g++ compiler to create an executable file based on the source code. From the main menu, choose Terminal > Configure Default Build Task . In the dropdown, which will display a tasks dropdown listing various predefined build tasks for C++ compilers. Choose g++.exe build active file , which will build the file that is currently displayed (active) in the editor. This will create a tasks.json file in a .vscode folder and open it in the editor. Your new tasks.json file should look similar to the JSON below: { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"C/C++: g++.exe build active file\", \"command\": \"C:/msys64/mingw64/bin/g++.exe\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\" ], \"options\": { \"cwd\": \"${fileDirname}\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"detail\": \"compiler: C:/msys64/mingw64/bin/g++.exe\" } ], \"version\": \"2.0.0\" } The command setting specifies the program to run; in this case that is g++. The args array specifies the command-line arguments that will be passed to g++. These arguments must be specified in the order expected by the compiler. This task tells g++ to take the active file ( ${file} ), compile it, and create an executable file in the current directory ( ${fileDirname} ) with the same name as the active file but with the .exe extension ( ${fileBasenameNoExtension}.exe ), resulting in helloworld.exe for our example. Note : You can learn more about tasks.json variables in the variables reference . The label value is what you will see in the tasks list; you can name this whatever you like. The \"isDefault\": true value in the group object specifies that this task will be run when you press kb(workbench.action.tasks.build) . This property is for convenience only; if you set it to false, you can still run it from the Terminal menu with Tasks: Run Build Task . Running the build Go back to helloworld.cpp . Your task builds the active file and you want to build helloworld.cpp . To run the build task defined in tasks.json , press kb(workbench.action.tasks.build) or from the Terminal main menu choose Run Build Task . When the task starts, you should see the Integrated Terminal panel appear below the source code editor. After the task completes, the terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful g++ build, the output looks something like this: Create a new terminal using the + button and you'll have a new terminal with the helloworld folder as the working directory. Run dir and you should now see the executable helloworld.exe . You can run helloworld in the terminal by typing helloworld.exe (or .\\helloworld.exe if you use a PowerShell terminal). Note : You might need to press kbstyle(Enter) a couple of times initially to see the PowerShell prompt in the terminal. This issue should be fixed in a future release of Windows. Modifying tasks.json You can modify your tasks.json to build multiple C++ files by using an argument like \"${workspaceFolder}\\\\*.cpp\" instead of ${file} . This will build all .cpp files in your current folder. You can also modify the output filename by replacing \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\" with a hard-coded filename (for example \"${workspaceFolder}\\\\myProgram.exe\" ). Debug helloworld.cpp Next, you'll create a launch.json file to configure VS Code to launch the GDB debugger when you press kb(workbench.action.debug.start) to debug the program. From the main menu, choose Run > Add Configuration... and then choose C++ (GDB/LLDB) . You'll then see a dropdown for various predefined debugging configurations. Choose g++.exe build and debug active file . VS Code creates a launch.json file, opens it in the editor, and builds and runs 'helloworld'. { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"g++.exe - Build and debug active file\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${fileDirname}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:\\\\msys64\\\\mingw64\\\\bin\\\\gdb.exe\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"C/C++: g++.exe build active file\" } ] } The program setting specifies the program you want to debug. Here it is set to the active file folder ${fileDirname} and active filename with the .exe extension ${fileBasenameNoExtension}.exe , which if helloworld.cpp is the active file will be helloworld.exe . By default, the C++ extension won't add any breakpoints to your source code and the stopAtEntry value is set to false . Change the stopAtEntry value to true to cause the debugger to stop on the main method when you start debugging. Note : The preLaunchTask setting is used to specify task to be executed before launch. Make sure it is consistent with the tasks.json file label setting. Start a debugging session Go back to helloworld.cpp so that it is the active file. Press kb(workbench.action.debug.start) or from the main menu choose Run > Start Debugging . Before you start stepping through the source code, let's take a moment to notice several changes in the user interface: The Integrated Terminal appears at the bottom of the source code editor. In the Debug Output tab, you see output that indicates the debugger is up and running. The editor highlights the first statement in the main method. This is a breakpoint that the C++ extension automatically sets for you: The Run view on the left shows debugging information. You'll see an example later in the tutorial. At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side. Step through the code Now you're ready to start stepping through the code. Click or press the Step over icon in the debugging control panel. This will advance program execution to the first line of the for loop, and skip over all the internal function calls within the vector and string classes that are invoked when the msg variable is created and initialized. Notice the change in the Variables window on the left. In this case, the errors are expected because, although the variable names for the loop are now visible to the debugger, the statement has not executed yet, so there is nothing to read at this point. The contents of msg are visible, however, because that statement has completed. Press Step over again to advance to the next statement in this program (skipping over all the internal code that is executed to initialize the loop). Now, the Variables window shows information about the loop variables. Press Step over again to execute the cout statement. (Note that as of the March 2019 release, the C++ extension does not print any output to the Debug Console until the loop exits.) If you like, you can keep pressing Step over until all the words in the vector have been printed to the console. But if you are curious, try pressing the Step Into button to step through source code in the C++ standard library! To return to your own code, one way is to keep pressing Step over . Another way is to set a breakpoint in your code by switching to the helloworld.cpp tab in the code editor, putting the insertion point somewhere on the cout statement inside the loop, and pressing kb(editor.debug.action.toggleBreakpoint) . A red dot appears in the gutter on the left to indicate that a breakpoint has been set on this line. Then press kb(workbench.action.debug.start) to start execution from the current line in the standard library header. Execution will break on cout . If you like, you can press kb(editor.debug.action.toggleBreakpoint) again to toggle off the breakpoint. When the loop has completed, you can see the output in the Integrated Terminal, along with some other diagnostic information that is output by GDB. Set a watch Sometimes you might want to keep track of the value of a variable as your program executes. You can do this by setting a watch on the variable. Place the insertion point inside the loop. In the Watch window, click the plus sign and in the text box, type word , which is the name of the loop variable. Now view the Watch window as you step through the loop. Add another watch by adding this statement before the loop: int i = 0; . Then, inside the loop, add this statement: ++i; . Now add a watch for i as you did in the previous step. To quickly view the value of any variable while execution is paused on a breakpoint, you can hover over it with the mouse pointer. C/C++ configurations If you want more control over the C/C++ extension, you can create a c_cpp_properties.json file, which will allow you to change settings such as the path to the compiler, include paths, C++ standard (default is C++17), and more. You can view the C/C++ configuration UI by running the command C/C++: Edit Configurations (UI) from the Command Palette ( kb(workbench.action.showCommands) ). This opens the C/C++ Configurations page. When you make changes here, VS Code writes them to a file called c_cpp_properties.json in the .vscode folder. Here, we've changed the Configuration name to GCC , set the Compiler path dropdown to the g++ compiler, and the IntelliSense mode to match the compiler ( gcc-x64 ) Visual Studio Code places these settings in .vscode\\c_cpp_properties.json . If you open that file directly, it should look something like this: { \"configurations\": [ { \"name\": \"GCC\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"windowsSdkVersion\": \"10.0.18362.0\", \"compilerPath\": \"C:/msys64/mingw64/bin/g++.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"windows-gcc-x64\" } ], \"version\": 4 } You only need to add to the Include path array setting if your program includes header files that are not in your workspace or in the standard library path. Compiler path The extension uses the compilerPath setting to infer the path to the C++ standard library header files. When the extension knows where to find those files, it can provide features like smart completions and Go to Definition navigation. The C/C++ extension attempts to populate compilerPath with the default compiler location based on what it finds on your system. The extension looks in several common compiler locations. The compilerPath search order is: First check for the Microsoft Visual C++ compiler Then look for g++ on Windows Subsystem for Linux (WSL) Then g++ for Mingw-w64. If you have Visual Studio or WSL installed, you may need to change compilerPath to match the preferred compiler for your project. For example, if you installed Mingw-w64 version 8.1.0 using the i686 architecture, Win32 threading, and sjlj exception handling install options, the path would look like this: C:\\Program Files (x86)\\mingw-w64\\i686-8.1.0-win32-sjlj-rt_v6-rev0\\mingw64\\bin\\g++.exe . Next steps Explore the VS Code User Guide . Review the Overview of the C++ extension . Create a new workspace, copy your .vscode JSON files to it, adjust the necessary settings for the new workspace path, program name, and so on, and start coding!"
  },
  "guides/vscode/cpp/config-msvc.html": {
    "href": "guides/vscode/cpp/config-msvc.html",
    "title": "Configure VS Code for Microsoft C++ | Fountain of Knowledge",
    "keywords": "Configure VS Code for Microsoft C++ In this tutorial, you configure Visual Studio Code to use the Microsoft Visual C++ compiler and debugger on Windows. After configuring VS Code, you will compile and debug a simple Hello World program in VS Code. This tutorial does not teach you details about the Microsoft C++ toolset or the C++ language. For those subjects, there are many good resources available on the Web. If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this tutorial, you must do the following: Install Visual Studio Code . Install the C/C++ extension for VS Code . You can install the C/C++ extension by searching for 'c++' in the Extensions view ( kb(workbench.view.extensions) ). Install the Microsoft Visual C++ (MSVC) compiler toolset. If you have a recent version of Visual Studio, open the Visual Studio Installer from the Windows Start menu and verify that the C++ workload is checked. If it's not installed, then check the box and click the Modify button in the installer. You can also install the Desktop development with C++ workload without a full Visual Studio IDE installation. From the Visual Studio Downloads page, scroll down until you see Tools for Visual Studio 2019 under the All Downloads section and select the download for Build Tools for Visual Studio 2019 . This will launch the Visual Studio Installer, which will bring up a dialog showing the available Visual Studio Build Tools workloads. Check the Desktop development with C++ workload and select Install . Note : You can use the C++ toolset from Visual Studio Build Tools along with Visual Studio Code to compile, build, and verify any C++ codebase as long as you also have a valid Visual Studio license (either Community, Pro, or Enterprise) that you are actively using to develop that C++ codebase. Check your Microsoft Visual C++ installation To use MSVC from a command line or VS Code, you must run from a Developer Command Prompt for Visual Studio . An ordinary shell such as PowerShell, Bash, or the Windows command prompt does not have the necessary path environment variables set. To open the Developer Command Prompt for VS, start typing 'developer' in the Windows Start menu, and you should see it appear in the list of suggestions. The exact name depends on which version of Visual Studio or the Visual Studio Build Tools you have installed. Click on the item to open the prompt. You can test that you have the C++ compiler, cl.exe , installed correctly by typing 'cl' and you should see a copyright message with the version and basic usage description. If the Developer Command Prompt is using the BuildTools location as the starting directory (you wouldn't want to put projects there), navigate to your user folder ( C:\\users\\{your username}\\ ) before you start creating new projects. Create Hello World From the Developer Command Prompt, create an empty folder called \"projects\" where you can store all your VS Code projects, then create a subfolder called \"helloworld\", navigate into it, and open VS Code ( code ) in that folder ( . ) by entering the following commands: mkdir projects cd projects mkdir helloworld cd helloworld code . The \"code .\" command opens VS Code in the current working folder, which becomes your \"workspace\". As you go through the tutorial, you will see three files created in a .vscode folder in the workspace: tasks.json (build instructions) launch.json (debugger settings) c_cpp_properties.json (compiler path and IntelliSense settings) Add a source code file In the File Explorer title bar, select the New File button and name the file helloworld.cpp . Add hello world source code Now paste in this source code: #include <iostream> #include <vector> #include <string> using namespace std; int main() { vector<string> msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"}; for (const string& word : msg) { cout << word << \" \"; } cout << endl; } Now press kb(workbench.action.files.save) to save the file. Notice how the file you just added appears in the File Explorer view ( kb(workbench.view.explorer) ) in the side bar of VS Code: You can also enable Auto Save to automatically save your file changes, by checking Auto Save in the main File menu. The Activity Bar on the far left lets you open different views such as Search , Source Control , and Run . You'll look at the Run view later in this tutorial. You can find out more about the other views in the VS Code User Interface documentation . Note : When you save or open a C++ file, you may see a notification from the C/C++ extension about the availability of an Insiders version, which lets you test new features and fixes. You can ignore this notification by selecting the X ( Clear Notification ). Explore IntelliSense In your new helloworld.cpp file, hover over vector or string to see type information. After the declaration of the msg variable, start typing msg. as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window that shows the type information for the msg object: You can press the kbstyle(Tab) key to insert the selected member; then, when you add the opening parenthesis, you will see information about any arguments that the function requires. Build helloworld.cpp Next, you will create a tasks.json file to tell VS Code how to build (compile) the program. This task will invoke the Microsoft C++ compiler to create an executable file based on the source code. From the main menu, choose Terminal > Configure Default Build Task . In the dropdown, which will display a tasks dropdown listing various predefined build tasks for C++ compilers. Choose cl.exe build active file , which will build the file that is currently displayed (active) in the editor. This will create a tasks.json file in a .vscode folder and open it in the editor. Your new tasks.json file should look similar to the JSON below: { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"shell\", \"label\": \"cl.exe build active file\", \"command\": \"cl.exe\", \"args\": [ \"/Zi\", \"/EHsc\", \"/Fe:\", \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", \"${file}\" ], \"problemMatcher\": [ \"$msCompile\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } The command setting specifies the program to run; in this case that is \"cl.exe\". The args array specifies the command-line arguments that will be passed to cl.exe. These arguments must be specified in the order expected by the compiler. This task tells the C++ compiler to take the active file ( ${file} ), compile it, and create an executable file ( /Fe: switch) in the current directory ( ${fileDirname} ) with the same name as the active file but with the .exe extension ( ${fileBasenameNoExtension}.exe ), resulting in helloworld.exe for our example. Note : You can learn more about tasks.json variables in the variables reference . The label value is what you will see in the tasks list; you can name this whatever you like. The problemMatcher value selects the output parser to use for finding errors and warnings in the compiler output. For cl.exe, you'll get the best results if you use the $msCompile problem matcher. The \"isDefault\": true value in the group object specifies that this task will be run when you press kb(workbench.action.tasks.build) . This property is for convenience only; if you set it to false, you can still run it from the Terminal menu with Tasks: Run Build Task . Running the build Go back to helloworld.cpp . Your task builds the active file and you want to build helloworld.cpp . To run the build task defined in tasks.json , press kb(workbench.action.tasks.build) or from the Terminal main menu choose Tasks: Run Build Task . When the task starts, you should see the Integrated Terminal panel appear below the source code editor. After the task completes, the terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful C++ build, the output looks something like this: Create a new terminal using the + button and you'll have a new terminal (running PowerShell) with the helloworld folder as the working directory. Run ls and you should now see the executable helloworld.exe along with various intermediate C++ output and debugging files ( helloworld.obj , helloworld.pdb ). You can run helloworld in the terminal by typing .\\helloworld.exe . Note : You might need to press kbstyle(Enter) a couple of times initially to see the PowerShell prompt in the terminal. This issue should be fixed in a future release of Windows. Modifying tasks.json You can modify your tasks.json to build multiple C++ files by using an argument like \"${workspaceFolder}\\\\*.cpp\" instead of ${file} . This will build all .cpp files in your current folder. You can also modify the output filename by replacing \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\" with a hard-coded filename (for example \"${workspaceFolder}\\\\myProgram.exe\" ). Debug helloworld.cpp Next, you'll create a launch.json file to configure VS Code to launch the Microsoft C++ debugger when you press kb(workbench.action.debug.start) to debug the program. From the main menu, choose Run > Add Configuration... and then choose C++ (Windows) . You'll then see a dropdown for various predefined debugging configurations. Choose cl.exe build and debug active file . VS Code creates a launch.json file, opens it in the editor, and builds and runs 'helloworld'. { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"cl.exe build and debug active file\", \"type\": \"cppvsdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"preLaunchTask\": \"cl.exe build active file\" } ] } The program setting specifies the program you want to debug. Here it is set to the active file folder ${fileDirname} and active filename with the .exe extension ${fileBasenameNoExtension}.exe , which if helloworld.cpp is the active file will be helloworld.exe . By default, the C++ extension won't add any breakpoints to your source code and the stopAtEntry value is set to false . Change the stopAtEntry value to true to cause the debugger to stop on the main method when you start debugging. Start a debugging session Go back to helloworld.cpp so that it is the active file. Press kb(workbench.action.debug.start) or from the main menu choose Run > Start Debugging . Before you start stepping through the source code, let's take a moment to notice several changes in the user interface: The Integrated Terminal appears at the bottom of the source code editor. In the Debug Output tab, you see output that indicates the debugger is up and running. The editor highlights the first statement in the main method. This is a breakpoint that the C++ extension automatically sets for you: The Run view on the left shows debugging information. You'll see an example later in the tutorial. At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side. Step through the code Now you're ready to start stepping through the code. Click or press the Step over icon in the debugging control panel until the for (const string& word : msg) statement is highlighted. The Step Over command skip over all the internal function calls within the vector and string classes that are invoked when the msg variable is created and initialized. Notice the change in the Variables window on the left. In this case, the errors are expected because, although the variable names for the loop are now visible to the debugger, the statement has not executed yet, so there is nothing to read at this point. The contents of msg are visible, however, because that statement has completed. Press Step over again to advance to the next statement in this program (skipping over all the internal code that is executed to initialize the loop). Now, the Variables window shows information about the loop variables. Press Step over again to execute the cout statement. Note As of the March 2019 version of the extension, no output is displayed until the loop completes. If you like, you can keep pressing Step over until all the words in the vector have been printed to the console. But if you are curious, try pressing the Step Into button to step through source code in the C++ standard library! To return to your own code, one way is to keep pressing Step over . Another way is to set a breakpoint in your code by switching to the helloworld.cpp tab in the code editor, putting the insertion point somewhere on the cout statement inside the loop, and pressing kb(editor.debug.action.toggleBreakpoint) . A red dot appears in the gutter on the left to indicate that a breakpoint has been set on this line. Then press kb(workbench.action.debug.start) to start execution from the current line in the standard library header. Execution will break on cout . If you like, you can press kb(editor.debug.action.toggleBreakpoint) again to toggle off the breakpoint. Set a watch Sometimes you might want to keep track of the value of a variable as your program executes. You can do this by setting a watch on the variable. Place the insertion point inside the loop. In the Watch window, click the plus sign and in the text box, type word , which is the name of the loop variable. Now view the Watch window as you step through the loop. Add another watch by adding this statement before the loop: int i = 0; . Then, inside the loop, add this statement: ++i; . Now add a watch for i as you did in the previous step. To quickly view the value of any variable while execution is paused on a breakpoint, you can hover over it with the mouse pointer. C/C++ configurations If you want more control over the C/C++ extension, you can create a c_cpp_properties.json file, which will allow you to change settings such as the path to the compiler, include paths, C++ standard (default is C++17), and more. You can view the C/C++ configuration UI by running the command C/C++: Edit Configurations (UI) from the Command Palette ( kb(workbench.action.showCommands) ). This opens the C/C++ Configurations page. When you make changes here, VS Code writes them to a file called c_cpp_properties.json in the .vscode folder. Visual Studio Code places these settings in .vscode\\c_cpp_properties.json . If you open that file directly, it should look something like this: { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"windowsSdkVersion\": \"10.0.18362.0\", \"compilerPath\": \"C:/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/14.24.28314/bin/Hostx64/x64/cl.exe\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"msvc-x64\" } ], \"version\": 4 } You only need to add to the Include path array setting if your program includes header files that are not in your workspace or in the standard library path. Compiler path The compilerPath setting is an important setting in your configuration. The extension uses it to infer the path to the C++ standard library header files. When the extension knows where to find those files, it can provide useful features like smart completions and Go to Definition navigation. The C/C++ extension attempts to populate compilerPath with the default compiler location based on what it finds on your system. The extension looks in several common compiler locations. The compilerPath search order is: First check for the Microsoft Visual C++ compilerOpe Then look for g++ on Windows Subsystem for Linux (WSL) Then g++ for Mingw-w64. If you have g++ or WSL installed, you might need to change compilerPath to match the preferred compiler for your project. For Microsoft C++, the path should look something like this, depending on which specific version you have installed: \"C:/Program Files (x86)/Microsoft Visual Studio/2017/BuildTools/VC/Tools/MSVC/14.16.27023/bin/Hostx64/x64/cl.exe\". Reusing your C++ configuration VS Code is now configured to use the Microsoft C++ compiler. The configuration applies to the current workspace. To reuse the configuration, just copy the JSON files to a .vscode folder in a new project folder (workspace) and change the names of the source file(s) and executable as needed. Troubleshooting The term 'cl.exe' is not recognized If you see the error \"The term 'cl.exe' is not recognized as the name of a cmdlet, function, script file, or operable program.\", this usually means you are running VS Code outside of a Developer Command Prompt for Visual Studio and VS Code doesn't know the path to the cl.exe compiler. You can always check that you are running VS Code in the context of the Developer Command Prompt by opening a new Terminal ( kb(workbench.action.terminal.new) ) and typing 'cl' to verify cl.exe is available to VS Code. Next steps Explore the VS Code User Guide . Review the Overview of the C++ extension . Create a new workspace, copy your .vscode JSON files to it, adjust the necessary settings for the new workspace path, program name, and so on, and start coding!"
  },
  "guides/vscode/cpp/configure-intellisense-crosscompilation.html": {
    "href": "guides/vscode/cpp/configure-intellisense-crosscompilation.html",
    "title": "IntelliSense for cross-compiling | Fountain of Knowledge",
    "keywords": "IntelliSense for cross-compiling The article is about configuring the C/C++ extension to provide proper IntelliSense (code completions) in Visual Studio Code when you compile for a different architecture than your development host machine. For example, when your host machine is x64 but you are compiling for ARM. The C/C++ extension isn't a compiler--it provides rich language features such as syntax highlighting and IntelliSense. For the extension to provide correct IntelliSense suggestions, and to reflect the right sizes of data types, you need to configure the C++ extension to emulate the target architecture. These configuration settings are stored in your project's c_cpp_properties.json file. To edit this file, in VS Code, select C/C++: Edit Configurations (UI) from the Command Palette ( kb(workbench.action.showCommands) ): Example IntelliSense configuration The following shows configuring the C/C++ extension for a Linux x64 host machine that targets Linux ARM. It configures the following IntelliSense settings: Compiler path : the extension queries your compiler at this location to retrieve system libraries and compiler defines. IntelliSense mode : emulates the target architecture and compiler so that the extension can provide correct IntelliSense and reflect the right sizes of data types such as pointer , size_t , long , and so on. At a minimum, setting compiler path and IntelliSense mode provides enough information for the extension to emulate your project's target architecture. Compiler path Set to the full path of the compiler you are using to build your project. For example: IntelliSense mode Set to the architecture-specific variant of the compiler you are using. For example: Include path You only need to modify the Include path if your program includes header files that aren't in your workspace, or that are not in the standard library path. The C/C++ extension populates the include path by querying the compiler specified by Compiler path . If the extension can't find the path for the target system libraries, you can enter the include path manually: Given the settings above, your c_cpp_configuration.json file will look something like the following. You can open it by selecting C/C++: Edit Configurations (JSON) from the Command Palette: { \"configurations\": [ { \"name\": \"myConfigurationName\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [], \"compilerPath\": \"/usr/bin/arm-none-eabi-g++\", \"cStandard\": \"c11\", \"cppStandard\": \"c++14\", \"IntelliSenseMode\": \"gcc-arm\" } ], \"version\": 4 } Next steps For more information about IntelliSense configuration, see Customizing default settings . If you have trouble configuring the settings, file an issue in the VS Code documentation repository . Explore the c_cpp_properties schema . Review the Overview of the C++ extension ."
  },
  "guides/vscode/cpp/config-wsl.html": {
    "href": "guides/vscode/cpp/config-wsl.html",
    "title": "Using C++ and WSL in VS Code | Fountain of Knowledge",
    "keywords": "Using C++ and WSL in VS Code In this tutorial, you will configure Visual Studio Code to use the GCC C++ compiler (g++) and GDB debugger on Ubuntu in the Windows Subsystem for Linux (WSL). GCC stands for GNU Compiler Collection; GDB is the GNU debugger. WSL is a Linux environment within Windows that runs directly on the machine hardware, not in a virtual machine. Note : Much of this tutorial is applicable to working with C++ and VS Code directly on a Linux machine. Visual Studio Code has support for working directly in WSL with the Remote - WSL extension . We recommend this mode of WSL development , where all your source code files, in addition to the compiler, are hosted on the Linux distro. For more background, see VS Code Remote Development . After completing this tutorial, you will be ready to create and configure your own C++ project, and to explore the VS Code documentation for further information about its many features. This tutorial does not teach you about GCC or Linux or the C++ language. For those subjects, there are many good resources available on the Web. If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this tutorial, you must do the following steps: Install Visual Studio Code . Install the Remote - WSL extension . Install Windows Subsystem for Linux and then use the links on that same page to install your Linux distribution of choice. This tutorial uses Ubuntu. During installation, remember your Linux user password because you'll need it to install additional software. Set up your Linux environment Open the Bash shell for WSL. If you installed an Ubuntu distro, type \"Ubuntu\" in the Windows search box and then click on it in the result list. For Debian, type \"Debian\", and so on. The shell appears with a command prompt that by default consists of your user name and computer name, and puts you in your home directory. For Ubuntu it looks like this: Make a directory called projects and then subdirectory under that called helloworld : mkdir projects cd projects mkdir helloworld Although you will be using VS Code to edit your source code, you'll be compiling the source code on Linux using the g++ compiler. You'll also debug on Linux using GDB. These tools are not installed by default on Ubuntu, so you have to install them. Fortunately, that task is quite easy! From the WSL command prompt, first run apt-get update to update the Ubuntu package lists. An out-of-date distro can sometimes interfere with attempts to install new packages. sudo apt-get update If you like, you can run sudo apt-get update && sudo apt-get dist-upgrade to also download the latest versions of the system packages, but this can take significantly longer depending on your connection speed. From the command prompt, install the GNU compiler tools and the GDB debugger by typing: sudo apt-get install build-essential gdb Verify that the install succeeded by locating g++ and gdb. If the filenames are not returned from the whereis command, try running the update command again. whereis g++ whereis gdb Note : The setup steps for installing the g++ compiler and GDB debugger apply if you are working directly on a Linux machine rather than in WSL. Running VS Code in your helloworld project, as well as the editing, building, and debugging steps are the same. Run VS Code in WSL Navigate to your helloworld project folder and launch VS Code from the WSL terminal with code . : cd $HOME/projects/helloworld code . You'll see a message about \"Installing VS Code Server\". VS Code is downloading and installing a small server on the Linux side that the desktop VS Code will then talk to. VS Code will then start and open the helloWorld folder. The File Explorer shows that VS Code is now running in the context of WSL with the title bar [WSL: Ubuntu] . You can also tell the remote context from the Status bar. If you click on the Remote Status bar item, you will see a dropdown of Remote commands appropriate for the session. For example, if you want to end your session running in WSL, you can select the Close Remote Connection command from the dropdown. Running code . from your WSL command prompt will restart VS Code running in WSL. The code . command opened VS Code in the current working folder, which becomes your \"workspace\". As you go through the tutorial, you will see three files created in a .vscode folder in the workspace: c_cpp_properties.json (compiler path and IntelliSense settings) tasks.json (build instructions) launch.json (debugger settings) Add a source code file In the File Explorer title bar, select the New File button and name the file helloworld.cpp . Install the C/C++ extension Once you create the file and VS Code detects it is a C++ language file, you may be prompted to install the Microsoft C/C++ extension if you don't already have it installed. Choose Install and then Reload Required when the button is displayed in the Extensions view to complete installing the C/C++ extension. If you already have C/C++ language extensions installed locally in VS Code, you'll need to go to the Extensions view ( kb(workbench.view.extensions) ) and install those extensions into WSL. Locally installed extensions can be installed into WSL by selecting the Install in WSL button and then Reload Required . Add hello world source code Now paste in this source code: #include <iostream> #include <vector> #include <string> using namespace std; int main() { vector<string> msg {\"Hello\", \"C++\", \"World\", \"from\", \"VS Code\", \"and the C++ extension!\"}; for (const string& word : msg) { cout << word << \" \"; } cout << endl; } Now press kb(workbench.action.files.save) to save the file. Notice how the file you just added appears in the File Explorer view ( kb(workbench.view.explorer) ) in the side bar of VS Code: You can also enable Auto Save to automatically save your file changes, by checking Auto Save in the main File menu. The Activity Bar on the far left lets you open different views such as Search , Source Control , and Run . You'll look at the Run view later in this tutorial. You can find out more about the other views in the VS Code User Interface documentation . Explore IntelliSense In your new helloworld.cpp file, hover over vector or string to see type information. After the declaration of the msg variable, start typing msg. as you would when calling a member function. You should immediately see a completion list that shows all the member functions, and a window that shows the type information for the msg object: You can press the kbstyle(Tab) key to insert the selected member; then, when you add the opening parenthesis, you will see information about any arguments that the function requires. Build helloworld.cpp Next, you will create a tasks.json file to tell VS Code how to build (compile) the program. This task will invoke the g++ compiler on WSL to create an executable file based on the source code. From the main menu, choose Terminal > Configure Default Build Task . In the dropdown, which will display a tasks dropdown listing various predefined build tasks for C++ compilers. Choose g++ build active file , which will build the file that is currently displayed (active) in the editor. This will create a tasks.json file in a .vscode folder and open it in the editor. Your new tasks.json file should look similar to the JSON below: { \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"shell\", \"label\": \"g++ build active file\", \"command\": \"/usr/bin/g++\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\" ], \"options\": { \"cwd\": \"/usr/bin\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } The command setting specifies the program to run; in this case that is g++. The args array specifies the command-line arguments that will be passed to g++. These arguments must be specified in the order expected by the compiler. This task tells g++ to take the active file ( ${file} ), compile it, and create an executable file in the current directory ( ${fileDirname} ) with the same name as the active file but without an extension ( ${fileBasenameNoExtension} ), resulting in helloworld for our example. Note : You can learn more about tasks.json variables in the variables reference . The label value is what you will see in the tasks list; you can name this whatever you like. The \"isDefault\": true value in the group object specifies that this task will be run when you press kb(workbench.action.tasks.build) . This property is for convenience only; if you set it to false, you can still run it from the Terminal menu with Tasks: Run Build Task . Running the build Go back to helloworld.cpp . Your task builds the active file and you want to build helloworld.cpp . To run the build task defined in tasks.json , press kb(workbench.action.tasks.build) or from the Terminal main menu choose Tasks: Run Build Task . When the task starts, you should see the Integrated Terminal panel appear below the source code editor. After the task completes, the terminal shows output from the compiler that indicates whether the build succeeded or failed. For a successful g++ build, the output looks something like this: Create a new terminal using the + button and you'll have a bash terminal running in the context of WSL with the helloworld folder as the working directory. Run ls and you should now see the executable helloworld (no file extension). You can run helloworld in the terminal by typing ./helloworld . Modifying tasks.json You can modify your tasks.json to build multiple C++ files by using an argument like \"${workspaceFolder}/*.cpp\" instead of ${file} . You can also modify the output filename by replacing \"${fileDirname}/${fileBasenameNoExtension}\" with a hard-coded filename (for example 'helloworld.out'). Debug helloworld.cpp Next, you'll create a launch.json file to configure VS Code to launch the GDB debugger when you press kb(workbench.action.debug.start) to debug the program. From the main menu, choose Run > Add Configuration... and then choose C++ (GDB/LLDB) . You'll then see a dropdown for various predefined debugging configurations. Choose g++ build and debug active file . VS Code creates a launch.json file, opens it in the editor, and builds and runs 'helloworld'. { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"g++ build and debug active file\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"g++ build active file\", \"miDebuggerPath\": \"/usr/bin/gdb\" } ] } The program setting specifies the program you want to debug. Here it is set to the active file folder ${fileDirname} and active filename without an extension ${fileBasenameNoExtension} , which if helloworld.cpp is the active file will be helloworld . By default, the C++ extension won't add any breakpoints to your source code and the stopAtEntry value is set to false . Change the stopAtEntry value to true to cause the debugger to stop on the main method when you start debugging. The remaining steps are provided as an optional exercise to help you get familiar with the editing and debugging experience. Start a debugging session Go back to helloworld.cpp so that it is the active file. Press kb(workbench.action.debug.start) or from the main menu choose Run > Start Debugging . Before you start stepping through the code, let's take a moment to notice several changes in the user interface: The Integrated Terminal appears at the bottom of the source code editor. In the Debug Output tab, you see output that indicates the debugger is up and running. The editor highlights the first statement in the main method. This is a breakpoint that the C++ extension automatically sets for you: The Run view on the left shows debugging information. You'll see an example later in the tutorial. At the top of the code editor, a debugging control panel appears. You can move this around the screen by grabbing the dots on the left side. Step through the code Now you're ready to start stepping through the code. Click or press the Step over icon in the debugging control panel. This will advance program execution to the first line of the for loop, and skip over all the internal function calls within the vector and string classes that are invoked when the msg variable is created and initialized. Notice the change in the Variables window on the left. In this case, the errors are expected because, although the variable names for the loop are now visible to the debugger, the statement has not executed yet, so there is nothing to read at this point. The contents of msg are visible, however, because that statement has completed. Press Step over again to advance to the next statement in this program (skipping over all the internal code that is executed to initialize the loop). Now, the Variables window shows information about the loop variables. Press Step over again to execute the cout statement. (Note that as of the March 2019 release, the C++ extension does not print any output to the Debug Console until the loop exits.) If you like, you can keep pressing Step over until all the words in the vector have been printed to the console. But if you are curious, try pressing the Step Into button to step through source code in the C++ standard library! To return to your own code, one way is to keep pressing Step over . Another way is to set a breakpoint in your code by switching to the helloworld.cpp tab in the code editor, putting the insertion point somewhere on the cout statement inside the loop, and pressing kb(editor.debug.action.toggleBreakpoint) . A red dot appears in the gutter on the left to indicate that a breakpoint has been set on this line. Then press kb(workbench.action.debug.start) to start execution from the current line in the standard library header. Execution will break on cout . If you like, you can press kb(editor.debug.action.toggleBreakpoint) again to toggle off the breakpoint. When the loop has completed, you can see the output in the Debug Console tab of the integrated terminal, along with some other diagnostic information that is output by GDB. Set a watch Sometimes you might want to keep track of the value of a variable as your program executes. You can do this by setting a watch on the variable. Place the insertion point inside the loop. In the Watch window, click the plus sign and in the text box, type word , which is the name of the loop variable. Now view the Watch window as you step through the loop. Add another watch by adding this statement before the loop: int i = 0; . Then, inside the loop, add this statement: ++i; . Now add a watch for i as you did in the previous step. To quickly view the value of any variable while execution is paused on a breakpoint, you can hover over it with the mouse pointer. C/C++ configurations If you want more control over the C/C++ extension, you can create a c_cpp_properties.json file, which will allow you to change settings such as the path to the compiler, include paths, C++ standard (default is C++17), and more. You can view the C/C++ configuration UI by running the command C/C++: Edit Configurations (UI) from the Command Palette ( kb(workbench.action.showCommands) ). This opens the C/C++ Configurations page. When you make changes here, VS Code writes them to a file called c_cpp_properties.json in the .vscode folder. You only need to modify the Include path setting if your program includes header files that are not in your workspace or in the standard library path. Visual Studio Code places these settings in .vscode/c_cpp_properties.json . If you open that file directly, it should look something like this: { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [], \"compilerPath\": \"/usr/bin/gcc\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x64\" } ], \"version\": 4 } Closing the WSL session When you are done working in WSL, you can close your remote session with the Close Remote Connection command available in the main File menu and the Command Palette ( kb(workbench.action.showCommands) ). This will restart VS Code running locally. You can easily reopen your WSL session from the File > Open Recent list by selecting folders with the [WSL] suffix. Next steps Explore the VS Code User Guide . Review the Overview of the C++ extension . Create a new workspace, copy your .json files to it, adjust the necessary settings for the new workspace path, program name, and so on, and start coding!"
  },
  "guides/vscode/cpp/cpp-debug.html": {
    "href": "guides/vscode/cpp/cpp-debug.html",
    "title": "Debug C++ in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Debug C++ in Visual Studio Code After you have set up the basics of your debugging environment as specified in the configuration tutorials for each target compiler/platform, you can learn more details about debugging C/C++ in this section. Visual Studio Code supports the following debuggers for C/C++ depending on the operating system you are using: Linux : GDB macOS : LLDB or GDB Windows : the Visual Studio Windows Debugger or GDB (using Cygwin or MinGW) Windows debugging with GDB You can debug Windows applications created using Cygwin or MinGW by using VS Code. To use Cygwin or MinGW debugging features, the debugger path must be set manually in the launch configuration ( launch.json ). To debug your Cygwin or MinGW application, add the miDebuggerPath property and set its value to the location of the corresponding gdb.exe for your Cygwin or MinGW environment. For example: \"miDebuggerPath\": \"c:\\\\mingw\\\\bin\\\\gdb.exe\" Cygwin/MinGW debugging on Windows supports both attach and launch debugging scenarios. To learn more, see Configuring C/C++ debugging . If you are debugging with GDB on Windows, see Windows Debugging with MinGW64 . Conditional breakpoints Conditional breakpoints enable you to break execution on a particular line of code only when the value of the condition is true. To set a conditional breakpoint, right-click on an existing breakpoint and select Edit Breakpoint . This opens a small peek window where you can enter the condition that must evaluate to true in order for the breakpoint to be hit during debugging. In the editor, conditional breakpoints are indicated by a breakpoint symbol that has a black equals sign inside of it. You can place the cursor over a conditional breakpoint to show its condition. Function breakpoints Function breakpoints enable you to break execution at the beginning of a function instead of on a particular line of code. To set a function breakpoint, on the Run view right-click inside the Breakpoints section, then choose Add Function Breakpoint and enter the name of the function on which you want to break execution. Expression evaluation VS Code supports expression evaluation in several contexts: You can type an expression into the Watch section of the Run view and it will be evaluated each time a breakpoint is hit. You can type an expression into the Debug Console and it will be evaluated only once. You can evaluate any expression that appears in your code while you're stopped at a breakpoint. Expressions in the Watch section take effect in the application being debugged; an expression that modifies the value of a variable will modify that variable for the duration of the program. Multi-threaded debugging The C/C++ extension for VS Code has the ability to debug multi-threaded programs. All threads and their call stacks appear in the Call Stack section: Memory dump debugging The C/C++ extension for VS Code also has the ability to debug memory dumps. To debug a memory dump, open your launch.json file and add the coreDumpPath (for GDB or LLDB) or dumpPath (for the Visual Studio Windows Debugger) property to the C++ Launch configuration, set its value to be a string containing the path to the memory dump. This will even work for x86 programs being debugged on an x64 machine. Additional symbols If there are additional directories where the debugger can find symbol files (for example, .pdb files for the Visual Studio Windows Debugger), they can be specified by adding the additionalSOLibSearchPath (for GDB or LLDB) or symbolSearchPath (for the Visual Studio Windows Debugger). For example: \"additionalSOLibSearchPath\": \"/path/to/symbols;/another/path/to/symbols\" or \"symbolSearchPath\": \"C:\\\\path\\\\to\\\\symbols;C:\\\\another\\\\path\\\\to\\\\symbols\" Locate source files The source file location can be changed if the source files are not located in the compilation location. This is done by simple replacement pairs added in the sourceFileMap section. The first match in this list will be used. For example: \"sourceFileMap\": { \"/build/gcc-4.8-fNUjSI/gcc-4.8-4.8.4/build/i686-linux-gnu/libstdc++-v3/include/i686-linux-gnu\": \"/usr/include/i686-linux-gnu/c++/4.8\", \"/build/gcc-4.8-fNUjSI/gcc-4.8-4.8.4/build/i686-linux-gnu/libstdc++-v3/include\": \"/usr/include/c++/4.8\" } GDB, LLDB, and LLDB-MI Commands (GDB/LLDB) For the C++ (GDB/LLDB) debugging environment, you can execute GDB, LLDB and LLDB-MI commands directly through the debug console with the -exec command, but be careful, executing commands directly in the debug console is untested and might crash VS Code in some cases. Other debugging features Unconditional breakpoints Watch window Call stack Stepping For more information on debugging with VS Code, see this introduction to debugging in VS Code . For additional ways to configure the launch.json file so that you can debug your C/C++ app, see Configuring C/C++ debugging . Natvis framework You create custom views of C++ object in the debugger with the Natvis framework. You can read the Custom views for native objects topic for details on using Natvis with the C/C++ extension. Debug remotely For information about attaching to a remote process, such as debugging a process in a Docker container, see Pipe transport . Debug the debugger If you are experiencing a debugging problem with the extension that we can't diagnose based on information in your issue report, we might ask you to enable logging and send us your logs. See Enable logging for the debug adapter to learn how to get C/C++ extension logs. Known limitations Symbols and code navigation All platforms: Because the extension doesn't parse function bodies, Peek Definition and Go to Definition don't work for symbols defined inside the body of a function. Debugging Windows: GDB on Cygwin and MinGW cannot break a running process. To set a breakpoint when the application is running (not stopped under the debugger), or to pause the application being debugged, press kbstyle(Ctrl-C) in the application's terminal. GDB on Cygwin cannot open core dumps. Linux: You may see an error saying: ptrace: Operation not permitted . This is due to GDB needing elevated permissions in order to attach to a process. This can be solved using the solutions below: When using attach to process , you need to provide your password before the debugging session can begin. To disable this error temporarily, use the following command: echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope To remove the error permanently, add a file called 10-ptrace.conf to /etc/sysctl.d/ and add the following kernel.yama.ptrace_scope = 0 . macOS: LLDB: When debugging with LLDB, if the Terminal window is closed while in break mode, debugging does not stop. Debugging can be stopped by pressing the Stop button. When debugging is stopped the Terminal window is not closed. GDB: Additional manual install steps are required to use GDB on macOS. See Manual Installation of GDB for OS X in the README . When attaching to a process with GDB, the application being debugged cannot be interrupted. GDB will only bind breakpoints set while the application is not running (either before attaching to the application, or while the application is in a stopped state). This is due to a bug in GDB . Core dumps cannot be loaded when debugging with GDB because GDB does not support the core dump format used in macOS . When attached to a process with GDB, break-all will end the process. Next steps Read on to find out about: Configure VS Code for Windows Subsystem for Linux Configure VS Code for Mingw-w64 and GCC Configure VS Code for macOS Configure C/C++ debugging - Learn about additional debugger configuration options. Basic Editing - Learn about the powerful Visual Studio Code editor. Code Navigation - Move quickly through your source code. Tasks - use tasks to build your project and more. Debugging - find out about the Visual Studio Code debugger. If you have any other questions or run into any issues, please file an issue on GitHub ."
  },
  "guides/vscode/cpp/cpp-ide.html": {
    "href": "guides/vscode/cpp/cpp-ide.html",
    "title": "Edit C++ in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Edit C++ in Visual Studio Code This topic provides a quick overview of general C/C++ editor features, as well as some that are specific to C/C++. For more information about editing in Visual Studio Code, see Basic Editing and Code Navigation . The C/C++ extension supports Remote Development . Editing features The C/C++ extension for VS Code has many features that help you write code, understand it, and navigate around in your source files. To provide the best experience, the extension needs to know where it can find each header file referenced in your code. By default, the extension searches the current source directory, its sub-directories, and some platform-specific locations. If a referenced header file can't be found, VS Code displays a green squiggle underneath each #include directive that references it. To specify additional include directories to be searched, place your cursor over any #include directive that displays a green squiggle, then click the lightbulb action when it appears. This opens the file c_cpp_properties.json for editing; here you can specify additional include directories for each platform configuration individually by adding more directories to the 'browse.path' property. List members When you type a member access symbol ( . or -> ) the editor will display a list of members. As you type additional letters, the list is filtered in real time: Code formatting The C/C++ extension for Visual Studio Code supports source code formatting using clang-format which is included with the extension. You can format an entire file with Format Document ( kb(editor.action.formatDocument) ) or just the current selection with Format Selection ( kb(editor.action.formatSelection) ) in right-click context menu. You can also configure auto-formatting with the following settings : editor.formatOnSave - to format when you save your file. editor.formatOnType - to format as you type (triggered on the kbstyle(;) character). By default, the clang-format style is set to \"file\" which means it looks for a .clang-format file inside your workspace. If the .clang-format file is found, formatting is applied according to the settings specified in the file. If no .clang-format file is found in your workspace, formatting is applied based on a default style specified in the C_Cpp.clang_format_fallbackStyle setting instead. Currently, the default formatting style is \"Visual Studio\" which is an approximation of the default code formatter in Visual Studio. The Visual Studio clang-format style is not yet an official clang-format style but it implies the following clang-format settings: UseTab: (VS Code current setting) IndentWidth: (VS Code current setting) BreakBeforeBraces: Allman AllowShortIfStatementsOnASingleLine: false IndentCaseLabels: false ColumnLimit: 0 To use a different version of clang-format than the one that ships with the extension, change the C_Cpp.clang_format_path setting to the path where the clang-format binary is installed. For example, on the Windows platform: \"C_Cpp.clang_format_path\": \"C:\\\\Program Files (x86)\\\\LLVM\\\\bin\\\\clang-format.exe\" Enhanced semantic colorization When IntelliSense is enabled, the Visual Studio Code C/C++ extension supports semantic colorization. See Enhanced colorization for more details about setting colors for classes, functions, variables and so on. Quick Info You can hover over a symbol to see an inline view of its definition: Peek Definition The Peek Definition feature displays a few lines of code near the definition inside a peek window , so that you don't have to navigate away from your current location. To peek at a symbol's definition, place your cursor on the symbol anywhere it's used in your source code and then press kb(editor.action.peekDefinition) . Alternatively, you can choose Peek Definition from the context menu (right-click, then choose Peek Definition ). Currently, the C/C++ extension doesn't parse code in a way that helps it distinguish between competing definitions based on how the symbol is used. These competing definitions arise when the symbol defines different things in different contexts, such as occurs with overloaded functions, classes and their constructors, and other situations. When this happens, each of the competing definitions is listed in the right-hand side of the peek window with the source code of the current selection displayed on the left. With the peek window open, you browse the list of competing definitions to find the one you're interested in. If you want to navigate to the location of one of the definitions just double-click the definition you're interested in, or by double-clicking anywhere in the source code displayed on the left-hand side of the peek window. Navigate source code The source code navigation features provided by the C/C++ extension are powerful tools for understanding and getting around in your codebase. These features are powered by tags stored in a local database of symbol information. With the C/C++ extension installed, this database is generated whenever a folder containing C++ source code files is loaded into VS Code. The database icon appears next to the active configuration name (\"Win32\" in the image below) while the tag-parser is generating this information. The icon disappears when all the symbols have been tagged. Search for symbols You can search for symbols in the current file or workspace to navigate your code more quickly. To search for a symbol in the current file, press kb(workbench.action.gotoSymbol) , then enter the name of the symbol you're looking for. A list of potential matches will appear; it is filtered as you type. Choose from the list of matches to navigate to its location. To search for a symbol in the current workspace, press kb(workbench.action.showAllSymbols) , then enter the name of the symbol. A list of potential matches will appear as before. If you choose a match that was found in a file that's not already open, the file will be opened before navigating to the match's location. You can also search for symbols by accessing these commands through the Command Palette . Use Quick Open ( kb(workbench.action.quickOpen) ) then enter the '@' command to search the current file, or the '#' command to search the current workspace. kb(workbench.action.gotoSymbol) and kb(workbench.action.showAllSymbols) are just shortcuts for the '@' and '#' commands, so everything works the same. Go to Definition You can also quickly navigate to where a symbol is defined by using the Go to Definition feature. To go to a symbol's definition, place your cursor on the symbol anywhere it is used in your source code and then press kb(editor.action.revealDefinition) . Or, choose Go to Definition from the context menu (right-click, then choose Go to Definition ). When there's only one definition of the symbol, you'll navigate directly to its location, otherwise the competing definitions are displayed in a peek window as described in the previous section and you have to choose the definition that you want to go to. Next steps Read on to find out about: Configure VS Code for Windows Subsystem for Linux Configure VS Code for MSVC Configure VS Code for Mingw-w64 and GCC Configure VS Code for macOS Configure IntelliSense for cross-compiling Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Tasks - use tasks to build your project and more Debugging - find out how to use the debugger with your project If you have any other questions or run into any issues, please file an issue on GitHub . You may be asked to provide logging information from the extension to help diagnose the issue. See C/C++ extension logging for help on providing extension logs."
  },
  "guides/vscode/cpp/customize-default-settings-cpp.html": {
    "href": "guides/vscode/cpp/customize-default-settings-cpp.html",
    "title": "Customizing default settings | Fountain of Knowledge",
    "keywords": "Customizing default settings You can override the default values for properties set in c_cpp_properties.json . Visual Studio Code settings The following C_Cpp.default.* settings map to each of the properties in a configuration block of c_cpp_properties.json . Namely: C_Cpp.default.includePath : string[] C_Cpp.default.defines : string[] C_Cpp.default.compileCommands : string C_Cpp.default.macFrameworkPath : string[] C_Cpp.default.forcedInclude : string[] C_Cpp.default.intelliSenseMode : string C_Cpp.default.compilerPath : string C_Cpp.default.cStandard : c89 | c99 | c11 | c17 C_Cpp.default.cppStandard : c++98 | c++03 | c++11 | c++14 | c++17 | c++20 C_Cpp.default.browse.path : string[] C_Cpp.default.browse.databaseFilename : string C_Cpp.default.browse.limitSymbolsToIncludedHeaders : boolean These settings have all of the benefits of VS Code settings, meaning that they can have default, \"User\", \"Workspace\", and \"Folder\" values. So you can set a global value for C_Cpp.default.cppStandard in your \"User\" settings and have it apply to all of the folders you open. If any one folder needs a different value, you can override the value by adding a \"Folder\" or \"Workspace\" value. This property of VS Code settings allows you to configure each of your workspaces independently - making the c_cpp_properties.json file optional. Updated c_cpp_properties.json syntax A special variable has been added to the accepted syntax of c_cpp_properties.json that will instruct the extension to insert the value from the VS Code settings mentioned above. If you set the value of any setting in c_cpp_properties.json to \"${default}\" it will instruct the extension to read the VS Code default setting for that property and insert it. For example: \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"additional/paths\", \"${default}\" ], \"defines\": [ \"${default}\" ], \"macFrameworkPath\": [ \"${default}\", \"additional/paths\" ], \"forcedInclude\": [ \"${default}\", \"additional/paths\" ], \"compileCommands\": \"${default}\", \"browse\": { \"limitSymbolsToIncludedHeaders\": true, \"databaseFilename\": \"${default}\", \"path\": [ \"${default}\", \"additional/paths\" ] }, \"intelliSenseMode\": \"${default}\", \"cStandard\": \"${default}\", \"cppStandard\": \"${default}\", \"compilerPath\": \"${default}\" } ], Note that for the properties that accept string[], the syntax proposed above allows you to augment the VS Code setting with additional values, thus allowing you to have common paths listed in the VS Code settings and configuration-specific settings in c_cpp_properties.json . If a property is missing from c_cpp_properties.json , the extension will use the value in the VS Code setting. If a developer assigns values to all of the settings that apply for a given folder, then c_cpp_properties.json could be removed from the .vscode folder as it will no longer be needed. For in-depth information about the c_cpp_properties.json settings file, See c_cpp_properties.json reference . System includes A new setting will be added that allows you specify the system include path separate from the folder's include path. If this setting has a value, then the system include path the extension gets from the compiler specified in the compilerPath setting will not be added to the path array that the extension uses for IntelliSense. We may want to provide a VS Code command to populate this value from the compiler's default for users who are interested in using it in case they want to make some modifications to the defaults. C_Cpp.default.systemIncludePath : string[] System include path/defines resolution strategies The extension determines the system includePath and defines to send to the IntelliSense engine in the following manner: If compileCommands has a valid value and the file open in the editor is in the database, use the compile command in the database entry to determine the include path and defines. The system include path and defines are determined using the following logic (in order): If systemIncludePath has a value, use it (continue to the next step to search for system defines). If compilerPath is valid, query it. Interpret the first argument in the command as the compiler and attempt to query it. If compilerPath is \"\", use an empty array for system include path and defines. If compilerPath is undefined, look for a compiler on the system and query it. If compileCommands is invalid or the current file is not listed in the database, use the includePath and defines properties in the configuration for IntelliSense. The system include path and defines are determined using the following logic (in order): If systemIncludePath has a value, use it (continue to the next step to search for system defines). If compilerPath is valid, query it. If compilerPath is \"\", use an empty array for system include path and defines (they are assumed to be in the includePath and defines for the current config already). If compilerPath is undefined, look for a compiler on the system and query it. System includes should not be added to the includePath or browse.path variables. If the extension detects any system include paths in the includePath property it will silently remove them so that it can ensure system include paths are added last and in the correct order (this is especially important for GCC/Clang). Enhanced semantic colorization When IntelliSense is enabled, the Visual Studio Code C/C++ extension supports semantic colorization. See Enhanced colorization for more details about setting colors for classes, functions, variables and so on. Extension logging If you are experiencing a problem with the extension that we can't diagnose based on information in your issue report, we might ask you to enable logging and send us your logs. See C/C++ extension logging for information about how to collect logs."
  },
  "guides/vscode/cpp/enable-logging-cpp.html": {
    "href": "guides/vscode/cpp/enable-logging-cpp.html",
    "title": "C/C++ extension logging | Fountain of Knowledge",
    "keywords": "C/C++ extension logging Logging information is available for the language server and the debug adapter. If you are experiencing a problem that we are unable to diagnose based on information in your issue report, we might ask you to enable logging and send us your logs. Logging information is delivered directly to the Output panel for the language server and to the Debug Console for the debug adapter. Enable logging for the language server To turn on full logging for the language server, follow these steps: Open the Command Palette and choose Preferences: Workspace settings . Search for \"logging\" in the search box. Find C_Cpp: Logging Level and change the level to Debug . From the main menu, open the Output panel by choosing View > Output . Select the C/C++ option in the log filter selector: Enable logging for the debug adapter Enabling logging for the debug adapter will show communication information between VS Code and our extension and between our extension and the debug adapter. Logging configuration for the debug adapter is configured in launch.json . Logging for LLDB-MI debuggers The logging block for macOS LLDB-MI debuggers, along with its default configuration, is in launch.json : \"logging\": { \"trace\": false, \"traceResponse\": false, \"engineLogging\": false } VS Code and the CppTools extension The logging here is called trace logging and can be enabled by setting trace and traceResponse to true in the logging block inside launch.json . This will help diagnose issues related to VS Code's communication to our extension and our responses. CppTools extension and the debugger The logging between CppTools and the debugger is called engineLogging . When using an MI debugger such as gdb or lldb , this will show the request, response, and events using the mi interpreter. This logging will help us determine whether the debugger is receiving the right commands and generating the correct responses. Logging for Visual C++ debugger The logging block for the Visual C++ debugger with its default configuration in launch.json is as follows: \"logging\": { \"engineLogging\": false } The Visual C++ debugger logging will show only the communication to and from VS Code as all communication to the debugger is done internally to the process and is not visible through logging."
  },
  "guides/vscode/cpp/faq-cpp.html": {
    "href": "guides/vscode/cpp/faq-cpp.html",
    "title": "Frequently asked questions | Fountain of Knowledge",
    "keywords": "Frequently asked questions Why are my files corrupted on format? How do I get IntelliSense to work correctly? Why do I see red squiggles under Standard Library types? How do I get the new IntelliSense to work with MinGW on Windows? How do I get the new IntelliSense to work with the Windows Subsystem for Linux? What is the difference between includePath and browse.path in c_cpp_properties.json? How do I recreate the IntelliSense database? What is the ipch folder? How do I disable the IntelliSense cache (ipch)? How do I set up debugging? How do I enable debug symbols? Why is debugging not working? What do I do if I suspect a C/C++ extension problem Why are my files corrupted on format? Files can be corrupted due to the fact that you either have a multi-root workspace where one folder is a child of the other, or you are using symlinks to open your file. Reduce the folders in the workspace to one and remove the symlink. This should fix your problem. How do I get IntelliSense to work correctly? Without any configuration, the extension will attempt to locate headers by searching your workspace folder and by emulating a compiler it finds on your computer. (for example cl.exe/WSL/MinGW for Windows, gcc/clang for macOS/Linux). If this automatic configuration is insufficient, you can modify the defaults by running the C/C++: Edit Configurations (UI) command. In that view, you can change the compiler you want to emulate, the paths to include files you want to use, preprocessor definitions, and more. Or, if you install a build system extension that interfaces with our extension, you can allow that extension to provide the configurations for you. For example, the CMake Tools extension can configure projects that use the CMake build system. Use the C/C++: Change Configuration Provider... command to enable any such extension to provide the configurations for IntelliSense. A third option for projects without build system extension support is to use a compile_commands.json file if your build system supports generating this file. In the \"Advanced\" section of the Configuration UI, you can supply the path to your compile_commands.json and the extension will use the compilation information listed in that file to configure IntelliSense. Note: If the extension is unable to resolve any of the #include directives in your source code, it will not show linting information for the body of the source file. If you check the Problems window in VS Code, the extension will provide more information about which files it was unable to locate. If you want to show the linting information anyway, you can change the value of the C_Cpp.errorSquiggles setting. Why do I see red squiggles under Standard Library types? The most common reason for this is missing include paths and defines. The easiest way to fix this on each platform is as follows: Linux/Mac : Set intelliSenseMode\": \"clang-x64 or intelliSenseMode\": \"gcc-x64 and compilerPath in c_cpp_properties.json to the path to your compiler. Windows : If you are using the Microsoft C++ compiler, set intelliSenseMode\": \"msvc-x64 , but don't add the compilerPath property to c_cpp_properties.json . If you are using Clang for Windows, set intelliSenseMode\": \"msvc-x64 , and compilerPath in c_cpp_properties.json to the path to your compiler. How do I get the new IntelliSense to work with MinGW on Windows? See Get Started with C++ and Mingw-w64 in Visual Studio Code . How do I get the new IntelliSense to work with the Windows Subsystem for Linux? See Get Started with C++ and Windows Subsystem for Linux in Visual Studio Code . What is the difference between includePath and browse.path? These two settings are available in c_cpp_properties.json and can be confusing. includePath This array of path strings is used by the \"Default\" IntelliSense engine. This new engine provides semantic-aware IntelliSense features and will be the eventual replacement for the Tag Parser that has been powering the extension since it was first released. It currently provides tooltips and error squiggles in the editor. The remaining features (for example, code completion, signature help, Go to Definition, ...) are implemented using the Tag Parser's database, so it is still important to ensure that the browse.path setting is properly set. The paths that you specify for this setting are the same paths that you would send to your compiler via the -I switch. When your source files are parsed, the IntelliSense engine will prepend these paths to the files specified by your #include directives while attempting to resolve them. These paths are not searched recursively. browse.path This array of path strings is used by the \"Tag Parser\" (\"browse engine\"). This engine will recursively enumerate all files under the paths specified and track them as potential includes while tag parsing your project folder. To disable recursive enumeration of a path, you can append a /* to the path string. When you open a workspace for the first time, the extension adds ${workspaceFolder} to both arrays. If this is undesirable, you can open your c_cpp_properties.json file and remove it. How do I recreate the IntelliSense database? Starting in version 0.12.3 of the extension, there is a command to reset your IntelliSense database. Open the Command Palette ( kb(workbench.action.showCommands) ) and choose the C/C++: Reset IntelliSense Database command. What is the ipch folder? The language server caches information about included header files to improve the performance of IntelliSense. When you edit C/C++ files in your workspace folder, the language server will store cache files in the ipch folder. By default, the ipch folder is stored under the user directory. Specifically, it is stored under %LocalAppData%/Microsoft/vscode-cpptools on Windows, and for Linux and macOS it is under ~/.vscode-cpptools . By using the user directory as the default path, it will create one cache location per user for the extension. As the cache size limit is applied to a cache location, having one cache location per user will limit the disk space usage of the cache to that one folder for everyone using the default setting value. VS Code per-workspace storage folders were not used because the location provided by VS Code is not well known and we didn't want to write GB's of files where users may not see them or know where to find them. With this in mind, we knew that we would not be able to meet the needs of every different development environment, so we provided settings to allow you to customize the way that works best for your situation. \"C_Cpp.intelliSenseCachePath\": <string> This setting allows you to set workspace or global overrides for the cache path. For example, if you want to share a single cache location for all workspace folders, open the VS Code settings, and add a User setting for IntelliSense Cache Path . \"C_Cpp.intelliSenseCacheSize\": <number> This setting allows you to set a limit on the amount of caching the extension does. This is an approximation, but the extension will make a best effort to keep the cache size as close to the limit you set as possible. If you are sharing the cache location across workspaces as explained above, you can still increase/decrease the limit, but you should make sure that you add a User setting for IntelliSense Cache Size . How do I disable the IntelliSense cache (ipch)? If you do not want to use the IntelliSense caching feature that improves the performance of IntelliSense, you can disable the feature by setting the IntelliSense Cache Size setting to 0 (or \"C_Cpp.intelliSenseCacheSize\": 0\" in the JSON settings editor). How do I set up debugging? The debugger needs to be configured to know which executable and debugger to use: From the main menu, select Run > Add Configuration... . The file launch.json will now be open for editing with a new configuration. The default settings will probably work except that you need to specify the program setting. See Debug configuration for more in-depth documentation on how to configure the debugger. How do I enable debug symbols? Enabling debug symbols is dependent on the type of compiler you are using. Below are some of the compilers and the compiler options necessary to enable debug symbols. When in doubt, please check your compiler's documentation for the options necessary to include debug symbols in the output. This may be some variant of -g or --debug . Clang (C++) If you invoke the compiler manually, add the --debug option. If you're using a script, make sure the CXXFLAGS environment variable is set. For example, export CXXFLAGS=\"${CXXFLAGS} --debug\" . If you're using CMake, make sure the CMAKE_CXX_FLAGS is set. For example, export CMAKE_CXX_FLAGS=${CXXFLAGS} . Clang (C) See Clang C++ but use CFLAGS instead of CXXFLAGS . gcc or g++ If you invoke the compiler manually, add the -g option. cl.exe Symbols are located in the *.pdb file. Why is debugging not working? My breakpoints aren't being hit When you start debugging, if your breakpoints aren't bound (solid red circle) or they are not being hit, you may need to enable debug symbols during compilation. Debugging starts but all the lines in my stack trace are grey If your debugger is showing a grey stack trace, won't stop at a breakpoint, or the symbols in the call stack are grey, then your executable was compiled without debug symbols . What do I do if I suspect a C/C++ extension problem If you are experiencing a problem with the extension that we can't diagnose based on information in your issue report, we might ask you to enable logging and send us your logs. See C/C++ extension logging for how to get C/C++ extension logs. If you have any other questions or run into any issues, please file an issue on GitHub ."
  },
  "guides/vscode/cpp/introvideos-cpp.html": {
    "href": "guides/vscode/cpp/introvideos-cpp.html",
    "title": "Introductory Videos for C++ | Fountain of Knowledge",
    "keywords": "Introductory Videos for C++ Get started with C++ in Visual Studio Code by watching these introductory videos! These videos are designed to help you set up C++ IntelliSense and build and debug C++ projects in VS Code. After watching these quick tutorials, you'll be able to enjoy VS Code's rich C++ feature set. Configure C++ IntelliSense This video walks you through the steps to configure C++ IntelliSense for your project. Build a C++ project Learn how to build C++ projects in VS Code by customizing your C++ build tasks. Debug a C++ project This video shows you how to customize debug configurations for your C++ project and start a C++ debugging session in VS Code. Next steps Learn about all the C++ editing features available in VS Code. Check out the Hello World tutorials for getting started with C++ for your toolset and platform: GCC on Windows Microsoft C++ on Windows GCC on Linux GCC on Windows Subsystem For Linux Clang/LLVM on macOS"
  },
  "guides/vscode/cpp/launch-json-reference.html": {
    "href": "guides/vscode/cpp/launch-json-reference.html",
    "title": "Configuring C/C++ debugging | Fountain of Knowledge",
    "keywords": "Configuring C/C++ debugging The launch.json file is used to configure the debugger in Visual Studio Code. Visual Studio Code generates a launch.json with almost all of the required information. To get started with debugging you need to fill in the program field with the path to the executable you plan to debug. This must be specified for both the launch and attach (if you plan to attach to a running instance at any point) configurations. The generated file contains two sections, one that configures debugging for launch and a second that configures debugging for attach. Configure VS Code's debugging behavior Set or change the following options to control VS Code's behavior during debugging: program (required) Specifies the full path to the executable the debugger will launch or attach to. The debugger requires this location in order to load debug symbols. symbolSearchPath Tells the Visual Studio Windows Debugger what paths to search for symbol (.pdb) files. Separate multiple paths with a semicolon. For example: \"C:\\\\Symbols;C:\\\\SymbolDir2\" . requireExactSource An optional flag that tells the Visual Studio Windows Debugger to require current source code to match the pdb. additionalSOLibSearchPath Tells GDB or LLDB what paths to search for .so files. Separate multiple paths with a semicolon. For example: \"/Users/user/dir1;/Users/user/dir2\" . externalConsole Used only when launching the debuggee. For attach , this parameter does not change the debuggee's behavior. Windows : When set to true, it will spawn an external console. When set to false, it will use VS Code's integratedTerminal. Linux : When set to true, it will notify VS Code to spawn an external console. When set to false, it will use VS Code's integratedTerminal. macOS : When set to true, it will spawn an external console through lldb-mi . When set to false, the output can be seen in VS Code's debugConsole. Due to limitations within lldb-mi , integratedTerminal support is not available. avoidWindowsConsoleRedirection In order to support VS Code's Integrated Terminal with gdb on Windows, the extension adds console redirection commands to the debuggee's arguments to have console input and output show up in the integrated terminal. Setting this option to true will disable it. logging Optional flags to determine what types of messages should be logged to the Debug Console. exceptions : Optional flag to determine whether exception messages should be logged to the Debug Console. Defaults to true. moduleLoad : Optional flag to determine whether module load events should be logged to the Debug Console. Defaults to true. programOutput : Optional flag to determine whether program output should be logged to the Debug Console. Defaults to true. engineLogging : Optional flag to determine whether diagnostic engine logs should be logged to the Debug Console. Defaults to false. trace : Optional flag to determine whether diagnostic adapter command tracing should be logged to the Debug Console. Defaults to false. traceResponse : Optional flag to determine whether diagnostic adapter command and response tracing should be logged to the Debug Console. Defaults to false. visualizerFile .natvis file to be used when debugging. See Create custom views of native objects for information on how to create Natvis files. showDisplayString When a visualizerFile is specified, showDisplayString will enable the display string. Turning on this option can cause slower performance during debugging. Example: { \"name\": \"C++ Launch (Windows)\", \"type\": \"cppvsdbg\", \"request\": \"launch\", \"program\": \"C:\\\\app1\\\\Debug\\\\app1.exe\", \"symbolSearchPath\": \"C:\\\\Symbols;C:\\\\SymbolDir2\", \"externalConsole\": true, \"logging\": { \"moduleLoad\": false, \"trace\": true }, \"visualizerFile\": \"${workspaceFolder}/my.natvis\", \"showDisplayString\": true } Configure the target application The following options enable you to modify the state of the target application when it is launched: args JSON array of command-line arguments to pass to the program when it is launched. Example [\"arg1\", \"arg2\"] . If you are escaping characters, you will need to double escape them. For example, [\"{\\\\\\\"arg1\\\\\\\": true}\"] will send {\"arg1\": true} to your application. cwd Sets the working directory of the application launched by the debugger. environment Environment variables to add to the environment for the program. Example: [ { \"name\": \"config\", \"value\": \"Debug\" } ] , not [ { \"config\": \"Debug\" } ] . Example: { \"name\": \"C++ Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/a.out\", \"args\": [\"arg1\", \"arg2\"], \"environment\": [{\"name\": \"config\", \"value\": \"Debug\"}], \"cwd\": \"${workspaceFolder}\" } Customizing GDB or LLDB You can change the behavior of GDB or LLDB by setting the following options: MIMode Indicates the debugger that VS Code will connect to. Must be set to gdb or lldb . This is pre-configured on a per-operating system basis and can be changed as needed. miDebuggerPath The path to the debugger (such as gdb). When only the executable is specified, it will search the operating system's PATH variable for a debugger (GDB on Linux and Windows, LLDB on OS X). miDebuggerArgs Additional arguments to pass to the debugger (such as gdb). stopAtEntry If set to true, the debugger should stop at the entry-point of the target (ignored on attach). Default value is false . stopAtConnect If set to true, the debugger should stop after connecting to the target. If set to false, the debugger will continue after connecting. Default value is false . setupCommands JSON array of commands to execute in order to set up the GDB or LLDB. Example: \"setupCommands\": [ { \"text\": \"target-run\", \"description\": \"run target\", \"ignoreFailures\": false }] . customLaunchSetupCommands If provided, this replaces the default commands used to launch a target with some other commands. For example, this can be \"-target-attach\" in order to attach to a target process. An empty command list replaces the launch commands with nothing, which can be useful if the debugger is being provided launch options as command-line options. Example: \"customLaunchSetupCommands\": [ { \"text\": \"target-run\", \"description\": \"run target\", \"ignoreFailures\": false }] . launchCompleteCommand The command to execute after the debugger is fully set up in order to cause the target process to run. Allowed values are \"exec-run\", \"exec-continue\", \"None\". The default value is \"exec-run\". Example: { \"name\": \"C++ Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/a.out\", \"stopAtEntry\": false, \"customLaunchSetupCommands\": [ { \"text\": \"target-run\", \"description\": \"run target\", \"ignoreFailures\": false } ], \"launchCompleteCommand\": \"exec-run\", \"linux\": { \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/usr/bin/gdb\" }, \"osx\": { \"MIMode\": \"lldb\" }, \"windows\": { \"MIMode\": \"gdb\", \"miDebuggerPath\": \"C:\\\\MinGw\\\\bin\\\\gdb.exe\" } } symbolLoadInfo loadAll : If true, symbols for all libs will be loaded, otherwise no solib symbols will be loaded. Modified by ExceptionList. Default value is true. exceptionList : List of filenames (wildcards allowed) separated by semicolons ; . Modifies behavior of LoadAll. If LoadAll is true then don't load symbols for libs that match any name in the list. Otherwise only load symbols for libs that match. Example: \"foo.so;bar.so\" Debugging dump files The C/C++ extension enables debugging dump files on Windows and core dump files Linux and OS X. dumpPath If you want to debug a Windows dump file, set this to the path to the dump file to start debugging in the launch configuration. coreDumpPath Full path to a core dump file to debug for the specified program. Set this to the path to the core dump file to start debugging in the launch configuration. Note: core dump debugging is not supported with MinGw. Remote debugging or debugging with a local debugger server miDebuggerServerAddress Network address of the debugger server (for example, gdbserver) to connect to for remote debugging (example: localhost:1234 ). debugServerPath Full path to debug server to launch. debugServerArgs Arguments for the debugger server. serverStarted Server-started pattern to look for in the debug server output. Regular expressions are supported. filterStdout If set to true, search stdout stream for server-started pattern and log stdout to debug output. Default value is true . filterStderr If set to true, search stderr stream for server-started pattern and log stderr to debug output. Default value is false . serverLaunchTimeout Time in milliseconds, for the debugger to wait for the debugServer to start up. Default is 10000. pipeTransport For information about attaching to a remote process, such as debugging a process in a Docker container, see the Pipe transport settings article. hardwareBreakpoints If provided, this explicitly controls hardware breakpoint behavior for remote targets. If require is set to true, always use hardware breakpoints. Default value is false . limit is an optional limit on the number of available hardware breakpoints to use which is only enforced when require is true and limit is greater than 0. Defaults value is 0. Example: \"hardwareBreakpoints\": { require: true, limit: 6 } . Additional properties processId Defaults to ${command:pickProcess} which will display a list of available processes the debugger can attach to. We recommend that you leave this default, but the property can be explicitly set to a specific process ID for the debugger to attach to. request Indicates whether the configuration section is intended to launch the program or attach to an already running instance. targetArchitecture Deprecated This option is no longer needed as the target architecture is automatically detected. type Indicates the underlying debugger being used. Must be cppvsdbg when using the Visual Studio Windows debugger, and cppdbg when using GDB or LLDB. This is automatically set to the correct value when the launch.json file is created. sourceFileMap This allows mapping of the compile-time paths for source to local source locations. It is an object of key/value pairs and will resolve the first string-matched path. (example: \"sourceFileMap\": { \"/mnt/c\": \"c:\\\\\" } will map any path returned by the debugger that begins with /mnt/c and convert it to c:\\\\ . You can have multiple mappings in the object but they will be handled in the order provided.) Environment variable definitions file An environment variable definitions file is a simple text file containing key-value pairs in the form of environment_variable=value , with # used for comments. Multiline values are not supported. The cppvsdbg debugger configuration also contains an envFile property that allows you to easily set variables for debugging purposes. For example: project.env file : # project.env # Example environment with key as 'MYENVRIONMENTPATH' and value as C:\\\\Users\\\\USERNAME\\\\Project MYENVRIONMENTPATH=C:\\\\Users\\\\USERNAME\\\\Project # Variables with spaces SPACED_OUT_PATH=\"C:\\\\This Has Spaces\\\\Project\" Symbol Options The symbolOptions element allows customization of how the debugger searches for symbols. Example: \"symbolOptions\": { \"searchPaths\": [ \"C:\\\\src\\\\MyOtherProject\\\\bin\\\\debug\", \"https://my-companies-symbols-server\" ], \"searchMicrosoftSymbolServer\": true, \"cachePath\": \"%TEMP%\\\\symcache\", \"moduleFilter\": { \"mode\": \"loadAllButExcluded\", \"excludedModules\": [ \"DoNotLookForThisOne*.dll\" ] } } Properties: searchPaths : Array of symbol server URLs (example: https://msdl.microsoft.com/download/symbols ) or directories (example: /build/symbols) to search for .pdb files. These directories will be searched in addition to the default locations -- next to the module and the path where the pdb was originally dropped to. searchMicrosoftSymbolServer : If true the Microsoft Symbol server ( https://msdl.microsoft.com/download/symbols ) is added to the symbols search path. If unspecified, this option defaults to false . cachePath \": Directory where symbols downloaded from symbol servers should be cached. If unspecified, the debugger will default to %TEMP%\\SymbolCache.. moduleFilter.mode : This value is either \"loadAllButExcluded\" or \"loadOnlyIncluded\" . In \"loadAllButExcluded\" mode, the debugger loads symbols for all modules unless the module is in the 'excludedModules' array. In \"loadOnlyIncluded\" mode, the debugger will not attempt to load symbols for ANY module unless it is in the 'includedModules' array, or it is included through the 'includeSymbolsNextToModules' setting. Properties for \"loadAllButExcluded\" mode: moduleFilter.excludedModules : Array of modules that the debugger should NOT load symbols for. Wildcards (example: MyCompany.*.dll) are supported. Properties for \"loadOnlyIncluded\" mode: moduleFilter.includedModules : Array of modules that the debugger should load symbols for. Wildcards (example: MyCompany.*.dll) are supported. moduleFilter.includeSymbolsNextToModules : If true, for any module NOT in the 'includedModules' array, the debugger will still check next to the module itself and the launching executable, but it will not check paths on the symbol search list. This option defaults to 'true'."
  },
  "guides/vscode/cpp/lldb-mi.html": {
    "href": "guides/vscode/cpp/lldb-mi.html",
    "title": "Debugging with LLDB-MI on macOS | Fountain of Knowledge",
    "keywords": "Debugging with LLDB-MI on macOS The debug adapter for the C/C++ extension utilizes the machine interface mode for both gdb and lldb. To use this interface in lldb, the extension utilizes lldb-mi . The lldb-mi executable was built from the GitHub lldb-mi repository and has a dependency on the LLDB.framework , which is part of Xcode. Prerequisites The lldb-mi executable requires LLDB.framework to run. How to obtain the LLDB.framework You can get the LLDB.framework one of two ways. Xcode: Open the Apple App Store . Search for 'Xcode'. Select the Xcode application and then Install . Xcode Command Line Tools: Open a terminal. Run xcode-select --install . Confirm the prompt. Example launch.json Below is an example launch.json debug configuration entry for lldb : \"configurations\": [ { \"name\": \"Launch (lldb)\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/a.out\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false } ] If you get a Developer Tools Access prompt You may see a dialog saying \"Developer Tools Access needs to take control of another process for debugging to continue.\" If you get this prompt, you will have to enter your username and password to allow debugging. If you want to permanently dismiss this prompt, you can run the following command in a terminal: sudo DevToolsSecurity --enable Additional configurations Using an LLDB.framework not installed via Xcode If you want to use an LLDB.framework that is not installed with Xcode, you need to: Copy the lldb-mi executable in ~/.vscode/extensions/ms.vscode-cpptools-<version>/debugAdapters/lldb-mi/bin to the folder where the LLDB.framework is located. Add the full path of lldb-mi to miDebuggerPath in your launch.json configuration. For example, if you have the LLDB.framework folder located at /Users/default/example/ , you would: Copy ~/.vscode/extensions/ms.vscode-cpptools-<version>/debugAdapters/lldb-mi/bin/lldb-mi into /Users/default/example/ . Add the following to your existing configuration: \"miDebuggerPath\": \"/Users/default/example/lldb-mi\" Using a custom-built lldb-mi If you built your own lldb-mi , you can use it by setting miDebuggerPath to the full path of the executable. References LLDB-MI Build LLDB-MI Repository"
  },
  "guides/vscode/cpp/natvis.html": {
    "href": "guides/vscode/cpp/natvis.html",
    "title": "Natvis: Custom views for native objects | Fountain of Knowledge",
    "keywords": "Natvis: Custom views for native objects The Natvis framework allows developers to write custom schemas to help visualize native objects. For gdb/lldb debugging ( type\": \"cppdbg ), a subset of the Natvis framework has been ported to the C/C++ extension and the code resides in the MIEngine shared component. If additional features that are not implemented are requested, please file an issue on the MIEngine GitHub page with details of what is missing. For Microsoft C++ debugging ( type\": \"cppvsdbg ), the debugger contains the full implementation of the Natvis framework as Visual Studio. Documentation The official Natvis documentation is located at Create custom views of C++ objects in the debugger . Schema The Natvis schema is provided here for convenience: <?xml version=\"1.0\" encoding=\"utf-8\"?> <xs:schema targetNamespace=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\" xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\" attributeFormDefault=\"unqualified\" elementFormDefault=\"qualified\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <!-- Definition of complex named types--> <xs:simpleType name=\"GuidType\"> <xs:annotation> <xs:documentation>Values of this type will look like: \"01234567-89AB-CDEF-0123-456789ABCDEF\" or \"{01234567-89AB-CDEF-0123-456789ABCDEF}\".</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"[{(]?[0-9A-Fa-f]{8}\\-?[0-9A-Fa-f]{4}\\-?[0-9A-Fa-f]{4}\\-?[0-9A-Fa-f]{4}\\-?[0-9A-Fa-f]{12}[})]?\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"CppIdType\"> <xs:annotation> <xs:documentation>A valid C++ identifier.</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"[a-zA-Z$_][a-zA-Z$_0-9]*\" /> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"StringType\"> <xs:restriction base=\"xs:string\"> <xs:minLength value=\"1\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"MaxItemsPerViewType\"> <xs:annotation> <xs:documentation> Specifies the maximum number of collection items that can be displayed at one time. If the number of items in the collection exceeds this limit, a special node will be created at the end, which can be expanded to show additional items. The precise cutoff for the maximum number of items to show in a view is a tuning parameter. While a higher number allow more items to be visible at one time, a lower number will improve the performance of Visual Studio when a custom list object is expanded. In general, the more complicated the traversal logic, the smaller the number of items per view needs to be in order to keep the IDE responsive. The maximum number of items per view must be between 1 and 50,000. A default value of 5,000 items will be used if this attribute is not specified. </xs:documentation> </xs:annotation> <xs:restriction base=\"xs:unsignedInt\"> <xs:minInclusive value=\"1\" /> <xs:maxInclusive value=\"50000\" /> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"ConditionType\"> <xs:annotation> <xs:documentation>Specifies the condition under which this element is active. The expression should produce a boolean value when evaluated.</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:minLength value=\"1\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"OptionalType\"> <xs:annotation> <xs:documentation> Specifies whether the element is optional. An optional element that fails to parse allows the remainder of the elements in the enclosing &lt;Type&gt; entry to be used. A mandatory element that fails to parse will cause the entire enclosing &lt;Type&gt; element to be invalidated. All elements are assumed, by default, to be mandatory, unless Optional=&quot;true&quot; is specified. </xs:documentation> </xs:annotation> <xs:restriction base=\"xs:boolean\"> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"ViewIncludeType\"> <xs:annotation> <xs:documentation> Specifies a semi-colon-delimited list of views in which this element should be shown. The view of the object is controlled via the ,view(&lt;name&gt;) format specifier. </xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:minLength value=\"1\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"ViewExcludeType\"> <xs:annotation> <xs:documentation> Specifies a semi-colon-delimited list of views in which this element should be hidden. The view of the object is controlled via the ,view(&lt;name&gt;) format specifier. </xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:minLength value=\"1\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"TypeNameType\"> <xs:annotation> <xs:documentation>Specifies the fully qualified name of the type to be visualized. If the type is a template class, it might contain '*' as a wildcard character for template parameters. Primitive data type names are only allowed with UIVisualizer definitions.</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:minLength value=\"1\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"ModuleNameStringType\"> <xs:annotation> <xs:documentation>Specifies the name of a module. It should include just the module name and no absolute or relative paths.</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:minLength value=\"1\"/> <xs:pattern value=\"([^\\\\^//])+\"/> <!-- Prevent absolute or relative pathing, just the module name only--> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"VersionStringType\"> <xs:annotation> <xs:documentation>1.2.3.4 or 1.2 are acceptable.</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"([0-9])+\\.([0-9])+(\\.([0-9])+\\.([0-9])+)?\"/> <!--1.2.3.4 or 1.2 are acceptable --> </xs:restriction> </xs:simpleType> <xs:complexType name=\"AlternativeHResultType\"> <xs:annotation> <xs:documentation>Specifies an alternative HRESULT which will share the same visualizer.</xs:documentation> </xs:annotation> <xs:attribute name=\"Name\" type=\"TypeNameType\" use=\"required\"/> </xs:complexType> <xs:complexType name=\"IntrinsicParameterType\"> <xs:annotation> <xs:documentation>Specifies the type of the parameter to the given intrinsic function.</xs:documentation> </xs:annotation> <xs:attribute name=\"Type\" type=\"StringType\" use=\"required\" /> <xs:attribute name=\"Name\" type=\"CppIdType\" use=\"optional\"> <xs:annotation> <xs:documentation>If an expression is provided, specifies the name by which the expression can refer to the parameter. If the function is implemented via a debugger extension, this attribute may be omitted. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:complexType name=\"IntrinsicType\"> <xs:annotation> <xs:documentation>Describes a custom intrinsic function that can be called from an expression. An &lt;Intrinsic&gt; element must be accompanied by a debugger component that implements the function through the IDkmIntrinsicFunctionEvaluator140 interface. </xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:element name=\"Parameter\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"IntrinsicParameterType\"></xs:element> </xs:choice> <xs:attributeGroup ref=\"CommonAttributes_NoCondition_NoView\" /> <xs:attribute name=\"Name\" type=\"CppIdType\" use=\"required\"> <xs:annotation> <xs:documentation>The name of the intrinsic function. This must be a valid C++ identifier. </xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Category\" type=\"IconType\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies which category icon should be assigned to the results of expressions that invoke this function. This controls which icon is used in the watch window for expressions that call the function. The default category value is 'Method'.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"ReturnType\" type=\"StringType\" use=\"optional\"> <xs:annotation> <xs:documentation>The return type of the intrinsic function. The return type may be omitted if an expression is provided (the type of the expression will imply the return type).</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Expression\" type=\"StringType\" use=\"optional\"> <xs:annotation> <xs:documentation> Expression that evaluates to the return value of the function. </xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"SourceId\" type=\"GuidType\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies the source id used to identify the debugger component that implements the function. This must match the filter constraints of the IDkmIntrinsicFunctionEvaluator140 implementation.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"LanguageId\" type=\"GuidType\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies the language id used to identify the debugger component that implements the function. This must match the filter constraints of the IDkmIntrinsicFunctionEvaluator140 implementation.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Id\" type=\"xs:unsignedInt\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies unique id for this function, given the source id and language id. It is used by the implementing component to determine which function was called if it implements multiple intrinsic functions.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"SideEffect\" type=\"xs:boolean\" use=\"optional\"> <xs:annotation> <xs:documentation>If true, indicates that this function may cause side effects. If true, calls to this function will be disabled in scenarios where unexpected side effects may be confusing to the user. Functions that modify state, either inside the debuggee or inside Visual Studio, should set this to true. By default, this value is false.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Varargs\" type=\"xs:boolean\" use=\"optional\"> <xs:annotation> <xs:documentation> If true, indicates that this function is a varargs function, and that additional arguments can be passed after the explicitly-listed parameters. Default is false. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:complexType name=\"AlternativeTypeType\"> <xs:annotation> <xs:documentation>Specifies an alternative type which will share the same visualizer.</xs:documentation> </xs:annotation> <xs:attribute name=\"Name\" type=\"TypeNameType\" use=\"required\"/> <xs:attribute name=\"Priority\" type=\"PriorityType\" use=\"optional\" /> <xs:attribute name=\"Inheritable\" type=\"xs:boolean\" use=\"optional\"> <xs:annotation> <xs:documentation> True if this visualizer may be used by objects of classes derived from the given type, false if an object must be directly of this type for the visualizer to take effect. Default is true. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:complexType name=\"VersionType\"> <xs:annotation> <xs:documentation>Specifies a matching module name and version for this visualizer.</xs:documentation> </xs:annotation> <xs:attribute name=\"Name\" type=\"ModuleNameStringType\" use=\"required\" /> <xs:attribute name=\"Min\" type=\"VersionStringType\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies the minimum (inclusive) version number. </xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Max\" type=\"VersionStringType\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies the maximum (inclusive) version number. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <!-- Attributes for elements that support filtering by view--> <xs:attributeGroup name=\"ViewConstraints\"> <xs:attribute name=\"IncludeView\" type =\"ViewIncludeType\" use=\"optional\" /> <xs:attribute name=\"ExcludeView\" type =\"ViewExcludeType\" use=\"optional\" /> </xs:attributeGroup> <xs:attributeGroup name=\"CommonAttributes_NoCondition_NoView\"> <xs:attribute name=\"ModuleName\" type=\"ModuleNameStringType\" use=\"optional\" /> <xs:attribute name=\"ModuleVersionMin\" type=\"VersionStringType\" use=\"optional\" /> <xs:attribute name=\"ModuleVersionMax\" type=\"VersionStringType\" use=\"optional\" /> <xs:attribute name=\"Optional\" type=\"OptionalType\" use=\"optional\" /> </xs:attributeGroup> <xs:attributeGroup name=\"CommonAttributes_NoCondition\"> <xs:attributeGroup ref=\"CommonAttributes_NoCondition_NoView\" /> <xs:attributeGroup ref=\"ViewConstraints\" /> </xs:attributeGroup> <!-- These attributes are shared by all top-level natvis elements (DisplayString/StringView/top-level children of Expand)--> <xs:attributeGroup name=\"CommonAttributes\"> <xs:attributeGroup ref=\"CommonAttributes_NoCondition\" /> <xs:attribute name=\"Condition\" type=\"ConditionType\" use=\"optional\" /> </xs:attributeGroup> <xs:complexType name=\"DisplayStringType\"> <xs:annotation> <xs:documentation>Specifies the string to be shown as the value of objects of the visualized type. It accepts arbitrary strings mixed with expressions. Everything inside curly braces (for example, { and }) is interpreted as an expression and gets evaluated. To escape a curly brace, you can type two curly braces (for example, \\{{ or }}).</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attributeGroup ref=\"CommonAttributes\" /> <xs:attribute name=\"LegacyAddin\" type=\"StringType\" use=\"optional\"> <xs:annotation> <xs:documentation>If a legacy add-in exists, specifies the dll of the legacy addin. If a full path isn't specified, Visual Studio will look in the visualizer directory next to the .natvis file that specified the add-in. A regular display string is still allowed in conjunction with an add-in, and will be used as a fallback if the add-in dll cannot be loaded.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Export\" type=\"StringType\" use=\"optional\"> <xs:annotation> <xs:documentation>If a legacy add-in exists, specifies the name of the export for the legacy add-in implementation. This attribute is valid only if 'LegacyAddin' is also specified.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Encoding\" type=\"EncodingType\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies the encoding of the string returned by the legacy addin. Default is Utf8. This attribute is valid only if 'LegacyAddin' is also specified. </xs:documentation> </xs:annotation> </xs:attribute> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:simpleType name=\"EncodingType\"> <xs:restriction base=\"xs:normalizedString\"> <xs:enumeration value=\"Ansi\" /> <xs:enumeration value=\"Utf8\" /> </xs:restriction> </xs:simpleType> <xs:complexType name=\"CustomVisualizerType\"> <xs:annotation> <xs:documentation>Specifies a visualizer add-in which customizes the debugger view of this object.</xs:documentation> </xs:annotation> <xs:attribute name=\"VisualizerId\" type=\"GuidType\" use=\"required\"/> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:complexType> <xs:complexType name=\"StringViewType\"> <xs:annotation> <xs:documentation>Specifies the expression whose value is sent to the built-in text visualizers.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"IndexNodeType\"> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attribute name=\"Condition\" type=\"ConditionType\" use=\"optional\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:attributeGroup name=\"NameAttribute\"> <xs:attribute type=\"xs:string\" name=\"Name\" use=\"optional\"> <xs:annotation> <xs:documentation> Specifies an optional name, in &lt;DisplayString&gt; syntax, for this node. If omitted, the name of the node will be the index of the item in the tree traversal. Expressions in curly braces are evaluated in the context of the node. </xs:documentation> </xs:annotation> </xs:attribute> </xs:attributeGroup> <xs:complexType name=\"ListItemsNodeType\"> <xs:annotation> <xs:documentation>Expression that points to value of the linked list node. It can be left empty or have 'this' to refer to the linked list node itself. This expression is evaluated under the context of the linked list node and not the parent linked list type.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attributeGroup ref=\"NameAttribute\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"TreeItemsNodeType\"> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attribute name=\"Condition\" type=\"ConditionType\" use=\"optional\" /> <xs:attributeGroup ref=\"NameAttribute\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"ItemType\"> <xs:annotation> <xs:documentation>Specifies a single child element. It only accepts expressions and no arbitrary strings. If the expression produces a complex type value, the child node itself can be expanded by the user.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attribute name=\"Name\" type=\"StringType\" use=\"required\"> <xs:annotation> <xs:documentation>Name of the child element as it will be shown under the name column in the debugger variable windows.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"ExpandedItemType\"> <xs:annotation> <xs:documentation>Specifies a child element whose children will be shown as the children of the current node. Use when you need to generate a flat view of a type when expanded.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:simpleType name=\"ArrayDirectionType\"> <xs:annotation> <xs:documentation>Specifies how the multi-dimensional array indices should be unrolled. Use 'Forward' for row-major arrays and 'Backward' for column-major arrays.</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:normalizedString\"> <xs:enumeration value=\"Forward\"/> <xs:enumeration value=\"Backward\"/> </xs:restriction> </xs:simpleType> <xs:simpleType name=\"IconType\"> <xs:restriction base=\"xs:normalizedString\"> <xs:enumeration value=\"Data\"> <xs:annotation> <xs:documentation> Indicates that the item should use the icon associated with general data. </xs:documentation> </xs:annotation> </xs:enumeration> <xs:enumeration value=\"Method\"> <xs:annotation> <xs:documentation> Indicates that the item should use the icon associated with method calls. </xs:documentation> </xs:annotation> </xs:enumeration> <xs:enumeration value=\"Property\"> <xs:annotation> <xs:documentation> Indicates that the item should use the icon associated with properties. </xs:documentation> </xs:annotation> </xs:enumeration> </xs:restriction> </xs:simpleType> <xs:complexType name=\"ExpandType\"> <xs:annotation> <xs:documentation>Specifies the list of child elements to be shown when a variable of the visualized type is expanded in the debugger windows.</xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:element name=\"Item\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ItemType\" /> <xs:element name=\"ArrayItems\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ArrayItemsType\" /> <xs:element name=\"IndexListItems\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"IndexListItemsType\" /> <xs:element name=\"LinkedListItems\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"LinkedListItemsType\" /> <xs:element name=\"TreeItems\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"TreeItemsType\" /> <xs:element name=\"ExpandedItem\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ExpandedItemType\" /> <xs:element name=\"Synthetic\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"SyntheticItemType\" /> <xs:element name=\"CustomListItems\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"CustomListItemsType\" /> </xs:choice> <xs:attribute name=\"HideRawView\" type=\"xs:boolean\"> <xs:annotation> <xs:documentation>Specifies whether or not the \"[Raw View]\" node for this object should be hidden. By default, this attribute is set to 'false', which will result in the raw view node of the current object visible to the user. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:complexType name=\"CustomListItemsType\"> <xs:annotation> <xs:documentation>Specifies custom logic for iterating through a collection which cannot be visualized by other means.</xs:documentation> </xs:annotation> <xs:sequence> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:element name=\"Variable\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"VariableType\"></xs:element> </xs:choice> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:element name=\"Size\" minOccurs=\"1\" maxOccurs=\"1\" type=\"CustomListSizeType\"> </xs:element> </xs:choice> <xs:choice minOccurs=\"0\" maxOccurs=\"1\"> <xs:element name=\"Skip\" minOccurs=\"1\" maxOccurs=\"1\" type=\"SkipType\"></xs:element> </xs:choice> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref =\"CustomListCode\" /> </xs:choice> </xs:sequence> <xs:attributeGroup ref=\"CommonAttributes\" /> <xs:attribute name=\"MaxItemsPerView\" type=\"MaxItemsPerViewType\" use=\"optional\"> </xs:attribute> </xs:complexType> <xs:complexType name=\"SkipType\"> <xs:annotation> <xs:documentation> Specifies logic to skip a specified number of items in the collection. The skip logic is invoked when the user scrolls in the watch window in order to quickly navigate the collection traversal down to the desired point. After the skip logic, control will return to be start of the execution, but with iteration variables modified as needed to reflect the updated state. The &lt;Skip&gt; element exist as an optional performance optimization to allow the collection traversal to skip through large numbers of items quickly. If a &lt;Skip&gt; element is not specified, the expression evaluator will run the traversal logic when it needs to do a skip until the desired number of &lt;Item&gt; elements have executed. Depending on the data structure of the underlying collection, this may involve a significant amount of unnecessary computation. </xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref=\"CustomListCode_NoItem\" /> </xs:choice> <xs:attribute name=\"Value\" type=\"CppIdType\" use=\"required\"> <xs:annotation> <xs:documentation> Name of the variable specifying the number of items to skip, as an unsigned 32-bit integer. If a &lt;Size&gt; element is specified, the expression evaluator will never pass in a skip value that would cause the current index of the traversal to exceed the bounds of the collection. If no &lt;Size&gt; element is specified, the skip value may be any arbitrary integer, and it is the responsibility of the &lt;Skip&gt; logic to do any bounds checking necessary. In the event that it is not possible to skip over the full number of items requested, the &lt;Skip&gt; logic should modify the value to the skip variable so that when execution completes, it contains the actual number of items skipped. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:complexType name=\"CustomListSizeType\"> <xs:annotation> <xs:documentation>Specifies the total number of items in the collection.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attribute name=\"Condition\" type=\"ConditionType\" use=\"optional\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:group name=\"CustomListCode_NoItem\"> <xs:choice> <!-- For the sake of simplifying implementation, I am not implementing declaring variables inside of an 'loop' block until I encounter a scenario that requires it.--> <!--<xs:element name=\"Variable\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"VariableType\"></xs:element>--> <xs:element name=\"Loop\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"LoopType_NoItem\"></xs:element> <xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:element name=\"If\" minOccurs=\"1\" maxOccurs=\"1\" type=\"IfType_NoItem\"></xs:element> <xs:element name=\"Elseif\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"IfType_NoItem\"></xs:element> <xs:element name=\"Else\" minOccurs=\"0\" maxOccurs=\"1\" type=\"ElseType_NoItem\"></xs:element> </xs:sequence> <xs:element name=\"Exec\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ExecType\"></xs:element> <xs:element name=\"Break\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"BreakType\"></xs:element> </xs:choice> </xs:group> <xs:group name=\"CustomListCode\"> <xs:choice> <!-- For the sake of simplifying implementation, I am not implementing declaring variables inside of an 'loop' block until I encounter a scenario that requires it.--> <!--<xs:element name=\"Variable\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"VariableType\"></xs:element>--> <xs:element name=\"Loop\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"LoopType\"></xs:element> <xs:sequence minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:element name=\"If\" minOccurs=\"1\" maxOccurs=\"1\" type=\"IfType\"></xs:element> <xs:element name=\"Elseif\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"IfType\"></xs:element> <xs:element name=\"Else\" minOccurs=\"0\" maxOccurs=\"1\" type=\"ElseType\"></xs:element> </xs:sequence> <xs:element name=\"Exec\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"ExecType\"></xs:element> <xs:element name=\"Break\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"BreakType\"></xs:element> <xs:element name=\"Item\" minOccurs=\"0\" maxOccurs=\"unbounded\" type=\"CustomListItemType\"></xs:element> </xs:choice> </xs:group> <xs:attributeGroup name=\"CustomListCode_Attributes\"> <xs:attribute name=\"Condition\" type=\"ConditionType\" use=\"optional\"> <xs:annotation> <xs:documentation>Condition controlling whether this element and inner elements should execute</xs:documentation> </xs:annotation> </xs:attribute> <xs:attributeGroup ref=\"CustomListCode_Attributes_NoCondition\" /> </xs:attributeGroup> <!-- Defines attributes that do on custom list code elements besides the condition. Currently, this is empty, but maintaining the group as a placeholder in case we decide to add something to it later. --> <xs:attributeGroup name=\"CustomListCode_Attributes_NoCondition\"> </xs:attributeGroup> <xs:complexType name=\"LoopType_NoItem\"> <xs:annotation> <xs:documentation>Specifies a block of instructions which will only execute multiple times until a &lt;Break&gt; element is encountered, or an expression fails to evaluate.</xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref=\"CustomListCode_NoItem\" /> </xs:choice> <xs:attributeGroup ref=\"CustomListCode_Attributes\" /> </xs:complexType> <xs:complexType name=\"LoopType\"> <xs:annotation> <xs:documentation>Specifies a block of instructions which will only execute multiple times until a &lt;Break&gt; element is encountered, or an expression fails to evaluate.</xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref=\"CustomListCode\" /> </xs:choice> <xs:attributeGroup ref=\"CustomListCode_Attributes\" /> </xs:complexType> <xs:complexType name=\"IfType_NoItem\"> <xs:annotation> <xs:documentation>Specifies a block of instructions which will only execute if a condition is true.</xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref=\"CustomListCode_NoItem\" /> </xs:choice> <xs:attributeGroup ref=\"CustomListCode_Attributes\" /> </xs:complexType> <xs:complexType name=\"IfType\"> <xs:annotation> <xs:documentation>Specifies a block of instructions which will only execute if a condition is true.</xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref=\"CustomListCode\" /> </xs:choice> <xs:attributeGroup ref=\"CustomListCode_Attributes\" /> </xs:complexType> <xs:complexType name=\"ElseType_NoItem\"> <xs:annotation> <xs:documentation>Specifies a block of instructions which will only execute if a condition is true.</xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref=\"CustomListCode_NoItem\" /> </xs:choice> <xs:attributeGroup ref=\"CustomListCode_Attributes_NoCondition\" /> </xs:complexType> <xs:complexType name=\"ElseType\"> <xs:annotation> <xs:documentation>Specifies a block of instructions which will only execute if a condition is true.</xs:documentation> </xs:annotation> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:group ref=\"CustomListCode\" /> </xs:choice> <xs:attributeGroup ref=\"CustomListCode_Attributes_NoCondition\" /> </xs:complexType> <xs:complexType name=\"VariableType\"> <xs:annotation> <xs:documentation> Declares a variable for use in future expressions with the &lt;CustomListItems&gt; block. </xs:documentation> </xs:annotation> <xs:attribute name=\"Name\" type=\"CppIdType\" use=\"required\"> <xs:annotation> <xs:documentation>Name of the variable.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"InitialValue\" type=\"StringType\" use=\"required\"> <xs:annotation> <xs:documentation> Expression evaluating to the initial value of the variable. This expression also specifies the type of the variable. Initial value expressions may make use of other variables already defined. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:complexType name=\"ExecType\"> <xs:annotation> <xs:documentation> Executes a single expression. The expression executes in the context of the object, but may use iteration variables. The expression may also modify iteration variables, but no other side effects are allowed. </xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attributeGroup ref=\"CustomListCode_Attributes\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"CustomListItemType\"> <xs:annotation> <xs:documentation>Generates a child item obtained by evaluating the given expression.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attributeGroup ref=\"CustomListCode_Attributes\" /> <xs:attribute name=\"Name\" type=\"xs:string\" use=\"optional\"> <xs:annotation> <xs:documentation> Specifies an optional name to use for the item. The name is provided in &lt;DisplayString&gt; syntax and may contain embedded expressions. If no name is provided a default name will be used in the form &quot;[i]&quot;, where 'i' is the index representing the order in which the item was returned. </xs:documentation> </xs:annotation> </xs:attribute> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"BreakType\"> <xs:annotation> <xs:documentation>Breaks out of the innermost &lt;Loop&gt; element. A &lt;Break&gt; element outside of a loop will terminate iteration of the collection.</xs:documentation> </xs:annotation> <xs:attributeGroup ref=\"CustomListCode_Attributes\" /> </xs:complexType> <xs:complexType name=\"SyntheticItemType\"> <xs:annotation> <xs:documentation>Specifies a child element whose value is not backed by an expression. The value of the item can be specified using a 'DisplayString' element. The children of the item can be specified using an 'Expand' element.</xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"CustomVisualizer\" type=\"CustomVisualizerType\" /> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DisplayString\" type=\"DisplayStringType\"/> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"StringView\" type=\"StringViewType\"/> <xs:element minOccurs=\"0\" name=\"Expand\" type=\"ExpandType\"/> </xs:sequence> <xs:attribute name=\"Name\" type=\"StringType\" use=\"required\"> <xs:annotation> <xs:documentation>Name of the child element as it will be shown under the name column in the debugger windows.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Expression\" type=\"StringType\" use=\"optional\"> <xs:annotation> <xs:documentation>Expression that will be used to retrieve the value of the item when the user wants to track it separately using 'Add watch' command on the item.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:complexType> <xs:complexType name=\"ValuePointerType\"> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attribute name=\"Condition\" type=\"ConditionType\" use=\"optional\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"SizeType\"> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"ArrayItemsType\"> <xs:annotation> <xs:documentation>Specifies an array view of the contents of a variable. It assumes data elements are contiguous in memory.</xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Direction\" type=\"ArrayDirectionType\" /> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Rank\" type=\"StringType\"> <xs:annotation> <xs:documentation>Specifies the rank of the array.</xs:documentation> </xs:annotation> </xs:element> <xs:element minOccurs=\"1\" maxOccurs=\"unbounded\" name=\"Size\" type=\"SizeType\"> <xs:annotation> <xs:documentation>Specifies the size of each dimension of the array. For multi-dimensional arrays, you can specify an expression that uses the implicit $i parameter. The parameter will be substituted with the dimension index to find the size of the array in that dimension.</xs:documentation> </xs:annotation> </xs:element> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"LowerBound\" type=\"StringType\"> <xs:annotation> <xs:documentation>Specifies the lower bound of each dimension of the array. For multi-dimensional arrays, you can specify an expression that uses the implicit $i parameter. The parameter will be substituted with the dimension index to find the lower bound of the array in that dimension.</xs:documentation> </xs:annotation> </xs:element> <xs:element minOccurs=\"1\" maxOccurs=\"unbounded\" name=\"ValuePointer\" type=\"ValuePointerType\"> <xs:annotation> <xs:documentation>Specifies the expression that points to the first element of the array. The expression must be a pointer of the element type that is not void*.</xs:documentation> </xs:annotation> </xs:element> </xs:sequence> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:complexType> <xs:complexType name=\"IndexListItemsType\"> <xs:annotation> <xs:documentation>Specifies a more generalized form of array view of a variable. Use when your data elements are not contiguous in memory and you need to compute index to the data elements.</xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"1\" maxOccurs=\"unbounded\" name=\"Size\" type=\"SizeType\"> <xs:annotation> <xs:documentation>Specifies the size of the index list.</xs:documentation> </xs:annotation> </xs:element> <xs:element minOccurs=\"1\" maxOccurs=\"unbounded\" name=\"ValueNode\" type=\"IndexNodeType\"> <xs:annotation> <xs:documentation>Specifies the expression that uses the implicit $i parameter that points to the ith element.</xs:documentation> </xs:annotation> </xs:element> </xs:sequence> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:complexType> <xs:complexType name=\"LinkedListItemsType\"> <xs:annotation> <xs:documentation>Specifies a linked list view of the contents of a variable.</xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Size\" type=\"SizeType\"> <xs:annotation> <xs:documentation>Specifies the number of elements in the linked list. If multiple size elements are specified, the first size element with a true condition (or no condition) will determine the size. If no size is specified (or all size elements have a false condition), the debugger will traverse the list to figure out the size. It is recommended that natvis entries specify a size for linked lists when possible, as providing a size will improve the performance of the debugger.</xs:documentation> </xs:annotation> </xs:element> <xs:element maxOccurs=\"1\" name=\"HeadPointer\" type=\"StringType\"> <xs:annotation> <xs:documentation>Expression that points to the first node of the linked list.</xs:documentation> </xs:annotation> </xs:element> <xs:element maxOccurs=\"1\" name=\"NextPointer\" type=\"StringType\"> <xs:annotation> <xs:documentation>Expression that points to the next element. This expression is evaluated under the context of the linked list node and not the parent linked list type.</xs:documentation> </xs:annotation> </xs:element> <xs:element maxOccurs=\"1\" name=\"ValueNode\" type=\"ListItemsNodeType\"> </xs:element> </xs:sequence> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:complexType> <xs:complexType name=\"TreeItemsType\"> <xs:annotation> <xs:documentation>Specifies a tree view of the contents of a variable.</xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Size\" type=\"StringType\"> <xs:annotation> <xs:documentation>The size of the tree.</xs:documentation> </xs:annotation> </xs:element> <xs:element maxOccurs=\"1\" name=\"HeadPointer\" type=\"StringType\"> <xs:annotation> <xs:documentation>Expression that points to the head of the tree.</xs:documentation> </xs:annotation> </xs:element> <xs:element maxOccurs=\"1\" name=\"LeftPointer\" type=\"StringType\"> <xs:annotation> <xs:documentation>Expression that points to the left child of a tree node. This expression is evaluated under the context of the tree node and not the parent type.</xs:documentation> </xs:annotation> </xs:element> <xs:element maxOccurs=\"1\" name=\"RightPointer\" type=\"StringType\"> <xs:annotation> <xs:documentation>Expression that points to the right child of a tree node. This expression is evaluated under the context of the tree node and not the parent type.</xs:documentation> </xs:annotation> </xs:element> <xs:element maxOccurs=\"1\" name=\"ValueNode\" type=\"TreeItemsNodeType\"> <xs:annotation> <xs:documentation>Expression that points to the value of the tree node. It can be left empty or have 'this' to refer to the tree node itself. This expression is evaluated under the context of the tree node and not the parent type.</xs:documentation> </xs:annotation> </xs:element> </xs:sequence> <xs:attributeGroup ref=\"CommonAttributes\" /> </xs:complexType> <xs:complexType name=\"UIVisualizerItemType\"> <xs:annotation> <xs:documentation>Specifies a UI visualizer which can handle objects of this type. The UI visualizer must be previously defined in the natvis file.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"ServiceId\" type=\"GuidType\" use=\"required\"> <xs:annotation> <xs:documentation>The service GUID of the visualizer.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Id\" type=\"xs:int\" use=\"required\"> <xs:annotation> <xs:documentation>Specifies the visualizer id. Use to differentiate multiple viewers provided by the visualizer service.</xs:documentation> </xs:annotation> </xs:attribute> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"MostDerivedObjectType\"> <xs:annotation> <xs:documentation> Specifies an expression which evaluates to the current object, casted to its most-derived type. In most cases, the debugger is able to automatically determine an object's most-derived type, in which case use of the &lt;MostDerivedType&gt; element is unnecessary. Automatic determination of an object's most-derived type requires the object to be an instance of a C++ class, with a compiler-generated virtual function table. This is sufficient for most class-hierarchies; however, custom logic may occasionally be necessary when dealing with a class hierarchy that does not contain virtual functions, or when the virtual function table is manually constructed by the application code. </xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attributeGroup ref=\"CommonAttributes\" /> <xs:attribute name=\"IgnoreVTable\" type=\"xs:boolean\" use=\"optional\"> <xs:annotation> <xs:documentation> If true, indicates that the most derived type of the object will always be the static type of the provided expression. By default, the debugger will use vtables to calculate the most-derived type of the provided most-derived-type expressions. This option should be used only when the application code builds vtables using custom logic that the debugger does not understand. </xs:documentation> </xs:annotation> </xs:attribute> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:simpleType name=\"SmartPointerUsage\"> <xs:annotation> <xs:documentation>Specifies how a smart pointer may be used syntactically.</xs:documentation> </xs:annotation> <xs:restriction base=\"xs:normalizedString\"> <xs:enumeration value=\"Minimal\"> <xs:annotation> <xs:documentation> Indicates that the smart pointer may be used syntactically only for the purposes of dereferencing and comparing. It defines the following overloaded operators: - operator*() (dereference) - operator->() (access field of dereferenced value) - operator==() (compare with raw pointer or another smart pointer of the same type) - operator!=() (compare with raw pointer or another smart pointer of the same type) </xs:documentation> </xs:annotation> </xs:enumeration> <xs:enumeration value=\"Indexable\"> <xs:annotation> <xs:documentation> Indicates that the smart pointer may be used syntactically for the purposes of dereferencing and comparing, and indexing It defines the following overloaded operators: - operator+() (add an offset of type size_t) - operator-() (subtract an offset of type size_t) - operator[] (add an offset of type size_t and dereference) - All of the operators supported by SmartPointerUsage=&quot;Minimal&quot; </xs:documentation> </xs:annotation> </xs:enumeration> <xs:enumeration value=\"Full\"> <xs:annotation> <xs:documentation> Indicates that the smart pointer will contain a conversion operator to the underlying pointer. All valid uses of the underlying pointer in the language may be used through the conversion operator. Direct assignment to the smart pointer is still forbidden; in order to modify the internal pointer in an expression, you must do so explicitly. </xs:documentation> </xs:annotation> </xs:enumeration> </xs:restriction> </xs:simpleType> <xs:complexType name=\"SmartPointerType\"> <xs:annotation> <xs:documentation> Indicates that the given type is a smart pointer. The text inside this element specifies the expression to evaluate the underlying pointer. The &lt;SmartPointer&gt; element has the following effects: - If no alternative &lt;DisplayString&gt; element is provided (or all &lt;DisplayString&gt; elements have failed conditions), the underlying pointer will be the display string - If no alternative &lt;StringView&gt; element is provided (or all &lt;StringView&gt; elements have failed conditions), the underlying pointer will be the string view, if it has one. - If no alternative &lt;Expand&gt; element is provided, the expansion of the smart pointer will be the expansion of the underlying pointer. - The smart pointer class will also support overloaded operators as determined by the &lt;Usage&gt; attribute. You can opt out of this behavior by specifying 'DefaultExpansion=&quot;false&quot;' </xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"StringType\"> <xs:attributeGroup ref=\"CommonAttributes_NoCondition\" /> <xs:attribute name=\"Usage\" type=\"SmartPointerUsage\" use=\"required\"> <xs:annotation> <xs:documentation>Indicates which combinations of operators this smart pointer object supports. </xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"DefaultExpansion\" type=\"xs:boolean\" use=\"optional\"> <xs:annotation> <xs:documentation> If true and no expand element is provided, a default expansion will be supplied based on the expansion of the underyling pointer. If false, no &lt;Expand&gt; element will be automatically created based on the smart pointer. If this attribute is not present, the default value is 'true'. </xs:documentation> </xs:annotation> </xs:attribute> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"VisualizerType\"> <xs:annotation> <xs:documentation>Specifies a visualizer entry which customizes the debugger view of a type.</xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"AlternativeType\" type=\"AlternativeTypeType\"/> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Version\" type=\"VersionType\" /> <xs:choice minOccurs=\"0\" maxOccurs=\"1\"> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Intrinsic\" type=\"IntrinsicType\" /> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"MostDerivedType\" type=\"MostDerivedObjectType\" /> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"CustomVisualizer\" type=\"CustomVisualizerType\" /> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"SmartPointer\" type=\"SmartPointerType\" /> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"DisplayString\" type=\"DisplayStringType\"/> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"StringView\" type=\"StringViewType\"/> <xs:element minOccurs=\"0\" name=\"Expand\" type=\"ExpandType\"/> </xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"UIVisualizer\" type=\"UIVisualizerItemType\"/> </xs:choice> </xs:sequence> <xs:attribute name=\"Name\" type=\"TypeNameType\" use=\"required\" /> <xs:attributeGroup ref=\"ViewConstraints\" /> <xs:attribute name=\"Priority\" type=\"PriorityType\" /> <xs:attribute name=\"Inheritable\" type=\"xs:boolean\" use=\"optional\"> <xs:annotation> <xs:documentation> True if this visualizer may be used by objects of classes derived from the given type, false if an object must be directly of this type for the visualizer to take effect. Default is true. </xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:simpleType name=\"PriorityType\"> <xs:annotation> <xs:documentation>Specifies an optional priority to assign to this entry for type matching. Higher priority entries within a particular file or directory are checked first. &lt;Type&gt; entries that do not specify a priority receive default priority of &quot;Medium&quot; &lt;AlternativeType&gt; entries which do not specify a priority will inherit the priority of the enclosing &lt;Type&gt; element. The priority is only used to disambiguate type matching when all other means of disambiguation are unavailable. For example, entries with more specific template instantiations, module constraints, or view constraints will take priority regardless of any priority values specified. Similarly, regardless of priority, natvis files that are part of a loaded project will always take precedence over files in the user natvis directory, which will, in turn, take precedence over files in the system-wide natvis directory. If two entries have the same priority and cannot otherwise be disambiguated, it is unspecified which one will get used. </xs:documentation> </xs:annotation> <xs:union> <xs:simpleType> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"Low\" /> <xs:enumeration value=\"MediumLow\" /> <xs:enumeration value=\"Medium\" /> <xs:enumeration value=\"MediumHigh\" /> <xs:enumeration value=\"High\" /> </xs:restriction> </xs:simpleType> </xs:union> </xs:simpleType> <xs:complexType name=\"UIVisualizerType\"> <xs:annotation> <xs:documentation>Specifies details of a UI visualizer which creates its own interface to display an object. Visualizer entry for a type needs to reference a UI visualizer in order to associate the type with the UI visualizer.</xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"ServiceId\" type=\"GuidType\" use=\"required\"> <xs:annotation> <xs:documentation>Specifies the visualizer service GUID. The service must be provided by a Visual Studio package that also implements IVsCppDebugUIVisualizer interface. The debugger will load the package only when user requests this visualization service.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Id\" type=\"xs:int\" use=\"required\"> <xs:annotation> <xs:documentation>Specifies the visualizer id. Use to differentiate multiple viewers provided by this visualizer service.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"MenuName\" type=\"xs:string\" use=\"required\"> <xs:annotation> <xs:documentation>Specifies the name which will be shown in the UI visualizer list for a variable.</xs:documentation> </xs:annotation> </xs:attribute> <xs:attribute name=\"Description\" type=\"xs:string\" use=\"optional\"> <xs:annotation> <xs:documentation>Specifies the description for this UI visualizer.</xs:documentation> </xs:annotation> </xs:attribute> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"HResultType\"> <xs:annotation> <xs:documentation>Specifies a visualizer entry which customizes the debugger view of an HRESULT.</xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"AlternativeHResult\" type=\"AlternativeHResultType\"> <xs:annotation> <xs:documentation>Other HResult types that will share the same visualizer.</xs:documentation> </xs:annotation> </xs:element> <xs:element minOccurs=\"1\" maxOccurs=\"1\" name=\"HRValue\" type=\"StringType\"> <xs:annotation> <xs:documentation>32 bit HRESULT value to be customized.</xs:documentation> </xs:annotation> </xs:element> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"HRDescription\" type=\"StringType\"> <xs:annotation> <xs:documentation>The description for this HRESULT value to be shown in the debugger windows.</xs:documentation> </xs:annotation> </xs:element> </xs:sequence> <xs:attribute name=\"Name\" type=\"StringType\" use=\"required\"> <xs:annotation> <xs:documentation>The name of the HRESULT value to be shown in the debugger windows.</xs:documentation> </xs:annotation> </xs:attribute> </xs:complexType> <xs:complexType name=\"LocalizedStringType\"> <xs:annotation> <xs:documentation> Defines a localized string resource that can be referenced by natvis elements that accept strings (.g.e.g. DisplayString, Name attribute of Item element). Use @&lt;id&gt;; format to reference a localized string (e.g. @1001;) </xs:documentation> </xs:annotation> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"Id\" use=\"required\"> <xs:annotation> <xs:documentation>The id of the localized string. Use @&lt;id&gt;; format to reference this localized string.</xs:documentation> </xs:annotation> <xs:simpleType> <xs:restriction base=\"xs:unsignedInt\"> <xs:minInclusive value=\"1\"/> </xs:restriction> </xs:simpleType> </xs:attribute> </xs:extension> </xs:simpleContent> </xs:complexType> <xs:complexType name=\"LocalizedStringsType\"> <xs:annotation> <xs:documentation> Specifies a list of localized strings that can be referenced by natvis elements. Define localized strings in a satellite natvis file with the same name as the main file and deploy it into a locale specific folder next to the main natvis file. Debugger will load localized resources from the appropriate satellite file. Define localized strings in the main natvis file to serve as defaults when there is no satellite file for a locale. </xs:documentation> </xs:annotation> <xs:sequence> <xs:element minOccurs=\"1\" maxOccurs=\"unbounded\" name=\"LocalizedString\" type=\"LocalizedStringType\"/> </xs:sequence> </xs:complexType> <!-- Definition of complex elements--> <xs:element name=\"AutoVisualizer\"> <xs:annotation> <xs:documentation>Root element of the natvis file.</xs:documentation> </xs:annotation> <xs:complexType> <xs:sequence> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"Version\" type=\"VersionType\"> <xs:annotation> <xs:documentation>Specifies a matching module name and version for all visualizers which do not explicitly specify a module name and version in this file.</xs:documentation> </xs:annotation> </xs:element> <xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"LocalizedStrings\" type=\"LocalizedStringsType\"/> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"UIVisualizer\" type=\"UIVisualizerType\"/> <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Type\" type=\"VisualizerType\" /> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"HResult\" type=\"HResultType\"/> <xs:element minOccurs=\"0\" maxOccurs=\"unbounded\" name=\"Intrinsic\" type=\"IntrinsicType\" /> </xs:choice> </xs:sequence> </xs:complexType> </xs:element> </xs:schema>"
  },
  "guides/vscode/cpp/pipe-transport.html": {
    "href": "guides/vscode/cpp/pipe-transport.html",
    "title": "Pipe transport | Fountain of Knowledge",
    "keywords": "Pipe transport Pipe transport allows communication through a pipe program to a remote shell. For example, ssh on Linux. With the introduction of Visual Studio Code Remote Development pipe transport is relevant primarily for IoT scenarios. How-To pipeTransport is an option within the launch.json file. The structure looks as follows: \"pipeTransport\": { \"pipeCwd\": \"/usr/bin\", \"pipeProgram\": \"/usr/bin/ssh\", \"pipeArgs\": [ \"-pw\", \"<password>\", \"user@10.10.10.10\" ], \"debuggerPath\": \"/usr/bin/gdb\" }, The pipeArgs can be any set of arguments necessary to set up and authenticate the pipe connection. In the example, a password is used but you can also use an ssh key. You may also need to add a sourceFileMap to map the path of where the code exists on the remote shell to where it is locally: \"sourceFileMap\": { // \"remote\": \"local\" \"/home/user/src\": \"/src/projectA/src\" } Attach You can also use the above pipeTransport block to attach to a remote process. In the attach case, you need to specify a processId . The extension can query processes from the remote machine. To do this, change processId\": \"${command:pickProcess} to processId\": \"${command:pickRemoteProcess} . The pipeTransport settings will be used to query the processes on the remote machine. Then select the process from the dropdown list. As with launch , you may need to configure sourceFileMap . Docker example The pipeTransport can also be used to debug a process in a Docker container. For an attach, launch.json will include: \"pipeTransport\": { \"pipeCwd\": \"${workspaceFolder}\", \"pipeProgram\": \"docker\", \"pipeArgs\": [ \"exec\", \"-i\", \"hello_gdb\", \"sh\", \"-c\" ], \"debuggerPath\": \"/usr/bin/gdb\" }, Where hello_gdb is the name of your container. Launch process by starting a container and then using the same pipeTransport to launch additional processes in the container. See this launch.json for a full example ."
  },
  "guides/vscode/customization/keyboard-shortcuts.html": {
    "href": "guides/vscode/customization/keyboard-shortcuts.html",
    "title": "General | Fountain of Knowledge",
    "keywords": "General Key Command kb(workbench.action.showCommands) , kbstyle(F1) Show Command Palette kb(workbench.action.quickOpen) Quick Open kb(workbench.action.newWindow) New window/instance kb(workbench.action.closeWindow) Close window/instance Basic Editing Key Command kb(editor.action.clipboardCutAction) Cut line (empty selection) kb(editor.action.clipboardCopyAction) Copy line (empty selection) kb(editor.action.movelinesdownAction) Move line down kb(editor.action.movelinesupAction) Move line up kb(editor.action.copylinesdownAction) Copy line down kb(editor.action.copylinesupAction) Copy line up kb(editor.action.deletelines) Delete line kb(editor.action.insertlineAfter) Insert line below kb(editor.action.insertlineBefore) Insert line above kb(editor.action.jumpToBracket) Jump to matching bracket kb(editor.action.indentlines) Indent line kb(editor.action.outdentlines) Outdent line kb(cursorHome) Go to beginning of line kb(cursorend) Go to end of line kb(cursorTop) Go to beginning of file kb(cursorBottom) Go to end of file kb(scrolllineup) Scroll line up kb(scrolllinedown) Scroll line down kb(scrollPageup) Scroll page up kb(scrollPagedown) Scroll page down kb(editor.fold) Fold (collapse) region kb(editor.unfold) Unfold (uncollapse) region kb(editor.foldRecursively) Fold (collapse) all subregions kb(editor.unfoldRecursively) Unfold (uncollapse) all subregions kb(editor.foldAll) Fold (collapse) all regions kb(editor.unfoldAll) Unfold (uncollapse) all regions kb(editor.action.addcommentline) Add line comment kb(editor.action.removecommentline) Remove line comment kb(editor.action.commentline) Toggle line comment kb(editor.action.blockcomment) Toggle block comment kb(editor.action.toggleWordWrap) Toggle word wrap Search and Replace Key Command kb(actions.find) Find kb(editor.action.startFindReplaceAction) Replace kb(editor.action.nextMatchFindAction) Find next kb(editor.action.previousMatchFindAction) Find previous kb(editor.action.selectAllMatches) Select all occurrences of Find match kb(editor.action.addSelectionTonextFindMatch) Add selection to next Find match kb(editor.action.moveSelectionTonextFindMatch) Move last selection to next Find match kb(toggleFindCaseSensitive) Toggle Find case sensitive kb(toggleFindRegex) Toggle Find regex kb(toggleFindWholeWord) Toggle Find whole word Multi-cursor and Selection Key Command kbstyle(Alt+Click) Insert cursor kb(editor.action.insertCursorabove) Insert cursor above kb(editor.action.insertCursorbelow) Insert cursor below kb(cursorUndo) Undo last cursor operation kb(editor.action.insertCursorAtendOfEachlineSelected) Insert cursor at end of each line selected kb(expandlineSelection) Select current line kb(editor.action.selectHighlights) Select all occurrences of current selection kb(editor.action.changeAll) Select all occurrences of current word kb(editor.action.smartSelect.expand) Expand selection kb(editor.action.smartSelect.shrink) Shrink selection kbstyle(Shift+Alt) + drag mouse Column selection kb(cursorColumnSelectup) Column selection up kb(cursorColumnSelectdown) Column selection down kb(cursorColumnSelectLeft) Column selection left kb(cursorColumnSelectRight) Column selection right kb(cursorColumnSelectPageup) Column selection page up kb(cursorColumnSelectPagedown) Column selection page down Rich Languages Editing Key Command kb(editor.action.triggerSuggest) Trigger suggestion kb(editor.action.triggerParameterHints) Trigger parameter hints kb(editor.action.formatDocument) Format document kb(editor.action.formatSelection) Format selection kb(editor.action.revealDefinition) Go to Definition kb(editor.action.peekDefinition) Peek Definition kb(editor.action.revealDefinitionAside) Open Definition to the side kb(editor.action.quickFix) Quick Fix kb(editor.action.goToReferences) Go to References kb(editor.action.rename) Rename Symbol kb(editor.action.inPlaceReplace.down) Replace with next value kb(editor.action.inPlaceReplace.up) Replace with previous value kb(editor.action.trimTrailingWhitespace) Trim trailing whitespace kb(workbench.action.editor.changeLanguageMode) Change file language Navigation Key Command kb(workbench.action.showAllSymbols) Show all Symbols kb(workbench.action.gotoline) Go to Line... kb(workbench.action.quickOpen) Go to File... kb(workbench.action.gotoSymbol) Go to Symbol... kb(workbench.actions.view.problems) Show Problems panel kb(editor.action.marker.nextInFiles) Go to next error or warning kb(editor.action.marker.prevInFiles) Go to previous error or warning kb(workbench.action.openpreviousRecentlyUsedEditorInGroup) Navigate editor group history kb(workbench.action.navigateBack) Go back kb(workbench.action.quickInputBack) Go back to previous step, when in the QuickInput UI kb(workbench.action.navigateForward) Go forward kb(editor.action.toggleTabFocusMode) Toggle Tab moves focus Editor Management Key Command kb(workbench.action.closeActiveEditor) , kbstyle(Ctrl+W) Close editor kb(workbench.action.closeFolder) Close folder kb(workbench.action.splitEditor) Split editor kb(workbench.action.focusFirstEditorGroup) Focus into first editor group kb(workbench.action.focusSecondEditorGroup) Focus into second editor group kb(workbench.action.focusThirdEditorGroup) Focus into third editor group kb(workbench.action.moveEditorLeftInGroup) Move editor left kb(workbench.action.moveEditorRightInGroup) Move editor right kb(workbench.action.moveActiveEditorGroupLeft) Move active editor group left/up kb(workbench.action.moveActiveEditorGroupRight) Move active editor group right/down File Management Key Command kb(workbench.action.files.newUntitledfile) New File kb(workbench.action.files.openfile) Open File... kb(workbench.action.files.openFileFolder) Open File... (macOS) kb(workbench.action.files.save) Save kb(workbench.action.files.saveAs) Save As... kb(saveAll) Save All kb(workbench.action.closeActiveEditor) Close kb(workbench.action.closeAllEditors) Close All kb(workbench.action.reopenClosedEditor) Reopen closed editor kb(workbench.action.keepEditor) Keep Open kb(workbench.action.opennextRecentlyUsedEditorInGroup) Open next kb(workbench.action.openpreviousRecentlyUsedEditorInGroup) Open previous kb(workbench.action.files.copyPathOfActivefile) Copy path of active file kb(workbench.action.files.revealActivefileInWindows) Reveal active file in Explorer kb(workbench.action.files.showOpenedfileInNewWindow) Show active file in new window/instance Display Key Command kb(workbench.action.toggleFullScreen) Toggle full screen kb(workbench.action.toggleEditorGroupLayout) Toggle editor layout kb(workbench.action.zoomIn) Zoom in kb(workbench.action.zoomOut) Zoom out kb(workbench.action.toggleSidebarVisibility) Toggle Sidebar visibility kb(workbench.view.explorer) Show Explorer / Toggle focus kb(workbench.view.search) Show Search kb(workbench.view.scm) Show Source Control kb(workbench.view.debug) Show Run kb(workbench.view.extensions) Show Extensions kb(workbench.action.replaceInfiles) Replace in files kb(workbench.action.search.toggleQueryDetails) Toggle Search details kb(workbench.action.terminal.openNativeConsole) Open new command prompt/terminal kb(workbench.action.output.toggleOutput) Show Output panel kb(markdown.showPreview) Toggle Markdown preview kb(markdown.showPreviewToSide) Open Markdown preview to the side Debug Key Command kb(editor.debug.action.toggleBreakpoint) Toggle breakpoint kb(workbench.action.debug.start) Start kb(workbench.action.debug.continue) Continue kb(workbench.action.debug.stepInto) Step into kb(workbench.action.debug.stepOut) Step out kb(workbench.action.debug.stepOver) Step over kb(workbench.action.debug.stop) Stop kb(editor.action.showHover) Show hover Integrated Terminal Key Command kb(workbench.action.terminal.toggleTerminal) Show integrated terminal kb(workbench.action.terminal.new) Create new terminal kb(workbench.action.terminal.copySelection) Copy selection kb(workbench.action.terminal.paste) Paste into active terminal kb(workbench.action.terminal.scrollup) Scroll up kb(workbench.action.terminal.scrolldown) Scroll down kb(workbench.action.terminal.scrollupPage) Scroll page up kb(workbench.action.terminal.scrolldownPage) Scroll page down kb(workbench.action.terminal.scrollToTop) Scroll to top kb(workbench.action.terminal.scrollToBottom) Scroll to bottom"
  },
  "guides/vscode/datascience/data-science-tutorial.html": {
    "href": "guides/vscode/datascience/data-science-tutorial.html",
    "title": "Data Science in VS Code tutorial | Fountain of Knowledge",
    "keywords": "Data Science in VS Code tutorial This tutorial demonstrates using Visual Studio Code and the Microsoft Python extension with common data science libraries to explore a basic data science scenario. Specifically, using passenger data from the Titanic, you will learn how to set up a data science environment, import and clean data, create a machine learning model for predicting survival on the Titanic, and evaluate the accuracy of the generated model. Prerequisites The following installations are required for the completion of the tutorial. If you do not have them already, install them prior to beginning. Visual Studio Code The Python extension for VS Code and Jupyter extension for VS Code from the Visual Studio Marketplace. Note that by default, the Python extension installs the Jupyter extension for you. For additional details on installing extensions, see Extension Marketplace . Both extensions are published by Microsoft. Miniconda with Python 3.7 Note : If you already have the full Anaconda distribution installed, you don't need to install Miniconda. Alternatively, if you'd prefer not to use Anaconda or Miniconda, you can create a Python virtual environment and install the packages needed for the tutorial using pip. If you go this route, you will need to install the following packages: pandas, jupyter, seaborn, scikit-learn, keras, and tensorflow. Set up a data science environment Visual Studio Code and the Python extension provide a great editor for data science scenarios. With native support for Jupyter notebooks combined with Anaconda, it's easy to get started. In this section, you will create a workspace for the tutorial, create an Anaconda environment with the data science modules needed for the tutorial, and create a Jupyter notebook that you'll use for creating a machine learning model. Begin by creating an Anaconda environment for the data science tutorial. Open an Anaconda command prompt and run conda create -n myenv python=3.7 pandas jupyter seaborn scikit-learn keras tensorflow to create an environment named myenv . For additional information about creating and managing Anaconda environments, see the Anaconda documentation . Next, create a folder in a convenient location to serve as your VS Code workspace for the tutorial, name it hello_ds . Open the project folder in VS Code by running VS Code and using the File > Open Folder command. Note that you can safely trust opening the folder, since you created it. Once VS Code launches, create the Jupyter notebook that will be used for the tutorial. Open the Command Palette ( kb(workbench.action.showCommands) ) and select Jupyter: Create New Blank Jupyter Notebook . Note : Alternatively, from the VS Code File Explorer, you can use the New File icon to create a Notebook file named hello.ipynb . Save the file as hello.ipynb using File > Save As... . After your file is created, you should see the open Jupyter notebook in the notebook editor. For additional information about native Jupyter notebook support, you can read the Jupyter Notebooks topic. Now select Select Kernel at the top right of the notebook. Choose the Python environment you created above in which to run your kernel. Prepare the data This tutorial uses the Titanic dataset available on OpenML.org , which is obtained from Vanderbilt University's Department of Biostatistics at https://hbiostat.org/data . The Titanic data provides information about the survival of passengers on the Titanic, as well as characteristics about the passengers such as age and ticket class. Using this data, the tutorial will establish a model for predicting whether a given passenger would have survived the sinking of the Titanic. This section shows how to load and manipulate data in your Jupyter notebook. To begin, download the Titanic data from OpenML.org as a CSV file (download links in the upper right) named data.csv and save it to the hello_ds folder that you created in the previous section. If you haven't already opened the file in VS Code, open the hello_ds folder and the Jupyter notebook ( hello.ipynb ), by going to File > Open Folder . Within your Jupyter notebook, begin by importing the pandas and numpy libraries, two common libraries used for manipulating data, and loading the Titanic data into a pandas DataFrame . To do so, copy the code below into the first cell of the notebook. For additional guidance about working with Jupyter notebooks in VS Code, see the Working with Jupyter Notebooks documentation. import pandas as pd import numpy as np data = pd.read_csv('data.csv') Now, run the cell using the Run cell icon or the kbstyle(Shift+Enter) shortcut. After the cell finishes running, you can view the data that was loaded using the Variables Explorer and Data Viewer. First select the Variables icon in the notebook's upper toolbar. A JUPYTER: VARIABLES pane will open at the bottom of VS Code. It contains a list of the variables defined so far in your running kernel. To view the data in the Pandas DataFrame just loaded, select the Data Viewer icon to the left of the data variable. Use the Data Viewer to view, sort, and filter the rows of data. After reviewing the data, it can then be helpful to graph some aspects of it to help visualize the relationships between the different variables. Before the data can be graphed, you need to make sure that there aren't any issues with it. If you look at the Titanic csv file, one thing you'll notice is that a question mark (\"?\") was used to designate cells where data wasn't available. While Pandas can read this value into a DataFrame, the result for a column like Age is that its data type will be set to Object instead of a numeric data type, which is problematic for graphing. This problem can be corrected by replacing the question mark with a missing value that pandas is able to understand. Add the following code to the next cell in your notebook to replace the question marks in the age and fare columns with the numpy NaN value. Notice that we also need to update the column's data type after replacing the values. Tip : To add a new cell you can use the insert cell icon that's in the bottom left corner of an existing cell. Alternatively, you can also use the kbstyle(Esc) to enter command mode, followed by the kbstyle(B) key. data.replace('?', np.nan, inplace= True) data = data.astype({\"age\": np.float64, \"fare\": np.float64}) Note : If you ever need to see the data type that has been used for a column, you can use the DataFrame dtypes attribute. Now that the data is in good shape, you can use seaborn and matplotlib to view how certain columns of the dataset relate to survivability. Add the following code to the next cell in your notebook and run it to see the generated plots. import seaborn as sns import matplotlib.pyplot as plt fig, axs = plt.subplots(ncols=5, figsize=(30,5)) sns.violinplot(x=\"survived\", y=\"age\", hue=\"sex\", data=data, ax=axs[0]) sns.pointplot(x=\"sibsp\", y=\"survived\", hue=\"sex\", data=data, ax=axs[1]) sns.pointplot(x=\"parch\", y=\"survived\", hue=\"sex\", data=data, ax=axs[2]) sns.pointplot(x=\"pclass\", y=\"survived\", hue=\"sex\", data=data, ax=axs[3]) sns.violinplot(x=\"survived\", y=\"fare\", hue=\"sex\", data=data, ax=axs[4]) To better view details on the graphs, you can open them in the plot viewer by hovering over the upper right corner of the graph and clicking the button that appears. These graphs are helpful in seeing some of the relationships between survival and the input variables of the data, but it's also possible to use pandas to calculate correlations. To do so, all the variables used need to be numeric for the correlation calculation and currently gender is stored as a string. To convert those string values to integers, add and run the following code. data.replace({'male': 1, 'female': 0}, inplace=True) Now, you can analyze the correlation between all the input variables to identify the features that would be the best inputs to a machine learning model. The closer a value is to 1, the higher the correlation between the value and the result. Use the following code to correlate the relationship between all variables and survival. data.corr().abs()[[\"survived\"]] Looking at the correlation results, you'll notice that some variables like gender have a fairly high correlation to survival, while others like relatives (sibsp = siblings or spouse, parch = parents or children) seem to have little correlation. Let's hypothesize that sibsp and parch are related in how they affect survivability, and group them into a new column called \"relatives\" to see whether the combination of them has a higher correlation to survivability. To do this, you will check if for a given passenger, the number of sibsp and parch is greater than 0 and, if so, you can then say that they had a relative on board. Use the following code to create a new variable and column in the dataset called relatives and check the correlation again. data['relatives'] = data.apply (lambda row: int((row['sibsp'] + row['parch']) > 0), axis=1) data.corr().abs()[[\"survived\"]] You'll notice that in fact when looked at from the standpoint of whether a person had relatives, versus how many relatives, there is a higher correlation with survival. With this information in hand, you can now drop from the dataset the low value sibsp and parch columns, as well as any rows that had NaN values, to end up with a dataset that can be used for training a model. data = data[['sex', 'pclass','age','relatives','fare','survived']].dropna() Note : Although age had a low direct correlation, it was kept because it seems reasonable that it might still have correlation in conjunction with other inputs. Train and evaluate a model With the dataset ready, you can now begin creating a model. For this section you'll use the scikit-learn library (as it offers some useful helper functions) to do pre-processing of the dataset, train a classification model to determine survivability on the Titanic, and then use that model with test data to determine its accuracy. A common first step to training a model is to divide up the dataset into training and validation data. This allows you to use a portion of the data to train the model and a portion of the data to test the model. If you used all your data to train the model, you wouldn't have a way to estimate how well it would actually perform against data the model has not yet seen. A benefit of the scikit-learn library is that it provides a method specifically for splitting a dataset into training and test data. Add and run a cell with the following code to the notebook to split up the data. from sklearn.model_selection import train_test_split x_train, x_test, y_train, y_test = train_test_split(data[['sex','pclass','age','relatives','fare']], data.survived, test_size=0.2, random_state=0) Next, you'll normalize the inputs such that all features are treated equally. For example, within the dataset the values for age range from ~0-100, while gender is only a 1 or 0. By normalizing all the variables, you can ensure that the ranges of values are all the same. Use the following code in a new code cell to scale the input values. from sklearn.preprocessing import StandardScaler sc = StandardScaler() X_train = sc.fit_transform(x_train) X_test = sc.transform(x_test) There are a number of different machine learning algorithms that you could choose from to model the data and scikit-learn provides support for a number of them , as well as a chart to help select the one that's right for your scenario. For now, use the Naïve Bayes algorithm , a common algorithm for classification problems. Add a cell with the following code to create and train the algorithm. from sklearn.naive_bayes import GaussianNB model = GaussianNB() model.fit(X_train, y_train) With a trained model, you can now try it against the test data set that was held back from training. Add and run the following code to predict the outcome of the test data and calculate the accuracy of the model. from sklearn import metrics predict_test = model.predict(X_test) print(metrics.accuracy_score(y_test, predict_test)) Looking at the result of the test data, you'll see that the trained algorithm had a ~75% success rate at estimating survival. (Optional) Use a neural network to increase accuracy A neural network is a model that uses weights and activation functions, modeling aspects of human neurons, to determine an outcome based on provided inputs. Unlike the machine learning algorithm you looked at previously, neural networks are a form of deep learning wherein you don't need to know an ideal algorithm for your problem set ahead of time. It can be used for many different scenarios and classification is one of them. For this section, you'll use the Keras library with TensorFlow to construct the neural network, and explore how it handles the Titanic dataset. The first step is to import the required libraries and to create the model. In this case, you'll use a Sequential neural network, which is a layered neural network wherein there are multiple layers that feed into each other in sequence. from keras.models import Sequential from keras.layers import Dense model = Sequential() After defining the model, the next step is to add the layers of the neural network. For now, let's keep things simple and just use three layers. Add the following code to create the layers of the neural network. model.add(Dense(5, kernel_initializer = 'uniform', activation = 'relu', input_dim = 5)) model.add(Dense(5, kernel_initializer = 'uniform', activation = 'relu')) model.add(Dense(1, kernel_initializer = 'uniform', activation = 'sigmoid')) The first layer will be set to have a dimension of 5, since you have 5 inputs: sex, pclass, age, relatives, and fare. The last layer must output 1, since you want a 1-dimensional output indicating whether a passenger would survive. The middle layer was kept at 5 for simplicity, although that value could have been different. The rectified linear unit (relu) activation function is used as a good general activation function for the first two layers, while the sigmoid activation function is required for the final layer as the output you want (of whether a passenger survives or not) needs to be scaled in the range of 0-1 (the probability of a passenger surviving). You can also look at the summary of the model you built with this line of code: model.summary() Once the model is created, it needs to be compiled. As part of this, you need to define what type of optimizer will be used, how loss will be calculated, and what metric should be optimized for. Add the following code to build and train the model. You'll notice that after training the accuracy is ~80%. Note : This step may take anywhere from a few seconds to a few minutes to run depending on your machine. model.compile(optimizer=\"adam\", loss='binary_crossentropy', metrics=['accuracy']) model.fit(X_train, y_train, batch_size=32, epochs=50) With the model built and trained its now time to see how it performs against the test data. y_pred = model.predict_classes(X_test) print(metrics.accuracy_score(y_test, y_pred)) Similar to the training, you'll notice that you were able to get close to 80% accuracy in predicting survival of passengers. This result was better than the 75% accuracy from the Naive Bayes Classifier tried previously. Next steps Now that you're familiar with the basics of performing machine learning within Visual Studio Code, here are some other Microsoft resources and tutorials to check out. Learn more about working with Jupyter Notebooks in Visual Studio Code (video). Get started with Azure Machine Learning for VS Code to deploy and optimize your model using the power of Azure. Find additional data to explore on Azure Open Data Sets ."
  },
  "guides/vscode/datascience/jupyter-notebooks.html": {
    "href": "guides/vscode/datascience/jupyter-notebooks.html",
    "title": "Jupyter Notebooks in VS Code | Fountain of Knowledge",
    "keywords": "Jupyter Notebooks in VS Code Jupyter (formerly IPython Notebook) is an open-source project that lets you easily combine Markdown text and executable Python source code on one canvas called a notebook . Visual Studio Code supports working with Jupyter Notebooks natively, and through Python code files . This topic covers the native support available for Jupyter Notebooks and demonstrates how to: Create, open, and save Jupyter Notebooks Work with Jupyter code cells View, inspect, and filter variables using the Variable Explorer and Data Viewer Connect to a remote Jupyter server Debug a Jupyter Notebook Setting up your environment To work with Python in Jupyter Notebooks, you must activate an Anaconda environment in VS Code, or another Python environment in which you've installed the Jupyter package . To select an environment, use the Python: Select Interpreter command from the Command Palette ( kb(workbench.action.showCommands) ). Once the appropriate environment is activated, you can create and open a Jupyter Notebook, connect to a remote Jupyter server for running code cells, and export a Jupyter Notebook as a Python file. Workspace Trust When getting started with Notebooks, you'll want to make sure that you are working in a trusted workspace. Harmful code can be embedded in notebooks and the Workspace Trust feature allows you to indicate which folders and their contents should allow or restrict automatic code execution. If you attempt to open a notebook when VS Code is in an untrusted workspace running Restricted Mode , you will not be able to execute cells and rich outputs will be hidden. Create or open a Jupyter Notebook You can create a Jupyter Notebook by running the Jupyter: Create Blank New Jupyter Notebook command from the Command Palette ( kb(workbench.action.showCommands) ) or by creating a new .ipynb file in your workspace. Next, select a kernel using the kernel picker in the top right. After selecting a kernel, the language picker located in the bottom right of each code cell will automatically update to the language supported by the kernel. If you have an existing Jupyter Notebook, you can open it by right-clicking on the file and opening with VS Code, or through the VS Code File Explorer. Running cells Once you have a Notebook, you can run a code cell using the Run icon to the left of the cell and the output will appear directly below the code cell. You can also use keyboard shortcuts to run code. When in command or edit mode, use kbstyle(Ctrl+Enter) to run the current cell or kbstyle(Shift+Enter) to run the current cell and advance to the next. You can run multiple cells by using Run All , Run All Above , or Run All Below . Save your Jupyter Notebook You can save your Jupyter Notebook using the keyboard shortcut kbstyle(Ctrl+S) or File > Save . Export your Jupyter Notebook You can export a Jupyter Notebook as a Python file ( .py ), a PDF, or an HTML file. To export, select the Export action on the main toolbar. You'll then be presented with a dropdown of file format options. Note: For PDF export, you must have TeX installed . If you don't, you will be notified that you need to install it when you select the PDF option. Also, be aware that if you have SVG-only output in your Notebook, they will not be displayed in the PDF. To have SVG graphics in a PDF, either ensure that your output includes a non-SVG image format or else you can first export to HTML and then save as PDF using your browser. Work with code cells in the Notebook Editor The Notebook Editor makes it easy to create, edit, and run code cells within your Jupyter Notebook. Create a code cell By default, a blank Notebook will have an empty code cell for you to start with. msg = \"Hello world\" print(msg) Code cell modes While working with code cells, a cell can be in three states: unselected, command mode, and edit mode. The current state of a cell is indicated by a vertical bar to the left of a code cell and editor border. When no bar is visible, the cell is unselected. When a cell is selected, it can be in two different modes. It can be in command mode or in edit mode. When the cell is in command mode, it can be operated on and accept keyboard commands. When the cell is in edit mode, the cell's contents (code or Markdown) can be modified. When a cell is in command mode, a solid vertical bar will appear to the left of the cell. When you're in edit mode, the solid vertical bar is joined by a border around the cell editor. To move from edit mode to command mode, press the kbstyle(Esc) key. To move from command mode to edit mode, press the kbstyle(Enter) key. You can also use the mouse to change the mode by clicking the vertical bar to the left of the cell or out of the code/Markdown region in the code cell. Add additional code cells Code cells can be added to a Notebook using the main toolbar, a cell's add cell toolbar (visible with hover), and through keyboard commands. Using the plus icons in the main toolbar and a cell's hover toolbar will add a new cell directly below the currently selected cell. When a code cell is in command mode, the kbstyle(A) key can be used to add a cell above and the kbstyle(B) can be used to add a cell below the selected cell. Select a code cell The selected code cell can be changed using the mouse, the up/down arrow keys on the keyboard, and the kbstyle(J) (down) and kbstyle(K) (up) keys. To use the keyboard, the cell must be in command mode. Select multiple code cells To select multiple cells, start with one cell in selected mode. If you want to select consecutive cells, hold down kbstyle(Shift) and click the last cell you want to select. If you want to select any group of cells, hold down kbstyle(Ctrl) and click the cells you'd like to add to your selection. Selected cells will be indicated by the filled background. Run a single code cell Once your code is added, you can run a cell using the Run icon to the left of the cell and the output will be displayed below the code cell. You can also use keyboard shortcuts to run a selected code cell. kbstyle(Ctrl+Enter) runs the currently selected cell, kbstyle(Shift+Enter) runs the currently selected cell and inserts a new cell immediately below (focus moves to new cell), and kbstyle(Alt+Enter) runs the currently selected cell and inserts a new cell immediately below (focus remains on current cell). These keyboard shortcuts can be used in both command and edit modes. Run multiple code cells Running multiple code cells can be accomplished in many ways. You can use the double arrow in the main toolbar of the Notebook Editor to run all cells within the Notebook or the Run icons with directional arrows in the cell toolbar to run all cells above or below the current code cell. Move a code cell Moving cells up or down within a Notebook can be accomplished via dragging and dropping. For code cells, the drag and drop area is to the left of the cell editor as indicated below. For rendered Markdown cells, you may click anywhere to drag and drop cells. To move multiple cells, you can use the same drag and drop areas in any cell included in the selection. You can also use the keyboard shortcuts kbstyle(Alt+Arrow) to move one or multiple selected cells. Delete a code cell Deleting a code cell can be accomplished by using the Delete icon in the code cell toolbar or through the keyboard shortcut kbstyle(dd) when the selected code cell is in command mode. Undo your last change You can use the kbstyle(z) key to undo your previous change, for example, if you've made an accidental edit, you can undo it to the previous correct state, or if you've deleted a cell accidentally, you can recover it. Switch between code and Markdown The Notebook Editor allows you to easily change code cells between Markdown and code. Clicking the language picker in the bottom right of a cell will allow you to switch between Markdown and, if applicable, any other language supported by the selected kernel. You can also use the keyboard to change the cell type. When a cell is selected and in command mode, the kbstyle(M) key switches the cell type to Markdown and the kbstyle(Y) key switches the cell type to code. Once Markdown is set, you can enter Markdown formatted content to the code cell. To render Markdown cells, you can select the check mark in the cell toolbar, or use the kbstyle(Ctrl+Enter) and kbstyle(Shift+Enter) keyboard shortcuts. Clear output or restart/interrupt the kernel If you'd like to clear all code cell outputs or restart/interrupt the kernel, you can accomplish that using the main Notebook Editor toolbar. Enable/disable line numbers When you are in command mode, you can enable or disable line numbering within a single code cell by using the kbstyle(L) key. To toggle line numbering for the entire notebook, use kbstyle(Shift+L) when in command mode on any cell. Table of Contents To navigate through your notebook, open the File Explorer in the Activity bar. Then open the Outline tab in the Side bar. Note: By default, the outline will only show Markdown. To show code cells, enable the following setting: Notebook > Outline: Show Code Cells . IntelliSense support in the Jupyter Notebook Editor The Python Jupyter Notebook Editor window has full IntelliSense – code completions, member lists, quick info for methods, and parameter hints. You can be just as productive typing in the Notebook Editor window as you are in the code editor. Variable Explorer and Data Viewer Within a Python Notebook, it's possible to view, inspect, sort, and filter the variables within your current Jupyter session. By selecting the Variables icon in the main toolbar after running code and cells, you'll see a list of the current variables, which will automatically update as variables are used in code. The variables pane will open at the bottom of the notebook. For additional information about your variables, you can also double-click on a row or use the Show variable in data viewer button next to the variable for a more detailed view of a variable in the Data Viewer. Once open, you can filter the values by searching over the rows. Saving plots To save a plot from your notebook, simply hover over the output and select the Save icon in the top right. Note: There is support for rendering plots created with matplotlib and Altair . Custom notebook diffing Under the hood, Jupyter Notebooks are JSON files. The segments in a JSON file are rendered as cells that are comprised of three components: input, output, and metadata. Comparing changes made in a notebook using lined-based diffing is difficult and hard to parse. The rich diffing editor for notebooks allows you to easily see changes for each component of a cell. You can even customize what types of changes you want displayed within your diffing view. In the top right, select the overflow menu item in the toolbar to customize what cell components you want included. Input differences will always be shown. To learn more about Git integration within VS Code, visit Version Control in VS Code . Debug a Jupyter Notebook If you need additional debug support in order to diagnose an issue in your code cells, you can export it as a Python file. Once exported as a Python file, the VS Code debugger lets you step through your code, set breakpoints, examine state, and analyze problems. Using the debugger is a helpful way to find and correct issues in notebook code. To debug your Python file: In VS Code, if you haven't already, activate a Python environment in which Jupyter is installed. From your Jupyter Notebook ( .ipynb ), select the Export button in the main toolbar. Once exported, you'll have a .py file with your code that you can use for debugging. After saving the .py file, to start the debugger, use one of the following options: For the whole Notebook, open the Command Palette ( kb(workbench.action.showCommands) ) and run the Python: Debug Current File in Python Interactive Window command. For an individual cell, use the Debug Cell action that appears above the cell. The debugger specifically starts on the code in that cell. By default, Debug Cell steps into user code. If you want to step into non-user code, you need to uncheck Data Science: Debug Just My Code in the Python extension settings ( kb(workbench.action.openSettings) ). To familiarize yourself with the general debugging features of VS Code, such as inspecting variables, setting breakpoints, and other activities, review VS Code debugging . As you find issues, stop the debugger, correct your code, save the file, and start the debugger again. When you're satisfied that all your code is correct, use the Python Interactive window to export the Python file as a Jupyter Notebook ( .ipynb ). Connect to a remote Jupyter server You can offload intensive computation in a Jupyter Notebook to other computers by connecting to a remote Jupyter server. Once connected, code cells run on the remote server rather than the local computer. To connect to a remote Jupyter server: Select the Jupyter Server: local button in the global Status bar or run the Jupyter: Specify local or remote Jupyter server for connections command from the Command Palette ( kb(workbench.action.showCommands) ). When prompted to Pick how to connect to Jupyter , select Existing: Specify the URI of an existing server . When prompted to Enter the URI of a Jupyter server , provide the server's URI (hostname) with the authentication token included with a ?token= URL parameter. (If you start the server in the VS Code terminal with an authentication token enabled, the URL with the token typically appears in the terminal output from where you can copy it.) Alternatively, you can specify a username and password after providing the URI. Note: For added security, Microsoft recommends configuring your Jupyter server with security precautions such as SSL and token support. This helps ensure that requests sent to the Jupyter server are authenticated and connections to the remote server are encrypted. For guidance about securing a notebook server, refer to the Jupyter documentation ."
  },
  "guides/vscode/datascience/overview.html": {
    "href": "guides/vscode/datascience/overview.html",
    "title": "Data Science in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Data Science in Visual Studio Code You can do all of your data science work within VS Code. Use Jupyter Notebooks and the Interactive Window to start analyzing and visualizing your data in minutes! Power your Python coding experience with IntelliSense support and build, train, and deploy machine learning models to the cloud or the edge with Azure Machine Learning service. Extensions The VS Code Marketplace offers a family of extensions that provide a first-class data science experience for Python data science. In order to get started with Python, Microsoft recommends the following extensions: What else can you use notebooks for? The support for mixing executable code, equations, visualizations and rich markdown makes notebooks useful for breaking down new concepts in a story telling form. This makes notebooks an exceptional tool for educators and students! Learn C#, F#, and Powershell with the .NET Interactive Notebooks extension."
  },
  "guides/vscode/datascience/python-interactive.html": {
    "href": "guides/vscode/datascience/python-interactive.html",
    "title": "How to use Python Interactive in Jupyter | Fountain of Knowledge",
    "keywords": "How to use Python Interactive in Jupyter This page is redirected to /docs/python/jupyter-support-py.md and only exists to keep the \"Python Interactive\" TOC item."
  },
  "guides/vscode/datascience/pytorch-support.html": {
    "href": "guides/vscode/datascience/pytorch-support.html",
    "title": "PyTorch support in Visual Studio Code | Fountain of Knowledge",
    "keywords": "PyTorch support in Visual Studio Code Along with support for Jupyter Notebooks , Visual Studio Code offers many features of particular interest for PyTorch developers. This article covers some of those features and illustrates how they can help you in your projects. If you're unfamiliar with PyTorch development, Microsoft Learn offers a Get started with PyTorch learning path that covers the fundamentals of deep learning with PyTorch. Data Viewer support for Tensors and data slices VS Code provides a Data Viewer that allows you to explore the variables within your code and notebooks, including PyTorch and TensorFlow Tensor data types. Along with that the Data Viewer has support for slicing data, allowing you to view any 2D slice of your higher dimensional data. To access the Data Viewer, you can either open it from the Notebook Variable Explorer by clicking the Data Viewer icon that shows up beside any Tensor variable. You'll also notice that the Variable Explorer shows the shape/dimensions of the Tensor as well. Or you can open it from a Python debugging session by right-clicking any Tensor variable in the debugger and selecting View Value in Data Viewer . If you have 3-dimensional or greater data (numpy ndarray , PyTorch Tensor , or TensorFlow EagerTensor types) a data slicing panel will open in the Data Viewer by default. Using the panel, you can either use the input box to programmatically specify your slice using Python slice syntax or you can use the interactive Axis and Index dropdowns to slice as well. Along with slicing, you can search for values of interest such as \"inf's\" or \"NaN's\" by searching for those keywords in the filter under each column name. TensorBoard integration TensorBoard is a data science companion dashboard that helps PyTorch and TensorFlow developers visualize datasets and model training. With TensorBoard directly integrated in VS Code, you can spot check your models predictions, view the architecture of your model, analyze your model's loss and accuracy over time, and profile your code to find out where it's the slowest. To start a TensorBoard session, open the Command Palette ( kb(workbench.action.showCommands) ) and search for the command Python: Launch TensorBoard . Afterwards, you will be prompted to select the folder where your TensorBoard log files are located. By default, VS Code uses your current working directory and automatically detects your TensorBoard log files within any subdirectories, but you can also specify your own directory. VS Code will then open a new tab with TensorBoard and manage its lifecycle as you work. You can also use the setting python.tensorboard.logDirectory to set a default TensorBoard log directory for your folder/workspace. PyTorch Profiler integration Along with TensorBoard, VS Code and the Python extension also integrate the PyTorch Profiler, allowing you to better analyze your PyTorch models in one place. For more information about the profiler, see the PyTorch Profiler documentation . IntelliSense through the Pylance language server The Python editing experience in VS Code, enhanced with the power of Pylance, provides completions and other rich features for PyTorch. For the best experience, update PyTorch to 1.8.1 to get improved completions for submodules, such as nn, cuda, and optim."
  },
  "guides/vscode/editor/accessibility.html": {
    "href": "guides/vscode/editor/accessibility.html",
    "title": "Accessibility | Fountain of Knowledge",
    "keywords": "Accessibility Visual Studio Code has many features to help make the editor accessible to all users. Zoom and High Contrast colors improve editor visibility, keyboard-only navigation allows use without a mouse, and the editor has been optimized for screen readers. Zoom You can adjust the Zoom level in VS Code with the View > Appearance > Zoom commands. The zoom level increases or decreases by 20% each time a Zoom command is executed. View > Appearance > Zoom In ( kb(workbench.action.zoomIn) ) - increase the Zoom level. View > Appearance > Zoom Out ( kb(workbench.action.zoomOut) ) - decrease the Zoom level. View > Appearance > Reset Zoom ( kb(workbench.action.zoomReset) ) - reset the Zoom level to 0. Persisted Zoom Level When you adjust the zoom level with the View > Zoom In / Out commands, the zoom level is persisted in the window.zoomLevel setting . The default value is 0 and each increment/decrement changes the zoom level by 20%. High Contrast theme We support a High Contrast color theme on all platforms. Use File > Preferences > Color Theme ( kb(workbench.action.selectTheme) ) to display the Select Color Theme dropdown and select the High Contrast theme. Keyboard navigation You will find that VS Code provides an exhaustive list of commands in the Command Palette ( kb(workbench.action.showCommands) ) so that you can run VS Code without using the mouse. Press kb(workbench.action.showCommands) then type a command name (for example 'git') to filter the list of commands. VS Code also has many preset keyboard shortcuts for commands. These are displayed to the right of the command in the Command Palette . You can also set your own keyboard shortcuts. File > Preferences > Keyboard Shortcuts ( kb(workbench.action.openGlobalKeybindings) ) brings up the Keyboard Shortcuts editor where you can discover and modify keybindings for VS Code actions. See Key Bindings for more details on customizing or adding your own keyboard shortcuts. For a quick navigation across the workbench, we recommend using Focus Next Part ( kb(workbench.action.focusNextPart) ) and Focus Previous Part ( kb(workbench.action.focusPreviousPart) ) commands. Anchor selection To make it easier to start and end selection using the keyboard we have four commands: Set Selection Anchor ( kb(editor.action.setSelectionAnchor) ), Select From Anchor to Cursor ( kb(editor.action.selectFromAnchorToCursor) ), Cancel Selection Anchor ( kb(editor.action.cancelSelectionAnchor) ) and Go to Selection Anchor . Tab navigation You can use the kbstyle(Tab) key to jump between VS Code UI controls. Use kbstyle(Shift+Tab) to tab in reverse order. As you tab through the UI controls, you can see an indicator around the UI element once the element gains focus. All elements in the workbench support tab navigation, but workbench toolbars and tab lists have only one tab stop, to avoid having too many. Once the focus is on a toolbar or a tab list, you can use the arrow keys to navigate within them. Tab trapping By default, pressing the kbstyle(Tab) within a source code file inserts the Tab character (or spaces depending on your Indentation setting) and does not leave the open file. You can toggle the trapping of kbstyle(Tab) with kb(editor.action.toggleTabFocusMode) and subsequent kbstyle(Tab) keys will move focus out of the file. When default kbstyle(Tab) trapping is off, you will see an indicator in the Status Bar. You can also toggle kbstyle(Tab) trapping from the Command Palette ( kb(workbench.action.showCommands) ) with the Toggle Tab Key Moves Focus action. Read-only files never trap the kbstyle(Tab) key. The Integrated Terminal panel respects the kbstyle(Tab) trapping mode and can be toggled with kb(editor.action.toggleTabFocusMode) . Screen readers VS Code supports screen readers in the editor using a strategy based on paging the text. We have tested using the following screen readers: NVDA and JAWS on Windows, VoiceOver on macOS and Orca on Linux. For NVDA, we recommend staying in focus mode and using the hotkeys to navigate, instead of using browse mode. The Go to Next/Previous Error or Warning actions ( kb(editor.action.marker.nextInFiles) and kb(editor.action.marker.prevInFiles) ) allow screen readers to announce the error or warning messages. When the suggestions pop up, they will get announced to screen readers. It is possible to navigate the suggestions using kbstyle(Ctrl+Up) and kbstyle(Ctrl+Down) , you can dismiss the suggestions with kbstyle(Shift+Escape) and if suggestions get in your way, you can disable the auto-popup of suggestions with the editor.quickSuggestions setting. The Go to Next/Previous Difference actions ( kb(editor.action.diffReview.next) and kb(editor.action.diffReview.prev) ), when in a diff editor pane, will bring up the Diff Review pane, which allows the navigation of the diffs, presented in a unified patch format. Arrow Up and Arrow Down can be used to navigate through the unchanged, inserted, or deleted lines. Pressing kbstyle(Enter) will return focus to the modified pane of the diff editor at the selected line number (or closest still existing line number in case a deleted line is selected). Use kbstyle(Escape) or kb(Shift+Escape) to dismiss the Diff Review pane. Accessibility help You can press kb(editor.action.showAccessibilityHelp) to trigger the Show Accessibility Help dialog while in an editor to check the state of various accessibility options in VS Code: Screen reader mode When VS Code detects that a screen reader is being used, it goes into screen reader optimized mode for the UI such as the editor and Integrated Terminal. The Status Bar displays Screen Reader Optimized in the lower right and you can exit screen reader mode by clicking on the display text. Certain features such as folding, minimap (code overview), and word wrap are disabled when in screen reader mode. You can control whether VS Code uses screen reader mode with the Editor: Accessibility Support setting ( editor.accessibilitySupport ) and the values are on , off , or the default auto to automatically detect a screen reader through querying the platform. Terminal accessibility Output in the Integrated Terminal can be navigated through by using the \"navigation mode\" commands available in the Command Palette (press kbstyle(F1) and search for \"terminal navigation mode\"). Minimum contrast ratio The setting terminal.integrated.minimumContrastRatio can be set to a number between 1 and 21, this will cause the text color either increase or reduce luminance until the contrast ratio is met or pure white ( #FFFFFF ) black ( #000000 ) is hit. Status Bar accessibility Once a focus is in the Status bar via Focus Next Part ( kb(workbench.action.focusNextPart) ) arrow navigation can be used to move focus between Status bar entries. Debugger accessibility The VS Code debugger UI is user accessible and has the following features: Changes in debug state are read out (for example 'started', 'breakpoint hit', 'terminated', ...). All debug actions are keyboard accessible. Both the Run view and Debug Console support Tab navigation. Debug hover is keyboard accessible ( kb(editor.action.showHover) ). Keyboard shortcuts can be created to set focus to each debugger area. Current known issues VS Code has some known accessibility issues depending on the platform. Here's a full list of VS Code accessibility issues. macOS There is screen reader support for the editor with VoiceOver. Linux Screen reader support for the editor is still work in progress because the accessibility implementation for Chrome on Linux is work in progress. Thus there are a couple of things needed in order to have screen reader Orca working with VS Code: Make sure to use the latest version of Orca out of master. More details can be found on the Orca page . We have tested that VS Code works well with Orca on Ubuntu 18, Fedora 31, Arch Linux. With Ubuntu 19, we have encountered issues. Make sure to have the setting \"editor.accessibilitySupport\": \"on\" in VS Code. You can do this using settings, or by running the Show Accessibility Help command and pressing kbstyle(Ctrl+E) to turn on accessibilitySupport. If Orca is still silent, try setting ACCESSIBILITY_ENABLED=1 as an environment variable. After enabling that setting, VS Code should work with the Orca screen reader. Next steps Read on to find out about: Visual Studio Code User Interface - A quick orientation to VS Code. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code."
  },
  "guides/vscode/editor/codebasics.html": {
    "href": "guides/vscode/editor/codebasics.html",
    "title": "Basic Editing | Fountain of Knowledge",
    "keywords": "Basic Editing Visual Studio Code is an editor first and foremost, and includes the features you need for highly productive source code editing. This topic takes you through the basics of the editor and helps you get moving with your code. Keyboard shortcuts Being able to keep your hands on the keyboard when writing code is crucial for high productivity. VS Code has a rich set of default keyboard shortcuts as well as allowing you to customize them. Keyboard Shortcuts Reference - Learn the most commonly used and popular keyboard shortcuts by downloading the reference sheet. Install a Keymap extension - Use the keyboard shortcuts of your old editor (such as Sublime Text, Atom, and Vim) in VS Code by installing a Keymap extension. Customize Keyboard Shortcuts - Change the default keyboard shortcuts to fit your style. Multiple selections (multi-cursor) VS Code supports multiple cursors for fast simultaneous edits. You can add secondary cursors (rendered thinner) with kbstyle(Alt+Click) . Each cursor operates independently based on the context it sits in. A common way to add more cursors is with kb(editor.action.insertCursorBelow) or kb(editor.action.insertCursorAbove) that insert cursors below or above. Note: Your graphics card driver (for example NVIDIA) might overwrite these default shortcuts. kb(editor.action.addSelectionToNextFindMatch) selects the word at the cursor, or the next occurrence of the current selection. Tip: You can also add more cursors with kb(editor.action.selectHighlights) , which will add a selection at each occurrence of the current selected text. Multi-cursor modifier If you'd like to change the modifier key for applying multiple cursors to kbstyle(Cmd+Click) on macOS and kbstyle(Ctrl+Click) on Windows and Linux, you can do so with the editor.multiCursorModifier setting . This lets users coming from other editors such as Sublime Text or Atom continue to use the keyboard modifier they are familiar with. The setting can be set to: ctrlCmd - Maps to kbstyle(Ctrl) on Windows and kbstyle(Cmd) on macOS. alt - The existing default kbstyle(Alt) . There's also a menu item Use Ctrl+Click for Multi-Cursor in the Selection menu to quickly toggle this setting. The Go To Definition and Open Link gestures will also respect this setting and adapt such that they do not conflict. For example, when the setting is ctrlCmd , multiple cursors can be added with kbstyle(Ctrl/Cmd+Click) , and opening links or going to definition can be invoked with kbstyle(Alt+Click) . Shrink/expand selection Quickly shrink or expand the current selection. Trigger it with kb(editor.action.smartSelect.shrink) and kb(editor.action.smartSelect.expand) . Here's an example of expanding the selection with kb(editor.action.smartSelect.expand) : Column (box) selection Place the cursor in one corner and then hold kbstyle(Shift+Alt) while dragging to the opposite corner: Note: This changes to kbstyle(Shift+Ctrl/Cmd) when using kbstyle(Ctrl/Cmd) as multi-cursor modifier . There are also default key bindings for column selection on macOS and Windows, but not on Linux. Key Command Command ID kb(cursorColumnSelectDown) Column Select Down cursorColumnSelectDown kb(cursorColumnSelectUp) Column Select Up cursorColumnSelectUp kb(cursorColumnSelectLeft) Column Select Left cursorColumnSelectLeft kb(cursorColumnSelectRight) Column Select Right cursorColumnSelectRight kb(cursorColumnSelectPageDown) Column Select Page Down cursorColumnSelectPageDown kb(cursorColumnSelectPageUp) Column Select Page Up cursorColumnSelectPageUp You can edit your keybindings.json to bind them to something more familiar if you want. Column Selection mode The user setting Editor: Column Selection controls this feature. Once this mode is entered, as indicated in the Status bar, the mouse gestures and the arrow keys will create a column selection by default. This global toggle is also accessible via the Selection > Column Selection Mode menu item. In addition, one can also disable Column Selection mode from the Status bar. Save / Auto Save By default, VS Code requires an explicit action to save your changes to disk, kb(workbench.action.files.save) . However, it's easy to turn on Auto Save , which will save your changes after a configured delay or when focus leaves the editor. With this option turned on, there is no need to explicitly save the file. The easiest way to turn on Auto Save is with the File > Auto Save toggle that turns on and off save after a delay. For more control over Auto Save , open User or Workspace settings and find the associated settings: files.autoSave : Can have the values: off - to disable auto save. afterDelay - to save files after a configured delay (default 1000 ms). onFocusChange - to save files when focus moves out of the editor of the dirty file. onWindowChange - to save files when the focus moves out of the VS Code window. files.autoSaveDelay : Configures the delay in milliseconds when files.autoSave is configured to afterDelay . The default is 1000 ms. Hot Exit VS Code will remember unsaved changes to files when you exit by default. Hot exit is triggered when the application is closed via File > Exit ( Code > Quit on macOS) or when the last window is closed. You can configure hot exit by setting files.hotExit to the following values: \"off\" : Disable hot exit. \"onExit\" : Hot exit will be triggered when the application is closed, that is when the last window is closed on Windows/Linux or when the workbench.action.quit command is triggered (from the Command Palette , keyboard shortcut or menu). All windows without folders opened will be restored upon next launch. \"onExitAndWindowClose\" : Hot exit will be triggered when the application is closed, that is when the last window is closed on Windows/Linux or when the workbench.action.quit command is triggered (from the Command Palette , keyboard shortcut or menu), and also for any window with a folder opened regardless of whether it is the last window. All windows without folders opened will be restored upon next launch. To restore folder windows as they were before shutdown, set window.restoreWindows to all . If something happens to go wrong with hot exit, all backups are stored in the following folders for standard install locations: Windows %APPDATA%\\Code\\Backups macOS $HOME/Library/Application Support/Code/Backups Linux $HOME/.config/Code/Backups Find and Replace VS Code allows you to quickly find text and replace in the currently opened file. Press kb(actions.find) to open the Find Widget in the editor, search results will be highlighted in the editor, overview ruler and minimap. If there are more than one matched result in the current opened file, you can press kb(editor.action.nextMatchFindAction) and kb(editor.action.previousMatchFindAction) to navigate to next or previous result when the find input box is focused. Seed Search String From Selection When the Find Widget is opened, it will automatically populate the selected text in the editor into the find input box. If the selection is empty, the word under the cursor will be inserted into the input box instead. This feature can be turned off by setting editor.find.seedSearchStringFromSelection to false . Find In Selection By default, the find operations are run on the entire file in the editor. It can also be run on selected text. You can turn this feature on by clicking the hamburger icon on the Find Widget. If you want it to be the default behavior of the Find Widget, you can set editor.find.autoFindInSelection to always , or to multiline , if you want it to be run on selected text only when multiple lines of content are selected. Advanced find and replace options In addition to find and replace with plain text, the Find Widget also has three advanced search options: Match Case Match Whole Word Regular Expression The replace input box support case preserving, you can turn it on by clicking the Preserve Case ( AB ) button. Multiline support and Find Widget resizing You can search multiple line text by pasting the text into the Find input box and Replace input box. Pressing Ctrl+Enter inserts a new line in the input box. While searching long text, the default size of Find Widget might be too small. You can drag the left sash to enlarge the Find Widget or double click the left sash to maximize it or shrink it to its default size. Search across files VS Code allows you to quickly search over all files in the currently opened folder. Press kb(workbench.view.search) and enter your search term. Search results are grouped into files containing the search term, with an indication of the hits in each file and its location. Expand a file to see a preview of all of the hits within that file. Then single-click on one of the hits to view it in the editor. Tip: We support regular expression searching in the search box, too. You can configure advanced search options by clicking the ellipsis ( Toggle Search Details ) below the search box on the right (or press kb(workbench.action.search.toggleQueryDetails) ). This will show additional fields to configure the search. Advanced search options In the two input boxes below the search box, you can enter patterns to include or exclude from the search. If you enter example , that will match every folder and file named example in the workspace. If you enter ./example , that will match the folder example/ at the top level of your workspace. Use , to separate multiple patterns. Paths must use forward slashes. You can also use glob syntax: * to match one or more characters in a path segment ? to match on one character in a path segment ** to match any number of path segments, including none {} to group conditions (for example {**/*.html,**/*.txt} matches all HTML and text files) [] to declare a range of characters to match ( example.[0-9] to match on example.0 , example.1 , …) VS Code excludes some folders by default to reduce the number of search results that you are not interested in (for example: node_modules ). Open settings to change these rules under the files.exclude and search.exclude section. Note that glob patterns in the search view work differently than in settings such as files.exclude and search.exclude . In the settings, you must use **/example to match a folder named example in subfolder folder1/example in your workspace. In the search view, the ** prefix is assumed. Also note the Use Exclude Settings and Ignore Files toggle button in the files to exclude box. The toggle determines whether to exclude files that are ignored by your .gitignore files and/or matched by your files.exclude and search.exclude settings. Tip: From the Explorer, you can right-click on a folder and select Find in Folder to search inside a folder only. Search and replace You can also Search and Replace across files. Expand the Search widget to display the Replace text box. When you type text into the Replace text box, you will see a diff display of the pending changes. You can replace across all files from the Replace text box, replace all in one file or replace a single change. Tip: You can quickly reuse a previous search term by using kb(history.showNext) and kb(history.showPrevious) to navigate through your search term history. IntelliSense We'll always offer word completion, but for the rich languages , such as JavaScript, JSON, HTML, CSS, SCSS, Less, C# and TypeScript, we offer a true IntelliSense experience. If a language service knows possible completions, the IntelliSense suggestions will pop up as you type. You can always manually trigger it with kb(editor.action.triggerSuggest) . By default, kbstyle(Tab) or kbstyle(Enter) are the accept keyboard triggers but you can also customize these key bindings . Tip: The suggestions filtering supports CamelCase so you can type the letters which are upper cased in a method name to limit the suggestions. For example, \"cra\" will quickly bring up \"createApplication\". Tip: IntelliSense suggestions can be configured via the editor.quickSuggestions and editor.suggestOnTriggerCharacters settings . JavaScript and TypeScript developers can take advantage of the npmjs type declaration (typings) file repository to get IntelliSense for common JavaScript libraries (Node.js, React, Angular). You can find a good explanation on using type declaration files in the JavaScript language topic and the Node.js tutorial. Learn more in the IntelliSense document . Formatting VS Code has great support for source code formatting. The editor has two explicit format actions: Format Document ( kb(editor.action.formatDocument) ) - Format the entire active file. Format Selection ( kb(editor.action.formatSelection) ) - Format the selected text. You can invoke these from the Command Palette ( kb(workbench.action.showCommands) ) or the editor context menu. VS Code has default formatters for JavaScript, TypeScript, JSON, and HTML. Each language has specific formatting options (for example, html.format.indentInnerHtml ) which you can tune to your preference in your user or workspace settings . You can also disable the default language formatter if you have another extension installed that provides formatting for the same language. \"html.format.enable\": false Along with manually invoking code formatting, you can also trigger formatting based on user gestures such as typing, saving or pasting. These are off by default but you can enable these behaviors through the following settings : editor.formatOnType - Format the line after typing. editor.formatOnSave - Format a file on save. editor.formatOnPaste - Format the pasted content. Note: Not all formatters support format on paste as to do so they must support formatting a selection or range of text. In addition to the default formatters, you can find extensions on the Marketplace to support other languages or formatting tools. There is a Formatters category so you can easily search and find formatting extensions . In the Extensions view search box, type 'formatters' or 'category:formatters' to see a filtered list of extensions within VS Code. Folding You can fold regions of source code using the folding icons on the gutter between line numbers and line start. Move the mouse over the gutter and click to fold and unfold regions. Use kbstyle(Shift + Click) on the folding icon to fold or unfold the region and all regions inside. You can also use the following actions: Fold ( kb(editor.fold) ) folds the innermost uncollapsed region at the cursor. Unfold ( kb(editor.unfold) ) unfolds the collapsed region at the cursor. Toggle Fold ( kb(editor.toggleFold) ) folds or unfolds the region at the cursor. Fold Recursively ( kb(editor.foldRecursively) ) folds the innermost uncollapsed region at the cursor and all regions inside that region. Unfold Recursively ( kb(editor.unfoldRecursively) ) unfolds the region at the cursor and all regions inside that region. Fold All ( kb(editor.foldAll) ) folds all regions in the editor. Unfold All ( kb(editor.unfoldAll) ) unfolds all regions in the editor. Fold Level X ( kb(editor.foldLevel2) for level 2) folds all regions of level X, except the region at the current cursor position. Fold All Block Comments ( kb(editor.foldAllBlockComments) ) folds all regions that start with a block comment token. Folding regions are by default evaluated based on the indentation of lines. A folding region starts when a line has a smaller indent than one or more following lines, and ends when there is a line with the same or smaller indent. Since the 1.22 release, folding regions can also be computed based on syntax tokens of the editor's configured language. The following languages already provide syntax aware folding: Markdown, HTML, CSS, LESS, SCSS, and JSON. If you prefer to switch back to indentation-based folding for one (or all) of the languages above, use: \"[html]\": { \"editor.foldingStrategy\": \"indentation\" }, Regions can also be defined by markers defined by each language. The following languages currently have markers defined: Language Start region End region Bat ::#region or REM #region ::#endregion or REM #endregion C# #region #endregion C/C++ #pragma region #pragma endregion CSS/Less/SCSS /*#region*/ /*#endregion*/ Coffeescript #region #endregion F# //#region or (#region) //#endregion or (#endregion) Java //#region or //<editor-fold> // #endregion or //</editor-fold> Markdown <!-- #region --> <!-- #endregion --> Perl5 #region or =pod #endregion or =cut PHP #region #endregion PowerShell #region #endregion Python #region or # region #endregion or # endregion TypeScript/JavaScript //#region //#endregion Visual Basic #Region #End Region To fold and unfold only the regions defined by markers use: Fold Marker Regions ( kb(editor.foldAllMarkerRegions) ) folds all marker regions. Unfold Marker Regions ( kb(editor.unfoldAllMarkerRegions) ) unfolds all marker regions. Indentation VS Code lets you control text indentation and whether you'd like to use spaces or tab stops. By default, VS Code inserts spaces and uses 4 spaces per kbstyle(Tab) key. If you'd like to use another default, you can modify the editor.insertSpaces and editor.tabSize settings . \"editor.insertSpaces\": true, \"editor.tabSize\": 4, Auto-detection VS Code analyzes your open file and determines the indentation used in the document. The auto-detected indentation overrides your default indentation settings. The detected setting is displayed on the right side of the Status Bar: You can click on the Status Bar indentation display to bring up a dropdown with indentation commands allowing you to change the default settings for the open file or convert between tab stops and spaces. Note: VS Code auto-detection checks for indentations of 2, 4, 6 or 8 spaces. If your file uses a different number of spaces, the indentation may not be correctly detected. For example, if your convention is to indent with 3 spaces, you may want to turn off editor.detectIndentation and explicitly set the tab size to 3. \"editor.detectIndentation\": false, \"editor.tabSize\": 3, File encoding support Set the file encoding globally or per workspace by using the files.encoding setting in User Settings or Workspace Settings . You can view the file encoding in the status bar. Click on the encoding button in the status bar to reopen or save the active file with a different encoding. Then choose an encoding. Next steps You've covered the basic user interface - there is a lot more to VS Code. Read on to find out about: Intro Video - Setup and Basics - Watch a tutorial on the basics of VS Code. User/Workspace Settings - Learn how to configure VS Code to your preferences through user and workspace settings. Code Navigation - Peek and Goto Definition, and more. Integrated Terminal - Learn about the integrated terminal for quickly performing command-line tasks from within VS Code. IntelliSense - VS Code brings smart code completions. Debugging - This is where VS Code really shines. Common questions Is it possible to globally search and replace? Yes, expand the Search view text box to include a replace text field. You can search and replace across all the files in your workspace. Note that if you did not open VS Code on a folder, the search will only run on the currently open files. How do I turn on word wrap? You can control word wrap through the editor.wordWrap setting . By default, editor.wordWrap is off but if you set to it to on , text will wrap on the editor's viewport width. \"editor.wordWrap\": \"on\" You can toggle word wrap for the VS Code session with kb(editor.action.toggleWordWrap) . You can also add vertical column rulers to the editor with the editor.rulers setting, which takes an array of column character positions where you'd like vertical rulers."
  },
  "guides/vscode/editor/command-line.html": {
    "href": "guides/vscode/editor/command-line.html",
    "title": "Command Line Interface (CLI) | Fountain of Knowledge",
    "keywords": "Command Line Interface (CLI) Visual Studio Code has a powerful command line interface built-in that lets you control how you launch the editor. You can open files, install extensions, change the display language, and output diagnostics through command-line options (switches). If you are looking for how to run command-line tools inside VS Code, see the Integrated Terminal . Command line help To get an overview of the VS Code command line interface, open a terminal or command prompt and type code --help . You will see the version, usage example, and list of command line options. Launching from command line You can launch VS Code from the command line to quickly open a file, folder, or project. Typically, you open VS Code within the context of a folder. To do this, from an open terminal or command prompt, navigate to your project folder and type code . : Note: Users on macOS must first run a command ( Shell Command: Install 'code' command in PATH ) to add VS Code executable to the PATH environment variable. Read the macOS setup guide for help. Windows and Linux installations should add the VS Code binaries location to your system path. If this isn't the case, you can manually add the location to the Path environment variable ( $PATH on Linux). For example, on Windows, VS Code is installed under AppData\\Local\\Programs\\Microsoft VS Code\\bin . To review platform specific setup instructions, see Setup . Insiders: If you are using the VS Code Insiders preview, you launch your Insiders build with code-insiders . Core CLI options Here are optional arguments you can use when starting VS Code at the command line via code : Argument Description -h or --help Print usage -v or --version Print VS Code version (for example, 1.22.2), GitHub commit id, and architecture (for example, x64). -n or --new-window Opens a new session of VS Code instead of restoring the previous session (default). -r or --reuse-window Forces opening a file or folder in the last active window. -g or --goto When used with file:line[:character] , opens a file at a specific line and optional character position. This argument is provided since some operating systems permit : in a file name. -d or --diff Open a file difference editor. Requires two file paths as arguments. -w or --wait Wait for the files to be closed before returning. --locale <locale> Set the display language (locale) for the VS Code session. (for example, en-US or zh-TW ) Opening Files and Folders Sometimes you will want to open or create a file. If the specified file does not exist, VS Code will create them for you along with any new intermediate folders: code index.html style.css documentation\\readme.md For both files and folders, you can use absolute or relative paths. Relative paths are relative to the current directory of the command prompt where you run code . If you specify more than one file at the command line, VS Code will open only a single instance. If you specify more than one folder at the command line, VS Code will create a Multi-root Workspace including each folder. Argument Description file Name of a file to open. If the file doesn't exist, it will be created and marked as edited. You can specify multiple files by separating each file name with a space. file:line[:character] Used with the -g argument. Name of a file to open at the specified line and optional character position. You can specify multiple files in this manner, but you must use the -g argument (once) before using the file:line[:character] specifier. folder Name of a folder to open. You can specify multiple folders and a new Multi-root Workspace is created. Working with extensions You can install and manage VS Code extensions from the command line. Argument Description --install-extension <ext> Install an extension. Provide the full extension name publisher.extension as an argument. Use --force argument to avoid prompts. --uninstall-extension <ext> Uninstall an extension. Provide the full extension name publisher.extension as an argument. --disable-extensions Disable all installed extensions. Extensions will still be visible in the Disabled section of the Extensions view but they will never be activated. --list-extensions List the installed extensions. --show-versions Show versions of installed extensions, when using --list-extensions --enable-proposed-api <ext> Enables proposed api features for an extension. Provide the full extension name publisher.extension as an argument. Advanced CLI options There are several CLI options that help with reproducing errors and advanced setup. Argument Description --extensions-dir <dir> Set the root path for extensions. Has no effect in Portable Mode . --user-data-dir <dir> Specifies the directory that user data is kept in, useful when running as root. Has no effect in Portable Mode . -s, --status Print process usage and diagnostics information. -p, --performance Start with the Developer: Startup Performance command enabled. --disable-gpu Disable GPU hardware acceleration. --verbose Print verbose output (implies --wait ). --prof-startup Run CPU profiler during startup. --upload-logs Uploads logs from current session to a secure endpoint. --add <dir> Add folder(s) to the last active window for a multi-root workspace. Opening VS Code with URLs You can also open projects and files using the platform's URL handling mechanism. Use the following URL formats to: Open a project vscode://file/{full path to project}/ vscode://file/c:/myProject/ Open a file vscode://file/{full path to file} vscode://file/c:/myProject/package.json Open a file to line and column vscode://file/{full path to file}:line:column vscode://file/c:/myProject/package.json:5:10 You can use the URL in applications such as browsers or file explorers that can parse and redirect the URL. For example, on Windows, you could pass a vscode:// URL directly to the Windows Explorer or to the command line as start vscode://{full path to file} . Note : If you are using VS Code Insiders builds, the URL prefix is vscode-insiders:// . Next steps Read on to find out about: Integrated Terminal - Run command-line tools from inside VS Code. Basic Editing - Learn the basics of the VS Code editor. Code Navigation - VS Code lets you quickly understand and move through your source code. Common questions 'code' is not recognized as an internal or external command Your OS cannot find the VS Code binary code on its path. The VS Code Windows and Linux installations should have installed VS Code on your path. Try uninstalling and reinstalling VS Code. If code is still not found, consult the platform specific setup topics for Windows and Linux . On macOS, you need to manually run the Shell Command: Install 'code' command in PATH command (available through the Command Palette kb(workbench.action.showCommands) ). Consult the macOS specific setup topic for details. How do I get access to a command line (terminal) from within VS Code? VS Code has an Integrated Terminal where you can run command-line tools from within VS Code. Can I specify the settings location for VS Code in order to have a portable version? Not directly through the command line, but VS Code has a Portable Mode which lets you keep settings and data in the same location as your installation, for example, on a USB drive."
  },
  "guides/vscode/editor/debugging.html": {
    "href": "guides/vscode/editor/debugging.html",
    "title": "Debugging | Fountain of Knowledge",
    "keywords": "Debugging One of the key features of Visual Studio Code is its great debugging support. VS Code's built-in debugger helps accelerate your edit, compile and debug loop. Debugger extensions VS Code has built-in debugging support for the Node.js runtime and can debug JavaScript, TypeScript, or any other language that gets transpiled to JavaScript. For debugging other languages and runtimes (including PHP , Ruby , Go , C# , Python , C++ , PowerShell and many others ), look for Debuggers extensions in the VS Code Marketplace or select Install Additional Debuggers in the top-level Run menu. Below are several popular extensions which include debugging support: Tip: The extensions shown above are dynamically queried. Select an extension tile above to read the description and reviews to decide which extension is best for you. Start debugging The following documentation is based on the built-in Node.js debugger, but most of the concepts and features are applicable to other debuggers as well. It is helpful to first create a sample Node.js application before reading about debugging. You can follow the Node.js walkthrough to install Node.js and create a simple \"Hello World\" JavaScript application ( app.js ). Once you have a simple application set up, this page will take you through VS Code debugging features. Run view To bring up the Run view, select the Run icon in the Activity Bar on the side of VS Code. You can also use the keyboard shortcut kb(workbench.view.debug) . The Run view displays all information related to running and debugging and has a top bar with debugging commands and configuration settings. If running and debugging is not yet configured (no launch.json has been created), VS Code shows the Run start view. Run menu The top-level Run menu has the most common run and debug commands: Launch configurations To run or debug a simple app in VS Code, select Run and Debug on the Debug start view or press kb(workbench.action.debug.start) and VS Code will try to run your currently active file. However, for most debugging scenarios, creating a launch configuration file is beneficial because it allows you to configure and save debugging setup details. VS Code keeps debugging configuration information in a launch.json file located in a .vscode folder in your workspace (project root folder) or in your user settings or workspace settings . To create a launch.json file, click the create a launch.json file link in the Run start view. VS Code will try to automatically detect your debug environment, but if this fails, you will have to choose it manually: Here is the launch configuration generated for Node.js debugging: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"skipFiles\": [ \"<node_internals>/**\" ], \"program\": \"${workspaceFolder}\\\\app.js\" } ] } If you go back to the File Explorer view ( kb(workbench.view.explorer) ), you'll see that VS Code has created a .vscode folder and added the launch.json file to your workspace. Note : You can debug a simple application even if you don't have a folder open in VS Code, but it is not possible to manage launch configurations and set up advanced debugging. The VS Code Status Bar is purple if you do not have a folder open. Note that the attributes available in launch configurations vary from debugger to debugger. You can use IntelliSense suggestions ( kb(editor.action.triggerSuggest) ) to find out which attributes exist for a specific debugger. Hover help is also available for all attributes. Do not assume that an attribute that is available for one debugger automatically works for other debuggers too. If you see green squiggles in your launch configuration, hover over them to learn what the problem is and try to fix them before launching a debug session. Review all automatically generated values and make sure that they make sense for your project and debugging environment. Launch versus attach configurations In VS Code, there are two core debugging modes, Launch and Attach , which handle two different workflows and segments of developers. Depending on your workflow, it can be confusing to know what type of configuration is appropriate for your project. If you come from a browser Developer Tools background, you might not be used to \"launching from your tool,\" since your browser instance is already open. When you open DevTools, you are simply attaching DevTools to your open browser tab. On the other hand, if you come from a server or desktop background, it's quite normal to have your editor launch your process for you, and your editor automatically attaches its debugger to the newly launched process. The best way to explain the difference between launch and attach is to think of a launch configuration as a recipe for how to start your app in debug mode before VS Code attaches to it, while an attach configuration is a recipe for how to connect VS Code's debugger to an app or process that's already running. VS Code debuggers typically support launching a program in debug mode or attaching to an already running program in debug mode. Depending on the request ( attach or launch ), different attributes are required, and VS Code's launch.json validation and suggestions should help with that. Add a new configuration To add a new configuration to an existing launch.json , use one of the following techniques: Use IntelliSense if your cursor is located inside the configurations array. Press the Add Configuration button to invoke snippet IntelliSense at the start of the array. Choose Add Configuration option in the Run menu. VS Code also supports compound launch configurations for starting multiple configurations at the same time; for more details, please read this section . In order to start a debug session, first select the configuration named Launch Program using the Configuration dropdown in the Run view. Once you have your launch configuration set, start your debug session with kb(workbench.action.debug.start) . Alternatively you can run your configuration through the Command Palette ( kb(workbench.action.showCommands) ), by filtering on Debug: Select and Start Debugging or typing 'debug ' , and selecting the configuration you want to debug. As soon as a debugging session starts, the DEBUG CONSOLE panel is displayed and shows debugging output, and the Status Bar changes color (orange for default color themes): In addition, the debug status appears in the Status Bar showing the active debug configuration. By selecting the debug status, a user can change the active launch configuration and start debugging without needing to open the Run view. Debug actions Once a debug session starts, the Debug toolbar will appear on the top of the editor. Continue / Pause kb(workbench.action.debug.continue) Step Over kb(workbench.action.debug.stepOver) Step Into kb(workbench.action.debug.stepInto) Step Out kb(workbench.action.debug.stepOut) Restart kb(workbench.action.debug.restart) Stop kb(workbench.action.debug.stop) Tip : Use the setting debug.toolBarLocation to control the location of the debug toolbar. It can either be the default floating , docked to the Run view or hidden . A floating debug toolbar can be dragged horizontally and also down to the editor area. Run mode In addition to debugging a program, VS Code supports running the program. The Debug: Run (Start Without Debugging) action is triggered with kb(workbench.action.debug.run) and uses the currently selected launch configuration. Many of the launch configuration attributes are supported in 'Run' mode. VS Code maintains a debug session while the program is running, and pressing the Stop button terminates the program. Tip : The Run action is always available, but not all debugger extensions support 'Run'. In this case, 'Run' will be the same as 'Debug'. Breakpoints Breakpoints can be toggled by clicking on the editor margin or using kb(editor.debug.action.toggleBreakpoint) on the current line. Finer breakpoint control (enable/disable/reapply) can be done in the Run view's BREAKPOINTS section. Breakpoints in the editor margin are normally shown as red filled circles. Disabled breakpoints have a filled gray circle. When a debugging session starts, breakpoints that cannot be registered with the debugger change to a gray hollow circle. The same might happen if the source is edited while a debug session without live-edit support is running. The Reapply All Breakpoints command sets all breakpoints again to their original location. This is helpful if your debug environment is \"lazy\" and \"misplaces\" breakpoints in source code that has not yet been executed. Optionally breakpoints can be shown in the editor's overview ruler by enabling the setting debug.showBreakpointsInOverviewRuler : Logpoints A Logpoint is a variant of a breakpoint that does not \"break\" into the debugger but instead logs a message to the console. Logpoints are especially useful for injecting logging while debugging production servers that cannot be paused or stopped. A Logpoint is represented by a \"diamond\" shaped icon. Log messages are plain text but can include expressions to be evaluated within curly braces ('{}'). Just like regular breakpoints, Logpoints can be enabled or disabled and can also be controlled by a condition and/or hit count. Note : Logpoints are supported by VS Code's built-in Node.js debugger, but can be implemented by other debug extensions. The Python and Java extensions, for example, support Logpoints. Data inspection Variables can be inspected in the VARIABLES section of the Run view or by hovering over their source in the editor. Variable values and expression evaluation are relative to the selected stack frame in the CALL STACK section. Variable values can be modified with the Set Value action from the variable's context menu. Additionally, you can use the Copy Value action to copy the variable's value, or Copy as Expression action to copy an expression to access the variable. Variables and expressions can also be evaluated and watched in the Run view's WATCH section. Variable names and values can be filtered by typing while the focus is on the VARIABLES section Launch.json attributes There are many launch.json attributes to help support different debuggers and debugging scenarios. As mentioned above, you can use IntelliSense ( kb(editor.action.triggerSuggest) ) to see the list of available attributes once you have specified a value for the type attribute. The following attributes are mandatory for every launch configuration: type - the type of debugger to use for this launch configuration. Every installed debug extension introduces a type: node for the built-in Node debugger, for example, or php and go for the PHP and Go extensions. request - the request type of this launch configuration. Currently, launch and attach are supported. name - the reader-friendly name to appear in the Debug launch configuration dropdown. Here are some optional attributes available to all launch configurations: presentation - using the order , group , and hidden attributes in the presentation object you can sort, group, and hide configurations and compounds in the Debug configuration dropdown and in the Debug quick pick. preLaunchTask - to launch a task before the start of a debug session, set this attribute to the label of a task specified in tasks.json (in the workspace's .vscode folder). Or, this can be set to ${defaultBuildTask} to use your default build task. postDebugTask - to launch a task at the very end of a debug session, set this attribute to the name of a task specified in tasks.json (in the workspace's .vscode folder). internalConsoleOptions - this attribute controls the visibility of the Debug Console panel during a debugging session. debugServer - for debug extension authors only : this attribute allows you to connect to a specified port instead of launching the debug adapter. serverReadyAction - if you want to open a URL in a web browser whenever the program under debugging outputs a specific message to the debug console or integrated terminal. For details see section Automatically open a URI when debugging a server program below. Many debuggers support some of the following attributes: program - executable or file to run when launching the debugger args - arguments passed to the program to debug env - environment variables (the value null can be used to \"undefine\" a variable) envFile - path to dotenv file with environment variables cwd - current working directory for finding dependencies and other files port - port when attaching to a running process stopOnEntry - break immediately when the program launches console - what kind of console to use, for example, internalConsole , integratedTerminal , or externalTerminal Variable substitution VS Code makes commonly used paths and other values available as variables and supports variable substitution inside strings in launch.json . This means that you do not have to use absolute paths in debug configurations. For example, ${workspaceFolder} gives the root path of a workspace folder, ${file} the file open in the active editor, and ${env:Name} the environment variable 'Name'. You can see a full list of predefined variables in the Variables Reference or by invoking IntelliSense inside the launch.json string attributes. { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/app.js\", \"cwd\": \"${workspaceFolder}\", \"args\": [ \"${env:USERNAME}\" ] } Platform-specific properties Launch.json supports defining values (for example, arguments to be passed to the program) that depend on the operating system where the debugger is running. To do so, put a platform-specific literal into the launch.json file and specify the corresponding properties inside that literal. Below is an example that passes \"args\" to the program differently on Windows: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/node_modules/gulp/bin/gulpfile.js\", \"args\": [\"myFolder/path/app.js\"], \"windows\": { \"args\": [\"myFolder\\\\path\\\\app.js\"] } } ] } Valid operating properties are \"windows\" for Windows, \"linux\" for Linux and \"osx\" for macOS. Properties defined in an operating system specific scope override properties defined in the global scope. Please note that the type property cannot be placed inside a platform-specific section, because type indirectly determines the platform in remote debugging scenarios, and that would result in a cyclic dependency. In the example below debugging the program always stops on entry except on macOS: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/node_modules/gulp/bin/gulpfile.js\", \"stopOnEntry\": true, \"osx\": { \"stopOnEntry\": false } } ] } Global launch configuration VS Code supports adding a \"launch\" object inside your User settings . This \"launch\" configuration will then be shared across your workspaces. For example: \"launch\": { \"version\": \"0.2.0\", \"configurations\": [{ \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${file}\" }] } Advanced breakpoint topics Conditional breakpoints A powerful VS Code debugging feature is the ability to set conditions based on expressions, hit counts, or a combination of both. Expression condition : The breakpoint will be hit whenever the expression evaluates to true . Hit count : The 'hit count' controls how many times a breakpoint needs to be hit before it will 'break' execution. Whether a 'hit count' is respected and the exact syntax of the expression vary among debugger extensions. You can add a condition and/or hit count when creating a source breakpoint (with the Add Conditional Breakpoint action) or when modifying an existing one (with the Edit Condition action). In both cases, an inline text box with a dropdown menu opens where you can enter expressions: Condition and hit count editing support is also supported for function and exception breakpoints. You can initiate condition editing from the context menu, or the new inline Edit Condition action. An example of condition editing in the BREAKPOINTS view: If a debugger does not support conditional breakpoints, the Add Conditional Breakpoint and Edit Condition actions will be missing. Inline breakpoints Inline breakpoints will only be hit when the execution reaches the column associated with the inline breakpoint. This is particularly useful when debugging minified code which contains multiple statements in a single line. An inline breakpoint can be set using kb(editor.debug.action.toggleInlineBreakpoint) or through the context menu during a debug session. Inline breakpoints are shown inline in the editor. Inline breakpoints can also have conditions. Editing multiple breakpoints on a line is possible through the context menu in the editor's left margin. Function breakpoints Instead of placing breakpoints directly in source code, a debugger can support creating breakpoints by specifying a function name. This is useful in situations where source is not available but a function name is known. A function breakpoint is created by pressing the + button in the BREAKPOINTS section header and entering the function name. Function breakpoints are shown with a red triangle in the BREAKPOINTS section. Data breakpoints If a debugger supports data breakpoints they can be set from the VARIABLES view and will get hit when the value of the underlying variable changes. Data breakpoints are shown with a red hexagon in the BREAKPOINTS section. Debug Console REPL Expressions can be evaluated with the Debug Console REPL ( Read-Eval-Print Loop ) feature. To open the Debug Console, use the Debug Console action at the top of the Debug pane or use the View: Debug Console command ( kb(workbench.debug.action.toggleRepl) ). Expressions are evaluated after you press kbstyle(Enter) and the Debug Console REPL shows suggestions as you type. If you need to enter multiple lines, use kbstyle(Shift+Enter) between the lines and then send all lines for evaluation with kbstyle(Enter) . Debug Console input uses the mode of the active editor, which means that the Debug Console input supports syntax coloring, indentation, auto closing of quotes, and other language features. Note : You must be in a running debug session to use the Debug Console REPL. Redirect input/output to/from the debug target Redirecting input/output is debugger/runtime specific, so VS Code does not have a built-in solution that works for all debuggers. Here are two approaches you might want to consider: Launch the program to debug (\"debug target\") manually in a terminal or command prompt and redirect input/output as needed. Make sure to pass the appropriate command line options to the debug target so that a debugger can attach to it. Create and run an \"attach\" debug configuration that attaches to the debug target. If the debugger extension you are using can run the debug target in VS Code's Integrated Terminal (or an external terminal), you can try to pass the shell redirect syntax (for example \"<\" or \">\") as arguments. Here's an example launch.json configuration: { \"name\": \"launch program that reads a file from stdin\", \"type\": \"node\", \"request\": \"launch\", \"program\": \"program.js\", \"console\": \"integratedTerminal\", \"args\": [ \"<\", \"in.txt\" ] } This approach requires that the \"<\" syntax is passed through the debugger extension and ends up unmodified in the Integrated Terminal. Multi-target debugging For complex scenarios involving more than one process (for example, a client and a server), VS Code supports multi-target debugging. Using multi-target debugging is simple: after you've started a first debug session, you can just launch another session. As soon as a second session is up and running, the VS Code UI switches to multi-target mode : The individual sessions now show up as top-level elements in the CALL STACK view. The debug toolbar shows the currently active session (and all other sessions are available in a dropdown menu). Debug actions (for example, all actions in the debug toolbar) are performed on the active session. The active session can be changed either by using the dropdown menu in the debug toolbar or by selecting a different element in the CALL STACK view. Compound launch configurations An alternative way to start multiple debug sessions is by using a compound launch configuration. A compound launch configuration lists the names of two or more launch configurations that should be launched in parallel. Optionally a preLaunchTask can be specified that is run before the individual debug sessions are started. { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Server\", \"program\": \"${workspaceFolder}/server.js\" }, { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Client\", \"program\": \"${workspaceFolder}/client.js\" } ], \"compounds\": [ { \"name\": \"Server/Client\", \"configurations\": [\"Server\", \"Client\"], \"preLaunchTask\": \"${defaultBuildTask}\" } ] } Compound launch configurations are displayed in the launch configuration dropdown menu. Remote debugging VS Code does not itself support remote debugging: this is a feature of the debug extension you are using, and you should consult the extension's page in the Marketplace for support and details. There is, however, one exception: the Node.js debugger included in VS Code supports remote debugging. See the Node.js Debugging topic to learn how to configure this. Automatically open a URI when debugging a server program Developing a web program typically requires opening a specific URL in a web browser in order to hit the server code in the debugger. VS Code has a built-in feature \" serverReadyAction \" to automate this task. Here is an example of a simple Node.js Express application: var express = require('express'); var app = express(); app.get('/', function (req, res) { res.send('Hello World!') }); app.listen(3000, function () { console.log('Example app listening on port 3000!') }); This application first installs a \"Hello World\" handler for the \"/\" URL and then starts to listen for HTTP connections on port 3000. The port is announced in the Debug Console and typically the developer would now type http://localhost:3000 into their browser application. The serverReadyAction feature makes it possible to add a structured property serverReadyAction to any launch config and select an \"action\" to be performed: { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/app.js\", \"serverReadyAction\": { \"pattern\": \"listening on port ([0-9]+)\", \"uriFormat\": \"http://localhost:%s\", \"action\": \"openExternally\" } } Here the pattern property describes the regular expression for matching the program's output string that announces the port. The pattern for the port number is put into parenthesis so that it is available as a regular expression capture group. In this example, we are extracting only the port number, but it is also possible to extract a full URI. The uriFormat property describes how the port number is turned into a URI. The first %s is substituted by the first capture group of the matching pattern. The resulting URI is then opened outside of VS Code (\"externally\") with the standard application configured for the URI's scheme. Trigger Debugging via Edge or Chrome Alternatively, the action can be set to debugWithEdge or debugWithChrome . In this mode, a webRoot property can be added that is passed to the Chrome or Edge debug session. To simplify things a bit, most properties are optional and we use the following fallback values: pattern : \"listening on.* (https?://\\\\S+|[0-9]+)\" which matches the commonly used messages \"listening on port 3000\" or \"Now listening on: https://localhost:5001\". uriFormat : \"http://localhost:%s\" webRoot : \"${workspaceFolder}\" Triggering an Arbitrary Launch Config In some cases you may need to configure additional options for the browser debug session--or use a different debugger entirely. You can do this by setting action to startDebugging , with a name property set to the name of the launch configuration to start when the pattern is matched. The named launch configuration must be in the same file or folder as the one with the serverReadyAction . Here the serverReadyAction feature in action: Next steps To learn about VS Code's Node.js debugging support, take a look at: Node.js - Describes the Node.js debugger, which is included in VS Code. TypeScript - The Node.js debugger also supports TypeScript debugging. To see tutorials on the basics of Node.js debugging, check out these videos: Intro Video - Debugging - Showcases the basics of debugging. Getting started with Node.js debugging - Shows how to attach a debugger to a running Node.js process. To learn about debugging support for other programming languages via VS Code extensions: C++ Python Java To learn about VS Code's task running support, go to: Tasks - Describes how to run tasks with Gulp, Grunt and Jake, and how to show errors and warnings. To write your own debugger extension, visit: Debugger Extension - Uses a mock sample to illustrate the steps required to create a VS Code debug extension. Common questions What are the supported debugging scenarios? Debugging of Node.js-based applications is supported on Linux, macOS, and Windows out of the box with VS Code. Many other scenarios are supported by VS Code extensions available in the Marketplace. I do not see any launch configurations in the Run view dropdown. What is wrong? The most common problem is that you did not set up launch.json or there is a syntax error in that file. Alternatively, you might need to open a folder, since no-folder debugging does not support launch configurations."
  },
  "guides/vscode/editor/editingevolved.html": {
    "href": "guides/vscode/editor/editingevolved.html",
    "title": "Code Navigation | Fountain of Knowledge",
    "keywords": "Code Navigation Visual Studio Code has a high productivity code editor which, when combined with programming language services, gives you the power of an IDE and the speed of a text editor. In this topic, we'll first describe VS Code's language intelligence features (suggestions, parameter hints, smart code navigation) and then show the power of the core text editor. Quick file navigation Tip: You can open any file by its name when you type kb(workbench.action.quickOpen) ( Quick Open ). The Explorer is great for navigating between files when you are exploring a project. However, when you are working on a task, you will find yourself quickly jumping between the same set of files. VS Code provides two powerful commands to navigate in and across files with easy-to-use key bindings. Hold kbstyle(Ctrl) and press kbstyle(Tab) to view a list of all files open in an editor group. To open one of these files, use kbstyle(Tab) again to pick the file you want to navigate to, then release kbstyle(Ctrl) to open it. Alternatively, you can use kb(workbench.action.navigateBack) and kb(workbench.action.navigateForward) to navigate between files and edit locations. If you are jumping around between different lines of the same file, these shortcuts allow you to navigate between those locations easily. Breadcrumbs The editor has a navigation bar above its contents called Breadcrumbs . It shows the current location and allows you to quickly navigate between folders, files, and symbols. Breadcrumbs always show the file path and, with the help of language extensions, the symbol path up to the cursor position. The symbols shown are the same as in Outline view and Go to Symbol. Selecting a breadcrumb in the path displays a dropdown with that level's siblings so you can quickly navigate to other folders and files. If the current file type has language support for symbols, you will see the current symbol path and a dropdown of other symbols at the same level and below. You can turn off breadcrumbs with the View > Show Breadcrumbs toggle or with the breadcrumbs.enabled setting . Breadcrumb customization The appearance of breadcrumbs can be customized. If you have very long paths or are only interested in either file paths or symbols paths, you can use the breadcrumbs.filePath and breadcrumbs.symbolPath settings. Both support on , off , and last and they define if or what part of the path you see. By default, breadcrumbs show file and symbol icons to the left of the breadcrumb but you can remove the icons by setting breadcrumbs.icons to false. Symbol order in Breadcrumbs You can control how symbols are ordered in the Breadcrumbs dropdown with the breadcrumbs.symbolSortOrder settings. Allowed values are: position - position in the file (default) name - alphabetical order type - symbol type order Breadcrumb keyboard navigation To interact with breadcrumbs, use the Focus Breadcrumbs command or press kb(breadcrumbs.focusAndSelect) . It will select that last element and open a dropdown that allows you to navigate to a sibling file or symbol. Use the kb(breadcrumbs.focusPrevious) and kb(breadcrumbs.focusNext) keyboard shortcuts to go to elements before or after the current element. When the dropdown appears, start typing - all matching elements will be highlighted and the best match will be selected for quick navigation. You can also interact with breadcrumbs without the dropdown. Press kb(breadcrumbs.focus) to focus the last element, use kb(breadcrumbs.focusPrevious) and kb(breadcrumbs.focusNext) to navigate, and use kb(breadcrumbs.revealFocused) to reveal the element in the editor. Go to Definition If a language supports it, you can go to the definition of a symbol by pressing kb(editor.action.revealDefinition) . If you press kbstyle(Ctrl) and hover over a symbol, a preview of the declaration will appear: Tip: You can jump to the definition with kbstyle(Ctrl+Click) or open the definition to the side with kbstyle(Ctrl+Alt+Click) . Go to Type Definition Some languages also support jumping to the type definition of a symbol by running the Go to Type Definition command from either the editor context menu or the Command Palette . This will take you to the definition of the type of a symbol. The command editor.action.goToTypeDefinition is not bound to a keyboard shortcut by default but you can add your own custom keybinding . Go to Implementation Languages can also support jumping to the implementation of a symbol by pressing kb(editor.action.goToImplementation) . For an interface, this shows all the implementors of that interface and for abstract methods, this shows all concrete implementations of that method. Go to Symbol You can navigate symbols inside a file with kb(workbench.action.gotoSymbol) . By typing kbstyle(:) the symbols will be grouped by category. Press kbstyle(Up) or kbstyle(Down) and navigate to the place you want. Open symbol by name Some languages support jumping to a symbol across files with kb(workbench.action.showAllSymbols) . Type the first letter of a type you want to navigate to, regardless of which file contains it, and press kbstyle(Enter) . Peek We think there's nothing worse than a big context switch when all you want is to quickly check something. That's why we support peeked editors. When you execute a Go to References search (via kb(editor.action.goToReferences) ), or a Peek Definition (via kb(editor.action.peekDefinition) ), we embed the result inline: You can navigate between different references in the peeked editor and make quick edits right there. Clicking on the peeked editor filename or double-clicking in the result list will open the reference in the outer editor. Tip: Additionally, the peek window is closed if you press kbstyle(Escape) or double-click in the peek editor region. You can disable this behavior with the editor.stablePeek setting . Bracket matching Matching brackets will be highlighted as soon as the cursor is near one of them. Tip: You can jump to the matching bracket with kb(editor.action.jumpToBracket) Reference information Some languages like C# support inline reference information, that is updated live. This allows you to quickly analyze the impact of your edit or the popularity of your specific method or property throughout your project: Tip: Directly invoke the Peek References action by clicking on these annotations. Tip: Reference information shown in CodeLens can be turned on or off through the editor.codeLens setting . Rename symbol Some languages support rename symbol across files. Press kb(editor.action.rename) and then type the new desired name and press kbstyle(Enter) . All usages of the symbol will be renamed, across files. Errors & warnings Warnings or Errors can be generated either via configured tasks , by rich language services, or by linters, that constantly analyze your code in the background. Since we love bug-free code, warnings and errors show up in multiple places: In the Status Bar, there is a summary of all errors and warnings counts. You can click on the summary or press kb(workbench.actions.view.problems) to display the PROBLEMS panel with a list of all current errors. If you open a file that has errors or warnings, they will be rendered inline with the text and in the overview ruler. Tip: To loop through errors or warnings in the current file, you can press kb(editor.action.marker.nextInFiles) or kb(editor.action.marker.prevInFiles) which will show an inline zone detailing the problem and possible Code Actions (if available): Code Action Warnings and Errors can provide Code Actions (also known as Quick Fixes) to help fix issues. These will be displayed in the editor in the left margin as a lightbulb. Clicking on the lightbulb will either display the Code Action options or perform the action. Outgoing link protection For your protection, VS Code displays a prompt before opening an outgoing website link from the editor. You can proceed to the external website in your browser or have the options to copy the link or cancel the request. If you choose Configure Trusted Domains , a dropdown lets you trust the exact URL, trust the URL domain and subdomains, or trust all domains to disable outgoing link protection. The option to Manage Trusted Domains , also available at any time from the Command Palette, brings up the Trusted Domains JSON file, where you can add, remove, or modify trusted domains. // You can use the \"Manage Trusted Domains\" command to open this file. // Save this file to apply the trusted domains rules. [ \"*.twitter.com\" ] The Trusted Domains JSON file also has comments with examples of the supported domain formats and a list of the domains trusted by default, such as https://*.visualstudio.com and https://*.microsoft.com . Next steps Now that you know how the editor works, time to try a few other things... Intro Video - Code Editing - Watch an introductory video on code editing features. User Interface - In case you missed a basic orientation around VS Code. Key Bindings - Learn how to modify key bindings to your preference. Debugging - This is where VS Code really shines. Common questions How can I automatically select the second entry in Quick Open instead of the first? With the command workbench.action.quickOpenPreviousEditor , you can have the second entry automatically selected in Quick Open. This can be useful if you want to select the previous entry from the list without having to invoke another keybinding: [ { \"key\": \"ctrl+p\", \"command\": \"workbench.action.quickOpenPreviousEditor\" }, { \"key\": \"ctrl+p\", \"command\": \"-workbench.action.quickOpen\" } ] How can I configure Ctrl+Tab to navigate across all editors of all groups By default, kbstyle(Ctrl+Tab) navigates between editors of the same editor group. If you want to navigate across all opened editors in all groups, you can create keyboard shortcuts for the workbench.action.quickOpenPreviousRecentlyUsedEditor and workbench.action.quickOpenLeastRecentlyUsedEditor commands: [ { \"key\": \"ctrl+tab\", \"command\": \"workbench.action.quickOpenPreviousRecentlyUsedEditor\", \"when\": \"!inEditorsPicker\" }, { \"key\": \"ctrl+shift+tab\", \"command\": \"workbench.action.quickOpenLeastRecentlyUsedEditor\", \"when\": \"!inEditorsPicker\" } ] How can I navigate between recently used editors without a picker Here is a list of commands you can use to navigate in editors without opening a picker: Key Command Command ID kb(workbench.action.openNextRecentlyUsedEditor) Open Next Recently Used Editor workbench.action.openNextRecentlyUsedEditor kb(workbench.action.openPreviousRecentlyUsedEditor) Open Previously Used Editor workbench.action.openPreviousRecentlyUsedEditor kb(workbench.action.openNextRecentlyUsedEditorInGroup) Open Next Recently Used Editor in Group workbench.action.openNextRecentlyUsedEditorInGroup kb(workbench.action.openPreviousRecentlyUsedEditorInGroup) Open Previously Used Editor in Group workbench.action.openPreviousRecentlyUsedEditorInGroup"
  },
  "guides/vscode/editor/emmet.html": {
    "href": "guides/vscode/editor/emmet.html",
    "title": "Emmet in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Emmet in Visual Studio Code Support for Emmet snippets and expansion is built right into Visual Studio Code, no extension required . Emmet 2.0 has support for the majority of the Emmet Actions including expanding Emmet abbreviations and snippets . How to expand Emmet abbreviations and snippets Emmet abbreviation and snippet expansions are enabled by default in html , haml , pug , slim , jsx , xml , xsl , css , scss , sass , less and stylus files, as well as any language that inherits from any of the above like handlebars and php . When you start typing an Emmet abbreviation, you will see the abbreviation displayed in the suggestion list. If you have the suggestion documentation fly-out open, you will see a preview of the expansion as you type. If you are in a stylesheet file, the expanded abbreviation shows up in the suggestion list sorted among the other CSS suggestions. Using Tab for Emmet expansions If you want to use the kbstyle(Tab) key for expanding the Emmet abbreviations, add the following setting: \"emmet.triggerExpansionOnTab\": true This setting allows using the kbstyle(Tab) key for indentation when text is not an Emmet abbreviation. Emmet when quickSuggestions are disabled If you have disabled the editor.quickSuggestions setting , you won't see suggestions as you type. You can still trigger suggestions manually by pressing kb(editor.action.triggerSuggest) and see the preview. Disable Emmet in suggestions If you don't want to see Emmet abbreviations in suggestions at all, then use the following setting: \"emmet.showExpandedAbbreviation\": \"never\" You can still use the command Emmet: Expand Abbreviation to expand your abbreviations. You can also bind any keyboard shortcut to the command id editor.emmet.action.expandAbbreviation as well. Emmet suggestion ordering To ensure Emmet suggestions are always on top in the suggestion list, add the following settings: \"emmet.showSuggestionsAsSnippets\": true, \"editor.snippetSuggestions\": \"top\" Emmet abbreviations in other file types To enable the Emmet abbreviation expansion in file types where it is not available by default, use the emmet.includeLanguages setting. Make sure to use language identifiers for both sides of the mapping, with the right side being the language identifier of an Emmet supported language (see the list above). For example: \"emmet.includeLanguages\": { \"javascript\": \"javascriptreact\", \"razor\": \"html\", \"plaintext\": \"pug\" } Emmet has no knowledge of these new languages, and so there might be Emmet suggestions showing up in non HTML/CSS contexts. To avoid this, you can use the following setting. \"emmet.showExpandedAbbreviation\": \"inMarkupAndStylesheetFilesOnly\" Note: If you used emmet.syntaxProfiles previously to map new file types, from VS Code 1.15 onwards you should use the setting emmet.includeLanguages instead. emmet.syntaxProfiles is meant for customizing the final output only. Emmet with multi-cursors You can use most of the Emmet actions with multi-cursors as well: Using filters Filters are special post-processors that modify the expanded abbreviation before it is output to the editor. There are 2 ways to use filters; either globally through the emmet.syntaxProfiles setting or directly in the current abbreviation. Below is an example of the first approach using the emmet.syntaxProfiles setting to apply the bem filter for all the abbreviations in HTML files: \"emmet.syntaxProfiles\": { \"html\": { \"filters\": \"bem\" } } To provide a filter for just the current abbreviation, append the filter to your abbreviation. For example, div#page|c will apply the comment filter to the div#page abbreviation. BEM filter (bem) If you use the Block Element Modifier (BEM) way of writing HTML, then bem filters are very handy for you to use. To learn more about how to use bem filters, read BEM filter in Emmet . You can customize this filter by using the bem.elementSeparator and bem.modifierSeparator preferences as documented in Emmet Preferences . Comment filter (c) This filter adds comments around important tags. By default, \"important tags\" are those tags with id and/or class attribute. For example div>div#page>p.title+p|c will be expanded to: <div> <div id=\"page\"> <p class=\"title\"></p> <!-- /.title --> <p></p> </div> <!-- /#page --> </div> You can customize this filter by using the filter.commentTrigger , filter.commentAfter and filter.commentBefore preferences as documented in Emmet Preferences . The format for the filter.commentAfter preference is different in VS Code Emmet 2.0. For example, instead of: \"emmet.preferences\": { \"filter.commentAfter\": \"\\n<!-- /<%= attr('id', '#') %><%= attr('class', '.') %> -->\" } in VS Code, you would use a simpler: \"emmet.preferences\": { \"filter.commentAfter\": \"\\n<!-- /[#ID][.CLASS] -->\" } Trim filter (t) This filter is applicable only when providing abbreviations for the Emmet: Wrap with Abbreviation command. It removes line markers from wrapped lines. Using custom Emmet snippets Custom Emmet snippets need to be defined in a json file named snippets.json . The emmet.extensionsPath setting should have the path to the directory containing this file. Below is an example for the contents of this snippets.json file. { \"html\": { \"snippets\": { \"ull\": \"ul>li[id=${1} class=${2}]*2{ Will work with html, pug, haml and slim }\", \"oll\": \"<ol><li id=${1} class=${2}> Will only work in html </ol>\", \"ran\": \"{ Wrap plain text in curly braces }\" } }, \"css\": { \"snippets\": { \"cb\": \"color: black\", \"bsd\": \"border: 1px solid ${1:red}\", \"ls\": \"list-style: ${1}\" } } } Authoring of Custom Snippets in Emmet 2.0 via the snippets.json file differs from the old way of doing the same in a few ways: Topic Old Emmet Emmet 2.0 Snippets vs Abbreviations Supports both in 2 separate properties called snippets and abbreviations The 2 have been combined into a single property called snippets. See default HTML snippets and CSS snippets CSS snippet names Can contain : Do not use : when defining snippet names. It is used to separate property name and value when Emmet tries to fuzzy match the given abbreviation to one of the snippets. CSS snippet values Can end with ; Do not add ; at end of snippet value. Emmet will add the trailing ; based on the file type (css/less/scss vs sass/stylus) or the emmet preference set for css.propertyEnd , sass.propertyEnd , stylus.propertyEnd Cursor location ${cursor} or | can be used Use only textmate syntax like ${1} for tab stops and cursor locations HTML Emmet snippets HTML custom snippets are applicable to all other markup flavors like haml or pug . When snippet value is an abbreviation and not actual HTML, the appropriate transformations can be applied to get the right output as per the language type. For example, for an unordered list with a list item, if your snippet value is ul>li , you can use the same snippet in html , haml , pug or slim , but if your snippet value is <ul><li></li></ul> , then it will work only in html files. If you want a snippet for plain text, then surround the text with {} . CSS Emmet snippets Values for CSS Emmet snippets should be a complete property name and value pair. CSS custom snippets are applicable to all other stylesheet flavors like scss , less or sass . Therefore, don't include a trailing ; at the end of the snippet value. Emmet will add it as needed based on whether the language requires it. Do not use : in the snippet name. : is used to separate property name and value when Emmet tries to fuzzy match the abbreviation to one of the snippets. Tab stops and cursors in custom snippets The syntax for tab stops in custom Emmet snippets follows the Textmate snippets syntax . Use ${1} , ${2} for tab stops and ${1:placeholder} for tab stops with placeholders. Previously, | or ${cursor} was used to denote the cursor location in the custom Emmet snippet. This is no longer supported. Use ${1} instead. Emmet configuration Below are Emmet settings that you can use to customize your Emmet experience in VS Code. emmet.includeLanguages Use this setting to add mapping between the language of your choice and one of the Emmet supported languages to enable Emmet in the former using the syntax of the latter. Make sure to use language ids for both sides of the mapping. For example: \"emmet.includeLanguages\": { \"javascript\": \"javascriptreact\", \"plaintext\": \"pug\" } emmet.excludeLanguages If there is a language where you do not want to see Emmet expansions, add it in this setting which takes an array of language id strings. emmet.syntaxProfiles See Emmet Customization of output profile to learn how you can customize the output of your HTML abbreviations. For example: \"emmet.syntaxProfiles\": { \"html\": { \"attr_quotes\": \"single\" }, \"jsx\": { \"self_closing_tag\": true } } emmet.variables Customize variables used by Emmet snippets. For example: \"emmet.variables\": { \"lang\": \"de\", \"charset\": \"UTF-16\" } emmet.showExpandedAbbreviation Controls the Emmet suggestions that show up in the suggestion/completion list. Setting Value Description never Never show Emmet abbreviations in the suggestion list for any language. inMarkupAndStylesheetFilesOnly Show Emmet suggestions only for languages that are purely markup and stylesheet based ('html', 'pug', 'slim', 'haml', 'xml', 'xsl', 'css', 'scss', 'sass', 'less', 'stylus'). always Show Emmet suggestions in all Emmet supported modes as well as the languages that have a mapping in the emmet.includeLanguages setting. Note: In the always mode, the new Emmet implementation is not context aware. For example, if you are editing a JavaScript React file, you will get Emmet suggestions not only when writing markup but also while writing JavaScript. emmet.showAbbreviationSuggestions Shows possible emmet abbreviations as suggestions. It is true by default. For example, when you type li , you get suggestions for all emmet snippets starting with li like link , link:css , link:favicon etc. This is helpful in learning Emmet snippets that you never knew existed unless you knew the Emmet cheatsheet by heart. Not applicable in stylesheets or when emmet.showExpandedAbbreviation is set to never . emmet.extensionsPath Provide the location of the directory that houses the snippets.json file which in turn has your custom snippets. emmet.triggerExpansionOnTab Set this to true to enable expanding Emmet abbreviations with kbstyle(Tab) key. We use this setting to provide the appropriate fallback to provide indentation when there is no abbreviation to expand. emmet.showSuggestionsAsSnippets If set to true , then Emmet suggestions will be grouped along with other snippets allowing you to order them as per editor.snippetSuggestions setting. Set this to true and editor.snippetSuggestions to top , to ensure that Emmet suggestions always show up on top among other suggestions. emmet.preferences You can use this setting to customize Emmet as documented in Emmet Preferences . The below customizations are currently supported: css.propertyEnd css.valueSeparator sass.propertyEnd sass.valueSeparator stylus.propertyEnd stylus.valueSeparator css.unitAliases css.intUnit css.floatUnit bem.elementSeparator bem.modifierSeparator filter.commentBefore filter.commentTrigger filter.commentAfter format.noIndentTags format.forceIndentationForTags profile.allowCompactBoolean css.fuzzySearchMinScore The format for the filter.commentAfter preference is different and simpler in Emmet 2.0. For example, instead of the older format \"emmet.preferences\": { \"filter.commentAfter\": \"\\n<!-- /<%= attr('id', '#') %><%= attr('class', '.') %> -->\" } you would use \"emmet.preferences\": { \"filter.commentAfter\": \"\\n<!-- /[#ID][.CLASS] -->\" } If you want support for any of the other preferences as documented in Emmet Preferences , please log a feature request . Next steps Emmet is just one of the great web developer features in VS Code. Read on to find out about: HTML - VS Code supports HTML with IntelliSense, closing tags, and formatting. CSS - We offer rich support for CSS, SCSS and Less. Common questions Custom tags do not get expanded in the suggestion list Custom tags when used in an expression like MyTag>YourTag or MyTag.someclass do show up in the suggestion list. But when these are used on their own like MyTag , they do not appear in the suggestion list. This is designed so to avoid noise in the suggestion list as every word is a potential custom tag. Add the following setting to enable expanding of Emmet abbreviations using tab which will expand custom tags in all cases. \"emmet.triggerExpansionOnTab\": true My HTML snippets ending with + do not work? HTML snippets ending with + like select+ and ul+ from the Emmet cheatsheet are not supported. This is a known issue in Emmet 2.0 Issue: emmetio/html-matcher#1 . Workaround is to create your own custom Emmet snippets for such scenarios. Where can I set all the preferences as documented in Emmet preferences You can set the preferences using the setting emmet.preferences . Only a subset of the preferences that are documented in Emmet preferences can be customized. Please read the preferences section under Emmet configuration . Any tips and tricks? Of course! In CSS abbreviations, when you use : , the left part is used to fuzzy match with the CSS property name and the right part is used to match with CSS property value. Take full advantage of this by using abbreviations like pos:f , trf:rx , fw:b , etc. Explore all other Emmet features as documented in Emmet Actions . Don't hesitate to create your own custom Emmet snippets ."
  },
  "guides/vscode/editor/extension-marketplace.html": {
    "href": "guides/vscode/editor/extension-marketplace.html",
    "title": "Extension Marketplace | Fountain of Knowledge",
    "keywords": "Extension Marketplace Increase the power of Visual Studio Code through Extensions The features that Visual Studio Code includes out-of-the-box are just the start. VS Code extensions let you add languages, debuggers, and tools to your installation to support your development workflow. VS Code's rich extensibility model lets extension authors plug directly into the VS Code UI and contribute functionality through the same APIs used by VS Code. This article explains how to find, install, and manage VS Code extensions from the Visual Studio Code Marketplace . Browse for extensions You can browse and install extensions from within VS Code. Bring up the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of VS Code or the View: Extensions command ( kb(workbench.view.extensions) ). This will show you a list of the most popular VS Code extensions on the VS Code Marketplace . Each extension in the list includes a brief description, the publisher, the download count, and a five star rating. You can select the extension item to display the extension's details page where you can learn more. Note: If your computer's Internet access goes through a proxy server, you will need to configure the proxy server. See Proxy server support for details. Install an extension To install an extension, select the Install button. Once the installation is complete, the Install button will change to the Manage gear button. Find and install an extension For example, let's install the popular Bracket Pair Colorizer extension. This extension adds highlighted lines linking bracket characters like [] , {} , and () so you can quickly see your code's nested sections. In the Extensions view ( kb(workbench.view.extensions) ), type 'bracket' in the search box to filter the Marketplace offerings to extensions with 'bracket' in the title or metadata. You should see the Bracket Pair Colorizer in the list. An extension is uniquely identified by its publisher and extension IDs. If you select the Bracket Pair Colorizer extension, you will see the Extension details page, where you can find the extension ID, in this case, coenraads.bracket-pair-colorizer . Knowing the extension ID can be helpful if there are several similarly named extensions. Select the Install button, and VS Code will download and install the extension from the Marketplace. When the installation is complete, the Install button will be replaced with a Manage gear button. To see the Bracket Pair Colorizer extension in action, open any source code file with nested regions and you will see highlighting lines and distinct colors for matching bracket characters. As you move the cursor around the editor, the highlighted enclosing region will change. Besides visual editor highlighting, the Bracket Pair Colorizer extension also contributes several commands, Expand Bracket Selection and Undo Bracket Selection , that you can find in the Command Palette ( kb(workbench.action.showCommands) ). These commands let you quickly expand or reduce text selection in the editor. The extension also provides settings for tuning its behavior, which you can find in the Settings editor ( kb(workbench.action.openSettings) ). If an extension doesn't provide the functionality you want, you can always Uninstall the extension from the Manage button context menu. This has been just one example of how to install and use an extension. The VS Code Marketplace has thousands of extensions supporting hundreds of programming languages and tasks. Everything from full featured language support for Java , Python , Go , and C++ to simple extensions that create GUIDs , change the color theme , or add virtual pets to the editor. Extension details On the extension details page, you can read the extension's README and review the extension's: Contributions - The extension's additions to VS Code such as settings, commands and keyboard shortcuts, language grammars, debugger, etc. Changelog - The extension repository CHANGELOG if available. Dependencies - Lists if the extension depends on any other extensions. If an extension is an Extension Pack, the Extension Pack section will display which extensions will be installed when you install the pack. Extension Packs bundle separate extensions together so they can be easily installed at one time. Extensions view filter and commands You can filter the Extensions view with the Filter Extensions context menu. There are filters to show: The list of currently installed extensions The list of outdated extensions that can be updated The list of currently enabled/disabled extensions The list of recommended extensions based on your workspace The list of globally popular extensions You can sort the extension list by Install Count or Rating in either ascending or descending order. You can learn more about extension search filters below . You can run additional Extensions view commands via the ... View and More Actions button. Through this context menu you can control extension updates, enable or disable all extensions, and use the Extension Bisect utility to isolate problematic extension behavior. Search for an extension You can clear the Search box at the top of the Extensions view and type in the name of the extension, tool, or programming language you're looking for. For example, typing 'python' will bring up a list of Python language extensions: If you know the exact identifier for an extension you're looking for, you can use the @id: prefix, for example @id:octref.vetur . Additionally, to filter or sort results, you can use the filter and sort commands, detailed below. Manage extensions VS Code makes it easy to manage your extensions. You can install, disable, update, and uninstall extensions through the Extensions view, the Command Palette (commands have the Extensions: prefix) or command-line switches. List installed extensions By default, the Extensions view will show the extensions you currently have enabled, all extensions that are recommended for you, and a collapsed view of all extensions you have disabled. You can use the Show Installed Extensions command, available in the Command Palette ( kb(workbench.action.showCommands) ) or the More Actions ( ... ) dropdown menu, to clear any text in the search box and show the list of all installed extensions, which includes those that have been disabled. Uninstall an extension To uninstall an extension, select the Manage gear button at the right of an extension entry and then choose Uninstall from the dropdown menu. This will uninstall the extension and prompt you to reload VS Code. Disable an extension If you don't want to permanently remove an extension, you can instead temporarily disable the extension by clicking the gear button at the right of an extension entry. You can disable an extension globally or just for your current Workspace. You will be prompted to reload VS Code after you disable an extension. If you want to quickly disable all installed extensions, there is a Disable All Installed Extensions command in the Command Palette and More Actions ( ... ) dropdown menu. Extensions remain disabled for all VS Code sessions until you re-enable them. Enable an extension Similarly if you have disabled an extension (it will be in the Disabled section of the list and marked Disabled ), you can re-enable it with the Enable or Enable (Workspace) commands in the dropdown menu. There is also an Enable All Extensions command in the More Actions ( ... ) dropdown menu. Extension auto-update VS Code checks for extension updates and installs them automatically. After an update, you will be prompted to reload VS Code. If you'd rather update your extensions manually, you can disable auto-update with the Disable Auto Updating Extensions command that sets the extensions.autoUpdate setting to false . If you don't want VS Code to even check for updates, you can set the extensions.autoCheckUpdates setting to false. Update an extension manually If you have extensions auto-update disabled, you can quickly look for extension updates by using the Show Outdated Extensions command that uses the @outdated filter. This will display any available updates for your currently installed extensions. Select the Update button for the outdated extension and the update will be installed and you'll be prompted to reload VS Code. You can also update all your outdated extensions at one time with the Update All Extensions command. If you also have automatic checking for updates disabled, you can use the Check for Extension Updates command to check which of your extensions can be updated. Recommended extensions You can see a list of recommended extensions using Show Recommended Extensions , which sets the @recommended filter . Extension recommendations can either be: Workspace Recommendations - Recommended by other users of your current workspace. Other Recommendations - Recommended based on recently opened files. See the section below to learn how to contribute recommendations for other users in your project. Ignoring recommendations To dismiss a recommendation, select on the extension item to open the Details page and then select the Manage gear button to display the context menu. Select the Ignore Recommendation menu item. Ignored recommendations will no longer be recommended to you. Configuring extensions VS Code extensions may have very different configurations and requirements. Some extensions contribute settings to VS Code, which can be modified in the Settings editor. Other extensions may have their own configuration files. Extensions may also require installation and setup of additional components like compilers, debuggers, and command-line tools. Consult the extension's README (visible in the Extensions view details page) or go to the extension page on the VS Code Marketplace (click on the extension name in the details page). Many extensions are open source and have a link to their repository on their Marketplace page. Command line extension management To make it easier to automate and configure VS Code, it is possible to list, install, and uninstall extensions from the command line . When identifying an extension, provide the full name of the form publisher.extension , for example ms-python.python . Example: code --extensions-dir <dir> Set the root path for extensions. code --list-extensions List the installed extensions. code --show-versions Show versions of installed extensions, when using --list-extension. code --install-extension (<extension-id> | <extension-vsix-path>) Installs an extension. code --uninstall-extension (<extension-id> | <extension-vsix-path>) Uninstalls an extension. code --enable-proposed-api (<extension-id>) Enables proposed API features for extensions. Can receive one or more extension IDs to enable individually. You can see the extension ID on the extension details page next to the extension name. Extensions view filters The Extensions view search box supports filters to help you find and manage extensions. You may have seen filters such as @installed and @recommended if you used the commands Show Installed Extensions and Show Recommended Extensions . Also, there are filters available to let you sort by popularity or ratings and search by category (for example 'Linters') and tags (for example 'node'). You can see a complete listing of all filters and sort commands by typing @ in the extensions search box and navigating through the suggestions: Here are the Extensions view filters: @builtin - Show extensions that come with VS Code. Grouped by type (Programming Languages, Themes, etc.). @disabled - Show disabled installed extensions. @installed - Show installed extensions. @outdated - Show outdated installed extensions. A newer version is available on the Marketplace. @enabled - Show enabled installed extensions. Extensions can be individually enabled/disabled. @recommended - Show recommended extensions. Grouped as Workspace specific or general use. @category - Show extensions belonging to specified category. Below are a few of supported categories. For a complete list, type @category and follow the options in the suggestion list: @category:themes @category:formatters @category:linters @category:snippets These filters can be combined as well. For example: Use @installed @category:themes to view all installed themes. If no filter is provided, the Extensions view displays the currently installed and recommended extensions. Sorting You can sort extensions with the @sort filter, which can take the following values: installs - Sort by Marketplace installation count, in descending order. rating - Sort by Marketplace rating (1-5 stars), in descending order. name - Sort alphabetically by extension name. Categories and tags Extensions can set Categories and Tags describing their features. You can filter on category and tag by using category: and tag: . Supported categories are: [Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs, Data Science, Machine Learning, Visualization, Notebooks] . They can be accessed through IntelliSense in the extensions search box: Note that you must surround the category name in quotes if it is more than one word (for example, category:\"SCM Providers\" ). Tags may contain any string and are not provided by IntelliSense, so review the Marketplace to find helpful tags. Install from a VSIX You can manually install a VS Code extension packaged in a .vsix file. Using the Install from VSIX command in the Extensions view command dropdown, or the Extensions: Install from VSIX command in the Command Palette , point to the .vsix file. You can also install using the VS Code --install-extension command-line switch providing the path to the .vsix file. code --install-extension myextension.vsix You may provide the --install-extension multiple times on the command line to install multiple extensions at once. If you'd like to learn more about packaging and publishing extensions, see our Publishing Extensions article in the Extension API. Workspace recommended extensions A good set of extensions can make working with a particular workspace or programming language more productive and you'd often like to share this list with your team or colleagues. You can create a recommended list of extensions for a workspace with the Extensions: Configure Recommended Extensions (Workspace Folder) command. In a single folder workspace, the command creates an extensions.json file located in the workspace .vscode folder where you can add a list of extensions identifiers ({publisherName}.{extensionName}). In a multi-root workspace , the command will open your .code-workspace file where you can list extensions under extensions.recommendations . You can still add extension recommendations to individual folders in a multi-root workspace by using the Extensions: Configure Recommended Extensions (Workspace Folder) command. An example extensions.json could be: { \"recommendations\": [ \"dbaeumer.vscode-eslint\", \"esbenp.prettier-vscode\" ] } which recommends a linter extension and a code formatter extension. An extension is identified using its publisher name and extension identifier publisher.extension . You can see the name on the extension's detail page. VS Code will provide you with auto-completion for installed extensions inside these files. . VS Code prompts a user to install the recommended extensions when a workspace is opened for the first time. The user can also review the list with the Extensions: Show Recommended Extensions command. Next steps Here are a few topics you may find interesting... Extension API - Start learning about the VS Code extension API. Your First Extension - Try creating a simple Hello World extension. Publishing to the Marketplace - Publish your own extension to the VS Code Marketplace. Common questions Where are extensions installed? Extensions are installed in a per user extensions folder. Depending on your platform, the location is in the following folder: Windows %USERPROFILE%\\.vscode\\extensions macOS ~/.vscode/extensions Linux ~/.vscode/extensions You can change the location by launching VS Code with the --extensions-dir <dir> command-line option . Whenever I try to install any extension, I get a connect ETIMEDOUT error You may see this error if your machine is going through a proxy server to access the Internet. See the Proxy server support section in the setup topic for details. Can I download an extension directly from the Marketplace? Some users prefer to download an extension once from the Marketplace and then install it multiple times from a local share. This is useful when there are connectivity concerns or if your development team wants to use a fixed set of extensions. To download an extension, navigate to the details page for the specific extension within the Marketplace . On that page, there is a Download Extension link in the Resources section, which is located on the right-hand side of the page. Once downloaded, you can then install the extension via the Install from VSIX command in the Extensions view command dropdown. Can I stop VS Code from providing extension recommendations? Yes, if you would prefer to not have VS Code display extension recommendations in the Extensions view or through notifications, you can modify the following settings: extensions.showRecommendationsOnlyOnDemand - Set to true to remove the RECOMMENDED section. extensions.ignoreRecommendations - Set to true to silence extension recommendation notifications. The Show Recommended Extensions command is always available if you want to see recommendations. Can I trust extensions from the Marketplace? The Marketplace runs a virus scan on each extension package that's published to ensure its safety. The virus scan is run for each new extension and for each extension update. Until the scan is all clear, the extension won't be published in the Marketplace for public usage. The Marketplace also prevents extension authors from name-squatting on official publishers such as Microsoft and RedHat. If a malicious extension is reported and verified, or a vulnerability is found in an extension dependency: The extension is removed from the Marketplace. The extension is added to a kill list so that if it has been installed, it will be automatically uninstalled by VS Code. The Marketplace also provides you with resources to make an informed decision about the extensions you install: Ratings & Review - Read what others think about the extension. Q & A - Review existing questions and the level of the publisher's responsiveness. You can also engage with the extension's publisher(s) if you have concerns. Issues, Repository, and License - Check if the publisher has provided these and if they have the support you expect. If you do see an extension that looks suspicious, you can report the extension to the Marketplace with the Report Abuse link at the bottom of the extension More Info section."
  },
  "guides/vscode/editor/github.html": {
    "href": "guides/vscode/editor/github.html",
    "title": "Working with GitHub in VS Code | Fountain of Knowledge",
    "keywords": "Working with GitHub in VS Code Using GitHub with Visual Studio Code lets you share your source code and collaborate with others. GitHub integration is provided through the GitHub Pull Requests and Issues extension. Install the GitHub Pull Requests and Issues extension To get started with the GitHub in VS Code, you'll need to create an account and install the GitHub Pull Requests and Issues extension. In this topic, we'll demonstrate how you can use some of your favorite parts of GitHub without leaving VS Code. If you're new to source control and want to start there, you can learn about VS Code's source control integration . Getting started with GitHub Pull Requests and Issues Once you've installed the GitHub Pull Requests and Issues extension, you'll need to sign in. Follow the prompts to authenticate with GitHub in the browser and return to VS Code. If you are not redirected to VS Code, you can add your authorization token manually. In the browser window, you will receive your authorization token. Copy the token, and switch back to VS Code. Select Signing in to github.com... in the Status bar, paste the token, and hit kbstyle(Enter) . Setting up a repository Cloning a repository You can search for and clone a repository from GitHub using the Git: Clone command in the Command Palette ( kb(workbench.action.showCommands) ) or by using the Clone Repository button in the Source Control view (available when you have no folder open). Authenticating with an existing repository Enabling authentication through GitHub happens when you run any Git action in VS Code that requires GitHub authentication, such as pushing to a repository that you're a member of or cloning a private repository. You don't need to have any special extensions installed for authentication; it is built into VS Code so that you can efficiently manage your repository. When you do something that requires GitHub authentication, you'll see a prompt to sign in: Follow the steps to sign into GitHub and return to VS Code. If authenticating with an existing repository doesn't work automatically, you may need to manually provide a personal access token. See Personal Access Token authentication for more information. Note that there are several ways to authenticate to GitHub, including using your username and password with two-factor authentication (2FA), a personal access token, or an SSH key. See About authentication to GitHub for more information and details about each option. Note : If you'd like to work on a repository without cloning the contents to you local machine, you can install the GitHub Repositories extension to browse and edit directly on GitHub. You can learn more below in the GitHub Repositories extension section. Editor integration Hovers When you have a repository open and a user is @-mentioned, you can hover over that username and see a GitHub-style hover. There is a similar hover for #-mentioned issue numbers, full GitHub issue URLs, and repository specified issues. Suggestions User suggestions are triggered by the \"@\" character and issue suggestions are triggered by the \"#\" character. Suggestions are available in the editor and in the Source Control view's input box. The issues that appear in the suggestion can be configured with the GitHub Issues: Queries ( githubIssues.queries ) setting . The queries use the GitHub search syntax . You can also configure which files show these suggestions using the settings GitHub Issues: Ignore Completion Trigger ( githubIssues.ignoreCompletionTrigger ) and GitHub Issues: Ignore User Completion Trigger ( githubIssues.ignoreUserCompletionTrigger ). These settings take an array of language identifiers to specify the file types. // Languages that the '#' character should not be used to trigger issue completion suggestions. \"githubIssues.ignoreCompletionTrigger\": [ \"python\" ] Pull requests From the Pull Requests view you can view, manage, and create pull requests. The queries used to display pull requests can be configured with the GitHub Pull Requests: Queries ( githubPullRequests.queries ) setting and use the GitHub search syntax . \"githubPullRequests.queries\": [ { \"label\": \"Assigned To Me\", \"query\": \"is:open assignee:${user}\" }, Creating Pull Requests You can use the GitHub Pull Requests: Create Pull Request command or use the + button in the Pull Requests view to create a pull request. If you have not already pushed your branch to a remote, the extension will do this for you. You can use the last commit message, the branch name, or write a custom title for the pull request. If your repository has a pull request template, this will automatically be used for the description. Reviewing Pull requests can be reviewed from the Pull Requests view. You can assign reviewers and labels, add comments, approve, close, and merge all from the pull request description. From the description page, you can also easily checkout the pull request locally using the Checkout button. This will add a new Changes in Pull Request view from which you can view diffs of the current changes as well as all commits and the changes within these commits. Files that have been commented on are decorated with a diamond icon. To view the file on disk, you can use the Open File inline action. The diff editors from this view use the local file, so file navigation, IntelliSense, and editing work as normal. You can add comments within the editor on these diffs. Both adding single comments and creating a whole review is supported. Issues Creating issues Issues can be created from the + button in the Issues view and by using the GitHub Issues: Create Issue from Selection and GitHub Issues: Create Issue from Clipboard commands. They can also be created using a Code Action for \"TODO\" comments. You can configure the trigger for the Code Action using the GitHub Issues: Create Issue Triggers ( githubIssues.createIssueTriggers ) setting. The default issue triggers are: \"githubIssues.createIssueTriggers\": [ \"TODO\", \"todo\", \"BUG\", \"FIXME\", \"ISSUE\", \"HACK\" ] Working on issues From the Issues view, you can see your issues and work on them. By default, when you start working on an issue, a branch will be created for you. You can configure the name of the branch using the GitHub Issues: Working Issue Branch ( githubIssues.workingIssueBranch ) setting. The commit message input box in the Source Control view will be populated with a commit message, which can be configured with GitHub Issues: Working Issue Format SCM ( githubIssues.workingIssueFormatScm ). If your workflow doesn't involve creating a branch, or if you want to be prompted to enter a branch name every time, you can skip that step by turning off the GitHub Issues: Use Branch For Issues ( githubIssues.useBranchForIssues ) setting. GitHub Repositories extension The GitHub Repositories extension lets you quickly browse, search, edit, and commit to any remote GitHub repository directly from within Visual Studio Code, without needing to clone the repository locally. This can be fast and convenient for many scenarios, where you just need to review source code or make a small change to a file or asset. Opening a repository Once you have installed the GitHub Repositories extension, you can open a repository with the GitHub Repositories: Open Repository... command from the Command Palette ( kb(workbench.action.showCommands) ) or by clicking the Remote indicator in the lower left of the Status bar. When you run the Open Repository command, you then choose whether to open a repository from GitHub, open a Pull Request from GitHub, or reopen a repository that you had previously connected to. If you haven't logged into GitHub from VS Code before, you'll be prompted to authenticate with your GitHub account. You can provide the repository URL directly or search GitHub for the repository you want by typing in the text box. Once you have selected a repository or Pull Request, the VS Code window will reload and you will see the repository contents in the File Explorer. You can then open files (with full syntax highlighting and bracket matching), make edits, and commit changes, just like you would working on a local clone of a repository. One difference from working with a local repository is that when you commit a change with the GitHub Repository extension, the changes are pushed directly to the remote repository, similar to if you were working in the GitHub web interface. Another feature of the GitHub Repositories extension is that every time you open a repository or branch, you get the up-to-date sources available from GitHub. You don't need to remember to pull to refresh as you would with a local repository. Switching branches You can easily switch between branches by clicking on the branch indicator in the Status bar. One great feature of the GitHub Repositories extension is that you can switch branches without needing to stash uncommitted changes. The extension remembers your changes and reapplies them when you switch branches. Remote Explorer You can quickly reopen remote repositories with the Remote Explorer available on the Activity bar. This view shows you the previously opened repositories and branches. Create Pull Requests If your workflow uses Pull Requests, rather than direct commits to a repository, you can create a new PR from the Source Control view. You'll be prompted to provide a title and create a new branch. Once you have created a Pull Request, you can use the GitHub Pull Request and Issues extension to review, edit, and merge your PR as described earlier in this topic. Virtual file system Without a repository's files on your local machine, the GitHub Repositories extension creates a virtual file system in memory so you can view file contents and make edits. Using a virtual file system means that some operations and extensions which assume local files are not enabled or have limited functionality. Features such as tasks, debugging, and integrated terminals are not enabled and you can learn about the level of support for the virtual file system via the features are not available link in the Remote indicator hover. Extension authors can learn more about running in a virtual file system and workspace in the Virtual Workspaces extension author's guide . Continue Working on... Sometimes you'll want to switch to working on a repository in a development environment with support for a local file system and full language and development tooling. The GitHub Repositories extension makes it easy for you to clone the repository locally or into a Docker container (if you have Docker and the Microsoft Docker extension installed) with the GitHub Repositories: Continue Working on... command available from the Command Palette ( kb(workbench.action.showCommands) ) or by clicking on the the Remote indicator in the Status bar. If you are using the browser-based editor , the \"Continue Working On...\" command has the options to open the repository locally or within a cloud-hosted environment in GitHub Codespaces ."
  },
  "guides/vscode/editor/integrated-terminal.html": {
    "href": "guides/vscode/editor/integrated-terminal.html",
    "title": "Integrated Terminal | Fountain of Knowledge",
    "keywords": "Integrated Terminal Visual Studio Code includes a fully featured integrated terminal that conveniently starts at the root of your workspace. It provides integration with the editor to support features like links and error detection . To open the terminal: Use the kb(workbench.action.terminal.toggleTerminal) keyboard shortcut with the backtick character. Use the View > Terminal menu command. From the Command Palette ( kb(workbench.action.showCommands) ), use the View: Toggle Integrated Terminal command. Note: Open an external terminal with the kb(workbench.action.terminal.openNativeConsole) keyboard shortcut if you prefer to work outside VS Code. Managing terminals The terminal tabs view is on the right side of the terminal view. Each terminal has an entry with its name, icon, color, and group decoration (if any). Tip: Change the tabs location using the terminal.integrated.tabs.location setting. Terminal instances can be added by clicking the + icon on the top-right of the TERMINAL panel, selecting a profile from the terminal dropdown, or by triggering the kb(workbench.action.terminal.new) command. This action creates another entry in the tab list associated with that terminal. Remove terminal instances by hovering a tab and selecting the Trash Can button, selecting a tab item and pressing kbstyle(Delete) , by using Terminal: Kill Active the Active Terminal Instance command, or via the right-click context menu. Navigate between terminal groups using focus next kb(workbench.action.terminal.focusNext) and focus previous kb(workbench.action.terminal.focusPrevious) . Icons may appear to the right of the terminal title on the tab label when a terminal's status changes. Some examples are on bell (macOS) and for tasks, displaying a check mark when there are no errors and an X otherwise. Hover the icon to read status information, which may contain actions. Grouping Split the terminal by: On hover, selecting the inline split button. Right-clicking the context menu and selecting the Split menu option. kbstyle(Alt) click on a tab, the + button, or the single tab on the terminal panel. Triggering the kb(workbench.action.terminal.split) command. Navigate between terminals in a group by focusing the previous pane, kb(workbench.action.terminal.focusPreviousPane) , and focusing the next pane, kb(workbench.action.terminal.focusNextPane) . Tabs support drag and drop to allow rearranging, dragging an entry in a terminal group into the empty will remove it from the group (for example, unsplit), dragging a tab into the main terminal area allows joining a group. Unsplit a split terminal by triggering the Terminal: Unsplit Terminal command. Customizing Tabs Change the terminal's name, icon, and tab color via the right-click context menu or by triggering the following commands: Command Command ID Terminal: Rename workbench.action.terminal.rename Terminal: Change Icon workbench.action.terminal.changeIcon Terminal: Change Color workbench.action.terminal.changeColor Tip: Go back to the old version by setting terminal.integrated.tabs.enabled:false Terminal profiles Terminal profiles are platform-specific shell configurations comprised of an executable path, arguments, and other customizations. Configure your default integrated terminal by running the Terminal: Select Default Profile command, which is also accessible via the terminal dropdown. The terminal's shell defaults to $SHELL on Linux and macOS and PowerShell on Windows. VS Code will automatically detect most standard shells that can then be configured as the default. Configuring profiles To create a new profile, run the Terminal: Select Default Profile command and activate the configure button on the right side of the shell to base it on. This will add a new entry to your settings that can be tweaked manually in your settings.json file. Profiles can be created using either a path or a source , as well as a set of optional arguments. A source is available only on Windows and can be used to let VS Code detect the install of either PowerShell or Git Bash . Alternatively a path pointing directly to the shell executable can be used. Here are some example profile configurations: { \"terminal.integrated.profiles.windows\": { \"PowerShell -NoProfile\": { \"source\": \"PowerShell\", \"args\": [\"-NoProfile\"] } }, \"terminal.integrated.profiles.linux\": { \"zsh (login)\": { \"path\": \"zsh\", \"args\": [\"-l\"] } } } Other arguments supported in profiles include: overrideName : A boolean indicating whether or not to replace the dynamic terminal title that detects what program is running with the static profile name. env : A map defining environment variables and their values, set the variable to null to delete it from the environment. This can be configured for all profiles using the terminal.integrated.env.<platform> setting. icon : An icon ID to use for the profile. color : A theme color ID to style the icon. Tip: Path, args, and env all support resolving variables The default profile can be defined manually with the terminal.integrated.defaultProfile.* settings. This should be set to the name of an existing profile: { \"terminal.integrated.profiles.windows\": { \"my-pwsh\": { \"source\": \"PowerShell\", \"args\": [\"-NoProfile\"] } }, \"terminal.integrated.defaultProfile.windows\": \"my-pwsh\" } Tip: The integrated terminal shell is running with the permissions of VS Code. If you need to run a shell command with elevated (administrator) or different permissions, use platform utilities such as runas.exe within a terminal. The default profile can be defined manually with the terminal.integrated.defaultProfile.* settings. This should be set to the name of an existing profile: { \"terminal.integrated.profiles.windows\": { \"PowerShell -NoProfile\": { \"source\": \"PowerShell\", \"args\": [\"-NoProfile\"] } }, \"terminal.integrated.defaultProfile.windows\": \"PowerShell -NoProfile\" } Removing built-in profiles To remove entries from the terminal dropdown, set the name of the profile to null . For example, to remove the Git Bash profile on Windows, use this setting: { \"terminal.integrated.profiles.windows\": { \"Git Bash\": null } } Configuring the task/debug profile By default, the task/debug features will use the default profile. To override that, use the terminal.integrated.automationShell.<platform> setting: { \"terminal.integrated.defaultProfile.osx\": \"fish\", // Use a fully POSIX-compatible shell and avoid running a complex ~/.config/fish/config.fish // for tasks and debug \"terminal.integrated.automationShell.osx\": \"/bin/sh\" } Working directory By default, the terminal will open at the folder that is opened in the Explorer. The terminal.integrated.cwd setting allows specifying a custom path to open instead: { \"terminal.integrated.cwd\": \"/home/user\" } Split terminals on Windows will start in the directory that the parent terminal started with. On macOS and Linux, split terminals will inherit the current working directory of the parent terminal. This behavior can be changed using the terminal.integrated.splitCwd setting: { \"terminal.integrated.splitCwd\": \"workspaceRoot\" } There are also extensions available that give more options such as Terminal Here . Terminal process reconnection Local and remote terminal processes are restored on window reload, such as when an extension install requires a reload. The terminal will be reconnected and the UI state of the terminals will be restored, including the active tab and split terminal relative dimensions. Links The terminal features link detection, showing an underline when files or URLs are hovered with the mouse that will go to the target when kbstyle(Ctrl) / kbstyle(Cmd) is held. If a file or URL cannot be detected, they are still surfaced as \"low confidence\" links, which only show an underline when is held. These low confidence links will search the workspace for the term, opening the match if one is found. Clicking a file link will either open that document in an editor or produce a Quick Pick with all matches. Extensions make use of links in the terminal, such as GitLens, to identify branches. Local echo On some remote connections, there's a delay between typing and seeing the characters on the terminal, as a result of the round trip the data has to make from VS code to the process. Local echo attempts to predict modifications and cursor movements made locally in the terminal in order to decrease this lag. When enabled, dimmed characters appear as you type. The dimmed style can be changed using the setting terminal.integrated.localEchoStyle . To disable the feature, set terminal.integrated.localEchoLatencyThreshold to -1 . To enable it all of the time, set it to 0 . Terminal appearance Customize the terminal's appearance using the following settings : Font: family, size, and weight Spacing: line height and letter spacing Cursor: style, width, and blinking Copy & Paste The keybindings for copy and paste follow platform standards: Linux: kbstyle(Ctrl+Shift+C) and kbstyle(Ctrl+Shift+V) , selection paste is available with kbstyle(Shift+Insert) macOS: kbstyle(Cmd+C) and kbstyle(Cmd+V) Windows: kbstyle(Ctrl+C) and kbstyle(Ctrl+V) Using the mouse Right-click behavior The right-click behavior differs based on the platform: Linux: Show the context menu. macOS: Select the word under the cursor and show the context menu. Windows: Copy and drop selection if there is a selection, otherwise paste. This can be configured using the terminal.integrated.rightClickBehavior setting. Alt click kbstyle(Alt) left click will reposition the cursor to underneath the mouse. This works by simulating arrow key strokes, which may fail for some shells or programs. This feature can be disabled. Keybindings and the shell While focus is in the integrated terminal, many key bindings will not work as the keystrokes are passed to and consumed by the terminal itself. There is a hardcoded list of commands, which skip being processed by the shell and instead get sent to the VS Code keybinding system. Customize this list with the terminal.integrated.commandsToSkipShell setting. Commands can be added to this list by adding the command name to the list, and removed by adding the command name to the list prefixed with a - . { \"terminal.integrated.commandsToSkipShell\": [ // Ensure the toggle sidebar visibility keybinding skips the shell \"workbench.action.toggleSidebarVisibility\", // Send quick open's keybinding to the shell \"-workbench.action.quickOpen\", ] } Look at the setting details to see the complete list of default commands. Tip: To override terminal.integrated.commandsToSkipShell and send keybindings to the shell instead of the workbench, set terminal.integrated.sendKeybindingsToShell . Chord keybindings in the terminal By default, when a chord keybinding is the highest priority keybinding, it will always skip the terminal shell (bypassing terminal.integrated.commandsToSkipShell ) and be evaluated by VS Code instead of the terminal. This is typically the desired behavior unless you're on Windows/Linux and want your shell to use ctrl+k (for bash this cuts the line after the cursor). This can be disabled with the following setting: { \"terminal.integrated.allowChords\": false } Send text via a keybinding The workbench.action.terminal.sendSequence command can be used to send a specific sequence of text to the terminal, including escape sequences. This enables things like sending arrow keys, enter, cursor moves, etc. For example, the below sequence jumps over the word to the left of the cursor ( kbstyle(Ctrl+Left) ) and presses backspace: { \"key\": \"ctrl+u\", \"command\": \"workbench.action.terminal.sendSequence\", \"args\": { \"text\": \"\\u001b[1;5D\\u007f\" } } This feature supports variable substitution . Note that the command only works with the \\u0000 format for using characters via their character code (not \\x00 ). Read more about these hex code and the sequences terminals work with on the following resources: XTerm Control Sequences List of C0 and C1 control codes Find The integrated terminal has find functionality that can be triggered with kb(workbench.action.terminal.focusFind) . If you want kbstyle(Ctrl+F) to go to the shell instead of launching the Find control on Linux and Windows, you will need to add the following to your settings.json which will tell the terminal not to skip the shell for keybindings matching the workbench.action.terminal.focusFind command: { \"terminal.integrated.commandsToSkipShell\": [ \"-workbench.action.terminal.focusFind\" ], } Run selected text To use the runSelectedText command, select text in an editor and run the command Terminal: Run Selected Text in Active Terminal via the Command Palette ( kb(workbench.action.showCommands) ): The terminal will attempt to run the selected text. If no text is selected in the active editor, the line that the cursor is on is run in the terminal. Tip: Also run the active file using the command workbench.action.terminal.runActiveFile . Automating launching of terminals The Tasks feature can be used to automate the launching of terminals, for example the following .vscode/tasks.json file will launch a Command Prompt and PowerShell terminal in a single terminal group when the window starts: { \"version\": \"2.0.0\", \"presentation\": { \"echo\": false, \"reveal\": \"always\", \"focus\": false, \"panel\": \"dedicated\", \"showReuseMessage\": true }, \"tasks\": [ { \"label\": \"Create terminals\", \"dependsOn\": [ \"First\", \"Second\" ], // Mark as the default build task so cmd/ctrl+shift+b will create them \"group\": { \"kind\": \"build\", \"isDefault\": true }, // Try start the task on folder open \"runOptions\": { \"runOn\": \"folderOpen\" } }, { // The name that shows up in terminal tab \"label\": \"First\", // The task will launch a shell \"type\": \"shell\", \"command\": \"\", // Set the shell type \"options\": { \"shell\": { \"executable\": \"cmd.exe\", \"args\": [] } }, // Mark as a background task to avoid the spinner animation on the terminal tab \"isBackground\": true, \"problemMatcher\": [], // Create the tasks in a terminal group \"presentation\": { \"group\": \"my-group\" } }, { \"label\": \"Second\", \"type\": \"shell\", \"command\": \"\", \"options\": { \"shell\": { \"executable\": \"pwsh.exe\", \"args\": [] } }, \"isBackground\": true, \"problemMatcher\": [], \"presentation\": { \"group\": \"my-group\" } } ] } This file could be committed to the repository to share it with other developers or alternatively created as a user task via the workbench.action.tasks.openUserTasks command. Next steps The basics of the terminal have been covered in this document, read on to find out more about: Tasks - Tasks let you integrate with external tools and leverage the terminal heavily. Mastering VS Code's Terminal - An external blog with plenty of power user tips for the terminal. Explore the rest of the terminal commands by browsing your keybindings.json file within VS Code. Common questions I'm having problems launching the terminal There's a dedicated troubleshooting guide for these sorts of problems. Can I use the integrated terminal with the Windows Subsystem for Linux? Yes. Select the Windows Subsystem for Linux (WSL) bash shell as your terminal default. If you have WSL enabled (through Windows Features), select WSL Bash from the terminal Select Default Shell dropdown. See Developing in WSL for details on working in WSL and the Remote - WSL extension. Why is VS Code shortcut X not working when the terminal has focus? Currently the terminal consumes many key bindings, preventing Visual Studio Code from reacting to them. An example of this is kbstyle(Ctrl+B) to open the Side Bar on Linux and Windows. This is necessary as various terminal programs and/or shells may respond to these key bindings themselves. Use the terminal.integrated.commandsToSkipShell setting to prevent specific key bindings from being handled by the terminal. Can I use Cmder's shell with the terminal on Windows? Yes, to use the Cmder shell in VS Code, you need to add the following settings to your settings.json file: { \"terminal.integrated.profiles.windows\": { \"cmder\": { \"path\": \"C:\\\\WINDOWS\\\\System32\\\\cmd.exe\", \"args\": [\"/K\", \"C:\\\\cmder\\\\vendor\\\\bin\\\\vscode_init.cmd\"] } }, \"terminal.integrated.defaultProfile.windows\": \"cmder\" } You may refer to Cmder's wiki for more information. Why is Cmd+k/Ctrl+k not clearing the terminal? Normally kbstyle(Cmd+k) / kbstyle(Ctrl+k) clears the terminal on macOS/Windows, but this can stop working when chord keybindings are added either by the user or extensions. The kbstyle(Cmd+k) / kbstyle(Ctrl+k) keybindings rely on the VS Code keybinding priority system that defines which keybinding is active at any given time (user > extension > default). In order to fix this, you need to redefine your user keybinding that will have priority, preferably at the bottom of your user keybindings.json file: macOS: { \"key\": \"cmd+k\", \"command\": \"workbench.action.terminal.clear\", \"when\": \"terminalFocus\" }, Windows: { \"key\": \"ctrl+k\", \"command\": \"workbench.action.terminal.clear\", \"when\": \"terminalFocus\" }, Why is nvm complaining about a prefix option when the integrated terminal is launched? nvm (Node Version Manager) users often see this error for the first time inside VS Code's integrated terminal: nvm is not compatible with the npm config \"prefix\" option: currently set to \"/usr/local\" Run `npm config delete prefix` or `nvm use --delete-prefix v8.9.1 --silent` to unset it This is mostly a macOS problem and does not happen in external terminals. The typical reasons for this are the following: npm was globally installed using another instance of node that is somewhere in your path (such as /usr/local/bin/npm ). In order to get the development tools on the $PATH , VS Code will launch a bash login shell on start up. This means that your ~/.bash_profile has already run and when an integrated terminal launches, it will run another login shell, reordering the $PATH potentially in unexpected ways. To resolve this issue, you need to track down where the old npm is installed and remove both it and its out of date node_modules. Find the nvm initialization script and running which npm before it runs, which should print the path when you launch a new terminal. Once you have the path to npm, find the old node_modules by resolving the symlink by running a command something like this: ls -la /usr/local/bin | grep \"np[mx]\" This will give you the resolved path at the end: ... npm -> ../lib/node_modules/npm/bin/npm-cli.js ... npx -> ../lib/node_modules/npm/bin/npx-cli.js From there, removing the files and relaunching VS Code should fix the issue: rm /usr/local/bin/npm /usr/local/lib/node_modules/npm/bin/npm-cli.js rm /usr/local/bin/npx /usr/local/lib/node_modules/npm/bin/npx-cli.js Can I use Powerline fonts in the integrated terminal? Yes. Specify Powerline fonts with the terminal.integrated.fontFamily setting . { \"terminal.integrated.fontFamily\": \"Meslo LG M DZ for Powerline\" } Note that you want to specify the font family, not an individual font like Meslo LG M DZ Regular for Powerline where Regular is the specific font name. How do I configure zsh on macOS to jump words with Ctrl+Left/Right arrow? By default, kbstyle(Ctrl+Left/Right) arrow will jump words in bash. Configure the same for zsh by adding these keybindings: [ { \"key\": \"ctrl+left\", \"command\": \"workbench.action.terminal.sendSequence\", \"args\": { \"text\": \"\\u001bb\" } }, { \"key\": \"ctrl+right\", \"command\": \"workbench.action.terminal.sendSequence\", \"args\": { \"text\": \"\\u001bf\" } } ] Why does macOS make a ding sound when I resize terminal split panes? The keybindings ⌃⌘← and ⌃⌘→ are the defaults for resizing individual split panes in the terminal, while they work they also cause a system \"invalid key\" sound to play due to an issue in Chromium. The recommended workaround is to tell macOS to no-op for these keybindings by running this in your terminal: mkdir -p ~/Library/KeyBindings cat > ~/Library/KeyBindings/DefaultKeyBinding.dict <<EOF { \"^@\\UF701\" = \"noop\"; \"^@\\UF702\" = \"noop\"; \"^@\\UF703\" = \"noop\"; } EOF Why is my terminal showing a multi-colored triangle or a completely black rectangle? The terminal can have problems rendering in some environments, for example you might see a big multi-colored triangle instead of text. This is typically caused by driver/VM graphics issues and the same also happens in Chromium. Work around these issues by launching code with the --disable-gpu flag or by using the setting \"terminal.integrated.gpuAcceleration\": \"off\" to avoid using the canvas in the terminal. Why are there duplicate paths in the terminal's $PATH environment variable and/or why are they reversed? This can happen on macOS because of how the terminal launches using VS Code's environment. When VS Code launches for the first time, in order to source your \"development environment\", it launches your configured shell as a login shell , which runs your ~/.profile / ~/.bash_profile / ~/.zprofile scripts. Now when the terminal launches, it also runs as a login shell, which will put the standard paths to the front (for example, /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin ) and reinitialize your shell environment. To get a better understanding, you can simulate what is happening by launching an inner login shell within your operating system's built-in terminal: # Add /test to the beginning of $PATH export PATH=/test:$PATH # Echo $PATH, /test should be at the beginning echo $PATH # Run bash as a login shell bash -l # Echo $PATH, the values should be jumbled echo $PATH Unfortunately, unlike in Linux, standalone macOS terminals all run as login shells by default, since macOS does not run a login shell when the user logs into the system. This encourages \"bad behavior\", like initializing aliases in your profile script when they should live in your rc script as that runs on non-login shells. There are two direct fixes for this. The first is to set \"terminal.integrated.inheritEnv\": false , which will strip most environment variables from the terminal's environment, except for some important ones (like HOME , SHELL , TMPDIR , etc.). The other fix is to no longer run a login shell in the terminal by creating a terminal profile and setting its args to [] . If you go with this fix, you will want to make sure any aliases in your profile scripts are moved over to your ~/.bashrc / ~/.zshrc file since aliases only apply to the shell they're set in. I'm having problems with the terminal rendering, what can I do? By default, the integrated terminal will render using GPU acceleration on most machines. It does this using multiple <canvas> elements, which are better tuned than the DOM for rendering interactive text that change often. The terminal actually features 3 renderers which fallback if they are detected to perform poorly in this order: WebGL - This is the fastest renderer that truly unlocks the GPU's power to render the terminal quickly. Canvas - This will be used if the WebGL context fails to load (for example, hardware/environment incapabilities), its performance may vary depending on your environment but in general it's much faster than the DOM renderer. DOM - This is the slowest by quite a bit but arguably the most reliable since it just uses the DOM. If the canvas renderer is detected to run slowly the DOM renderer will be activated. Unfortunately some issues cannot be automatically detected, if you experience issues with the GPU acceleration you can disable it terminal.integrated.gpuAcceleration in your user or workspace settings , which will use the DOM renderer. This can be driven by the follow setting: { \"terminal.integrated.gpuAcceleration\": \"off\" }"
  },
  "guides/vscode/editor/intellisense.html": {
    "href": "guides/vscode/editor/intellisense.html",
    "title": "IntelliSense | Fountain of Knowledge",
    "keywords": "IntelliSense IntelliSense is a general term for various code editing features including: code completion, parameter info, quick info, and member lists. IntelliSense features are sometimes called by other names such as \"code completion\", \"content assist\", and \"code hinting.\" IntelliSense for your programming language Visual Studio Code IntelliSense is provided for JavaScript, TypeScript, JSON, HTML, CSS, SCSS, and Less out of the box. VS Code supports word based completions for any programming language but can also be configured to have richer IntelliSense by installing a language extension. Below are the most popular language extensions in the Marketplace . Select an extension tile below to read the description and reviews to decide which extension is best for you. IntelliSense features VS Code IntelliSense features are powered by a language service. A language service provides intelligent code completions based on language semantics and an analysis of your source code. If a language service knows possible completions, the IntelliSense suggestions will pop up as you type. If you continue typing characters, the list of members (variables, methods, etc.) is filtered to only include members containing your typed characters. Pressing kbstyle(Tab) or kbstyle(Enter) will insert the selected member. You can trigger IntelliSense in any editor window by typing kb(editor.action.triggerSuggest) or by typing a trigger character (such as the dot character ( kbstyle(.) ) in JavaScript). Tip: The suggestions widget supports CamelCase filtering, meaning you can type the letters which are upper cased in a method name to limit the suggestions. For example, \"cra\" will quickly bring up \"createApplication\". If you prefer, you can turn off IntelliSense while you type. See Customizing IntelliSense below to learn how to disable or customize VS Code's IntelliSense features. As provided by the language service, you can see quick info for each method by either pressing kb(toggleSuggestionDetails) or clicking the info icon. The accompanying documentation for the method will now expand to the side. The expanded documentation will stay so and will update as you navigate the list. You can close this by pressing kb(toggleSuggestionDetails) again or by clicking on the close icon. After choosing a method you are provided with parameter info . When applicable, a language service will surface the underlying types in the quick info and method signatures. In the image above, you can see several any types. Because JavaScript is dynamic and doesn't need or enforce types, any suggests that the variable can be of any type. Types of completions The JavaScript code below illustrates IntelliSense completions. IntelliSense gives both inferred proposals and the global identifiers of the project. The inferred symbols are presented first, followed by the global identifiers (shown by the Word icon). VS Code IntelliSense offers different types of completions, including language server suggestions, snippets, and simple word based textual completions. Methods and Functions method , function , constructor Variables variable Fields field Type parameters typeParameter Constants constant Classes class Interfaces interface Structures struct Events event Operators operator Modules module Properties and Attributes property Values and Enumerations value , enum References reference Keywords keyword Files file Folders folder Colors color Unit unit Snippet prefixes snippet Words text Customizing IntelliSense You can customize your IntelliSense experience in settings and key bindings. Settings The settings shown below are the default settings. You can change these settings in your settings.json file as described in User and Workspace Settings . { // Controls if quick suggestions should show up while typing \"editor.quickSuggestions\": { \"other\": true, \"comments\": false, \"strings\": false }, // Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character. \"editor.acceptSuggestionOnCommitCharacter\": true, // Controls if suggestions should be accepted on 'Enter' - in addition to 'Tab'. Helps to avoid ambiguity between inserting new lines or accepting suggestions. The value 'smart' means only accept a suggestion with Enter when it makes a textual change \"editor.acceptSuggestionOnEnter\": \"on\", // Controls the delay in ms after which quick suggestions will show up. \"editor.quickSuggestionsDelay\": 10, // Controls if suggestions should automatically show up when typing trigger characters \"editor.suggestOnTriggerCharacters\": true, // Controls if pressing tab inserts the best suggestion and if tab cycles through other suggestions \"editor.tabCompletion\": \"off\", // Controls whether sorting favours words that appear close to the cursor \"editor.suggest.localityBonus\": true, // Controls how suggestions are pre-selected when showing the suggest list \"editor.suggestSelection\": \"recentlyUsed\", // Enable word based suggestions \"editor.wordBasedSuggestions\": true, // Enable parameter hints \"editor.parameterHints.enabled\": true, } Tab Completion The editor supports \"tab completion\" which inserts the best matching completion when pressing kb(insertBestCompletion) . This works regardless of the suggest widget showing or not. Also, pressing kb(insertNextSuggestion) after inserting a suggestions will insert the next best suggestion. By default, tab completion is disabled. Use the editor.tabCompletion setting to enable it. These values exist: off - (default) Tab completion is disabled. on - Tab completion is enabled for all suggestions and repeated invocations insert the next best suggestion. onlySnippets - Tab completion only inserts static snippets which prefix match the current line prefix. Locality Bonus Sorting of suggestions depends on extension information and on how well they match the current word you are typing. In addition, you can ask the editor to boost suggestions that appear closer to the cursor position, using the editor.suggest.localityBonus setting. In above images you can see that count , context , and colocated are sorted based on the scopes in which they appear (loop, function, file). Suggestion selection By default, VS Code pre-selects the previously used suggestion in the suggestion list. This is very useful as you can quickly insert the same completion multiple times. If you'd like different behavior, for example, always select the top item in the suggestion list, you can use the editor.suggestSelection setting. The available editor.suggestSelection values are: first - Always select the top list item. recentlyUsed - (default) The previously used item is selected unless a prefix (type to select) selects a different item. recentlyUsedByPrefix - Select items based on previous prefixes that have completed those suggestions. \"Type to select\" means that the current prefix (roughly the text left of the cursor) is used to filter and sort suggestions. When this happens and when its result differs from the result of recentlyUsed it will be given precedence. When using the last option, recentlyUsedByPrefix , VS Code remembers which item was selected for a specific prefix (partial text). For example, if you typed co and then selected console , the next time you typed co , the suggestion console would be pre-selected. This lets you quickly map various prefixes to different suggestions, for example co -> console and con -> const . Snippets in suggestions By default, VS Code shows snippets and completion proposals in one widget. You can control the behavior with the editor.snippetSuggestions setting. To remove snippets from the suggestions widget, set the value to \"none\" . If you'd like to see snippets, you can specify the order relative to suggestions; at the top ( \"top\" ), at the bottom ( \"bottom\" ), or inline ordered alphabetically ( \"inline\" ). The default is \"inline\" . Key bindings The key bindings shown below are the default key bindings. You can change these in your keybindings.json file as described in Key Bindings . Note: There are many more key bindings relating to IntelliSense. Open the Default Keyboard Shortcuts ( File > Preferences > Keyboard Shortcuts ) and search for \"suggest\". [ { \"key\": \"ctrl+space\", \"command\": \"editor.action.triggerSuggest\", \"when\": \"editorHasCompletionItemProvider && editorTextFocus && !editorReadonly\" }, { \"key\": \"ctrl+space\", \"command\": \"toggleSuggestionDetails\", \"when\": \"editorTextFocus && suggestWidgetVisible\" }, { \"key\": \"ctrl+alt+space\", \"command\": \"toggleSuggestionFocus\", \"when\": \"editorTextFocus && suggestWidgetVisible\" } ] Troubleshooting If you find IntelliSense has stopped working, the language service may not be running. Try restarting VS Code and this should solve the issue. If you are still missing IntelliSense features after installing a language extension, open an issue in the repository of the language extension. Tip: For configuring and troubleshooting JavaScript IntelliSense, see the JavaScript documentation . A particular language extension may not support all the VS Code IntelliSense features. Review the extension's README to find out what is supported. If you think there are issues with a language extension, you can usually find the issue repository for an extension through the VS Code Marketplace . Navigate to the extension's Details page and select the Support link. Next steps IntelliSense is just one of VS Code's powerful features. Read on to learn more: JavaScript - Get the most out of your JavaScript development, including configuring IntelliSense. Node.js - See an example of IntelliSense in action in the Node.js walkthrough. Debugging - Learn how to set up debugging for your application. Creating Language extensions - Learn how to create extensions that add IntelliSense for new programming languages. Common questions Why am I not getting any suggestions? This can be caused by a variety of reasons. First, try restarting VS Code. If the problem persists, consult the language extension's documentation. For JavaScript specific troubleshooting, please see the JavaScript language topic . Why am I not seeing method and variable suggestions? This issue is caused by missing type declaration (typings) files in JavaScript. You can check if a type declaration file package is available for a specific library by using the TypeSearch site. There is more information about this issue in the JavaScript language topic . For other languages, please consult the extension's documentation."
  },
  "guides/vscode/editor/multi-root-workspaces.html": {
    "href": "guides/vscode/editor/multi-root-workspaces.html",
    "title": "Multi-root Workspaces | Fountain of Knowledge",
    "keywords": "Multi-root Workspaces You can work with multiple project folders in Visual Studio Code with multi-root workspaces. This can be helpful when you are working on several related projects at one time. For example, you might have a repository with a product's documentation that you like to keep current when you update the product source code. Note : If you'd like to learn more about the VS Code \"workspace\" concept, you can review What is a VS Code \"workspace\"? Unless you are explicitly creating a multi-root workspace, a \"workspace\" is just your project's single root folder. Adding folders It is easy to add another folder to your existing workspace. There are several gestures for adding folders: Add Folder to Workspace The File > Add Folder to Workspace command brings up an Open Folder dialog to select the new folder. Once a root folder is added, the Explorer will show the new folder as a root in the File Explorer. You can right-click on any of the root folders and use the context menu to add or remove folders. The File Explorer should work and behave as before. You can move files between root folders and use any of the typical file operation actions provided in the context menu and the Explorer view. Settings like files.exclude are supported for each root folder if configured, and across all folders if configured as global user setting. Drag and drop You can use drag and drop to add folders to a workspace. Drag a folder to the File Explorer to add it to the current workspace. You can even select and drag multiple folders. Note : Dropping a single folder into the editor region of VS Code will still open the folder in single folder mode. If you drag and drop multiple folders into the editor region, a new multi-root workspace will be created. You can also use drag and drop to reorder folders in the workspace. Multiple selection native file open dialogs Opening multiple folders with your platform's native file open dialog will create a multi-root workspace. command line --add Add a folder or multiple folders to the last active VS Code instance for a multi-root workspace. code --add vscode vscode-docs Removing folders You can remove a folder from a Workspace with the Remove Folder from Workspace context menu command. Workspace file When you add multiple folders, they are initially placed in a Workspace titled UNTITLED WORKSPACE and that name will remain until you save the workspace. You do not need to save a Workspace until you want to have it in a permanent location, for example, on your Desktop. Untitled Workspaces are present as long as the VS Code instance they are using is open. Once you completely close an instance with an untitled workspace, you will be asked to save it if you plan to open it again in the future: When you save your workspace, it will create a .code-workspace file and the file name will be displayed in the File Explorer. Save Workspace As... If you want to move your Workspace file to a new location, you can use the File > Save Workspace As command, which will automatically set the correct folder paths relative to the new Workspace file location. Opening workspace files To reopen a Workspace, you can: Double-click the .code-workspace file in your platform's Explorer. Use the File > Open Workspace command and select the Workspace file. Select the Workspace from the File > Open Recent ( kb(workbench.action.openRecent) ) list. Workspaces have a (Workspace) suffix to differentiate them from folders. Just like Close Folder when a single folder is open in VS Code, there is a Close Workspace ( kb(workbench.action.closeFolder) ) command to close the active Workspace. Workspace file schema The schema of .code-workspace is fairly straightforward. You have an array of folders with either absolute or relative paths. Relative paths are better when you want to share Workspace files. You can override the display name of your folders with the name attribute, to give more meaningful names to folders in the Explorer. For example, you could name your project folders such as 'Product' and 'Documentation' to easily identify the content by folder name: { \"folders\": [ { // Source code \"name\": \"Product\", \"path\": \"vscode\" }, { // Docs and release notes \"name\": \"Documentation\", \"path\": \"vscode-docs\" }, { // Yeoman extension generator \"name\": \"Extension generator\", \"path\": \"vscode-generator-code\" } ] } which will result in the following Explorer display: As you can see from the example above, you can add comments to your Workspace files. The Workspace file can also contain Workspace global settings under settings and extension recommendations under extensions , which we will discuss below. General UI Editor There are only a few changes to the VS Code UI when you are using multi-root workspaces, primarily to disambiguate files between folders. For example, if there is a name collision between files in multiple folders, VS Code will include the folder name in tabbed headers. If you'd always like to see the folder displayed in the tabbed header, you can use the workbench.editor.labelFormat setting \"medium\" or \"long\" values to show the folder or full paths. \"workbench.editor.labelFormat\": \"medium\" VS Code UI such as the OPEN EDITORS and Quick Open ( kb(workbench.action.quickOpen) ) lists include the folder name. If you are using an File Icon Theme and the active theme supports it, you will see a special Workspace icon. Below you can see the Workspace icons from the built-in Minimal (Visual Studio Code) file icon theme: Search VS Code features like global search work across all folders and group the search results by folder. When you have a multi-root workspace open, you can choose to search in a single root folder by using the ./ syntax in the files to include box. For example, if you enter ./project1/**/*.txt , that will search for all .txt files under the project1/ root folder. Settings With multiple root folders in one workspace, it is possible to have a .vscode folder in each root folder defining the settings that should apply for that folder. To avoid setting collisions, only resource (file, folder) settings are applied when using a multi-root workspace. Settings that affect the entire editor (for example, UI layout) are ignored. For example, two projects cannot both set the zoom level. User settings are supported as with single folder projects and you can also set global Workspace settings that will apply to all folders in your multi-root Workspace. Global Workspace settings will be stored in your .code-workspace file. { \"folders\": [ { \"path\": \"vscode\" }, { \"path\": \"vscode-docs\" }, { \"path\": \"vscode-generator-code\" } ], \"settings\": { \"window.zoomLevel\": 1, \"files.autoSave\": \"afterDelay\" } } When you go from a single folder instance to multiple folders, VS Code will add the appropriate editor-wide settings from the first folder to the new global Workspace settings. You can easily review and modify the different settings files through the Settings editor. The Settings editor tabs let you select your User settings, global Workspace settings, and individual folder settings. You can also open specific settings files with the commands: Preferences: Open User Settings - Open your global User settings Preferences: Open Workspace Settings - Open the settings section of your Workspace file. Preferences: Open Folder Settings - Open the settings for the active folder. Global Workspace settings override User settings and folder settings can override Workspace or User settings. Unsupported folder settings Unsupported editor-wide folder settings will be shown as grayed out in your folder settings and are filtered out of the DEFAULT FOLDER SETTINGS list. You will also see an information icon in front of the setting. Debugging With multi-root workspaces, VS Code searches across all folders for launch.json debug configuration files and displays them with the folder name as a suffix. Additionally VS Code will also display launch configurations defined in the workspace configuration file. The example above shows the debugging configurations for the TSLint extension . There is a launch configuration from the tslint extension folder to start the extension running in the VS Code Extension Host and also an attach configuration from the tslint-server folder to attach the debugger to a running TSLint server. You can also see the three Add Config commands for the folders, tslint , tslint-server , and tslint-tests , in the vscode-tslint Workspace . The Add Config command will either open an existing launch.json file in the folder's .vscode subfolder or create a new one and display the debugging configuration template dropdown. Variables used in a configuration (for example ${workspaceFolder} or the now deprecated ${workspaceRoot} ) are resolved relative to the folder they belong to. It is possible to scope a variable per workspace folder by appending the root folder's name to a variable (separated by a colon). Workspace launch configurations Workspace scoped launch configurations live in the \"launch\" section of the workspace configuration file ( Workspaces: Open Workspace Configuration File in the Command Palette): Alternatively, new launch configurations can be added via the \"Add Config (workspace)\" entry of the Launch Configuration dropdown menu: A compound launch configuration can reference the individual launch configurations by name as long as the names are unique within the workspace, for example: \"compounds\": [{ \"name\": \"Launch Server & Client\", \"configurations\": [ \"Launch Server\", \"Launch Client\" ] }] If the individual launch configuration names are not unique, the qualifying folder can be specified with a more verbose \"folder\" syntax: \"compounds\": [{ \"name\": \"Launch Server & Client\", \"configurations\": [ \"Launch Server\", { \"folder\": \"Web Client\", \"name\": \"Launch Client\" }, { \"folder\": \"Desktop Client\", \"name\": \"Launch Client\" } ] }] In addition to compounds , the launch section of the workspace configuration file can contain regular launch configurations too. Make sure that all used variables are explicitly scoped to a specific folder because otherwise they are not valid for the workspace. You can find more details about explicitly scoped variables in the Variables Reference . Here is an example for a launch configuration where the program lives in a folder \"Program\" and where all files from a folder \"Library\" should be skipped when stepping: \"launch\": { \"configurations\": [{ \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch test\", \"program\": \"${workspaceFolder:Program}/test.js\", \"skipFiles\": [ \"${workspaceFolder:Library}/out/**/*.js\" ] }] } Tasks Similar to how VS Code searches for debugging configurations, VS Code will also try to autodetect tasks from gulp, grunt, npm, and TypeScript project files across all folders in a workspace as well as search for tasks defined in tasks.json files. The location of tasks is indicated by a folder name suffix. Note that tasks defined in tasks.json must be version 2.0.0. From the TSLint extension Workspace example above, you can see that there are two configured tasks from tasks.json files in the tslint and tslint-tests folders and numerous autodetected npm and TypeScript compiler detected tasks . Workspace task configuration Workspace scoped tasks live in the \"tasks\" section of the workspace configuration file ( Workspaces: Open Workspace Configuration File in the Command Palette). Only \"shell\" and \"process\" type tasks can be defined in the workspace configuration file. Source Control With multi-root workspaces, there is a SOURCE CONTROL PROVIDERS section that gives you an overview when you have multiple active repositories. These can be contributed by several SCM providers; for example, you can have Git repositories side-by-side with Azure DevOps Server workspaces. As you select repositories in this view, you can see the source control details below. You can use kbstyle(Ctrl+Click) or kbstyle(Shift+Click) to select multiple repositories. Their details will appear as separate regions underneath. Extensions Multi-root workspaces have been available as a preview on Insiders build since the June 2017 1.14 release and we've been working with extension authors to help them get ready for the release to Stable. If you are an extension author, you can review our Adopting Multi Root Workspace APIs guide to learn about VS Code API changes and how to make your extension work well across multiple folders. Below are some of the popular extensions that have already adopted the multi-root workspace APIs. Note : If an extension doesn't yet support multiple folders, it will still work in the first folder of your multi-root workspace. Extension recommendations VS Code supports folder level extension recommendations through the extensions.json files under the folder's .vscode subfolder. You can also provide global Workspace extension recommendations by adding them to your .code-workspace file. You can use the Extensions: Configure Recommended Extensions (Workspace Folder) command to open your Workspace file and add extension identifiers ({publisherName}.{extensionName}) to the extensions.recommendations array. { \"folders\": [ { \"path\": \"vscode\" }, { \"path\": \"vscode-docs\" } ], \"extensions\": { \"recommendations\": [ \"eg2.tslint\", \"dbaeumer.vscode-eslint\", \"esbenp.prettier-vscode\" ] } } Next steps What is a VS Code \"workspace\"? - More about single-folder and multi-root workspaces. Debugging - Learn how to set up debugging for your application. Tasks - Tasks let you run external tools like compilers within VS Code. Common questions How can I go back to working with a single project folder? You can either close the Workspace and open the folder directly or remove the folder from Workspace. As an extension author what do I need to do? See our Adopting Multi Root Workspace APIs guide. Most extensions can easily support multi-root workspaces."
  },
  "guides/vscode/editor/portable.html": {
    "href": "guides/vscode/editor/portable.html",
    "title": "Portable Mode | Fountain of Knowledge",
    "keywords": "Portable Mode Visual Studio Code supports Portable mode . This mode enables all data created and maintained by VS Code to live near itself, so it can be moved around across environments. This mode also provides a way to set the installation folder location for VS Code extensions, useful for corporate environments that prevent extensions from being installed in the Windows AppData folder. Portable mode is supported on the ZIP download for Windows, and the TAR.GZ download for Linux, as well as the regular Application download for macOS. See the Download page to find the correct .zip / .tar.gz file for your platform. Note: Do not attempt to configure portable mode on an installation from the Windows User or System installers . Portable mode is only supported on the Windows ZIP ( .zip ) archive. Note as well that the Windows ZIP archive does not support auto update. Enable Portable mode Windows, Linux After unzipping the VS Code download, create a data folder within VS Code's folder: |- VSCode-win32-x64-1.25.0-insider | |- Code.exe (or code executable) | |- data | |- ... From then on, that folder will be used to contain all VS Code data, including session state, preferences, extensions, etc. The data folder can be moved to other VS Code installations. This is useful for updating your portable VS Code version, in which case you can move the data folder to a newer extracted version of VS Code. macOS On macOS , you need to place the data folder as a sibling of the application itself. Since the folder will be alongside the application, you need to name it specifically so that VS Code can find it. The default folder name is code-portable-data : |- Visual Studio Code.app |- code-portable-data Portable Mode won't work if your application is in quarantine , which happens by default if you just downloaded VS Code. Make sure you remove the quarantine attribute, if Portable Mode doesn't seem to work: xattr -dr com.apple.quarantine Visual\\ Studio\\ Code.app Note: On Insiders, the folder should be named code-insiders-portable-data . Update Portable VS Code On Windows and Linux , you can update VS Code by copying the data folder over to a more recent version of VS Code. On macOS , automatic updates should work as always, no extra work needed. Migrate to Portable mode You can also migrate an existing installation to Portable mode: Download the VS Code ZIP distribution for your platform. Create the data or code-portable-data folder as above. Copy the user data directory Code to data and rename it to user-data : Windows %APPDATA%\\Code macOS $HOME/Library/Application Support/Code Linux $HOME/.config/Code Copy the extensions directory to data : Windows %USERPROFILE%\\.vscode\\extensions macOS ~/.vscode/extensions Linux ~/.vscode/extensions Here's the desired outcome on Windows : |- VSCode-win32-x64-1.25.0-insider | |- Code.exe (or code executable) | |- data | | |- user-data | | | |- ... | | |- extensions | | | |- ... | |- ... TMP directory By default, the default TMP directory is still the system one even in Portable Mode, since no state is kept there. If you want to also have your TMP directory within your portable directory, you can create an empty tmp directory inside the data folder. As long as a tmp directory exists, it will be used for TMP data."
  },
  "guides/vscode/editor/refactoring.html": {
    "href": "guides/vscode/editor/refactoring.html",
    "title": "Refactoring | Fountain of Knowledge",
    "keywords": "Refactoring Source code refactoring can improve the quality and maintainability of your project by restructuring your code while not modifying the runtime behavior. Visual Studio Code supports refactoring operations (refactorings) such as Extract Method and Extract Variable to improve your code base from within your editor. For example, a common refactoring used to avoid duplicating code (a maintenance headache) is the Extract Method refactoring, where you select source code that you'd like to reuse elsewhere and pull it out into its own shared method. Refactorings are provided by a language service and VS Code has built-in support for TypeScript and JavaScript refactoring through the TypeScript language service. Refactoring support for other programming languages is provided through VS Code extensions which contribute language services. The UI and commands for refactoring are the same across languages, and in this topic we'll demonstrate refactoring support with the TypeScript language service. Code Actions = Quick Fixes and refactorings In VS Code, Code Actions can provide both refactorings and Quick Fixes for detected issues (highlighted with green squiggles). An available Code Action is announced by a lightbulb near the source code when the cursor is on a squiggle or selected text region. Clicking on the Code Action lightbulb or using the Quick Fix command kb(editor.action.quickFix) will display Quick Fixes and refactorings. If you'd just like to see refactorings without Quick Fixes, you can use the Refactor command ( kb(editor.action.refactor) ). Note: If you prefer to not see the Code Action lightbulb in your editor, you can disable lightbulbs with the editor.lightbulb.enable setting . You can still open Quick Fixes through Quick Fix command and kb(editor.action.quickFix) keyboard shortcut. Refactoring actions Extract Method Select the source code you'd like to extract and then click on the lightbulb in the gutter or press ( kb(editor.action.quickFix) ) to see available refactorings. Source code fragments can be extracted into a new method, or into a new function at various different scopes. During the extract refactoring, you will be prompted to provide a meaningful name. Extract Variable TypeScript language service provides Extract to const refactoring to create a new local variable for the currently selected expression: When working with classes, you can also extract a value to a new property. Rename symbol Renaming is a common operation related to refactoring source code and VS Code has a separate Rename Symbol command ( kb(editor.action.rename) ). Some languages support rename symbol across files. Press kb(editor.action.rename) and then type the new desired name and press kbstyle(Enter) . All usages of the symbol will be renamed, across files. Keybindings for Code Actions The editor.action.codeAction command lets you configure keybindings for specific Code Actions. This keybinding, for example, triggers the Extract function refactoring Code Actions: { \"key\": \"ctrl+shift+r ctrl+e\", \"command\": \"editor.action.codeAction\", \"args\": { \"kind\": \"refactor.extract.function\" } } Code Action kinds are specified by extensions using the enhanced CodeActionProvided API. Kinds are hierarchical, so \"kind\": \"refactor\" will show all refactoring Code Actions, whereas \"kind\": \"refactor.extract.function\" will only show Extract function refactorings. Using the above keybinding, if only a single \"refactor.extract.function\" Code Action is available, it will be automatically applied. If multiple Extract function Code Actions are available, we bring up a context menu to select them: You can also control how/when Code Actions are automatically applied using the apply argument: { \"key\": \"ctrl+shift+r ctrl+e\", \"command\": \"editor.action.codeAction\", \"args\": { \"kind\": \"refactor.extract.function\", \"apply\": \"first\" } } Valid values for \"apply\" : \"first\" - Always automatically apply the first available Code Action. \"ifSingle\" - Default. Automatically apply the Code Action if only one is available. Otherwise, show the context menu. \"never\" - Always show the Code Action context menu, even if only a single Code Action is available. When a Code Action keybinding is configured with \"preferred\": true , only preferred Quick Fixes and refactorings are shown. A preferred Quick Fix addresses the underlying error, while a preferred refactoring is the most common refactoring choice. For example, while multiple refactor.extract.constant refactorings may exist, each extracting to a different scope in the file, the preferred refactor.extract.constant refactoring is the one that extracts to a local variable. This keybinding uses \"preferred\": true to create a refactoring that always tries to extract the selected source code to a constant in the local scope: { \"key\": \"shift+ctrl+e\", \"command\": \"editor.action.codeAction\", \"args\": { \"kind\": \"refactor.extract.constant\", \"preferred\": true, \"apply\": \"ifsingle\" } } Extensions with refactorings You can find extensions that support refactoring by looking in the VS Code Marketplace . You can go to the Extensions view ( kb(workbench.view.extensions) ) and type 'refactor' in the search box. You can then sort by install count or ratings to see which extensions are popular. Tip: The extensions shown above are dynamically queried. Click on an extension tile above to read the description and reviews to decide which extension is best for you. Next steps Intro Video - Code Editing - Watch an introductory video on code editing features. Code Navigation - VS Code lets you move quickly through your source code. Debugging - Learn about debugging with VS Code. Common questions Why don't I see any lightbulbs when there are errors in my code? Lightbulbs (Code Actions) are only shown when your cursor hovers over the text showing the error. Hovering over the text will show the error description, but you need to move the cursor or select text to see lightbulbs for Quick Fixes and refactorings."
  },
  "guides/vscode/editor/settings-sync.html": {
    "href": "guides/vscode/editor/settings-sync.html",
    "title": "Settings Sync | Fountain of Knowledge",
    "keywords": "Settings Sync Settings Sync lets you share your Visual Studio Code configurations such as settings, keybindings, and installed extensions across your machines so you are always working with your favorite setup. Turning on Settings Sync You can turn on Settings Sync using the Turn On Settings Sync... entry in the Manage gear menu at the bottom of the Activity Bar. You will be asked to sign in and what preferences you would like to sync; currently Settings, Keyboard Shortcuts, Extensions, User Snippets, and UI State are supported. Selecting the Sign in & Turn on button will ask you to choose between signing in with your Microsoft or GitHub account. After making this selection, the browser will open so that you can sign in to your Microsoft or GitHub account. When a Microsoft account is chosen, you can use either personal accounts, such as Outlook accounts, or Azure accounts, and you can also link a GitHub account to a new or existing Microsoft account. After signing in, Settings Sync will be turned on and continue to synchronize your preferences automatically in the background. Merge or Replace If you already synced from a machine and turning on sync from another machine, you will be shown with following Merge or Replace dialog. Merge : Selecting this option will merge local settings with remote settings from the cloud. Replace Local : Selecting this option will overwrite local settings with remote settings from the cloud. Merge Manually... : Selecting this option will open Merges view where you can merge preferences one by one. Configuring synced data Machine settings (with machine or machine-overridable scopes ) are not synchronized by default, since their values are specific to a given machine. You can also add or remove settings you want to this list from the Settings editor or using the setting settingsSync.ignoredSettings . Keyboard Shortcuts are synchronized per platform by default. If your keyboard shortcuts are platform-agnostic, you can synchronize them across platforms by disabling the setting settingsSync.keybindingsPerPlatform . All built-in and installed extensions are synchronized along with their global enablement state. You can skip synchronizing an extension, either from the Extensions view ( kb(workbench.view.extensions) ) or using the setting settingsSync.ignoredExtensions . Following UI State is synchronized currently: Display Language Activity Bar entries Panel entries Views layout and visibility Recently used commands Do not show again notifications You can always change what is synced via the Settings Sync: Configure command or by opening the Manage gear menu, selecting Settings Sync is On , and then Settings Sync: Configure . Conflicts When synchronizing settings between multiple machines, there may occasionally be conflicts. Conflicts can happen when first setting up sync between machines or when settings change while a machine is offline. When conflicts occur, you will be presented with the following options: Accept Local : Selecting this option will overwrite remote settings in the cloud with your local settings. Accept Remote : Selecting this option will overwrite local settings with remote settings from the cloud. Show Conflicts : Selecting this will display a diff editor similar to the Source Control diff editor, where you can preview the local and remote settings and choose to either accept local or remote or manually resolve the changes in your local settings file and then accept the local file. Switching Accounts If at any time you want to sync your data to a different account, you can turn off and turn on Settings Sync again with different account. Syncing Stable versus Insiders By default, the VS Code Stable and Insiders builds use different Settings Sync services, and therefore do not share settings. You can sync your Insiders with Stable by selecting the Stable sync service while turning on Settings Sync. This option is only available in VS Code Insiders. Note: Since Insiders builds are newer than Stable builds, syncing them can sometimes lead to data incompatibility. In such cases, Settings sync will be disabled automatically on stable to prevent data inconsistencies. Once newer version of Stable build is released, you can upgrade your stable client and turn on sync to continue syncing. Restoring data VS Code always stores local and remote backups of your preferences while syncing and provides views for accessing these. In case something goes wrong, you can restore your data from these views. You can open these views using Settings Sync: Show Synced Data command from the Command Palette. The Local Sync activity view is hidden by default and you can enable it using Views submenu under Settings Sync view overflow actions. Local backups folder in the disk can be accessed via the Settings Sync: Open Local Backups Folder command. The folder is organized by the type of preference and contains versions of your JSON files, named with a timestamp of when the backup occurred. Note : Local backups are automatically deleted after 30 days. For remote backups the latest 20 versions of each individual resource (settings, extensions, etc.) is retained. Synced Machines VS Code keeps track of the machines synchronizing your preferences and provides a view to access them. Every machine is given a default name based on the type of VS Code (Insiders or Stable) and the platform it is on. You can always update the machine name using the edit action available on the machine entry in the view. You can also disable sync on another machine using Turn off Settings Sync context menu action on the machine entry in the view. You can open this view using Settings Sync: Show Synced Data command from the Command Palette. Extension authors If you are an extension author, you should make sure your extension behaves appropriately when users enable Setting Sync. For example, you probably don't want your extension to display the same dismissed notifications or welcome pages on multiple machines. Sync user global state between machines If your extension needs to preserve some user state across different machines then provide the state to Settings Sync using vscode.ExtensionContext.globalState.setKeysForSync . Sharing state such as UI dismissed or viewed flags across machines can provide a better user experience. There is an example of using setKeysforSync in the Extension Capabilities topic. Reporting issues Settings Sync activity can be monitored in the Log (Settings Sync) output view. If you experience a problem with Settings Sync, include this log when creating the issue. If your problem is related to authentication, also include the log from the Account output view. How do I delete my data? If you want to remove all your data from our servers, just turn off sync via Settings Sync is On menu available under Manage gear menu and select the checkbox to clear all cloud data. If you choose to re-enable sync, it will be as if you're signing in for the first time. Next steps User and Workspace settings - Learn how to configure VS Code to your preferences through user and workspace settings. Common questions Is VS Code Settings Sync the same as the Settings Sync extension? No, the Settings Sync extension by Shan Khan uses a private Gist on GitHub to share your VS Code settings across different machines and is unrelated to the VS Code Settings Sync. What types of accounts can I use for Settings Sync sign in? VS Code Settings Sync supports signing in with either a Microsoft account (for example Outlook or Azure accounts) or a GitHub account. Sign in with GitHub Enterprise accounts is not supported. Other authentication providers may be supported in the future and you can review the proposed Authentication Provider API in issue #88309 . Can I use a different backend or service for Settings Sync? Settings Sync uses a dedicated service to store settings and coordinate updates. A service provider API may be exposed in the future to allow for custom Settings Sync backends. Troubleshooting keychain issues Settings Sync persists authentication information to the system keychain. Writing to the keychain can fail in some cases if the keychain is misconfigured. macOS If the keychain throws the error \"The user name or passphrase you entered is not correct.\", open the Keychain Access app, right-click on the login keychain, and lock and unlock it again. This error was first reported in issue #76 as a problem after upgrading to macOS High Sierra, but it has also been reported on more recent macOS versions. Linux If the keychain throws the error \"No such interface \"org.freedesktop.Secret.Collection\" on object at path /org/freedesktop/secrets/collection/login\", try following the steps described in issue #92972 to create a new keyring. If the error is \"Writing login information to the keychain failed with error 'Unknown or unsupported transport \"disabled\" for address \"disabled:\"'\", check that dbus-launch has been started by following the instructions in issue #120392 . Can I share settings between VS Code Stable and Insiders? Yes. Please refer to the Syncing Stable versus Insiders section for more information. Please note that this can sometimes lead to data incompatibility because Insiders builds are newer than Stable builds. In such cases, Settings Sync will be disabled automatically on Stable to prevent data inconsistencies. Once a newer version of the Stable build is released, you can upgrade your client and turn on Settings Sync to continue syncing."
  },
  "guides/vscode/editor/tasks.html": {
    "href": "guides/vscode/editor/tasks.html",
    "title": "Integrate with External Tools via Tasks | Fountain of Knowledge",
    "keywords": "Integrate with External Tools via Tasks If you are using Visual Studio Code version 1.13 or earlier, refer to the previous version of the Tasks documentation . Lots of tools exist to automate tasks like linting, building, packaging, testing, or deploying software systems. Examples include the TypeScript Compiler , linters like ESLint and TSLint as well as build systems like Make , Ant , Gulp , Jake , Rake , and MSBuild . These tools are mostly run from the command line and automate jobs inside and outside the inner software development loop (edit, compile, test, and debug). Given their importance in the development life cycle, it is helpful to be able to run tools and analyze their results from within VS Code. Tasks in VS Code can be configured to run scripts and start processes so that many of these existing tools can be used from within VS Code without having to enter a command line or write new code. Workspace or folder specific tasks are configured from the tasks.json file in the .vscode folder for a workspace. Extensions can also contribute tasks using a Task Provider , and these contributed tasks can add workspace-specific configurations defined in the tasks.json file. Note: Task support is only available when working on a workspace folder. It is not available when editing single files. TypeScript Hello World Let's start with a simple \"Hello World\" TypeScript program that we want to compile to JavaScript. Create an empty folder \"mytask\", generate a tsconfig.json file and start VS Code from that folder. mkdir mytask cd mytask tsc --init code . Now create a HelloWorld.ts file with the following content function sayHello(name: string): void { console.log(`Hello ${name}!`); } sayHello('Dave'); Pressing kb(workbench.action.tasks.build) or running Run Build Task from the global Terminal menu show the following picker: The first entry executes the TypeScript compiler and translates the TypeScript file to a JavaScript file. When the compiler has finished, there should be a HelloWorld.js file. The second entry starts the TypeScript compiler in watch mode. Every save to the HelloWorld.ts file will regenerate the HelloWorld.js file. You can also define the TypeScript build or watch task as the default build task so that it is executed directly when triggering Run Build Task ( kb(workbench.action.tasks.build) ). To do so, select Configure Default Build Task from the global Terminal menu. This shows you a picker with the available build tasks. Select tsc: build or tsc: watch and VS Code will generate a tasks.json file. The one shown below makes the tsc: build task the default build task: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"typescript\", \"tsconfig\": \"tsconfig.json\", \"problemMatcher\": [ \"$tsc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } Unlike the previous 0.1.0 version of the tasks.json file, this does not define a new task. It annotates the tsc: build tasks contributed by VS Code's TypeScript extension to be the default build task. You can now execute the TypeScript compiler by pressing kb(workbench.action.tasks.build) . Task auto-detection VS Code currently auto-detects tasks for the following systems: Gulp, Grunt, Jake, and npm. We are working with the corresponding extension authors to add support for Maven and the C# dotnet command as well. If you develop a JavaScript application using Node.js as the runtime, you usually have a package.json file describing your dependencies and the scripts to run. If you have cloned the eslint-starter example, then executing Run Tasks from the global menu shows the following list: If you have not already done so, install the necessary npm modules by running npm install . Now open the server.js file and add a semicolon to the end of a statement (note the ESLint starter assumes statements without a semicolon) and execute the Run Tasks again. This time select the npm: lint task. When prompted for the problem matcher to use, select ESLint stylish Executing the task produces one error, shown in the Problems view: In addition, VS Code created a tasks.json file with the following content: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"npm\", \"script\": \"lint\", \"problemMatcher\": [ \"$eslint-stylish\" ] } ] } This instructs VS Code to scan the output of the npm lint script for problems using the ESLint stylish format. For Gulp, Grunt, and Jake, the task auto-detection works the same. Below is an example of the tasks detected for the vscode-node-debug extension. Tip: You can run your task through Quick Open ( kb(workbench.action.quickOpen) ) by typing 'task', kbstyle(Space) and the command name. In this case, 'task lint'. Task auto detection can be disabled using the following settings: { \"typescript.tsc.autoDetect\": \"off\", \"grunt.autoDetect\": \"off\", \"jake.autoDetect\": \"off\", \"gulp.autoDetect\": \"off\", \"npm.autoDetect\": \"off\" } Custom tasks Not all tasks or scripts can be auto-detected in your workspace. Sometimes it is necessary to define your own custom tasks. Assume you have a script to run your tests in order to set up some environment correctly. The script is stored in a script folder inside your workspace and named test.sh for Linux and macOS and test.cmd for Windows. Run Configure Tasks from the global Terminal menu and select the Create tasks.json file from template entry. This opens the following picker: Note: If you don't see the list of task runner templates, you may already have a tasks.json file in your folder and its contents will be open in the editor. Close the file and either delete or rename it for this example. We are working on more auto-detection support, so this list will get smaller and smaller in the future. Since we want to write our own custom task, select Others from the list. This opens the tasks.json file with a task skeleton. Replace the contents with the following: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Run tests\", \"type\": \"shell\", \"command\": \"./scripts/test.sh\", \"windows\": { \"command\": \".\\\\scripts\\\\test.cmd\" }, \"group\": \"test\", \"presentation\": { \"reveal\": \"always\", \"panel\": \"new\" } } ] } The task's properties have the following semantic: label : The task's label used in the user interface. type : The task's type. For a custom task, this can either be shell or process . If shell is specified, the command is interpreted as a shell command (for example: bash, cmd, or PowerShell). If process is specified, the command is interpreted as a process to execute. command : The actual command to execute. windows : Any Windows specific properties. Will be used instead of the default properties when the command is executed on the Windows operating system. group : Defines to which group the task belongs. In the example, it belongs to the test group. Tasks that belong to the test group can be executed by running Run Test Task from the Command Palette . presentation : Defines how the task output is handled in the user interface. In this example, the Integrated Terminal showing the output is always revealed and a new terminal is created on every task run. options : Override the defaults for cwd (current working directory), env (environment variables), or shell (default shell). Options can be set per task but also globally or per platform. Environment variables configured here can only be referenced from within your task script or process and will not be resolved if they are part of your args, command, or other task attributes. runOptions : Defines when and how a task is run. You can see the full set of task properties and values with IntelliSense in your tasks.json file. Bring up suggestions with Trigger Suggest ( kb(editor.action.triggerSuggest) ) and read the descriptions on hover or with the Read More... ('i') flyout. You can also review the tasks.json schema . Shell commands need special treatment when it comes to commands and arguments that contain spaces or other special characters like $ . By default, the task system supports the following behavior: If a single command is provided, the task system passes the command as is to the underlying shell. If the command needs quoting or escaping to function properly, the command needs to contain the proper quotes or escape characters. For example, to list the directory of a folder containing spaces in its name, the command executed in bash should look like this: ls 'folder with spaces' . { \"label\": \"dir\", \"type\": \"shell\", \"command\": \"dir 'folder with spaces'\" } If a command and arguments are provided, the task system will use single quotes if the command or arguments contain spaces. For cmd.exe , double quotes are used. A shell command like below will be executed in PowerShell as dir 'folder with spaces' . { \"label\": \"dir\", \"type\": \"shell\", \"command\": \"dir\", \"args\": [ \"folder with spaces\" ] } If you want to control how the argument is quoted, the argument can be a literal specifying the value and a quoting style. The example below uses escaping instead of quoting for an argument with spaces. { \"label\": \"dir\", \"type\": \"shell\", \"command\": \"dir\", \"args\": [ { \"value\": \"folder with spaces\", \"quoting\": \"escape\" } ] } Besides escaping, the following values are supported: strong : Uses the shell's strong quoting mechanism, which suppresses all evaluations inside the string. Under PowerShell and for shells under Linux and macOS, single quotes are used ( ' ). For cmd.exe, \" is used. weak : Uses the shell's weak quoting mechanism, which still evaluates expression inside the string (for example, environment variables). Under PowerShell and for shells under Linux and macOS, double quotes are used ( \" ). cmd.exe doesn't support weak quoting so VS Code uses \" as well. If the command itself contains spaces, VS Code will by default strong quote the command as well. As with arguments, the user can control the quoting of the command using the same literal style. There are more task properties to configure your workflow. You can use IntelliSense with kb(editor.action.triggerSuggest) to get an overview of the valid properties. In addition to the global menu bar, task commands can be accessed using the Command Palette ( kb(workbench.action.showCommands) ). You can filter on 'task' and can see the various task related commands. Compound tasks You can also compose tasks out of simpler tasks with the dependsOn property. For example, if you have a workspace with a client and server folder and both contain a build script, you can create a task that starts both build scripts in separate terminals. If you list more than one task in the dependsOn property, they are executed in parallel by default. The tasks.json file looks like this: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Client Build\", \"command\": \"gulp\", \"args\": [\"build\"], \"options\": { \"cwd\": \"${workspaceFolder}/client\" } }, { \"label\": \"Server Build\", \"command\": \"gulp\", \"args\": [\"build\"], \"options\": { \"cwd\": \"${workspaceFolder}/server\" } }, { \"label\": \"Build\", \"dependsOn\": [\"Client Build\", \"Server Build\"] } ] } If you specify \"dependsOrder\": \"sequence\" then your task dependencies are executed in the order they are listed in dependsOn . Any background/watch tasks used in dependsOn with \"dependsOrder\": \"sequence\" must have a problem matcher that tracks when they are \"done\". The following task runs task Two, task Three, and then task One. { \"label\": \"One\", \"type\": \"shell\", \"command\": \"echo Hello \", \"dependsOrder\": \"sequence\", \"dependsOn\":[ \"Two\", \"Three\" ] } User level tasks You can create user level tasks that are not tied to a specific workspace or folder using the Tasks: Open User Tasks command. Only shell and process tasks can be used here since other task types require workspace information. Output behavior Sometimes you want to control how the Integrated Terminal panel behaves when running tasks. For instance, you may want to maximize editor space and only look at task output if you think there is a problem. The behavior of the terminal can be controlled using the presentation property of a task. It offers the following properties: reveal : Controls whether the Integrated Terminal panel is brought to front. Valid values are: always - The panel is always brought to front. This is the default. never - The user must explicitly bring the terminal panel to the front using the View > Terminal command ( kb(workbench.action.terminal.toggleTerminal) ). silent - The terminal panel is brought to front only if the output is not scanned for errors and warnings. focus : Controls whether the terminal is taking input focus or not. Default is false . echo : Controls whether the executed command is echoed in the terminal. Default is true . showReuseMessage : Controls whether to show the \"Terminal will be reused by tasks, press any key to close it\" message. panel : Controls whether the terminal instance is shared between task runs. Possible values are: shared : The terminal is shared and the output of other task runs are added to the same terminal. dedicated : The terminal is dedicated to a specific task. If that task is executed again, the terminal is reused. However, the output of a different task is presented in a different terminal. new : Every execution of that task is using a new clean terminal. clear : Controls whether the terminal is cleared before this task is run. Default is false . group : Controls whether the task is executed in a specific terminal group using split panes. Tasks in the same group (specified by a string value) will use split terminals to present instead of a new terminal panel. You can modify the terminal panel behavior for auto-detected tasks as well. For example, if you want to change the output behavior for the npm: run lint from the ESLint example from above, add the presentation property to it: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"npm\", \"script\": \"lint\", \"problemMatcher\": [ \"$eslint-stylish\" ], \"presentation\": { \"reveal\": \"never\" } } ] } You can also mix custom tasks with configurations for detected tasks. A tasks.json that configures the npm: run lint task and adds a custom Run Test tasks looks like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"npm\", \"script\": \"lint\", \"problemMatcher\": [ \"$eslint-stylish\" ], \"presentation\": { \"reveal\": \"never\" } }, { \"label\": \"Run tests\", \"type\": \"shell\", \"command\": \"./scripts/test.sh\", \"windows\": { \"command\": \".\\\\scripts\\\\test.cmd\" }, \"group\": \"test\", \"presentation\": { \"reveal\": \"always\", \"panel\": \"new\" } } ] } Run behavior You can specify a task's run behaviors using the runOptions property: reevaluateOnRerun : Controls how variables are evaluated when a task is executed through the Rerun Last Task command. The default is true , meaning that variables will be reevaluated when a task is rerun. When set to false the resolved variable values from the previous run of the task will be used. runOn : Specifies when a task is run. default : The task will only be run when executed through the Run Task command. folderOpen : The task will be run when the containing folder is opened. The first time you open a folder that contains a task with folderOpen , you will be asked if you want to allow tasks to run automatically in that folder. You can change your decision later using the Allow Automatic Tasks in Folder and Disallow Automatic Tasks in Folder commands. Customizing auto-detected tasks As mentioned above, you can customize auto-detected tasks in the tasks.json file. You usually do so to modify presentation properties or to attach a problem matcher to scan the task's output for errors and warnings. You can customize a task directly from the Run Task list by pressing the gear icon to the right to insert the corresponding task reference into the tasks.json file. Assume you have the following Gulp file to lint JavaScript files using ESLint (the file is taken from https://github.com/adametry/gulp-eslint ): const gulp = require('gulp'); const eslint = require('gulp-eslint'); gulp.task('lint', () => { // ESLint ignores files with \"node_modules\" paths. // So, it's best to have gulp ignore the directory as well. // Also, Be sure to return the stream from the task; // Otherwise, the task may end before the stream has finished. return gulp.src(['**/*.js','!node_modules/**']) // eslint() attaches the lint output to the \"eslint\" property // of the file object so it can be used by other modules. .pipe(eslint()) // eslint.format() outputs the lint results to the console. // Alternatively use eslint.formatEach() (see Docs). .pipe(eslint.format()) // To have the process exit with an error code (1) on // lint error, return the stream and pipe to failAfterError last. .pipe(eslint.failAfterError()); }); gulp.task('default', ['lint'], function () { // This will only run if the lint task is successful... }); Executing Run Task from the global Terminal menu will show the following picker: Press the gear icon. This will create the following tasks.json file: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"gulp\", \"task\": \"default\", \"problemMatcher\": [] } ] } Usually you would now add a problem matcher (in this case $eslint-stylish ) or modify the presentation settings. Processing task output with problem matchers VS Code can process the output from a task with a problem matcher. Problem matchers scan the task output text for known warning or error strings, and report these inline in the editor and in the Problems panel. VS Code ships with several problem matchers 'in-the-box': TypeScript : $tsc assumes that file names in the output are relative to the opened folder. TypeScript Watch : $tsc-watch matches problems reported from the tsc compiler when executed in watch mode. JSHint : $jshint assumes that file names are reported as an absolute path. JSHint Stylish : $jshint-stylish assumes that file names are reported as an absolute path. ESLint Compact : $eslint-compact assumes that file names in the output are relative to the opened folder. ESLint Stylish : $eslint-stylish assumes that file names in the output are relative to the opened folder. Go : $go matches problems reported from the go compiler. Assumes that file names are relative to the opened folder. CSharp and VB Compiler : $mscompile assumes that file names are reported as an absolute path. Lessc compiler : $lessc assumes that file names are reported as absolute path. Node Sass compiler : $node-sass assumes that file names are reported as an absolute path. You can also create your own problem matcher, which we'll discuss in a later section . Binding keyboard shortcuts to tasks If you need to run a task frequently, you can define a keyboard shortcut for the task. For example, to bind Ctrl+H to the Run tests task from above, add the following to your keybindings.json file: { \"key\": \"ctrl+h\", \"command\": \"workbench.action.tasks.runTask\", \"args\": \"Run tests\" } Variable substitution When authoring tasks configurations, it is useful to have a set of predefined common variables such as the active file ( ${file} ) or workspace root folder ( ${workspaceFolder} ). VS Code supports variable substitution inside strings in the tasks.json file and you can see a full list of predefined variables in the Variables Reference . Note: Not all properties will accept variable substitution. Specifically, only command , args , and options support variable substitution. Below is an example of a custom task configuration that passes the current opened file to the TypeScript compiler. { \"label\": \"TypeScript compile\", \"type\": \"shell\", \"command\": \"tsc ${file}\", \"problemMatcher\": [ \"$tsc\" ] } Similarly, you can reference your project's configuration settings by prefixing the name with ${config: . For example, ${config:python.formatting.autopep8Path} returns the Python extension setting formatting.autopep8Path . Below is an example of a custom task configuration, which executes autopep8 on the current file using the autopep8 executable defined by the python.formatting.autopep8Path setting: { \"label\": \"autopep8 current file\", \"type\": \"process\", \"command\": \"${config:python.formatting.autopep8Path}\", \"args\": [ \"--in-place\", \"${file}\" ] } If you want to specify the selected Python interpreter used by the Python extension for tasks.json or launch.json , you can use the ${command:python.interpreterPath} command. If simple variable substitution isn't enough, you can also get input from the user of your task by adding an inputs section to your tasks.json file. For more information about inputs , see the Variables Reference . Operating system specific properties The task system supports defining values (for example, the command to be executed) specific to an operating system. To do so, put an operating system specific literal into the tasks.json file and specify the corresponding properties inside that literal. Below is an example that uses the Node.js executable as a command and is treated differently on Windows and Linux: { \"label\": \"Run Node\", \"type\": \"process\", \"windows\": { \"command\": \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" }, \"linux\": { \"command\": \"/usr/bin/node\" } } Valid operating properties are windows for Windows, linux for Linux, and osx for macOS. Properties defined in an operating system specific scope override properties defined in the task or global scope. Task properties can also be defined in the global scope. If present, they will be used for specific tasks unless they define the same property with a different value. In the example below, there is a global presentation property, which defines that all tasks should be executed in a new panel: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"presentation\": { \"panel\": \"new\" }, \"tasks\": [ { \"label\": \"TS - Compile current file\", \"type\": \"shell\", \"command\": \"tsc ${file}\", \"problemMatcher\": [ \"$tsc\" ] } ] } Character escaping in PowerShell When the default shell is PowerShell, or when a task is configured to use PowerShell, you might see unexpected space and quote escaping. The unexpected escaping only occurs with cmdlets because VS Code doesn't know if your command contains cmdlets. Example 1 below shows a case where you'll get escaping that doesn't work with PowerShell. Example 2 shows the best, cross-platform, way to get good escaping. In some cases, you might not be able to follow example 2 and you'll need to do the manual escaping shown in example 3. \"tasks\": [ { \"label\": \"PowerShell example 1 (unexpected escaping)\", \"type\": \"shell\", \"command\": \"Get-ChildItem \\\"Folder With Spaces\\\"\" }, { \"label\": \"PowerShell example 2 (expected escaping)\", \"type\": \"shell\", \"command\": \"Get-ChildItem\", \"args\": [\"Folder With Spaces\"] }, { \"label\": \"PowerShell example 3 (manual escaping)\", \"type\": \"shell\", \"command\": \"& Get-ChildItem \\\\\\\"Folder With Spaces\\\\\\\"\" } ] Changing the encoding for a task output Tasks frequently act with files on disk. If these files are stored on disk with an encoding different than the system encoding, you need to let the command executed as a task know which encoding to use. Since this depends on the operating system and the shell used, there is no general solution to control this. Below are advice and examples on how to make it work. If you need to tweak the encoding, you should check whether it makes sense to change the default encoding used by your operating system or at least change it for the shell you use by tweaking the shell's profile file. If you only need to tweak it for a specific task, then add the OS-specific command necessary to change the encoding to the tasks command line. The following example is for Windows using code page of 437 as its default. The task shows the output of a file containing Cyrillic characters and therefore needs code page 866. The task to list the file looks like this assuming that the default shell is set to cmd.exe : { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"more\", \"type\": \"shell\", \"command\": \"chcp 866 && more russian.txt\", \"problemMatcher\": [] } ] } If the task is executed in PowerShell , the command needs to read like this chcp 866; more russian.txt . On Linux and macOS, the locale command can be used to inspect the locale and tweak the necessary environment variables. Examples of tasks in action To highlight the power of tasks, here are a few examples of how VS Code can use tasks to integrate external tools like linters and compilers. Transpiling TypeScript to JavaScript The TypeScript topic includes an example that creates a task to transpile TypeScript to JavaScript and observe any related errors from within VS Code. Compiling Markdown to HTML The Markdown topic provides two examples for compiling Markdown to HTML: Manually compiling with a Build task Automating the compile step with a file watcher Transpiling Less and SCSS into CSS The CSS topic provides examples of how to use Tasks to generate CSS files. Manually transpiling with a Build task Automation of the compile step with a file watcher Defining a problem matcher VS Code ships some of the most common problem matchers 'in-the-box'. However, there are lots of compilers and linting tools out there, all of which produce their own style of errors and warnings so you may want to create your own problem matcher. We have a helloWorld.c program in which the developer mistyped printf as prinft . Compiling it with gcc will produce the following warning: helloWorld.c:5:3: warning: implicit declaration of function 'prinft' We want to produce a problem matcher that can capture the message in the output and show a corresponding problem in VS Code. Problem matchers heavily rely on regular expressions . The section below assumes you are familiar with regular expressions. Tip: We have found the RegEx101 playground , which has an ECMAScript (JavaScript) flavor, to be a great way to develop and test regular expressions. A matcher that captures the above warning (and errors) looks like this: { // The problem is owned by the cpp language service. \"owner\": \"cpp\", // The file name for reported problems is relative to the opened folder. \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], // The actual pattern to match problems in the output. \"pattern\": { // The regular expression. Example to match: helloWorld.c:5:3: warning: implicit declaration of function 'printf' [-Wimplicit-function-declaration] \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", // The first match group matches the file name which is relative. \"file\": 1, // The second match group matches the line on which the problem occurred. \"line\": 2, // The third match group matches the column at which the problem occurred. \"column\": 3, // The fourth match group matches the problem's severity. Can be ignored. Then all problems are captured as errors. \"severity\": 4, // The fifth match group matches the message. \"message\": 5 } } Note that the file, line, and message properties are mandatory. The fileLocation specifies whether the file paths that are produced by the task output and matched in the problem are absolute or relative . If the task produces both absolute and relative paths, you can use the autoDetect file location. With autoDetect , paths are first tested as absolute paths, and if the file doesn't exist then the path is assumed to be relative. Here is a finished tasks.json file with the code above (comments removed) wrapped with the actual task details: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"command\": \"gcc\", \"args\": [\"-Wall\", \"helloWorld.c\", \"-o\", \"helloWorld\"], \"problemMatcher\": { \"owner\": \"cpp\", \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], \"pattern\": { \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 } } } ] } Running it inside VS Code and pressing kb(workbench.actions.view.problems) to get the list of problems gives you the following output: Note: The C/C++ extension includes problem matchers for GCC so there is no need to define our own. There are a couple more properties that can be used inside a pattern. These are: location - If the problem location is line or line,column or startLine,startColumn,endLine,endColumn, then our generic location match group can be used. endLine - The match group index for the problem's end line. Can be omitted if no end line value is provided by the compiler. endColumn - The match group index for the problem's end column. Can be omitted if no end column value is provided by the compiler. code - The match group index for the problem's code. Can be omitted if no code value is provided by the compiler. You can also define a problem matcher that captures only a file. To do so, define a pattern with the optional kind attribute set to file . In this case, there is no need to provide a line or location property. Note: A functional pattern must at least provide a match group for file and message if the kind property is set to file . If no kind property is provided or the kind property is set to location , a function pattern must provide a line or location property as well. Note: The problem matcher only parses output from the given command. If you want to parse output written to separate file (e.g. a log file), make the command that you run print out lines from the separate file before it finishes executing. Defining a multiline problem matcher Some tools spread problems found in a source file over several lines, especially if stylish reporters are used. An example is ESLint ; in stylish mode it produces output like this: test.js 1:0 error Missing \"use strict\" statement strict ✖ 1 problems (1 errors, 0 warnings) Our problem matcher is line-based so we need to capture the file name (test.js) with a different regular expression than the actual problem location and message (1:0 error Missing \"use strict\" statement). To do this, use an array of problem patterns for the pattern property. This way you define a pattern per each line you want to match. The following problem pattern matches the output from ESLint in stylish mode - but still has one small issue that we need to resolve next. The code below has a first regular expression to capture the file name and the second to capture the line, column, severity, message, and error code: { \"owner\": \"javascript\", \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], \"pattern\": [ { \"regexp\": \"^([^\\\\s].*)$\", \"file\": 1 }, { \"regexp\": \"^\\\\s+(\\\\d+):(\\\\d+)\\\\s+(error|warning|info)\\\\s+(.*)\\\\s\\\\s+(.*)$\", \"line\": 1, \"column\": 2, \"severity\": 3, \"message\": 4, \"code\": 5 } ] } However, this pattern will not work if there is more than one problem on a resource. For instance, imagine the following output from ESLint: test.js 1:0 error Missing \"use strict\" statement strict 1:9 error foo is defined but never used no-unused-vars 2:5 error x is defined but never used no-unused-vars 2:11 error Missing semicolon semi 3:1 error \"bar\" is not defined no-undef 4:1 error Newline required at end of file but not found eol-last ✖ 6 problems (6 errors, 0 warnings) The pattern's first regular expression will match \"test.js\", the second \"1:0 error ...\". The next line \"1:9 error ...\" is processed but not matched by the first regular expression and so no problem is captured. To make this work, the last regular expression of a multiline pattern can specify the loop property. If set to true, it instructs the task system to apply the last pattern of a multiline matcher to the lines in the output as long as the regular expression matches. The information captured by the first pattern, which in this case matches test.js , will be combined with each of the subsequent lines that match the loop pattern to create multiple problems. In this example, six problems would be created. Here is a problem matcher to fully capture ESLint stylish problems: { \"owner\": \"javascript\", \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], \"pattern\": [ { \"regexp\": \"^([^\\\\s].*)$\", \"file\": 1 }, { \"regexp\": \"^\\\\s+(\\\\d+):(\\\\d+)\\\\s+(error|warning|info)\\\\s+(.*)\\\\s\\\\s+(.*)$\", \"line\": 1, \"column\": 2, \"severity\": 3, \"message\": 4, \"code\": 5, \"loop\": true } ] } Note : If you have multiple problems that occur on the same resource with the exact same line and column, then only one problem will be shown. This applies to all problem matchers, not just multiline problem matchers. Modifying an existing problem matcher If an existing problem matcher is close to what you need, you can modify it in your tasks.json task. For example, the $tsc-watch problem matcher only applies to closed documents. If you want to have it apply to all documents you can modify it: { \"type\": \"npm\", \"script\": \"watch\", \"problemMatcher\": { \"base\": \"$tsc-watch\", \"applyTo\": \"allDocuments\" }, \"isBackground\": true, } Other modifiable problem matcher properties include background , fileLocation , owner , pattern , severity , and source . Background / watching tasks Some tools support running in the background while watching the file system for changes and then triggering an action when a file changes on disk. With Gulp such functionality is provided through the npm module gulp-watch . The TypeScript compiler tsc has built in support for this via the --watch command line option. To provide feedback that a background task is active in VS Code and producing problem results, a problem matcher has to use additional information to detect these state changes in the output. Let's take the tsc compiler as an example. When the compiler is started in watch mode, it prints the following additional information to the console: > tsc --watch 12:30:36 PM - Compilation complete. Watching for file changes. When a file changes on disk that contains a problem, the following output appears: 12:32:35 PM - File change detected. Starting incremental compilation... src/messages.ts(276,9): error TS2304: Cannot find name 'candidate'. 12:32:35 PM - Compilation complete. Watching for file changes. Looking at the output shows the following pattern: The compiler runs when File change detected. Starting incremental compilation... is printed to the console. The compiler stops when Compilation complete. Watching for file changes. is printed to the console. Between those two strings problems are reported. The compiler also runs once the initial start (without printing File change detected. Starting incremental compilation... to the console). To capture this information, a problem matcher can provide a background property. For the tsc compiler, an appropriate background property looks like this: \"background\": { \"activeOnStart\": true, \"beginsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - File change detected\\\\. Starting incremental compilation\\\\.\\\\.\\\\.\", \"endsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - Compilation complete\\\\. Watching for file changes\\\\.\" } In addition to the background property on the problem matcher, the task itself has to be marked as isBackground so that the task keeps running in the background. A full handcrafted tasks.json for a tsc task running in watch mode looks like this: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"watch\", \"command\": \"tsc\", \"args\": [\"--watch\"], \"isBackground\": true, \"problemMatcher\": { \"owner\": \"typescript\", \"fileLocation\": \"relative\", \"pattern\": { \"regexp\": \"^([^\\\\s].*)\\\\((\\\\d+|\\\\d+,\\\\d+|\\\\d+,\\\\d+,\\\\d+,\\\\d+)\\\\):\\\\s+(error|warning|info)\\\\s+(TS\\\\d+)\\\\s*:\\\\s*(.*)$\", \"file\": 1, \"location\": 2, \"severity\": 3, \"code\": 4, \"message\": 5 }, \"background\": { \"activeOnStart\": true, \"beginsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - File change detected\\\\. Starting incremental compilation\\\\.\\\\.\\\\.\", \"endsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - Compilation complete\\\\. Watching for file changes\\\\.\" } } } ] } Convert from \"0.1.0\" to \"2.0.0\" Note : If you have created a workspace that consists of multiple folders ( Multi-root Workspace ), only version 2.0.0 tasks are detected and shown in the Terminal > Run Task picker. Try running without tasks.json Tasks 2.0.0 version comes with lots of new auto-detection features so you can try removing an existing tasks.json file to see which tasks still work. One way is to rename the existing tasks.json to tasks.json.off . Migrating to Tasks 2.0.0 If you have lots of task customizations, you can switch by changing the version attribute to \"2.0.0\" . After doing so, you might encounter warnings (green squiggles) because some properties are now deprecated. Here is a migration guide: taskName : Use the label property instead. isShellCommand : Use the \"type\": \"shell\" property instead. isBuildCommand : Use the \"group\": \"build\" property instead. isTestCommand : Use the \"group\": \"test\" property instead. echoCommand : Use the \"presentation\" : { \"echo\": \"...\" } property instead. showOutput : Use the \"presentation\" : { \"reveal\": \"...\" } property instead. suppressTaskName : By default, the task name gets appended to the list of arguments when running a task version 0.1.0 . Since version 2.0.0 supports commands per task, you can inline the command into the task and specify the arguments accordingly. Consider the following 0.1.0 configuration: { \"version\": \"0.1.0\", \"isShellCommand\": true, \"command\": \"script\", \"tasks\": [ { \"taskName\": \"Run tests\", \"suppressTaskName\": true, \"args\": [ \"test\" ] } ] } The corresponding 2.0.0 configuration would look like this: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Run tests\", \"type\": \"shell\", \"command\": \"script test\" } ] } taskSelector : Move the command into the task and specify the task selector inside the command. { \"version\": \"0.1.0\", \"command\": \"msbuild\", \"args\": [ \"/property:GenerateFullPaths=true\" ], \"taskSelector\": \"/t:\", \"tasks\": [ { \"label\": \"build\" } ] } A corresponding 2.0.0 configuration would look like this: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"command\": \"msbuild\", \"args\": [ \"/property:GenerateFullPaths=true\", \"/t:build\" ] } ] } If you want to use a 0.1.0 version of the tasks.json file with the new terminal runner, you can add the runner property to the tasks.json file: \"runner\": \"terminal\" . Next steps That was tasks - let's keep going... tasks.json Schema - You can review the full tasks.json schema and descriptions. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Language Support - Learn about our supported programming languages, both shipped with VS Code and through community extensions. Debugging - Debug your source code directly in the VS Code editor. Common questions Can a task use a different shell than the one specified for the Integrated Terminal? Yes. You can use the \"terminal.integrated.automationShell.*\" setting to set the shell that will be used for all automation in VS Code, which includes Tasks. \"terminal.integrated.automationShell.windows\": \"cmd.exe\", Alternatively, you can override a task's shell with the options.shell property. You can set this per task, globally, or per platform. For example, to use cmd.exe on Windows, your tasks.json would include: { \"version\": \"2.0.0\", \"windows\": { \"options\": { \"shell\": { \"executable\": \"cmd.exe\", \"args\": [ \"/d\", \"/c\" ] } } }, ... Can a background task be used as a prelaunchTask in launch.json? Yes. Since a background task will run until killed, a background task on its own has no signal that it has \"completed\". To use a background task as a prelaunchTask , you must add an appropriate background problemMatcher to the background task so that there is a way for the task system and debug system to know that the task \"finished\". Your task could be: { \"type\": \"npm\", \"script\": \"watch\", \"problemMatcher\": \"$tsc-watch\", \"isBackground\": true, } Note: The $tsc-watch is a background problem matcher, as is required for a background task. You can then use the task as a prelaunchTask in your launch.json file: { \"name\": \"Launch Extension\", \"type\": \"extensionHost\", \"request\": \"launch\", \"runtimeExecutable\": \"${execPath}\", \"args\": [ \"--extensionDevelopmentPath=${workspaceRoot}\" ], \"stopOnEntry\": false, \"sourceMaps\": true, \"outFiles\": [ \"${workspaceRoot}/out/src/**/*.js\" ], \"preLaunchTask\": \"npm: watch\" } For more on background tasks, go to Background / watching tasks . Why do I get \"command not found\" when running a task? The message \"command not found\" happens when the task command you're trying to run is not recognized by your terminal as something runnable. Most often, this occurs because the command is configured as part of your shell's startup scripts. Tasks are run as non-login and non-interactive, which means that the startup scripts for your shell won't be run. nvm in particular is known to use startup scripts as part of its configuration. There are several ways to resolve this issue: Make sure your command is on your path and doesn't require startup scripts to get added to your path. This is the most thorough way to solve the problem, and is the recommended solution. You can make a one-off fix for your task to run as login or interactive. This is not recommended, as it can have other consequences. However, it can also be a quick and easy fix for a single task. Below is an example of a task that does this with bash as the shell: { \"type\": \"npm\", \"script\": \"watch\", \"options\": { \"shell\": { \"args\": [\"-c\", \"-l\"] } } } The above npm task will run bash with a command ( -c ), just like the tasks system does by default. However, this task also runs bash as a login shell ( -l )."
  },
  "guides/vscode/editor/tasks-appendix.html": {
    "href": "guides/vscode/editor/tasks-appendix.html",
    "title": "Appendix | Fountain of Knowledge",
    "keywords": "Appendix This is additional information for Visual Studio Code tasks . Schema for tasks.json The following interfaces define the basic schema of the tasks.json file. Note : Some task options are contributed by VS Code extensions. You can use tasks.json IntelliSense to find a complete list, using the Trigger Suggestions command ( kb(editor.action.triggerSuggest) ). interface TaskConfiguration extends BaseTaskConfiguration { /** * The configuration's version number */ version: \"2.0.0\"; /** * Windows specific task configuration */ windows?: BaseTaskConfiguration; /** * macOS specific task configuration */ osx?: BaseTaskConfiguration; /** * Linux specific task configuration */ linux?: BaseTaskConfiguration; } interface BaseTaskConfiguration { /** * The type of a custom task. Tasks of type \"shell\" are executed * inside a shell (e.g. bash, cmd, powershell, ...) */ type: \"shell\" | \"process\"; /** * The command to be executed. Can be an external program or a shell * command. */ command: string; /** * Specifies whether a global command is a background task. */ isBackground?: boolean; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The arguments passed to the command. Can be omitted. */ args?: string[]; /** * The presentation options. */ presentation?: PresentationOptions; /** * The problem matcher to be used if a global command is executed (e.g. no tasks * are defined). A tasks.json file can either contain a global problemMatcher * property or a tasks property but not both. */ problemMatcher?: string | ProblemMatcher | (string | ProblemMatcher)[]; /** * The configuration of the available tasks. A tasks.json file can either * contain a global problemMatcher property or a tasks property but not both. */ tasks?: TaskDescription[]; } /** * Options to be passed to the external program or shell */ export interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted the current workspace's root is used. */ cwd?: string; /** * The environment of the executed program or shell. If omitted * the parent process' environment is used. */ env?: { [key:string]:string; }; /** * Configuration of the shell when task type is `shell` */ shell: { /** * The shell to use. */ executable: string; /** * The arguments to be passed to the shell executable to run in command mode * (e.g ['-c'] for bash or ['/S', '/C'] for cmd.exe). */ args?: string[]; } } /** * The description of a task. */ interface TaskDescription { /** * The task's name */ label: string; /** * The type of a custom task. Tasks of type \"shell\" are executed * inside a shell (e.g. bash, cmd, powershell, ...) */ type: \"shell\" | \"process\"; /** * The command to execute. If the type is \"shell\" it should be the full * command line including any additional arguments passed to the command. */ command: string; /** * Whether the executed command is kept alive and runs in the background. */ isBackground?: boolean; /** * Additional arguments passed to the command. Should be used if type * is \"process\". */ args?: string[]; /** * Defines the group to which this task belongs. Also supports to mark * a task as the default task in a group. */ group?: \"build\" | \"test\" | { kind: \"build\" | \"test\"; isDefault: boolean }; /** * The presentation options. */ presentation?: PresentationOptions; /** * The problem matcher(s) to use to capture problems in the tasks * output. */ problemMatcher?: string | ProblemMatcher | (string | ProblemMatcher)[]; /** * Defines when and how a task is run. */ runOptions?: RunOptions; } interface PresentationOptions { /** * Controls whether the task output is reveal in the user interface. * Defaults to `always`. */ reveal?: \"never\" | \"silent\" | \"always\"; /** * Controls whether the command associated with the task is echoed * in the user interface. */ echo?: boolean; /** * Controls whether the panel showing the task output is taking focus. */ focus?: boolean; /** * Controls if the task panel is used for this task only (dedicated), * shared between tasks (shared) or if a new panel is created on * every task execution (new). Defaults to `shared` */ panel?: \"shared\" | \"dedicated\" | \"new\"; } /** * A description of a problem matcher that detects problems * in build output. */ interface ProblemMatcher { /** * The name of a base problem matcher to use. If specified the * base problem matcher will be used as a template and properties * specified here will replace properties of the base problem * matcher */ base?: string; /** * The owner of the produced VS Code problem. This is typically * the identifier of a VS Code language service if the problems are * to be merged with the one produced by the language service * or 'external'. Defaults to 'external' if omitted. */ owner?: string; /** * The severity of the VS Code problem produced by this problem matcher. * * Valid values are: * \"error\": to produce errors. * \"warning\": to produce warnings. * \"info\": to produce infos. * * The value is used if a pattern doesn't specify a severity match group. * Defaults to \"error\" if omitted. */ severity?: string; /** * Defines how filename reported in a problem pattern * should be read. Valid values are: * - \"absolute\": the filename is always treated absolute. * - \"relative\": the filename is always treated relative to * the current working directory. This is the default. * - [\"relative\", \"path value\"]: the filename is always * treated relative to the given path value. * - \"autodetect\": the filename is treated relative to * the current workspace directory, and if the file * does not exist, it is treated as absolute. * - [\"autodetect\", \"path value\"]: the filename is treated * relative to the given path value, and if it does not * exist, it is treated as absolute. */ fileLocation?: string | string[]; /** * The name of a predefined problem pattern, the inline definition * of a problem pattern or an array of problem patterns to match * problems spread over multiple lines. */ pattern?: string | ProblemPattern | ProblemPattern[]; /** * Additional information used to detect when a background task (like a watching task in Gulp) * is active. */ background?: BackgroundMatcher; } /** * A description to track the start and end of a background task. */ interface BackgroundMatcher { /** * If set to true the watcher is in active mode when the task * starts. This is equals of issuing a line that matches the * beginPattern. */ activeOnStart?: boolean; /** * If matched in the output the start of a background task is signaled. */ beginsPattern?: string; /** * If matched in the output the end of a background task is signaled. */ endsPattern?: string; } interface ProblemPattern { /** * The regular expression to find a problem in the console output of an * executed task. */ regexp: string; /** * Whether the pattern matches a problem for the whole file or for a location * inside a file. * * Defaults to \"location\". */ kind?: \"file\" | \"location\"; /** * The match group index of the filename. */ file: number; /** * The match group index of the problem's location. Valid location * patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn). * If omitted the line and column properties are used. */ location?: number; /** * The match group index of the problem's line in the source file. * Can only be omitted if location is specified. */ line?: number; /** * The match group index of the problem's column in the source file. */ column?: number; /** * The match group index of the problem's end line in the source file. * * Defaults to undefined. No end line is captured. */ endLine?: number; /** * The match group index of the problem's end column in the source file. * * Defaults to undefined. No end column is captured. */ endColumn?: number; /** * The match group index of the problem's severity. * * Defaults to undefined. In this case the problem matcher's severity * is used. */ severity?: number; /** * The match group index of the problem's code. * * Defaults to undefined. No code is captured. */ code?: number; /** * The match group index of the message. Defaults to 0. */ message: number; /** * Specifies if the last pattern in a multi line problem matcher should * loop as long as it does match a line consequently. Only valid on the * last problem pattern in a multi line problem matcher. */ loop?: boolean; } /** * A description to when and how run a task. */ interface RunOptions { /** * Controls how variables are evaluated when a task is executed through * the Rerun Last Task command. * The default is `true`, meaning that variables will be re-evaluated when * a task is rerun. When set to `false`, the resolved variable values from * the previous run of the task will be used. */ reevaluateOnRerun?: boolean; /** * Specifies when a task is run. * * Valid values are: * \"default\": The task will only be run when executed through the Run Task command. * \"folderOpen\": The task will be run when the containing folder is opened. */ runOn?: string; }"
  },
  "guides/vscode/editor/tasks-v1.html": {
    "href": "guides/vscode/editor/tasks-v1.html",
    "title": "Tasks (legacy version) | Fountain of Knowledge",
    "keywords": "Tasks (legacy version) This documentation describes the legacy Tasks system in Visual Studio Code version 1.13 and earlier. If you want to learn about the latest Tasks 2.0, please refer to the Tasks topic. Developers use lots of tools, mostly run from the command line, to automate jobs outside the inner software development loop (edit, compile, test and debug). Given their importance in the development life-cycle, it is very helpful to be able to run them and analyze their results from within Visual Studio Code. Note: Task support is only available when working on a workspace folder. It is not available when editing single files. Hello World Let's start with a simple \"Hello World\" task which will display text to the OUTPUT panel when run. Create an empty folder \"mytask\" and start VS Code from that folder. mkdir mytask cd mytask code . Tasks are defined in a workspace tasks.json file and VS Code has templates for common task runners. In the Command Palette ( kb(workbench.action.showCommands) ), you can filter on 'task' and can see the various Task related commands. Select the Tasks: Configure Task Runner command and you will see a list of task runner templates. Select Others to create a task which runs an external command. Note: If you don't see the list of task runner templates, you may already have a tasks.json file in your folder and its contents will be open in the editor. Close the file and either delete or rename it for this example. You should now see a tasks.json file in your workspace .vscode folder with the following content: { \"version\": \"0.1.0\", \"command\": \"echo\", \"isShellCommand\": true, \"args\": [\"Hello World\"], \"showOutput\": \"always\" } In this example, we are just running the echo shell command with \"Hello World\" as an argument. Test the echo task by running Tasks: Run Task and selecting echo from the dropdown list. The OUTPUT panel will open and you'll see the text \"Hello World\". You can get IntelliSense on tasks.json variables and their values with hover and trigger smart completions with kb(editor.action.triggerSuggest) . Tip: You can run your task through Quick Open ( kb(workbench.action.quickOpen) ) by typing 'task', kbstyle(Space) and the command name. In this case, 'task echo'. Output Window Behavior Sometimes you will want to control how the output window behaves when running tasks. For instance, you may want to maximize editor space and only look at task output if you think there is a problem. The property showOutput controls this and the valid values are: always - The output window is always brought to front. This is the default. never - The user must explicitly bring the output window to the front using the View > Output command ( kb(workbench.action.output.toggleOutput) ). silent - The output window is brought to front only if no problem matchers are set for the task. echoCommand To see the exact command VS Code is running, you can enable the echoCommand setting in tasks.json : Note: VS Code ships with predefined tasks.json templates to run npm, MSBuild, Maven and other command-line tools. A great way to learn about tasks is to review these templates and see which tools or task runners are similar to other tools you may be using. command and tasks[] tasks.json takes a single command value which can be a task runner like gulp or grunt or any command-line tool like a compiler or linter. By default, the command will show up in the Tasks: Run Task dropdown list. You can also define multiple tasks in a tasks array in order to pass different arguments or use different settings when the command is run. Here's a simple example passing different arguments to the echo command: { \"version\": \"0.1.0\", \"command\": \"echo\", \"isShellCommand\": true, \"args\": [], \"showOutput\": \"always\", \"echoCommand\": true, \"suppressTaskName\": true, \"tasks\": [ { \"taskName\": \"hello\", \"args\": [\"Hello World\"] }, { \"taskName\": \"bye\", \"args\": [\"Good Bye\"] } ] } Now when you run Tasks: Run Task , you will now see two tasks in the dropdown list, hello and bye . We set suppressTaskName to true as by default the task name is also passed to the command which would result in \"echo hello Hello World\". Some tasks.json properties such as showOutput and suppressTaskName can be set both globally and then overridden in specific tasks. The tasks args property values are appended to the global arguments. The final command line is constructed as follows: If suppressTaskName is true , the command line is command 'global args' 'task args' . If suppressTaskName is false , it is command 'global args' taskName 'task args' . There are also tasks specific properties. One useful property is isBuildCommand , which if set to true, will run the task with the Tasks: Run Build Task ( kb(workbench.action.tasks.build) ) command. Running multiple commands If you want to run multiple different commands you can specify different commands per task. A tasks.json file using commands per task looks like this: { \"version\": \"0.1.0\", \"tasks\": [ { \"taskName\": \"tsc\", \"command\": \"tsc\", \"args\": [\"-w\"], \"isShellCommand\": true, \"isBackground\": true, \"problemMatcher\": \"$tsc-watch\" }, { \"taskName\": \"build\", \"command\": \"gulp\", \"args\": [\"build\"], \"isShellCommand\": true } ] } The first task starts the TypeScript compiler in watch mode, the second one starts the gulp build. If a task specifies a local command to run, the task name is not included into the command line ( suppressTaskName is true by default for these tasks). Since a local command can specify local arguments, there is no need for adding it by default. If a tasks.json file specifies both global and task local commands, the task local commands win over the global command. There is no merging between a global and a task local command. Binding keyboard shortcuts to tasks If you need to run a task frequently, you can also define a keyboard shortcut for the task. For example, to bind kbstyle(Ctrl+H) to the build task from above, add the following to your keybindings.json file: { \"key\": \"ctrl+h\", \"command\": \"workbench.action.tasks.runTask\", \"args\": \"build\" } Variable substitution When authoring tasks configurations, it is useful to have a set of predefined common variables such as the active file ( ${file} ) or workspace root folder ( ${workspaceFolder} ). VS Code supports variable substitution inside strings in the tasks.json file and you can see a full list of predefined variables in the Variables Reference . Below is an example of a configuration that passes the current opened file to the TypeScript compiler. { \"command\": \"tsc\", \"args\": [\"${file}\"] } Operating System Specific Properties The task system supports defining values (for example, the command to be executed) specific to an operating system. To do so, put an operating system specific literal into the tasks.json file and specify the corresponding properties inside that literal. Below is an example that uses the Node.js executable as a command and is treated differently on Windows and Linux: { \"version\": \"0.1.0\", \"windows\": { \"command\": \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" }, \"linux\": { \"command\": \"/usr/bin/node\" } } Valid operating properties are windows for Windows, linux for Linux and osx for macOS. Properties defined in an operating system specific scope override properties defined in the global scope. In the example below: { \"version\": \"0.1.0\", \"showOutput\": \"never\", \"windows\": { \"showOutput\": \"always\" } } Output from the executed task is never brought to front except for Windows where it is always shown. Tasks local commands can be made operating specific as well. The syntax is the same as for global commands. Here an example that adds an OS specific argument to a command: { \"version\": \"0.1.0\", \"tasks\": [ { \"taskName\": \"build\", \"command\": \"gulp\", \"isShellCommand\": true, \"windows\": { \"args\": [\"build\", \"win32\"] }, \"linux\": { \"args\": [\"build\", \"linux\"] }, \"osx\": { \"args\": [\"build\", \"osx\"] } } ] } Examples of Tasks in Action To highlight the power of Tasks, here are a few examples of how VS Code can use Tasks to integrate external tools like linters and compilers. Transpiling TypeScript to JavaScript The TypeScript topic includes an example that creates a task to transpile TypeScript to JavaScript and observe any related errors from within VS Code. Compiling Markdown to HTML The Markdown topic provides two examples for compiling Markdown to HTML: Manually compiling with a Build task Automation of the compile step with a file watcher Transpiling Less and SCSS into CSS The CSS topic provides examples of how to use Tasks to generate CSS files. Manually transpiling with a Build task Automation of the compile step with a file watcher Autodetecting Gulp, Grunt and Jake Tasks VS Code can autodetect tasks from within Gulp, Grunt and Jake files. This adds their tasks to the task list without requiring additional configuration (unless you need to use a problem matcher, more on that in a moment). To help make this example more concrete, let's use this simple Gulp file. This defines two tasks: build and debug. The first compiles C# code using Mono 's compiler. The second starts the MyApp under the Mono debugger. var gulp = require(\"gulp\"); var program = \"MyApp\"; var port = 55555; gulp.task('default', ['debug']); gulp.task('build', function() { return gulp .src('./**/*.cs') .pipe(msc(['-fullpaths', '-debug', '-target:exe', '-out:' + program])); }); gulp.task('debug', ['build'], function(done) { return mono.debug({ port: port, program: program}, done); }); Pressing kb(workbench.action.showCommands) and then typing Run Task followed by kbstyle(Enter) will list all available tasks. Selecting one and pressing kbstyle(Enter) will execute the task. Note: Gulp, Grunt and Jake are autodetected only if the corresponding files (for example gulpfile.js ) are present in the root of the opened folder. Processing Task Output with Problem Matchers VS Code can process the output from a task with a problem matcher and we ship with a number of them 'in the box': TypeScript : $tsc assumes that file names in the output are relative to the opened folder. TypeScript Watch : $tsc-watch matches problems reported from the tsc compiler when executed in watch mode. JSHint : $jshint assumes that file names are reported as an absolute path. JSHint Stylish : $jshint-stylish assumes that file names are reported as an absolute path. ESLint Compact : $eslint-compact assumes that file names in the output are relative to the opened folder. ESLint Stylish : $eslint-stylish assumes that file names in the output are relative to the opened folder. Go : $go matches problems reported from the go compiler. Assumes that file names are relative to the opened folder. CSharp and VB Compiler : $mscompile assumes that file names are reported as an absolute path. Less : $lessCompile assumes that file names are reported as absolute path. Problem matchers scan the task output text for known warning or error strings and report these inline in the editor and in the Problems panel. Problem matchers can be set globally or in a specific task entry. You can also create your own problem matcher which we'll talk about soon. Mapping Gulp, Grunt and Jake Output to Problem Matchers You need to configure the tasks in a tasks.json file (located under your workspace .vscode folder) if you want to do more than just run the task. For example, you might want to match reported problems and highlight them within VS Code, or to trigger a build task using the Tasks: Run Build Task command ( kb(workbench.action.tasks.build) ). If you don't already have a tasks.json under your workspace .vscode folder, running the Tasks: Configure Task Runner action from the Command Palette ( kb(workbench.action.showCommands) ) will offer you a set of templates to pick from. For this example, select Gulp from the list. Given a gulpfile.js like the example above, this will generate a tasks.json file like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"0.1.0\", \"command\": \"gulp\", \"isShellCommand\": true, \"args\": [ \"--no-color\" ], \"tasks\": [ { \"taskName\": \"build\", \"args\": [], \"isBuildCommand\": true, \"problemMatcher\": [ \"$lessCompile\", \"$tsc\", \"$jshint\" ] } ] } Since we execute the Mono compiler to compile C# files, we should use the $msCompile problem matcher to detect any problems reported by the compiler. The problemMatcher property will then be: \"problemMatcher\": [ \"$msCompile\" ] Several things to note about this tasks.json : We want to run the gulp command in a shell (VS Code directly executing it) so we used isShellCommand . We added an explicit tasks property which allowed us to optionally augment a task that was in the gulpfile.js . We defined a problem matcher $msCompile to process the output - since we are compiling C# using the Mono compiler, the built-in one works as msc adheres to the Microsoft compiler pattern. Defining a Problem Matcher VS Code ships some of the most common problem matchers out of the box. However, there are lots of compilers and linting tools out there, all of which produce their own style of errors and warnings. So let's talk about how to make your own problem matcher. We have a helloWorld.c program in which the developer mistyped printf as prinft . Compiling it with gcc will produce the following warning: helloWorld.c:5:3: warning: implicit declaration of function 'prinft' We want to produce a problem matcher that can capture the message in the output and show a corresponding problem in VS Code. Problem matchers heavily rely on regular expressions . The section below assumes you are familiar with regular expressions. Tip: We have found the RegEx101 playground a really good way to develop and test regular expressions. A matcher that captures the above warning (and errors) looks like: { // The problem is owned by the cpp language service. \"owner\": \"cpp\", // The file name for reported problems is relative to the opened folder. \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], // The actual pattern to match problems in the output. \"pattern\": { // The regular expression. Example to match: helloWorld.c:5:3: warning: implicit declaration of function 'printf' [-Wimplicit-function-declaration] \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", // The first match group matches the file name which is relative. \"file\": 1, // The second match group matches the line on which the problem occurred. \"line\": 2, // The third match group matches the column at which the problem occurred. \"column\": 3, // The fourth match group matches the problem's severity. Can be ignored. Then all problems are captured as errors. \"severity\": 4, // The fifth match group matches the message. \"message\": 5 } } Please note that the file, line and message properties are mandatory. Here is a finished tasks.json file with the code above (comments removed) wrapped with the actual task details: { \"version\": \"0.1.0\", \"command\": \"gcc\", \"args\": [\"-Wall\", \"helloWorld.c\", \"-o\", \"helloWorld\"], \"problemMatcher\": { \"owner\": \"cpp\", \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], \"pattern\": { \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 } } } Running it inside VS Code and pressing kb(workbench.actions.view.problems) to get the list of problems gives you the following output: There are a couple more properties that can be used inside a pattern. These are: location if the problem location is line or line,column or startLine,startColumn,endLine,endColumn then our generic location match group can be used. endLine the match group index for the problem's end line. Can be omitted if no end line value is provided by the compiler. endColumn the match group index for the problem's end column. Can be omitted if no end column value is provided by the compiler. code the match group index for the problem's code. Can be omitted if no code value is provided by the compiler. Note: A functional pattern must at least provide a match group for file, message and line or location. Defining a Multiline Problem Matcher Some tools spread problems found in a source file over several lines, especially if stylish reporters are used. An example is ESLint ; in stylish mode it produces output like this: test.js 1:0 error Missing \"use strict\" statement strict ✖ 1 problems (1 errors, 0 warnings) Our problem matcher is line-based so we need to capture the file name (test.js) with a different regular expression than the actual problem location and message (1:0 error Missing \"use strict\" statement). To do this we use an array of problem patterns for the pattern property. This way you define a pattern per each line you want to match. The following problem pattern matches the output from ESLint in stylish mode - but still has one small issue which we will resolve next. The code below has a first regular expression to capture the file name and the second to capture the line, column, severity, message and error code: { \"owner\": \"javascript\", \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], \"pattern\": [ { \"regexp\": \"^([^\\\\s].*)$\", \"file\": 1 }, { \"regexp\": \"^\\\\s+(\\\\d+):(\\\\d+)\\\\s+(error|warning|info)\\\\s+(.*)\\\\s\\\\s+(.*)$\", \"line\": 1, \"column\": 2, \"severity\": 3, \"message\": 4, \"code\": 5 } ] } Of course it's never quite that simple, and this pattern will not work if there is more than one problem on a resource. For instance, imagine the following output from ESLint: test.js 1:0 error Missing \"use strict\" statement strict 1:9 error foo is defined but never used no-unused-vars 2:5 error x is defined but never used no-unused-vars 2:11 error Missing semicolon semi 3:1 error \"bar\" is not defined no-undef 4:1 error Newline required at end of file but not found eol-last ✖ 6 problems (6 errors, 0 warnings) The pattern's first regular expression will match \"test.js\", the second \"1:0 error ...\". The next line \"1:9 error ...\" is processed but not matched by the first regular expression and so no problem is captured. To make this work, the last regular expression of a multiline pattern can specify the loop property. If set to true, it instructs the task system to apply the last pattern of a multiline matcher to the lines in the output as long as the regular expression matches. The information captured by all previous patterns is combined with the information captured by the last pattern and turned into a problem inside VS Code. Here is a problem matcher to fully capture ESLint stylish problems: { \"owner\": \"javascript\", \"fileLocation\": [\"relative\", \"${workspaceFolder}\"], \"pattern\": [ { \"regexp\": \"^([^\\\\s].*)$\", \"file\": 1 }, { \"regexp\": \"^\\\\s+(\\\\d+):(\\\\d+)\\\\s+(error|warning|info)\\\\s+(.*)\\\\s\\\\s+(.*)$\", \"line\": 1, \"column\": 2, \"severity\": 3, \"message\": 4, \"code\": 5, \"loop\": true } ] } Background / Watching tasks Some tools support running in the background while watching the file system for changes and then triggering an action when a file changes on disk. With Gulp such functionality is provided through the npm module gulp-watch . The TypeScript compiler tsc has built in support for this via the --watch command line option. To provide feedback that a background task is active in VS Code and producing problem results, a problem matcher has to use additional information to detect these state changes in the output. Let's take the tsc compiler as an example. When the compiler is started in watch mode, it prints the following additional information to the console: > tsc --watch 12:30:36 PM - Compilation complete. Watching for file changes. When a file changes on disk which contains a problem, the following output appears: 12:32:35 PM - File change detected. Starting incremental compilation... src/messages.ts(276,9): error TS2304: Cannot find name 'candidate'. 12:32:35 PM - Compilation complete. Watching for file changes. Looking at the output shows the following pattern: The compiler runs when File change detected. Starting incremental compilation... is printed to the console. The compiler stops when Compilation complete. Watching for file changes. is printed to the console. Between those two strings problems are reported. The compiler also runs once the initial start (without printing File change detected. Starting incremental compilation... to the console). To capture this information, a problem matcher can provide a watching property. For the tsc compiler, this looks like follows: \"watching\": { \"activeOnStart\": true, \"beginsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - File change detected\\\\. Starting incremental compilation\\\\.\\\\.\\\\.\", \"endsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - Compilation complete\\\\. Watching for file changes\\\\.\" } In addition to the watching property on the problem matcher, the task itself has to be marked as isBackground so that the task keeps running in the background. A full handcrafted tasks.json for a tsc task running in watch mode looks like this: { \"version\": \"0.1.0\", \"command\": \"tsc\", \"suppressTaskName\": true, \"tasks\": [ { \"taskName\": \"watch\", \"args\": [\"--watch\"], \"isBackground\": true, \"problemMatcher\": { \"owner\": \"typescript\", \"fileLocation\": \"relative\", \"pattern\": { \"regexp\": \"^([^\\\\s].*)\\\\((\\\\d+|\\\\,\\\\d+|\\\\d+,\\\\d+,\\\\d+,\\\\d+)\\\\):\\\\s+(error|warning|info)\\\\s+(TS\\\\d+)\\\\s*:\\\\s*(.*)$\", \"file\": 1, \"location\": 2, \"severity\": 3, \"code\": 4, \"message\": 5 }, \"watching\": { \"activeOnStart\": true, \"beginsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - File change detected\\\\. Starting incremental compilation\\\\.\\\\.\\\\.\", \"endsPattern\": \"^\\\\s*\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM)? - Compilation complete\\\\. Watching for file changes\\\\.\" } } } ] } Next steps That was tasks - let's keep going... Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code.* Language Support - Learn about our supported programming languages, both shipped with VS Code and through community extensions. Debugging - Debug your source code directly in the VS Code editor."
  },
  "guides/vscode/editor/tasks-v1-appendix.html": {
    "href": "guides/vscode/editor/tasks-v1-appendix.html",
    "title": "Appendix (legacy version) | Fountain of Knowledge",
    "keywords": "Appendix (legacy version) This is additional information for Visual Studio Code tasks . Schema for tasks.json The following interfaces define the schema of the tasks.json file. interface TaskConfiguration extends BaseTaskConfiguration { /** * The configuration's version number */ version: string; /** * Windows specific task configuration */ windows?: BaseTaskConfiguration; /** * macOS specific task configuration */ osx?: BaseTaskConfiguration; /** * Linux specific task configuration */ linux?: BaseTaskConfiguration; } interface BaseTaskConfiguration { /** * The command to be executed. Can be an external program or a shell * command. */ command: string; /** * Specifies whether the command is a shell command and therefore must * be executed in a shell interpreter (e.g. cmd.exe, bash, ...). * * Defaults to false if omitted. */ isShellCommand?: boolean | ShellConfiguration; /** * Specifies whether a global command is a background task. */ isBackground?: boolean; /** * The command options used when the command is executed. Can be omitted. */ options?: CommandOptions; /** * The arguments passed to the command. Can be omitted. */ args?: string[]; /** * Controls whether the output view of the running tasks is brought to front or not. * * Valid values are: * \"always\": bring the output window always to front when a task is executed. * \"silent\": only bring it to front if no problem matcher is defined for the task executed. * \"never\": never bring the output window to front. * * If omitted \"always\" is used. */ showOutput?: string; /** * If set to false the task name is added as an additional argument to the * command when executed. If set to true the task name is suppressed. If * omitted false is used. */ suppressTaskName?: boolean; /** * Some commands require that the task argument is highlighted with a special * prefix (e.g. /t: for MSBuild). This property can be used to control such * a prefix. */ taskSelector?:string; /** * The problem matcher to be used if a global command is executed (e.g. no tasks * are defined). A tasks.json file can either contain a global problemMatcher * property or a tasks property but not both. */ problemMatcher?: string | ProblemMatcher | (string | ProblemMatcher)[]; /** * The configuration of the available tasks. A tasks.json file can either * contain a global problemMatcher property or a tasks property but not both. */ tasks?: TaskDescription[]; } /** * Configuration of the shell when run in terminal */ export interface ShellConfiguration { /** * The shell executable. */ executable: string; /** * The arguments to be passed to the shell executable. */ args?: string[]; } /** * Options to be passed to the external program or shell */ export interface CommandOptions { /** * The current working directory of the executed program or shell. * If omitted the current workspace's root is used. */ cwd?: string; /** * The environment of the executed program or shell. If omitted * the parent process' environment is used. */ env?: { [key:string]:string; }; } /** * The description of a task. */ export interface TaskDescription { /** * The task's name */ taskName: string; /** * Additional arguments passed to the command when this task is * executed. */ args?: string[]; /** * Whether this task maps to the default build command. */ isBuildCommand?:boolean; /** * Whether this task maps to the default test command. */ isTestCommand?: boolean; /** * Whether the executed command is kept alive and runs in the background. */ isBackground?: boolean; /** * Controls whether the output view of the running tasks is brought to front or not. * See BaseTaskConfiguration#showOutput for details. */ showOutput?: string; /** * See BaseTaskConfiguration#suppressTaskName for details. */ suppressTaskName?: boolean; /** * The problem matcher(s) to use to capture problems in the tasks * output. */ problemMatcher?: string | ProblemMatcher | (string | ProblemMatcher)[]; } /** * A description of a problem matcher that detects problems * in build output. */ export interface ProblemMatcher { /** * The name of a base problem matcher to use. If specified the * base problem matcher will be used as a template and properties * specified here will replace properties of the base problem * matcher */ base?: string; /** * The owner of the produced VS Code problem. This is typically * the identifier of a VS Code language service if the problems are * to be merged with the one produced by the language service * or 'external'. Defaults to 'external' if omitted. */ owner?: string; /** * The severity of the VS Code problem produced by this problem matcher. * * Valid values are: * \"error\": to produce errors. * \"warning\": to produce warnings. * \"info\": to produce infos. * * The value is used if a pattern doesn't specify a severity match group. * Defaults to \"error\" if omitted. */ severity?: string; /** * Defines how filename reported in a problem pattern * should be read. Valid values are: * - \"absolute\": the filename is always treated absolute. * - \"relative\": the filename is always treated relative to * the current working directory. This is the default. * - [\"relative\", \"path value\"]: the filename is always * treated relative to the given path value. */ fileLocation?: string | string[]; /** * The name of a predefined problem pattern, the inline definition * of a problem pattern or an array of problem patterns to match * problems spread over multiple lines. */ pattern?: string | ProblemPattern | ProblemPattern[]; /** * Additional information used to detect when a background task (like a watching task in Gulp) * is active. */ watching?: WatchingMatcher; } /** * A description to track the start and end of a watching task. */ export interface WatchingMatcher { /** * If set to true the watcher is in active mode when the task * starts. This is equals of issuing a line that matches the * beginPattern. */ activeOnStart?: boolean; /** * If matched in the output the start of a watching task is signaled. */ beginsPattern?: string; /** * If matched in the output the end of a watching task is signaled. */ endsPattern?: string; } export interface ProblemPattern { /** * The regular expression to find a problem in the console output of an * executed task. */ regexp: string; /** * The match group index of the filename. */ file: number; /** * The match group index of the problem's location. Valid location * patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn). * If omitted the line and column properties are used. */ location?: number; /** * The match group index of the problem's line in the source file. * Can only be omitted if location is specified. */ line?: number; /** * The match group index of the problem's column in the source file. */ column?: number; /** * The match group index of the problem's end line in the source file. * * Defaults to undefined. No end line is captured. */ endLine?: number; /** * The match group index of the problem's end column in the source file. * * Defaults to undefined. No end column is captured. */ endColumn?: number; /** * The match group index of the problem's severity. * * Defaults to undefined. In this case the problem matcher's severity * is used. */ severity?: number; /** * The match group index of the problem's code. * * Defaults to undefined. No code is captured. */ code?: number; /** * The match group index of the message. Defaults to 0. */ message: number; /** * Specifies if the last pattern in a multi line problem matcher should * loop as long as it does match a line consequently. Only valid on the * last problem pattern in a multi line problem matcher. */ loop?: boolean; }"
  },
  "guides/vscode/editor/userdefinedsnippets.html": {
    "href": "guides/vscode/editor/userdefinedsnippets.html",
    "title": "Snippets in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Snippets in Visual Studio Code Code snippets are templates that make it easier to enter repeating code patterns, such as loops or conditional-statements. In Visual Studio Code, snippets appear in IntelliSense ( kb(editor.action.triggerSuggest) ) mixed with other suggestions, as well as in a dedicated snippet picker ( Insert Snippet in the Command Palette). There is also support for tab-completion: Enable it with \"editor.tabCompletion\": \"on\" , type a snippet prefix (trigger text), and press kb(insertSnippet) to insert a snippet. The snippet syntax follows the TextMate snippet syntax with the exceptions of 'interpolated shell code' and the use of \\u ; both are not supported. Built-in snippets VS Code has built-in snippets for a number of languages such as: JavaScript, TypeScript, Markdown, and PHP. You can see the available snippets for a language by running the Insert Snippet command in the Command Palette to get a list of the snippets for the language of the current file. However, keep in mind that this list also includes user snippets that you have defined, and any snippets provided by extensions you have installed. Install snippets from the Marketplace Many extensions on the VS Code Marketplace include snippets. You can search for extensions that contains snippets in the Extensions view ( kb(workbench.view.extensions) ) using the @category:\"snippets\" filter. If you find an extension you want to use, install it, then restart VS Code and the new snippets will be available. Create your own snippets You can easily define your own snippets without any extension. To create or edit your own snippets, select User Snippets under File > Preferences ( Code > Preferences on macOS), and then select the language (by language identifier ) for which the snippets should appear, or the New Global Snippets file option if they should appear for all languages. VS Code manages the creation and refreshing of the underlying snippets file(s) for you. Snippets files are written in JSON, support C-style comments, and can define an unlimited number of snippets. Snippets support most TextMate syntax for dynamic behavior, intelligently format whitespace based on the insertion context, and allow easy multiline editing. Below is an example of a for loop snippet for JavaScript: // in file 'Code/User/snippets/javascript.json' { \"For Loop\": { \"prefix\": [ \"for\", \"for-const\" ], \"body\": [ \"for (const ${2:element} of ${1:array}) {\", \"\\t$0\", \"}\" ], \"description\": \"A for loop.\" } } In the example above: \"For Loop\" is the snippet name. It is displayed via IntelliSense if no description is provided. prefix defines one or more trigger words that display the snippet in IntelliSense. Substring matching is performed on prefixes, so in this case, \"fc\" could match \"for-const\". body is one or more lines of content, which will be joined as multiple lines upon insertion. Newlines and embedded tabs will be formatted according to the context in which the snippet is inserted. description is an optional description of the snippet displayed by IntelliSense. Additionally, the body of the example above has three placeholders (listed in order of traversal): ${1:array} , ${2:element} , and $0 . You can quickly jump to the next placeholder with kb(jumpToNextSnippetPlaceholder) , at which point you may edit the placeholder or jump again the next one. The string after the colon (if any) is the default text, for example element in ${2:element} . Placeholder traversal order is ascending by number, starting from one; zero is an optional special case that always comes last, and exits snippet mode with the cursor at the specified position. Snippet scope Snippets are scoped so that only relevant snippets are suggested. Snippets can be scoped by either: the language(s) to which snippets are scoped (possibly all) the project(s) to which snippets are scoped (probably all) Language snippet scope Every snippet is scoped to one, several, or all (\"global\") languages based on whether it is defined in: a language snippet file a global snippet file Single-language user-defined snippets are defined in a specific language's snippet file (for example javascript.json ), which you can access by language identifier through Preferences: Configure User Snippets . A snippet is only accessible when editing the language for which it is defined. Multi-language and global user-defined snippets are all defined in \"global\" snippet files (JSON with the file suffix .code-snippets ), which is also accessible through Preferences: Configure User Snippets . In a global snippets file, a snippet definition may have an additional scope property that takes one or more language identifiers, which makes the snippet available only for those specified languages. If no scope property is given, then the global snippet is available in all languages. Most user-defined snippets are scoped to a single language, and so are defined in a language-specific snippet file. Project snippet scope You can also have a global snippets file (JSON with file suffix .code-snippets ) scoped to your project. Project-folder snippets are created with the New Snippets file for ' '... option in the Preferences: Configure User Snippets dropdown menu and are located at the root of the project in a .vscode folder. Project snippet files are useful for sharing snippets with all users working in that project. Project-folder snippets are similar to global snippets and can be scoped to specific languages through the scope property. Snippet syntax The body of a snippet can use special constructs to control cursors and the text being inserted. The following are supported features and their syntaxes: Tabstops With tabstops, you can make the editor cursor move inside a snippet. Use $1 , $2 to specify cursor locations. The number is the order in which tabstops will be visited, whereas $0 denotes the final cursor position. Multiple occurrences of the same tabstop are linked and updated in sync. Placeholders Placeholders are tabstops with values, like ${1:foo} . The placeholder text will be inserted and selected such that it can be easily changed. Placeholders can be nested, like ${1:another ${2:placeholder}} . Choice Placeholders can have choices as values. The syntax is a comma-separated enumeration of values, enclosed with the pipe-character, for example ${1|one,two,three|} . When the snippet is inserted and the placeholder selected, choices will prompt the user to pick one of the values. Variables With $name or ${name:default} , you can insert the value of a variable. When a variable isn't set, its default or the empty string is inserted. When a variable is unknown (that is, its name isn't defined) the name of the variable is inserted and it is transformed into a placeholder. The following variables can be used: TM_SELECTED_TEXT The currently selected text or the empty string TM_CURRENT_LINE The contents of the current line TM_CURRENT_WORD The contents of the word under cursor or the empty string TM_LINE_INDEX The zero-index based line number TM_LINE_NUMBER The one-index based line number TM_FILENAME The filename of the current document TM_FILENAME_BASE The filename of the current document without its extensions TM_DIRECTORY The directory of the current document TM_FILEPATH The full file path of the current document RELATIVE_FILEPATH The relative (to the opened workspace or folder) file path of the current document CLIPBOARD The contents of your clipboard WORKSPACE_NAME The name of the opened workspace or folder WORKSPACE_FOLDER The path of the opened workspace or folder For inserting the current date and time: CURRENT_YEAR The current year CURRENT_YEAR_SHORT The current year's last two digits CURRENT_MONTH The month as two digits (example '02') CURRENT_MONTH_NAME The full name of the month (example 'July') CURRENT_MONTH_NAME_SHORT The short name of the month (example 'Jul') CURRENT_DATE The day of the month CURRENT_DAY_NAME The name of day (example 'Monday') CURRENT_DAY_NAME_SHORT The short name of the day (example 'Mon') CURRENT_HOUR The current hour in 24-hour clock format CURRENT_MINUTE The current minute CURRENT_SECOND The current second CURRENT_SECONDS_UNIX The number of seconds since the Unix epoch For inserting random values: RANDOM 6 random Base-10 digits RANDOM_HEX 6 random Base-16 digits UUID A Version 4 UUID For inserting line or block comments, honoring the current language: BLOCK_COMMENT_START Example output: in PHP /* or in HTML <!-- BLOCK_COMMENT_END Example output: in PHP */ or in HTML --> LINE_COMMENT Example output: in PHP // The snippet below inserts /* Hello World */ in JavaScript files and <!-- Hello World --> in HTML files: { \"hello\": { \"scope\": \"javascript,html\", \"prefix\": \"hello\", \"body\": \"$BLOCK_COMMENT_START Hello World $BLOCK_COMMENT_END\" } } Variable transforms Transformations allow you to modify the value of a variable before it is inserted. The definition of a transformation consists of three parts: A regular expression that is matched against the value of a variable, or the empty string when the variable cannot be resolved. A \"format string\" that allows to reference matching groups from the regular expression. The format string allows for conditional inserts and simple modifications. Options that are passed to the regular expression. The following example inserts the name of the current file without its ending, so from foo.txt it makes foo . ${TM_FILENAME/(.*)\\\\..+$/$1/} | | | | | | | |-> no options | | | | | |-> references the contents of the first | | capture group | | | |-> regex to capture everything before | the final `.suffix` | |-> resolves to the filename Placeholder-Transform Like a Variable-Transform, a transformation of a placeholder allows changing the inserted text for the placeholder when moving to the next tab stop. The inserted text is matched with the regular expression and the match or matches - depending on the options - are replaced with the specified replacement format text. Every occurrence of a placeholder can define its own transformation independently using the value of the first placeholder. The format for Placeholder-Transforms is the same as for Variable-Transforms. Transform examples The examples are shown within double quotes, as they would appear inside a snippet body, to illustrate the need to double escape certain characters. Sample transformations and the resulting output for the filename example-123.456-TEST.js . Example Output Explanation \"${TM_FILENAME/[\\\\.]/_/}\" example-123_456-TEST.js Replace the first . with _ \"${TM_FILENAME/[\\\\.-]/_/g}\" example_123_456_TEST_js Replace each . or - with _ \"${TM_FILENAME/(.*)/${1:/upcase}/}\" EXAMPLE-123.456-TEST.JS Change to all uppercase \"${TM_FILENAME/[^0-9^a-z]//gi}\" example123456TESTjs Remove non-alphanumeric characters Grammar Below is the EBNF ( extended Backus-Naur form ) for snippets. With \\ (backslash), you can escape $ , } , and \\ . Within choice elements, the backslash also escapes comma and pipe characters. any ::= tabstop | placeholder | choice | variable | text tabstop ::= '$' int | '${' int '}' | '${' int transform '}' placeholder ::= '${' int ':' any '}' choice ::= '${' int '|' text (',' text)* '|}' variable ::= '$' var | '${' var '}' | '${' var ':' any '}' | '${' var transform '}' transform ::= '/' regex '/' (format | text)+ '/' options format ::= '$' int | '${' int '}' | '${' int ':' '/upcase' | '/downcase' | '/capitalize' | '/camelcase' | '/pascalcase' '}' | '${' int ':+' if '}' | '${' int ':?' if ':' else '}' | '${' int ':-' else '}' | '${' int ':' else '}' regex ::= JavaScript Regular Expression value (ctor-string) options ::= JavaScript Regular Expression option (ctor-options) var ::= [_a-zA-Z] [_a-zA-Z0-9]* int ::= [0-9]+ text ::= .* Using TextMate snippets You can also use existing TextMate snippets (.tmSnippets) with VS Code. See the Using TextMate Snippets topic in our Extension API section to learn more. Assign keybindings to snippets You can create custom keybindings to insert specific snippets. Open keybindings.json ( Preferences: Open Keyboard Shortcuts File ), which defines all your keybindings, and add a keybinding passing \"snippet\" as an extra argument: { \"key\": \"cmd+k 1\", \"command\": \"editor.action.insertSnippet\", \"when\": \"editorTextFocus\", \"args\": { \"snippet\": \"console.log($1)$0\" } } The keybinding will invoke the Insert Snippet command but instead of prompting you to select a snippet, it will insert the provided snippet. You define the custom keybinding as usual with a keyboard shortcut, command ID, and optional when clause context for when the keyboard shortcut is enabled. Also, instead of using the snippet argument value to define your snippet inline, you can reference an existing snippet by using the langId and name arguments. The langId argument is the name of the JSON user snippet file and name is the snippet's unique name from this file: { \"key\": \"cmd+k 1\", \"command\": \"editor.action.insertSnippet\", \"when\": \"editorTextFocus\", \"args\": { \"langId\": \"csharp\", \"name\": \"myFavSnippet\" } } Next steps Command Line - VS Code has a rich command-line interface to open or diff files and install extensions. Extension API - Learn about other ways to extend VS Code. Snippet Guide - You can package snippets for use in VS Code. Common questions What if I want to use existing TextMate snippets from a .tmSnippet file? You can easily package TextMate snippets files for use in VS Code. See Using TextMate Snippets in our Extension API documentation. How do I have a snippet place a variable in the pasted script? To have a variable in the pasted script, you need to escape the '$' of the $variable name so that it isn't parsed by the snippet expansion phase. \"VariableSnippet\":{ \"prefix\": \"_Var\", \"body\": \"\\\\$MyVar = 2\", \"description\": \"A basic snippet that places a variable into script with the $ prefix\" } This results in the pasted snippet as: $MyVar = 2 Can I remove snippets from IntelliSense? Yes, you can hide specific snippets from showing in IntelliSense (completion list) by selecting the Hide from IntelliSense button to the right of snippet items in the Insert Snippet command dropdown. You can still select the snippet with the Insert Snippet command but the hidden snippet won't be displayed in IntelliSense."
  },
  "guides/vscode/editor/variables-reference.html": {
    "href": "guides/vscode/editor/variables-reference.html",
    "title": "Variables Reference | Fountain of Knowledge",
    "keywords": "Variables Reference Visual Studio Code supports variable substitution in Debugging and Task configuration files as well as some select settings. Variable substitution is supported inside some key and value strings in launch.json and tasks.json files using ${variableName} syntax. Predefined variables The following predefined variables are supported: ${workspaceFolder} - the path of the folder opened in VS Code ${workspaceFolderBasename} - the name of the folder opened in VS Code without any slashes (/) ${file} - the current opened file ${fileWorkspaceFolder} - the current opened file's workspace folder ${relativeFile} - the current opened file relative to workspaceFolder ${relativeFileDirname} - the current opened file's dirname relative to workspaceFolder ${fileBasename} - the current opened file's basename ${fileBasenameNoExtension} - the current opened file's basename with no file extension ${fileDirname} - the current opened file's dirname ${fileExtname} - the current opened file's extension ${cwd} - the task runner's current working directory on startup ${lineNumber} - the current selected line number in the active file ${selectedText} - the current selected text in the active file ${execPath} - the path to the running VS Code executable ${defaultBuildTask} - the name of the default build task ${pathSeparator} - the character used by the operating system to separate components in file paths Predefined variables examples Supposing that you have the following requirements: A file located at /home/your-username/your-project/folder/file.ext opened in your editor; The directory /home/your-username/your-project opened as your root workspace. So you will have the following values for each variable: ${workspaceFolder} - /home/your-username/your-project ${workspaceFolderBasename} - your-project ${file} - /home/your-username/your-project/folder/file.ext ${fileWorkspaceFolder} - /home/your-username/your-project ${relativeFile} - folder/file.ext ${relativeFileDirname} - folder ${fileBasename} - file.ext ${fileBasenameNoExtension} - file ${fileDirname} - /home/your-username/your-project/folder ${fileExtname} - .ext ${lineNumber} - line number of the cursor ${selectedText} - text selected in your code editor ${execPath} - location of Code.exe ${pathSeparator} - / on macOS or linux, \\ on Windows Tip : Use IntelliSense inside string values for tasks.json and launch.json to get a full list of predefined variables. Variables scoped per workspace folder By appending the root folder's name to a variable (separated by a colon), it is possible to reach into sibling root folders of a workspace. Without the root folder name, the variable is scoped to the same folder where it is used. For example, in a multi root workspace with folders Server and Client , a ${workspaceFolder:Client} refers to the path of the Client root. Environment variables You can also reference environment variables through the ${env:Name} syntax (for example, ${env:USERNAME} ). { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/app.js\", \"cwd\": \"${workspaceFolder}\", \"args\": [ \"${env:USERNAME}\" ] } Configuration variables You can reference VS Code settings (\"configurations\") through ${config:Name} syntax (for example, ${config:editor.fontSize} ). Command variables If the predefined variables from above are not sufficient, you can use any VS Code command as a variable through the ${command:commandID} syntax. A command variable is replaced with the (string) result from the command evaluation. The implementation of a command can range from a simple calculation with no UI, to some sophisticated functionality based on the UI features available via VS Code's extension API. If the command returns anything other than a string, then the variable replacement will not complete. Command variables must return a string. An example of this functionality is in VS Code's Node.js debugger extension, which provides an interactive command extension.pickNodeProcess for selecting a single process from the list of all running Node.js processes. The command returns the process ID of the selected process. This makes it possible to use the extension.pickNodeProcess command in an Attach by Process ID launch configuration in the following way: { \"configurations\": [ { \"type\": \"node\", \"request\": \"attach\", \"name\": \"Attach by Process ID\", \"processId\": \"${command:extension.pickNodeProcess}\" } ] } Input variables Command variables are already powerful but they lack a mechanism to configure the command being run for a specific use case. For example, it is not possible to pass a prompt message or a default value to a generic \"user input prompt\". This limitation is solved with input variables which have the syntax: ${input:variableID} . The variableID refers to entries in the inputs section of launch.json and tasks.json , where additional configuration attributes are specified. The following example shows the overall structure of a tasks.json that makes use of input variables: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"task name\", \"command\": \"${input:variableID}\", // ... } ], \"inputs\": [ { \"id\": \"variableID\", \"type\": \"type of input variable\", // type specific configuration attributes } ] } Currently VS Code supports three types of input variables: promptString : Shows an input box to get a string from the user. pickString : Shows a Quick Pick dropdown to let the user select from several options. command : Runs an arbitrary command. Each type requires additional configuration attributes: promptString : description : Shown in the quick input, provides context for the input. default : Default value that will be used if the user doesn't enter something else. password : Set to true to input with a password prompt that will not show the typed value. pickString : description : Shown in the quick pick, provides context for the input. options : An array of options for the user to pick from. default : Default value that will be used if the user doesn't enter something else. It must be one of the option values. command : command : Command being run on variable interpolation. args : Optional option bag passed to the command's implementation. Below is an example of a tasks.json that illustrates the use of inputs using Angular CLI: { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"ng g\", \"type\": \"shell\", \"command\": \"ng\", \"args\": [ \"g\", \"${input:componentType}\", \"${input:componentName}\" ], } ], \"inputs\": [ { \"type\": \"pickString\", \"id\": \"componentType\", \"description\": \"What type of component do you want to create?\", \"options\": [\"component\", \"directive\", \"pipe\", \"service\", \"class\", \"guard\", \"interface\", \"enum\", \"enum\"], \"default\": \"component\" }, { \"type\": \"promptString\", \"id\": \"componentName\", \"description\": \"Name your component.\", \"default\": \"my-new-component\" } ] } Running the example: The following example shows how to use a user input variable of type command in a debug configuration that lets the user pick a test case from a list of all test cases found in a specific folder. It is assumed that some extension provides an extension.mochaSupport.testPicker command that locates all test cases in a configurable location and shows a picker UI to pick one of them. The arguments for a command input are defined by the command itself. { \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Run specific test\", \"program\": \"${workspaceFolder}/${input:pickTest}\" } ], \"inputs\": [ { \"id\": \"pickTest\", \"type\": \"command\", \"command\": \"extension.mochaSupport.testPicker\", \"args\": { \"testFolder\": \"/out/tests\", } } ] } Command inputs can also be used with tasks. In this example, the built-in Terminate Task command is used. It can accept an argument to terminate all tasks. { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Terminate All Tasks\", \"command\": \"echo ${input:terminate}\", \"type\": \"shell\", \"problemMatcher\": [] } ], \"inputs\": [ { \"id\": \"terminate\", \"type\": \"command\", \"command\": \"workbench.action.tasks.terminate\", \"args\": \"terminateAll\" } ] } Common questions Details of variable substitution in a debug configuration or task Variable substitution in debug configurations or tasks is a two pass process: In the first pass, all variables are evaluated to string results. If a variable occurs more than once, it is only evaluated once. In the second pass, all variables are substituted with the results from the first pass. A consequence of this is that the evaluation of a variable (for example, a command-based variable implemented in an extension) has no access to other substituted variables in the debug configuration or task. It only sees the original variables. This means that variables cannot depend on each other (which ensures isolation and makes substitution robust against evaluation order). Is variable substitution supported in User and Workspace settings? The predefined variables are supported in a select number of setting keys in settings.json files such as the terminal cwd , env , shell and shellArgs values. Some settings like window.title have their own variables: \"window.title\": \"${dirty}${activeEditorShort}${separator}${rootName}${separator}${appName}\" Refer to the comments in the Settings editor ( kb(workbench.action.openSettings) ) to learn about setting specific variables. Why isn't ${workspaceRoot} documented? The variable ${workspaceRoot} was deprecated in favor of ${workspaceFolder} to better align with Multi-root Workspace support. Why aren't variables in tasks.json being resolved? Not all values in tasks.json support variable substitution. Specifically, only command , args , and options support variable substitution. How can I know a variable's actual value? One easy way to check a variable's runtime value is to create a VS Code task to output the variable value to the console. For example, to see the resolved value for ${workspaceFolder} , you can create and run ( Terminal > Run Task ) the following simple 'echo' task in tasks.json : { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"echo\", \"type\": \"shell\", \"command\": \"echo ${workspaceFolder}\" } ] }"
  },
  "guides/vscode/editor/versioncontrol.html": {
    "href": "guides/vscode/editor/versioncontrol.html",
    "title": "Using Version Control in VS Code | Fountain of Knowledge",
    "keywords": "Using Version Control in VS Code Visual Studio Code has integrated source control management (SCM) and includes Git support in-the-box. Many other source control providers are available through extensions on the VS Code Marketplace. Tip: Click on an extension tile to read the description and reviews in the Marketplace. SCM Providers VS Code has support for handling multiple Source Control providers simultaneously. For example, you can open multiple Git repositories alongside your Azure DevOps Server local workspace and seamlessly work across your projects. To turn on the Source Control Providers view, select the overflow menu in the Source Control view ( kb(workbench.view.scm) ), hover over Views , and make sure that Source Control Repositories is marked with a check. The Source Control Providers view shows the detected providers and repositories, and you can scope the display of your changes by selecting a specific provider. SCM Provider extensions If you would like to install another SCM provider, you can search on the scm providers extension category in the Extensions view ( kb(workbench.view.extensions) ). Start typing '@ca' and you will see suggestions for extension categories like debuggers and linters. Select @category:\"scm providers\" to see available SCM providers. Git support VS Code ships with a Git source control manager (SCM) extension. Most of the source control UI and work flows are common across other SCM extensions, so reading about the general Git support in VS Code will help you understand how to use another provider. Note: If you are new to Git, the git-scm website is a good place to start, with a popular online book , Getting Started videos and cheat sheets . The VS Code documentation assumes you are already familiar with Git. Note: VS Code will leverage your machine's Git installation, so you need to install Git first before you get these features. Make sure you install at least version 2.0.0 . 👉 When you commit, be aware that if your username and/or email is not set in your Git configuration, Git will fall back to using information from your local machine. You can find the details in Git commit information . The Source Control icon in the Activity Bar on the left will always indicate an overview of how many changes you currently have in your repository. Selecting the icon will show you the details of your current repository changes: CHANGES , STAGED CHANGES and MERGE CHANGES . Clicking each item will show you in detail the textual changes within each file . Note that for unstaged changes, the editor on the right still lets you edit the file: feel free to use it! You can also find indicators of the status of your repository in the bottom-left corner of VS Code: the current branch , dirty indicators , and the number of incoming and outgoing commits of the current branch. You can checkout any branch in your repository by clicking that status indicator and selecting the Git reference from the list. Tip: You can open VS Code in a sub-directory of a Git repository. VS Code's Git services will still work as usual, showing all changes within the repository, but file changes outside of the scoped directory are shaded with a tool tip indicating they are located outside the current workspace. Commit Staging (git add) and unstaging (git reset) can be done via contextual actions in the files or by drag-and-drop. You can type a commit message above the changes and press kbstyle(Ctrl+Enter) (macOS: kbstyle(⌘+Enter) ) to commit them. If there are any staged changes, only changes will be committed. Otherwise, you'll get a prompt asking you to select what changes you'd like to commit and get the option to change your commit settings. We've found this to be a great workflow. For example, in the earlier screenshot, only the staged changes to gulpfile.js will be included in the commit. A consecutive commit action could commit later changes to gulpfile.js , the deletion of yarn.lock , and changes to tests.js in a separate commit. More specific Commit actions can be found in the Views and More Actions ... menu on the top of the Source Control view. Tip: If you commit your change to the wrong branch, undo your commit using the Git: Undo Last Commit command in the Command Palette ( kb(workbench.action.showCommands) ). Cloning a repository If you haven't opened a folder yet, the Source Control view will give you the options to Open Folder from your local machine or Clone Repository . If you select Clone Repository , you will be asked for the URL of the remote repository (for example on GitHub ) and the parent directory under which to put the local repository. For a GitHub repository, you would find the URL from the GitHub Code dialog. You would then paste that URL into the Git: Clone prompt. You'll also see the option to Clone from GitHub . Once you authenticate with your GitHub account in VS Code, you'll be able to search through repositories by name, and select any repo to clone it. You can also start the flow to clone a Git repository with the Git: Clone command in the Command Palette ( kb(workbench.action.showCommands) ). To see a step-by-step walkthrough, check out our Clone repos from VS Code video. Note : If you'd like to work on a repository without cloning the contents to you local machine, you can install the GitHub Repositories extension to browse and edit directly on GitHub. You can learn more in the GitHub Repositories extension section. Branches and Tags You can create and checkout branches directly within VS code through the Git: Create Branch and Git: Checkout to commands in the Command Palette ( kb(workbench.action.showCommands) ). If you run Git: Checkout to , you will see a dropdown list containing all of the branches or tags in the current repository. It will also give you the option to create a new branch if you decide that's a better option, or checkout a branch in detached mode. The Git: Create Branch command lets you quickly create a new branch. Just provide the name of your new branch and VS Code will create the branch and switch to it. If you choose to Create new branch from... , you'll get an extra prompt that allows you to specify which commit the new branch should be pointing to. Remotes Given that your repository is connected to some remote and that your checked out branch has an upstream link to a branch in that remote, VS Code offers you useful actions to push , pull , and sync that branch (the latter will run a pull command followed by a push command). You can find these actions in the Views and More Actions ... menu, along with the option to add or remove a remote . VS Code is able to periodically fetch changes from your remotes. This enables VS Code to show how many changes your local repository is ahead or behind the remote. Starting with VS Code 1.19, this feature is disabled by default and you can use the git.autofetch setting to enable it. Tip: You should set up a credential helper to avoid getting asked for credentials every time VS Code talks to your Git remotes. If you don't do this, you may want to consider disabling automatic fetching via the git.autofetch setting to reduce the number of prompts you get. Git Status Bar actions There is a Synchronize Changes action in the Status Bar, next to the branch indicator, when the current checked out branch has an upstream branch configured. Synchronize Changes will pull remote changes down to your local repository and then push local commits to the upstream branch. If there is no upstream branch configured and the Git repository has remotes set up, the Publish action is enabled. This will let you publish the current branch to a remote. Gutter indicators If you open a folder that is a Git repository and begin making changes, VS Code will add useful annotations to the gutter and to the overview ruler. A red triangle indicates where lines have been deleted A green bar indicates new added lines A blue bar indicates modified lines Merge conflicts Merge conflicts are recognized by VS Code. Differences are highlighted and there are inline actions to accept either one or both changes. Once the conflicts are resolved, stage the conflicting file so you can commit those changes. Viewing diffs Our Git tooling supports viewing of diffs within VS Code. Tip: You can diff any two files by first right clicking on a file in the Explorer or OPEN EDITORS list and selecting Select for Compare and then right-click on the second file to compare with and select Compare with 'file_name_you_chose' . Alternatively from the keyboard hit kb(workbench.action.showCommands) and select File: Compare Active File With and you will be presented with a list of recent files. Diff editor review pane There is a review pane in the Diff editor that presents changes in a unified patch format. You can navigate between changes with Go to Next Difference ( kb(editor.action.diffReview.next) ) and Go to Previous Difference ( kb(editor.action.diffReview.prev) ). Lines can be navigated with arrow keys and pressing kbstyle(Enter) will jump back in the Diff editor and the selected line. Note: This experience is especially helpful for screen reader users. Timeline view The Timeline view, accessible at the bottom of the File Explorer by default, is a unified view for visualizing time-series events (for example, Git commits) for a file. VS Code's built-in Git support provides the Git commit history of the specified file. Selecting a commit will open a diff view of the changes introduced by that commit. When you right-click on a commit, you'll get options to Copy Commit ID and Copy Commit Message . Visual Studio Code supports more Git history workflows through extensions available on the VS Code Marketplace. Tip: Click on an extension tile to read the description and reviews in the Marketplace. Git output window You can always peek under the hood to see the Git commands we are using. This is helpful if something strange is happening or if you are just curious. :) To open the Git output window, run View > Output and select Git from the dropdown list. Initialize a repository If your workspace is on your local machine, you can enable Git source control by creating a Git repository with the Initialize Repository command. When VS Code doesn't detect an existing Git repository, the Source Control view will give you the options to Initialize Repository or Publish to GitHub . You can also run the Git: Initialize Repository and Publish to GitHub commands from the Command Palette ( kb(workbench.action.showCommands) ). Running Initialize Repository will create the necessary Git repository metadata files and show your workspace files as untracked changes ready to be staged. Publish to GitHub will directly publish your workspace folder to a GitHub repository, allowing you to choose between a private and public repositories. Check out our publishing repos video for more information about publishing to GitHub. VS Code as Git editor When you launch VS Code from the command line, you can pass the --wait argument to make the launch command wait until you have closed the new VS Code instance. This can be useful when you configure VS Code as your Git external editor so Git will wait until you close the launched VS Code instance. Here are the steps to do so: Make sure you can run code --help from the command line and you get help. if you do not see help, please follow these steps: macOS: Select Shell Command: Install 'Code' command in path from the Command Palette . Windows: Make sure you selected Add to PATH during the installation. Linux: Make sure you installed Code via our new .deb or .rpm packages. From the command line, run git config --global core.editor \"code --wait\" Now you can run git config --global -e and use VS Code as editor for configuring Git. VS Code as Git diff tool Add the following to your Git configurations to use VS Code as the diff tool: [diff] tool = default-difftool [difftool \"default-difftool\"] cmd = code --wait --diff $LOCAL $REMOTE This leverages the --diff option you can pass to VS Code to compare two files side by side. To summarize, here are some examples of where you can use VS Code as the editor: git rebase HEAD~3 -i do interactive rebase using VS Code git commit use VS Code for the commit message git add -p followed by kbstyle(e) for interactive add git difftool <commit>^ <commit> use VS Code as the diff editor for changes Working with pull requests Visual Studio Code also supports pull request workflows through the GitHub Pull Requests and Issues extension available on the VS Code Marketplace. Pull request extensions let you review, comment, and verify source code contributions directly within VS Code. Next steps Intro Video - Git Version Control - An introductory video providing an overview of VS Code Git support. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Debugging - This is where VS Code really shines Tasks - Running tasks with Gulp, Grunt, and Jake. Showing Errors and Warnings Source Control API - If you want to integrate another Source Control provider into VS Code, see our Source Control API. Common questions I initialized my repo but the actions in the ... menu are all grayed out To push, pull, and sync you need to have a Git origin set up. You can get the required URL from the repository host. Once you have that URL, you need to add it to the Git settings by running a couple of command-line actions. For example: > git remote add origin https://github.com/<repo owner>/<repo name>.git > git push -u origin main My team is using Team Foundation Version Control (TFVC) instead of Git. What should I do? Use the Azure Repos extension and this will light up TFVC support. Why do the Pull, Push and Sync actions never finish? This usually means there is no credential management configured in Git and you're not getting credential prompts for some reason. You can always set up a credential helper in order to pull and push from a remote server without having VS Code prompt for your credentials each time. How can I sign in to Git with my Azure DevOps organization that requires multi-factor authentication? There are now Git credential helpers that assist with multi-factor authentication. You can download these from Git Credential Manager for Mac and Linux and Git Credential Manager for Windows . I have GitHub Desktop installed on my computer but VS Code ignores it VS Code only supports the official Git distribution for its Git integration. I keep getting Git authentication dialogs whenever VS Code is running VS Code automatically fetches changes from the server in order to present you with a summary of incoming changes. The Git authentication dialog is independent from VS Code itself and is a part of your current Git credential helper. One way to avoid these prompts is to set up a credential helper that remembers your credentials. Another option is to disable the auto fetch feature by changing the following setting: \"git.autofetch\": false . Can I use SSH Git authentication with VS Code? Yes, though VS Code works most easily with SSH keys without a passphrase. If you have an SSH key with a passphrase, you'll need to launch VS Code from a Git Bash prompt to inherit its SSH environment."
  },
  "guides/vscode/editor/whyvscode.html": {
    "href": "guides/vscode/editor/whyvscode.html",
    "title": "Why did we build Visual Studio Code? | Fountain of Knowledge",
    "keywords": "Why did we build Visual Studio Code? Visual Studio Code combines the simplicity of a source code editor with powerful developer tooling, like IntelliSense code completion and debugging. First and foremost, it is an editor that gets out of your way. The delightfully frictionless edit-build-debug cycle means less time fiddling with your environment, and more time executing on your ideas. Available for macOS, Linux, and Windows Visual Studio Code supports macOS, Linux, and Windows - so you can hit the ground running, no matter the platform. Edit, build, and debug with ease At its heart, Visual Studio Code features a lightning fast source code editor, perfect for day-to-day use. With support for hundreds of languages, VS Code helps you be instantly productive with syntax highlighting, bracket-matching, auto-indentation, box-selection, snippets, and more. Intuitive keyboard shortcuts, easy customization and community-contributed keyboard shortcut mappings let you navigate your code with ease. For serious coding, you'll often benefit from tools with more code understanding than just blocks of text. Visual Studio Code includes built-in support for IntelliSense code completion, rich semantic code understanding and navigation, and code refactoring. And when the coding gets tough, the tough get debugging. Debugging is often the one feature that developers miss most in a leaner coding experience, so we made it happen. Visual Studio Code includes an interactive debugger, so you can step through source code, inspect variables, view call stacks, and execute commands in the console. VS Code also integrates with build and scripting tools to perform common tasks making everyday workflows faster. VS Code has support for Git so you can work with source control without leaving the editor including viewing pending changes diffs. Make it your own Customize every feature to your liking and install any number of third-party extensions. While most scenarios work \"out of the box\" with no configuration, VS Code also grows with you, and we encourage you to optimize your experience to suit your unique needs. VS Code is an open-source project so you can also contribute to the growing and vibrant community on GitHub. Built with love for the Web VS Code includes enriched built-in support for Node.js development with JavaScript and TypeScript, powered by the same underlying technologies that drive Visual Studio. VS Code also includes great tooling for web technologies such as JSX/React, HTML, CSS, SCSS, Less, and JSON. Robust and extensible architecture Architecturally, Visual Studio Code combines the best of web, native, and language-specific technologies. Using Electron , VS Code combines web technologies such as JavaScript and Node.js with the speed and flexibility of native apps. VS Code uses a newer, faster version of the same industrial-strength HTML-based editor that has powered the \"Monaco\" cloud editor, Internet Explorer's F12 Tools, and other projects. Additionally, VS Code uses a tools service architecture that enables it to integrate with many of the same technologies that power Visual Studio, including Roslyn for .NET, TypeScript, the Visual Studio debugging engine, and more. Visual Studio Code includes a public extensibility model that lets developers build and use extensions, and richly customize their edit-build-debug experience. Ready, set, code! If you prefer a code editor-centric development tool or are building cross-platform web and cloud applications, we invite you to try out Visual Studio Code and let us know what you think! Next steps Read on to find out about: Visual Studio Code User Interface - A quick orientation to VS Code. Intro Videos - Learn about the VS Code editor features. Debugging - OK time for the really fun stuff - break, step, watch."
  },
  "guides/vscode/editor/workspaces.html": {
    "href": "guides/vscode/editor/workspaces.html",
    "title": "What is a VS Code \"workspace\"? | Fountain of Knowledge",
    "keywords": "What is a VS Code \"workspace\"? A Visual Studio Code \"workspace\" is the collection of one or more folders that are opened in a VS Code window (instance). In most cases, you will have a single folder opened as the workspace but, depending on your development workflow, you can include more than one folder, using an advanced configuration called Multi-root workspaces . The concept of a workspace enables VS Code to: Configure settings that only apply to a specific folder or folders but not others. Persist task and debugger launch configurations that are only valid in the context of that workspace. Store and restore UI state associated with that workspace (for example, the files that are opened). Selectively enable or disable extensions only for that workspace. You may see the terms \"folder\" and \"workspace\" used interchangeably in VS Code documentation, issues, and community discussions. Think of a workspace as the root of a project that has extra VS Code knowledge and capabilities. Note: It is also possible to open VS Code without a workspace. For example, when you open a new VS Code window by selecting a file from your platform's File menu, you will not be inside a workspace. In this mode, some of VS Code's capabilities are reduced but you can still open text files and edit them. How do I open a VS Code \"workspace\"? The easiest way to open a workspace is using the File menu and selecting one of the available folder entries for opening. Alternatively if you launch VS Code from a terminal, you can pass the path to a folder as the first argument to the code command for opening. Single-folder workspaces You don't have to do anything for a folder to become a VS Code workspace other than open the folder with VS Code. Once a folder has been opened, VS Code will automatically keep track of things such as your open files and editor layout so the editor will be as you left it when you reopen that folder. You can also add other folder-specific configurations such as workspace-specific settings (versus global user settings), task definitions , and debugging launch files (see below in the workspace settings section). A single-folder workspace opened inside VS Code Multi-root workspaces Multi-root workspaces are an advanced capability of VS Code that allows you to configure multiple distinct folders to be part of the workspace. Instead of opening a folder as workspace, you will open a <name>.code-workspace JSON file that lists the folders of the workspace. For example: { \"folders\": [ { \"path\": \"my-folder-a\" }, { \"path\": \"my-folder-b\" } ] } A multi-root workspace opened in VS Code Note: The visual difference of having a folder opened versus opening a .code-workspace file can be subtle. To give you a hint that a .code-workspace file has been opened, some areas of the user interface (for example, the root of the File Explorer) show an extra (Workspace) suffix next to the name. Untitled multi-root workspaces It is easy to add or remove folders in your workspace. You can start off by opening a folder in VS Code and then later add more folders as you see fit. Unless you already have opened a .code-workspace file, the first time you add a second folder to a workspace, VS Code will automatically create an \"untitled\" workspace. In the background, VS Code automatically maintains a untitled.code-workspace file for you that contains all of the folders and workspace settings from your current session. The workspace will remain \"untitled\" until you decide to save it to disk. An untitled multi-root workspace opened in VS Code Note: There is really no difference between an untitled workspace and a saved workspace other than the fact that an untitled workspace is automatically created for you for your convenience and will always restore until you save it. We automatically delete untitled workspaces (after asking you for confirmation) when you close a window in which an untitled workspace is opened. Workspace settings Workspace settings enable you to configure settings in the context of the workspace you have opened and always override global user settings. They are physically stored in a JSON file and their location depends on whether you opened a folder as a workspace or you opened a .code-workspace file. Refer to the settings documentation for a comprehensive explanation of setting scopes and their file locations. Single-folder workspace settings Workspace settings will be stored in .vscode/settings.json when you open a folder as workspace. The Settings editor when a folder is opened as workspace Multi-root workspace settings When you open a .code-workspace as workspace, all workspace settings will be added into the .code-workspace file. You can still configure settings per root folder and the Settings editor will present a third setting scope called Folder Settings : The Settings editor when a multi-root workspace is opened Settings configured per folder will override settings defined in the .code-workspace . Workspace tasks and launch configurations Similar to how workspace settings are specific to a workspace, tasks and launch configurations can also be scoped to a workspace. Depending on whether you have a folder opened as workspace or a .code-workspace file, the location of workspace task and launch configurations will either be inside the .vscode folder or inside the .code-workspace file. In addition, task and launch configurations can always be defined at the level of a folder, even when you have opened a .code-workspace file. Refer to tasks and debugging chapters for a more comprehensive overview of how to use tasks and launch configurations in VS Code. Common questions What is the benefit of multi-root workspace over a folder? The most obvious advantage is that a multi-root workspace allows you to work with multiple projects that may not be stored inside the same parent folder on disk. You can pick folders from anywhere to add to the workspace. Even if you are mainly working in a single-folder-based project, you can benefit from using .code-workspace files. You can store multiple .code-workspace files inside the folder to provide a scoped folder-view of certain aspects of the project depending on the scenario (for example client.code-workspace , server.code-workspace to filter out unrelated folders from the File Explorer). Since .code-workspace files support relative paths for the folders section, these workspace files will work for everyone independent of where the folder is stored. Finally, if for some projects you want to apply the same set of workspace settings or tasks/launch configurations, consider adding these into a .code-workspace file and add/remove these folders from that workspace. Why is VS Code restoring all untitled workspaces on a restart? Untitled workspaces are designed to be something you must explicitly decide to keep or not. The first time an untitled workspace is created, VS Code adds the specified folders into the workspace file and also all existing workspace settings. This user data is always restored and displayed in a VS Code window until the untitled workspace is saved or deleted. How do I delete an untitled workspace? You can delete an untitled workspace by closing its window and dismissing the prompt to save the untitled workspace. Can I use a multi-root workspace without folders It is possible to leave the folders section of a .code-workspace file empty so that you end up with an instance of VS Code that does not show any root folders. You can still store workspace settings and even tasks or launch configurations in this case. Does VS Code support projects or solutions? VS Code doesn't have the concept of a \"project\" or \"solution\" as they are sometimes defined in other development tools, for example Visual Studio IDE. You may see the term \"project\" used in VS Code documentation but it usually means \"the thing you're working on\". Depending on your programming language or framework, the toolset itself may support something called a \"project\" to help define build configurations or enumerate included files."
  },
  "guides/vscode/editor/workspace-trust.html": {
    "href": "guides/vscode/editor/workspace-trust.html",
    "title": "Workspace Trust | Fountain of Knowledge",
    "keywords": "Workspace Trust Visual Studio Code takes security seriously and wants to help you safely browse and edit code no matter the source or original authors. The Workspace Trust feature lets you decide whether your project folders should allow or restrict automatic code execution. Note : When in doubt, leave a folder in Restricted Mode . You can always enable trust later. Safe code browsing It's great that there is so much source code available on public repositories and file shares. No matter the coding task or problem, there is probably already a good solution available somewhere. It is also great that there are so many powerful coding tools available to help you understand, debug, and optimize your code. However, using open-source code and tools does have risks, and you can leave yourself open to malicious code execution and exploits. Workspace Trust provides an extra layer of security when working with unfamiliar code, by preventing automatic code execution when a workspace is open in \"Restricted Mode\". Note : The terms \"workspace\" and \"folder\" are used widely in the VS Code UI and documentation. You can think of a \"workspace\" as a folder with extra metadata created and used by VS Code. Restricted Mode When prompted by the Workspace Trust dialog, if you choose No, I don't trust the authors , VS Code will go into Restricted Mode to prevent code execution. The workbench will display a banner at the top with links to Manage your folder via the Workspace Trust editor, and Learn More about Workspace Trust (which takes you to back to this documentation). You will also see a Restricted Mode badge in the Status bar. Restricted Mode tries to prevent automatic code execution by disabling or limiting the operation of several VS Code features: tasks, debugging, workspace settings, and extensions. To see the full list of features disabled in Restricted Mode, you can open the Workspace Trust editor via the Manage link in the banner, or by clicking the Restricted Mode badge in the Status bar. Tasks Tasks can run scripts and tool binaries, and because task definitions are defined in the workspace .vscode folder, they are part of the committed source code for a repo, and shared to every user of that repo. Were someone to create a malicious task, it could be unknowningly run by anyone who cloned that repository. If you try to run or even enumerate tasks ( Terminal > Run Task... ) while in Restricted Mode, VS Code will display a prompt to trust the folder and continue executing the task. Cancelling the dialog leaves VS Code in Restricted Mode. Debugging Similar to running a VS Code task, debug extensions can run debugger binaries when launching a debug session. For that reason, debugging is also disabled when a folder is open in Restricted Mode. If you try to start a debug session ( Run > Start Debugging ) while in Restricted Mode, VS Code will display a prompt to trust the folder and continue launching the debugger. Cancelling the dialog leaves VS Code in Restricted Mode, and does not start the debug session. Workspace settings Workspace settings are stored in the .vscode folder at the root of your workspace, and are therefore shared by anyone who clones the workspace repository. Some settings contain paths to executables (for example, linter binaries), which if set to point to malicious code, could do damage. For this reason, there is a set of workspace settings that are disabled when running in Restricted Mode. In the Workspace Trust editor, there is a link to display the workspace settings that aren't being applied. Clicking the link brings up the Settings editor scoped by the @tag:requireTrustedWorkspace tag. Extensions The VS Code extensions ecosystem is incredibly rich and diverse. People have created extensions to help with just about any programming task or editor customization. Some extensions provide full programming language support (IntelliSense, debugging, code analysis), and others let you play music or have virtual pets . Most extensions run code on your behalf and could potentially do harm. Some extensions have settings that could cause them to act maliciously if configured to run an unexpected executable. For this reason, extensions that have not explicitly opted into Workspace Trust are disabled by default in Restricted Mode. You can review an installed extension's status by clicking the extensions are disabled or have limited functionality link in the Workspace Trust editor, which displays the Extensions view scoped with the @workspaceUnsupported filter. Disabled in Restricted Mode Extensions that have either not explicitly indicated that they support running in Restricted Mode are shown in the Disabled in Restricted Mode section. An extension author can also indicate that they never want to be enabled in Restricted Mode if they determine that their extension could be misused by modifications (settings or files) in a workspace. Limited in Restricted Mode Extension authors can also evaluate their extensions for possible security vulnerabilities and declare that they have limited support when running in Restricted Mode. This mode means the extension may disable some features or functionality to prevent a possible exploit. Extensions can add custom text to the Extensions view Workspace Trust badge explaining the limitation when running in an untrusted folder. For example, the VS Code built-in PHP extension limits the use of the php.validate.executablePath setting to trusted folders since overriding this setting could run a malicious program. You can override an extension's Workspace Trust support level using the extensions.supportUntrustedWorkspaces setting described in the Enabling extensions section below. If you try to install an extension in Restricted Mode, you will be prompted to either trust the workspace or just install the extension. If the extension doesn't support Workspace Trust, it will be installed, but be disabled or running with limited functionality. Note : Extension authors can learn how to update their extensions to support Workspace Trust by reading the Workspace Trust Extension Guide . Trusting a workspace If you trust the authors and maintainers of a project, you can trust the project's folder on your local machine. For example, it is usually safe to trust repositories from well-known GitHub organizations such as github.com/microsoft or github.com/docker. The initial Workspace Trust prompt when you open a new folder allows you to trust that folder and its subfolders. You can also bring up the Workspace Editor and quickly toggle a folder's trusted state. There are several ways to bring up the Workspace Editor dialog. When in Restricted Mode: Restricted Mode banner Manage link Restricted Mode Status bar item You can also at any time use: Workspaces: Manage Workspace Trust command from the Command Palette ( kb(workbench.action.showCommands) ) Manage Workspace Trust from the Manage gear in the Activity bar Selecting folders When you trust a folder, it is added to the Trusted Folders & Workspaces list displayed in the Workspace Trust editor. You can manually add, edit, and remove folders from this list and the active folder enabling trust is highlighted in bold. Selecting a parent folder When you trust a folder via the Workspace Trust editor, you have the option to trust the parent folder. This will apply trust to the parent folder and all subfolders. This can be helpful if you have many folders with trusted content co-located under one folder. When opening a subfolder under a trusted parent, you won't see the usual Don't Trust button to put you back in Restricted Mode, instead there is text mentioning that your folder is trusted due to another folder. You can add, modify, and remove a parent folder entry from the Trusted Folders & Workspaces list. Folder configurations As mentioned above, you can trust a parent folder and all subfolders will be trusted. This allows you to control Workspace Trust via a repository's location on disk. For example, you could put all trusted repos under a \"TrustedRepos\" parent folder, and unfamiliar repos under another parent folder such as \"ForEvaluation\". You would trust the \"TrustedRepos\" folder, and selectively trust folders under \"ForEvaluation\". ├── TrustedRepos - Clone trusted repositories under this parent folder └── ForEvaluation - Clone experimental or unfamiliar repositories under this parent folder You also group and set trust on your repositories by grouping them under organization-base parent folders. ├── github/microsoft - Clone a specific organization's repositories under this parent folder ├── github/{myforks} - Place your forked repositories under this parent folder └── local - Local un-published repositories Enabling extensions What happens if you want to use Restricted Mode but your favorite extension doesn't support Workspace Trust? This can happen if an extension, while useful and functional, isn't being actively maintained and hasn't declared their Workspace Trust support. To handle this scenario, you can override the extension's trust state with the extensions.supportUntrustedWorkspaces setting. Note : Be careful overriding an extension's Workspace Trust support. It may be that the extension author has a good reason for disabling their extension in Restricted Mode. If in doubt, reach out to the extension author or review recent changelogs to get more context. If you open the Settings editor ( kb(workbench.action.openSettings) ) and search for \"trust extensions\", you can find the Extensions: Support Untrusted Workspaces setting, which has an Edit in settings.json link. Select that link and you will go to your user settings.json file with a new entry for extensions.supportUntrustedWorkspaces . This setting takes an object that has a list of extension IDs and their support status and version. You can select any of your installed extensions via IntelliSense suggestions. Below you can see a settings.json entry for the Prettier extension. \"extensions.supportUntrustedWorkspaces\": { \"esbenp.prettier-vscode\": { \"supported\": true, \"version\": \"6.4.0\" }, }, You can either enable or disable Workspace Trust support with the supported attribute. The version attribute specifies the exact extension version applicable and you can remove the version field if you want to set the state for all versions. If you'd like to learn more about how extension authors evaluate and determine which features to limit in Restricted Mode, you can read the Workspace Trust Extension Guide . Opening untrusted files If you open a file that is located outside of a trusted folder, VS Code will detect that the file comes from somewhere outside the folder root and prompt you with the option to continue to open the file or open the file in a new window in Restricted Mode. Opening in Restricted Mode is the safest option and you can always reopen the file in your original VS Code window once you determine the file is trustworthy. If you would prefer to not be prompted when opening files from outside trusted workspaces, you can set security.workspace.trust.untrustedFiles to open . You can also set security.workspace.trust.untrustedFiles to newWindow to always create a new window in Restricted Mode. Checking the Remember my decision for all workspaces option in the untrusted files dialog applies your choice to the security.workspace.trust.untrustedFiles user setting. Opening untrusted folders When working with multi-root workspaces with multiple folders, if you try to add a new folder to a trusted multi-root workspace, you will be prompted to decide if you trust the files in that folder or if not, the entire workspace will switch to Restricted Mode. Empty windows (no open folder) By default, if you open a new VS Code window (instance) without opening a folder or workspace, VS Code runs the window with full trust. All installed extensions are enabled and you can use the empty window without restrictions. When you open a file, you will be prompted whether you want to open an untrusted file since there is no folder to parent it. You can switch an empty window to Restricted Mode using the Workspace Trust editor (select Manage Workspace Trust from the Manage gear button or the Command Palette) and selecting Don't Trust . The empty window will remain in Restricted Mode for your current session but will go back to trusted if you restart or create a new window. If you want all empty windows to be in Restricted Mode, you can set security.workspace.trust.emptyWindow to false . Settings Below are the available Workspace Trust settings: security.workspace.trust.enabled - Enable Workspace Trust feature. Default is true. security.workspace.trust.startupPrompt - Whether to show the Workspace Trust dialog on startup. Default is to only show once per distinct folder or workspace. security.workspace.trust.emptyWindow - Whether to always trust an empty window (no open folder). Default is true. security.workspace.trust.untrustedFiles - Controls how to handle loose files in a workspace. Default is to prompt. extensions.supportUntrustedWorkspaces - Override extension Workspace Trust declarations. Either true or false. security.workspace.trust.banner - Controls when the Restricted Mode banner is displayed. Default is untilDismissed . Command-line switch You can disable Workspace Trust via the VS Code command line by passing --disable-workspace-trust . This switch only affects the current session. <!-- ## Special configurations ### Remote extensions SSH - paths are relative to the remote machine WSL - paths are relative to WSL instance (/mnt/) (might map to already trusted local path) Containers ### Codespaces (move to docs/remote/codespaces?) Paths a little weird --> Next steps Learn more at: Workspace Trust Extension Guide - Learn how extension authors can support Workspace Trust. What is a VS Code \"workspace\"? - Find out more details about the VS Code \"workspace\" concept. GitHub Repositories extension - Work directly on a repository without cloning the source code to your local machine. Common questions Can I still edit my source code in Restricted Mode? Yes, you can still browse and edit source code in Restricted Mode. Some language features may be disabled, but text editing is always supported. Where did my installed extensions go? In Restricted Mode, any extension that doesn't support Workspace Trust will be disabled, and all UI elements such as Activity bar icons and commands will not be displayed. You can override an extension's Workspace Trust support level with the extensions.supportUntrustedWorkspaces setting but do so with care. Enabling extensions has more details. <!-- List of popular extensions that currently need this override. --> Can I disable the Workspace Trust feature? You can but it is not recommended. If you don't want VS Code to check for Workspace Trust when opening a new folder or repository, you can set security.workspace.trust.enabled to false. VS Code will then behave as it did before the 1.57 release. How do I untrust a folder/workspace? Bring up Workspace Trust editor ( Workspaces: Manage Workspace Trust from the Command Palette) and select the Don't Trust button. You can also remove the folder from the Trusted Folders & Workspaces list. Why don't I see the \"Don't Trust\" button? If you don't see the Don't Trust button in the Workspace Trust dialog, the folder's trust level may be inherited from a parent folder. Review the Trusted Folders & Workspaces list to check if a parent folder has enabled Workspace Trust. Some workflows such as connecting to a GitHub Codespace or attaching to a running Docker container are automatically trusted since these are managed environments to which you should already have a high level of trust. What does Workspace Trust protect against? Many features of VS Code allow third-party tools and extensions to run automatically, such as linting or format on save, or when you do certain operations like compiling code or debugging. An unethical person could craft an innocent looking project that would run malicious code without your knowledge and harm your local machine. Workspace Trust provides an extra layer of security by trying to prevent code execution while you are evaluating the safety and integrity of unfamiliar source code."
  },
  "guides/vscode/getstarted/introvideos.html": {
    "href": "guides/vscode/getstarted/introvideos.html",
    "title": "Introductory Videos | Fountain of Knowledge",
    "keywords": "Introductory Videos Start your journey using Visual Studio Code with this set of introductory videos! These videos are designed to give you an overview of VS Code's various features and quickly get you familiar with them. Getting Started Set up and learn the basics of Visual Studio Code. Duration 5 min minutes Code Editing Learn how to edit and run code in VS Code. Duration 3 min minutes Personalize Personalize VS Code to make it yours with themes. Duration 2 min minutes Extensions Add features, themes, and more to VS Code with extensions! Duration 4 min minutes Debugging Get started with debugging in VS Code. Duration 6 min minutes Version Control Learn how to use Git version control in VS Code. Duration 3 min minutes Customize Learn how to customize your settings and keyboard shortcuts in VS Code. Duration 6 min minutes Productivity Tips Become a VS Code power user with these productivity tips. Duration 4 min minutes"
  },
  "guides/vscode/getstarted/keybindings.html": {
    "href": "guides/vscode/getstarted/keybindings.html",
    "title": "Key Bindings for Visual Studio Code | Fountain of Knowledge",
    "keywords": "Key Bindings for Visual Studio Code Visual Studio Code lets you perform most tasks directly from the keyboard. This page lists out the default bindings (keyboard shortcuts) and describes how you can update them. Note: If you visit this page on a Mac, you will see the key bindings for the Mac. If you visit using Windows or Linux, you will see the keys for that platform. If you need the key bindings for another platform, hover your mouse over the key you are interested in. Keyboard Shortcuts editor Visual Studio Code provides a rich and easy keyboard shortcuts editing experience using Keyboard Shortcuts editor. It lists all available commands with and without keybindings and you can easily change / remove / reset their keybindings using the available actions. It also has a search box on the top that helps you in finding commands or keybindings. You can open this editor by going to the menu under File > Preferences > Keyboard Shortcuts . ( Code > Preferences > Keyboard Shortcuts on macOS) Most importantly, you can see keybindings according to your keyboard layout. For example, key binding kbstyle(Cmd+\\) in US keyboard layout will be shown as kbstyle(Ctrl+Shift+Alt+Cmd+7) when layout is changed to German. The dialog to enter key binding will assign the correct and desired key binding as per your keyboard layout. For doing more advanced keyboard shortcut customization, read Advanced Customization . Keymap extensions Keyboard shortcuts are vital to productivity and changing keyboarding habits can be tough. To help with this, File > Preferences > Keymaps shows you a list of popular keymap extensions. These extensions modify the VS Code shortcuts to match those of other editors so you don't need to learn new keyboard shortcuts. There is also a Keymaps category of extensions in the Marketplace. Tip: Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Keyboard Shortcuts Reference We also have a printable version of these keyboard shortcuts. Help > Keyboard Shortcut Reference displays a condensed PDF version suitable for printing as an easy reference. Below are links to the three platform-specific versions (US English keyboard): Windows macOS Linux Detecting keybinding conflicts If you have many extensions installed or you have customized your keyboard shortcuts, you can sometimes have keybinding conflicts where the same keyboard shortcut is mapped to several commands. This can result in confusing behavior, especially if different keybindings are going in and out of scope as you move around the editor. The Keyboard Shortcuts editor has a context menu command Show Same Keybindings , which will filter the keybindings based on a keyboard shortcut to display conflicts. Pick a command with the keybinding you think is overloaded and you can see if multiple commands are defined, the source of the keybindings and when they are active. Troubleshooting keybindings To troubleshoot keybindings problems, you can execute the command Developer: Toggle Keyboard Shortcuts Troubleshooting . This will activate logging of dispatched keyboard shortcuts and will open an output panel with the corresponding log file. You can then press your desired keybinding and check what keyboard shortcut VS Code detects and what command is invoked. For example, when pressing cmd+/ in a code editor on macOS, the logging output would be: [KeybindingService]: / Received keydown event - modifiers: [meta], code: MetaLeft, keyCode: 91, key: Meta [KeybindingService]: | Converted keydown event - modifiers: [meta], code: MetaLeft, keyCode: 57 ('Meta') [KeybindingService]: \\ Keyboard event cannot be dispatched. [KeybindingService]: / Received keydown event - modifiers: [meta], code: Slash, keyCode: 191, key: / [KeybindingService]: | Converted keydown event - modifiers: [meta], code: Slash, keyCode: 85 ('/') [KeybindingService]: | Resolving meta+[Slash] [KeybindingService]: \\ From 2 keybinding entries, matched editor.action.commentLine, when: editorTextFocus && !editorReadonly, source: built-in. The first keydown event is for the MetaLeft key ( cmd ) and cannot be dispatched. The second keydown event is for the Slash key ( / ) and is dispatched as meta+[Slash] . There were two keybinding entries mapped from meta+[Slash] and the one that matched was for the command editor.action.commentLine , which has the when condition editorTextFocus && !editorReadonly and is a built-in keybinding entry. Viewing modified keybindings You can view any user modified keyboard shortcuts in VS Code in the Keyboard Shortcuts editor with the Show User Keybindings command in the More Actions ( ... ) menu. This applies the @source:user filter to the Keyboard Shortcuts editor ( Source is 'User'). Advanced customization All keyboard shortcuts in VS Code can be customized via the keybindings.json file. To configure keyboard shortcuts through the JSON file, open Keyboard Shortcuts editor and select the Open Keyboard Shortcuts (JSON) button on the right of the editor title bar. This will open your keybindings.json file where you can overwrite the Default Keybindings . You can also open the keybindings.json file from the Command Palette ( kb(workbench.action.showCommands) ) with the Preferences: Open Keyboard Shortcuts (JSON) command. Keyboard rules Each rule consists of: a key that describes the pressed keys. a command containing the identifier of the command to execute. an optional when clause containing a boolean expression that will be evaluated depending on the current context . Chords (two separate keypress actions) are described by separating the two keypresses with a space. For example, kbstyle(Ctrl+K Ctrl+C) . When a key is pressed: the rules are evaluated from bottom to top . the first rule that matches, both the key and in terms of when , is accepted. no more rules are processed. if a rule is found and has a command set, the command is executed. The additional keybindings.json rules are appended at runtime to the bottom of the default rules, thus allowing them to overwrite the default rules. The keybindings.json file is watched by VS Code so editing it while VS Code is running will update the rules at runtime. The keyboard shortcuts dispatching is done by analyzing a list of rules that are expressed in JSON. Here are some examples: // Keybindings that are active when the focus is in the editor { \"key\": \"home\", \"command\": \"cursorHome\", \"when\": \"editorTextFocus\" }, { \"key\": \"shift+home\", \"command\": \"cursorHomeSelect\", \"when\": \"editorTextFocus\" }, // Keybindings that are complementary { \"key\": \"f5\", \"command\": \"workbench.action.debug.continue\", \"when\": \"inDebugMode\" }, { \"key\": \"f5\", \"command\": \"workbench.action.debug.start\", \"when\": \"!inDebugMode\" }, // Global keybindings { \"key\": \"ctrl+f\", \"command\": \"actions.find\" }, { \"key\": \"alt+left\", \"command\": \"workbench.action.navigateBack\" }, { \"key\": \"alt+right\", \"command\": \"workbench.action.navigateForward\" }, // Global keybindings using chords (two separate keypress actions) { \"key\": \"ctrl+k enter\", \"command\": \"workbench.action.keepEditor\" }, { \"key\": \"ctrl+k ctrl+w\", \"command\": \"workbench.action.closeAllEditors\" }, Accepted keys The key is made up of modifiers and the key itself. The following modifiers are accepted: Platform Modifiers macOS kbstyle(Ctrl+) , kbstyle(Shift+) , kbstyle(Alt+) , kbstyle(Cmd+) Windows kbstyle(Ctrl+) , kbstyle(Shift+) , kbstyle(Alt+) , kbstyle(Win+) Linux kbstyle(Ctrl+) , kbstyle(Shift+) , kbstyle(Alt+) , kbstyle(Meta+) The following keys are accepted: kbstyle(f1-f19) , kbstyle(a-z) , kbstyle(0-9) kbstyle(`) , kbstyle(-) , kbstyle(=) , kbstyle([) , kbstyle(]) , kbstyle(\\) , kbstyle(;) , kbstyle(') , kbstyle(,) , kbstyle(.) , kbstyle(/) kbstyle(left) , kbstyle(up) , kbstyle(right) , kbstyle(down) , kbstyle(pageup) , kbstyle(pagedown) , kbstyle(end) , kbstyle(home) kbstyle(tab) , kbstyle(enter) , kbstyle(escape) , kbstyle(space) , kbstyle(backspace) , kbstyle(delete) kbstyle(pausebreak) , kbstyle(capslock) , kbstyle(insert) kbstyle(numpad0-numpad9) , kbstyle(numpad_multiply) , kbstyle(numpad_add) , kbstyle(numpad_separator) kbstyle(numpad_subtract) , kbstyle(numpad_decimal) , kbstyle(numpad_divide) Command arguments You can invoke a command with arguments. This is useful if you often perform the same operation on a specific file or folder. You can add a custom keyboard shortcut to do exactly what you want. The following is an example overriding the kbstyle(Enter) key to print some text: { \"key\": \"enter\", \"command\": \"type\", \"args\": { \"text\": \"Hello World\" }, \"when\": \"editorTextFocus\" } The type command will receive {\"text\": \"Hello World\"} as its first argument and add \"Hello World\" to the file instead of producing the default command. For more information on commands that take arguments, refer to Built-in Commands . Removing a specific key binding rule You can write a key binding rule that targets the removal of a specific default key binding. With the keybindings.json , it was always possible to redefine all the key bindings of VS Code, but it can be difficult to make a small tweak, especially around overloaded keys, such as kbstyle(Tab) or kbstyle(Escape) . To remove a specific key binding, add a - to the command and the rule will be a removal rule. Here is an example: // In Default Keyboard Shortcuts ... { \"key\": \"tab\", \"command\": \"tab\", \"when\": ... }, { \"key\": \"tab\", \"command\": \"jumpToNextSnippetPlaceholder\", \"when\": ... }, { \"key\": \"tab\", \"command\": \"acceptSelectedSuggestion\", \"when\": ... }, ... // To remove the second rule, for example, add in keybindings.json: { \"key\": \"tab\", \"command\": \"-jumpToNextSnippetPlaceholder\" } Keyboard layouts Note: This section relates only to key bindings, not to typing in the editor. The keys above are string representations for virtual keys and do not necessarily relate to the produced character when they are pressed. More precisely: Reference: Virtual-Key Codes (Windows) kbstyle(tab) for VK_TAB ( 0x09 ) kbstyle(;) for VK_OEM_1 ( 0xBA ) kbstyle(=) for VK_OEM_PLUS ( 0xBB ) kbstyle(,) for VK_OEM_COMMA ( 0xBC ) kbstyle(-) for VK_OEM_MINUS ( 0xBD ) kbstyle(.) for VK_OEM_PERIOD ( 0xBE ) kbstyle(/) for VK_OEM_2 ( 0xBF ) kbstyle(`) for VK_OEM_3 ( 0xC0 ) kbstyle([) for VK_OEM_4 ( 0xDB ) kbstyle(\\) for VK_OEM_5 ( 0xDC ) kbstyle(]) for VK_OEM_6 ( 0xDD ) kbstyle(') for VK_OEM_7 ( 0xDE ) etc. Different keyboard layouts usually reposition the above virtual keys or change the characters produced when they are pressed. When using a different keyboard layout than the standard US, Visual Studio Code does the following: All the key bindings are rendered in the UI using the current system's keyboard layout. For example, Split Editor when using a French (France) keyboard layout is now rendered as kbstyle(Ctrl+*) : When editing keybindings.json , VS Code highlights misleading key bindings, those that are represented in the file with the character produced under the standard US keyboard layout, but that need pressing keys with different labels under the current system's keyboard layout. For example, here is how the Default Keyboard Shortcuts rules look like when using a French (France) keyboard layout: There is also a widget that helps input the key binding rule when editing keybindings.json . To launch the Define Keybinding widget, press kb(editor.action.defineKeybinding) . The widget listens for key presses and renders the serialized JSON representation in the text box and below it, the keys that VS Code has detected under your current keyboard layout. Once you've typed the key combination you want, you can press kbstyle(Enter) and a rule snippet will be inserted. Note: On Linux, Visual Studio Code detects your current keyboard layout on start-up and then caches this information. For a good experience, we recommend restarting VS Code if you change your keyboard layout. Keyboard layout-independent bindings Using scan codes, it is possible to define keybindings which do not change with the change of the keyboard layout. For example: { \"key\": \"cmd+[Slash]\", \"command\": \"editor.action.commentLine\", \"when\": \"editorTextFocus\" } Accepted scan codes: kbstyle([F1]-[F19]) , kbstyle([KeyA]-[KeyZ]) , kbstyle([Digit0]-[Digit9]) kbstyle([Backquote]) , kbstyle([Minus]) , kbstyle([Equal]) , kbstyle([BracketLeft]) , kbstyle([BracketRight]) , kbstyle([Backslash]) , kbstyle([Semicolon]) , kbstyle([Quote]) , kbstyle([Comma]) , kbstyle([Period]) , kbstyle([Slash]) kbstyle([ArrowLeft]) , kbstyle([ArrowUp]) , kbstyle([ArrowRight]) , kbstyle([ArrowDown]) , kbstyle([PageUp]) , kbstyle([PageDown]) , kbstyle([End]) , kbstyle([Home]) kbstyle([Tab]) , kbstyle([Enter]) , kbstyle([Escape]) , kbstyle([Space]) , kbstyle([Backspace]) , kbstyle([Delete]) kbstyle([Pause]) , kbstyle([CapsLock]) , kbstyle([Insert]) kbstyle([Numpad0]-[Numpad9]) , kbstyle([NumpadMultiply]) , kbstyle([NumpadAdd]) , kbstyle([NumpadComma]) kbstyle([NumpadSubtract]) , kbstyle([NumpadDecimal]) , kbstyle([NumpadDivide]) when clause contexts VS Code gives you fine control over when your key bindings are enabled through the optional when clause. If your key binding doesn't have a when clause, the key binding is globally available at all times. A when clause evaluates to either Boolean true or false for enabling key bindings. VS Code sets various context keys and specific values depending on what elements are visible and active in the VS Code UI. For example, the built-in Start Debugging command has the keyboard shortcut kb(workbench.action.debug.start) , which is only enabled when there is an appropriate debugger available (context debuggersAvailable is true) and the editor isn't in debug mode (context inDebugMode is false): You can also view a keybinding's when clause directly in the Default Keybindings JSON ( Preferences: Open Default Keyboard Shortcuts (JSON) ): { \"key\": \"f5\", \"command\": \"workbench.action.debug.start\", \"when\": \"debuggersAvailable && !inDebugMode\" }, Conditional operators For when clause conditional expressions, the following conditional operators are useful for keybindings: Operator Symbol Example Equality == \"editorLangId == typescript\" Inequality != \"resourceExtname != .js\" Or || \"isLinux || isWindows\" And && \"textInputFocus && !editorReadonly\" Matches =~ \"resourceScheme =~ /^untitled$|^file$/\" You can find the full list of when clause conditional operators in the when clause contexts reference. Available contexts You can find some of the available when clause contexts in the when clause context reference . The list there isn't exhaustive and you can find other when clause contexts by searching and filtering in the Keyboard Shortcuts editor ( Preferences: Open Keyboard Shortcuts ) or reviewing the Default Keybindings JSON file ( Preferences: Open Default Keyboard Shortcuts (JSON) ). Custom keybindings for refactorings The editor.action.codeAction command lets you configure keybindings for specific Refactorings (Code Actions). For example, the keybinding below triggers the Extract function refactoring Code Actions: { \"key\": \"ctrl+shift+r ctrl+e\", \"command\": \"editor.action.codeAction\", \"args\": { \"kind\": \"refactor.extract.function\" } } This is covered in depth in the Refactoring topic where you can learn about different kinds of Code Actions and how to prioritize them in the case of multiple possible refactorings. Default Keyboard Shortcuts You can view all default keyboard shortcuts in VS Code in the Keyboard Shortcuts editor with the Show Default Keybindings command in the More Actions ( ... ) menu. This applies the @source:default filter to the Keyboard Shortcuts editor ( Source is 'Default'). You can view the default keyboard shortcuts as a JSON file using the command Preferences: Open Default Keyboard Shortcuts (JSON) . Note: The following keys are rendered assuming a standard US keyboard layout. If you use a different keyboard layout, please read below . You can view the currently active keyboard shortcuts in VS Code in the Command Palette ( View -> Command Palette ) or in the Keyboard Shortcuts editor ( File > Preferences > Keyboard Shortcuts ). Some commands included below do not have default keyboard shortcuts and so are displayed as kbstyle(unassigned) but you can assign your own keybindings. Basic Editing Command Key Command id Cut line (empty selection) kb(editor.action.clipboardCutAction) editor.action.clipboardCutAction Copy line (empty selection) kb(editor.action.clipboardCopyAction) editor.action.clipboardCopyAction Paste kb(editor.action.clipboardPasteAction) editor.action.clipboardPasteAction Delete Line kb(editor.action.deleteLines) editor.action.deleteLines Insert Line Below kb(editor.action.insertLineAfter) editor.action.insertLineAfter Insert Line Above kb(editor.action.insertLineBefore) editor.action.insertLineBefore Move Line Down kb(editor.action.moveLinesDownAction) editor.action.moveLinesDownAction Move Line Up kb(editor.action.moveLinesUpAction) editor.action.moveLinesUpAction Copy Line Down kb(editor.action.copyLinesDownAction) editor.action.copyLinesDownAction Copy Line Up kb(editor.action.copyLinesUpAction) editor.action.copyLinesUpAction Undo kb(undo) undo Redo kb(redo) redo Add Selection To Next Find Match kb(editor.action.addSelectionToNextFindMatch) editor.action.addSelectionToNextFindMatch Move Last Selection To Next Find Match kb(editor.action.moveSelectionToNextFindMatch) editor.action.moveSelectionToNextFindMatch Undo last cursor operation kb(cursorUndo) cursorUndo Insert cursor at end of each line selected kb(editor.action.insertCursorAtEndOfEachLineSelected) editor.action.insertCursorAtEndOfEachLineSelected Select all occurrences of current selection kb(editor.action.selectHighlights) editor.action.selectHighlights Select all occurrences of current word kb(editor.action.changeAll) editor.action.changeAll Select current line kb(expandLineSelection) expandLineSelection Insert Cursor Below kb(editor.action.insertCursorBelow) editor.action.insertCursorBelow Insert Cursor Above kb(editor.action.insertCursorAbove) editor.action.insertCursorAbove Jump to matching bracket kb(editor.action.jumpToBracket) editor.action.jumpToBracket Indent Line kb(editor.action.indentLines) editor.action.indentLines Outdent Line kb(editor.action.outdentLines) editor.action.outdentLines Go to Beginning of Line kb(cursorHome) cursorHome Go to End of Line kb(cursorEnd) cursorEnd Go to End of File kb(cursorBottom) cursorBottom Go to Beginning of File kb(cursorTop) cursorTop Scroll Line Down kb(scrollLineDown) scrollLineDown Scroll Line Up kb(scrollLineUp) scrollLineUp Scroll Page Down kb(scrollPageDown) scrollPageDown Scroll Page Up kb(scrollPageUp) scrollPageUp Fold (collapse) region kb(editor.fold) editor.fold Unfold (uncollapse) region kb(editor.unfold) editor.unfold Fold (collapse) all subregions kb(editor.foldRecursively) editor.foldRecursively Unfold (uncollapse) all subregions kb(editor.unfoldRecursively) editor.unfoldRecursively Fold (collapse) all regions kb(editor.foldAll) editor.foldAll Unfold (uncollapse) all regions kb(editor.unfoldAll) editor.unfoldAll Add Line Comment kb(editor.action.addCommentLine) editor.action.addCommentLine Remove Line Comment kb(editor.action.removeCommentLine) editor.action.removeCommentLine Toggle Line Comment kb(editor.action.commentLine) editor.action.commentLine Toggle Block Comment kb(editor.action.blockComment) editor.action.blockComment Find kb(actions.find) actions.find Replace kb(editor.action.startFindReplaceAction) editor.action.startFindReplaceAction Find Next kb(editor.action.nextMatchFindAction) editor.action.nextMatchFindAction Find Previous kb(editor.action.previousMatchFindAction) editor.action.previousMatchFindAction Select All Occurrences of Find Match kb(editor.action.selectAllMatches) editor.action.selectAllMatches Toggle Find Case Sensitive kb(toggleFindCaseSensitive) toggleFindCaseSensitive Toggle Find Regex kb(toggleFindRegex) toggleFindRegex Toggle Find Whole Word kb(toggleFindWholeWord) toggleFindWholeWord Toggle Use of Tab Key for Setting Focus kb(editor.action.toggleTabFocusMode) editor.action.toggleTabFocusMode Toggle Render Whitespace kb(toggleRenderWhitespace) toggleRenderWhitespace Toggle Word Wrap kb(editor.action.toggleWordWrap) editor.action.toggleWordWrap Rich Languages Editing Command Key Command id Trigger Suggest kb(editor.action.triggerSuggest) editor.action.triggerSuggest Trigger Parameter Hints kb(editor.action.triggerParameterHints) editor.action.triggerParameterHints Format Document kb(editor.action.formatDocument) editor.action.formatDocument Format Selection kb(editor.action.formatSelection) editor.action.formatSelection Go to Definition kb(editor.action.revealDefinition) editor.action.revealDefinition Show Hover kb(editor.action.showHover) editor.action.showHover Peek Definition kb(editor.action.peekDefinition) editor.action.peekDefinition Open Definition to the Side kb(editor.action.revealDefinitionAside) editor.action.revealDefinitionAside Quick Fix kb(editor.action.quickFix) editor.action.quickFix Go to References kb(editor.action.goToReferences) editor.action.goToReferences Rename Symbol kb(editor.action.rename) editor.action.rename Replace with Next Value kb(editor.action.inPlaceReplace.down) editor.action.inPlaceReplace.down Replace with Previous Value kb(editor.action.inPlaceReplace.up) editor.action.inPlaceReplace.up Expand AST Selection kb(editor.action.smartSelect.expand) editor.action.smartSelect.expand Shrink AST Selection kb(editor.action.smartSelect.shrink) editor.action.smartSelect.shrink Trim Trailing Whitespace kb(editor.action.trimTrailingWhitespace) editor.action.trimTrailingWhitespace Change Language Mode kb(workbench.action.editor.changeLanguageMode) workbench.action.editor.changeLanguageMode Navigation Command Key Command id Show All Symbols kb(workbench.action.showAllSymbols) workbench.action.showAllSymbols Go to Line... kb(workbench.action.gotoLine) workbench.action.gotoLine Go to File..., Quick Open kb(workbench.action.quickOpen) workbench.action.quickOpen Go to Symbol... kb(workbench.action.gotoSymbol) workbench.action.gotoSymbol Show Problems kb(workbench.actions.view.problems) workbench.actions.view.problems Go to Next Error or Warning kb(editor.action.marker.nextInFiles) editor.action.marker.nextInFiles Go to Previous Error or Warning kb(editor.action.marker.prevInFiles) editor.action.marker.prevInFiles Show All Commands kb(workbench.action.showCommands) or kbstyle(F1) workbench.action.showCommands Navigate Editor Group History kb(workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup) workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup Go Back kb(workbench.action.navigateBack) workbench.action.navigateBack Go back in Quick Input kb(workbench.action.quickInputBack) workbench.action.quickInputBack Go Forward kb(workbench.action.navigateForward) workbench.action.navigateForward Editor/Window Management Command Key Command id New Window kb(workbench.action.newWindow) workbench.action.newWindow Close Window kb(workbench.action.closeWindow) workbench.action.closeWindow Close Editor kb(workbench.action.closeActiveEditor) workbench.action.closeActiveEditor Close Folder kb(workbench.action.closeFolder) workbench.action.closeFolder Cycle Between Editor Groups kb(workbench.action.navigateEditorGroups) workbench.action.navigateEditorGroups Split Editor kb(workbench.action.splitEditor) workbench.action.splitEditor Focus into First Editor Group kb(workbench.action.focusFirstEditorGroup) workbench.action.focusFirstEditorGroup Focus into Second Editor Group kb(workbench.action.focusSecondEditorGroup) workbench.action.focusSecondEditorGroup Focus into Third Editor Group kb(workbench.action.focusThirdEditorGroup) workbench.action.focusThirdEditorGroup Focus into Editor Group on the Left kb(workbench.action.focusPreviousGroup) workbench.action.focusPreviousGroup Focus into Editor Group on the Right kb(workbench.action.focusNextGroup) workbench.action.focusNextGroup Move Editor Left kb(workbench.action.moveEditorLeftInGroup) workbench.action.moveEditorLeftInGroup Move Editor Right kb(workbench.action.moveEditorRightInGroup) workbench.action.moveEditorRightInGroup Move Active Editor Group Left kb(workbench.action.moveActiveEditorGroupLeft) workbench.action.moveActiveEditorGroupLeft Move Active Editor Group Right kb(workbench.action.moveActiveEditorGroupRight) workbench.action.moveActiveEditorGroupRight Move Editor into Next Group kb(workbench.action.moveEditorToNextGroup) workbench.action.moveEditorToNextGroup Move Editor into Previous Group kb(workbench.action.moveEditorToPreviousGroup) workbench.action.moveEditorToPreviousGroup File Management Command Key Command id New File kb(workbench.action.files.newUntitledFile) workbench.action.files.newUntitledFile Open File... kb(workbench.action.files.openFile) workbench.action.files.openFile Save kb(workbench.action.files.save) workbench.action.files.save Save All kb(saveAll) saveAll Save As... kb(workbench.action.files.saveAs) workbench.action.files.saveAs Close kb(workbench.action.closeActiveEditor) workbench.action.closeActiveEditor Close Others kb(workbench.action.closeOtherEditors) workbench.action.closeOtherEditors Close Group kb(workbench.action.closeEditorsInGroup) workbench.action.closeEditorsInGroup Close Other Groups kb(workbench.action.closeEditorsInOtherGroups) workbench.action.closeEditorsInOtherGroups Close Group to Left kb(workbench.action.closeEditorsToTheLeft) workbench.action.closeEditorsToTheLeft Close Group to Right kb(workbench.action.closeEditorsToTheRight) workbench.action.closeEditorsToTheRight Close All kb(workbench.action.closeAllEditors) workbench.action.closeAllEditors Reopen Closed Editor kb(workbench.action.reopenClosedEditor) workbench.action.reopenClosedEditor Keep Open kb(workbench.action.keepEditor) workbench.action.keepEditor Copy Path of Active File kb(workbench.action.files.copyPathOfActiveFile) workbench.action.files.copyPathOfActiveFile Reveal Active File in Windows kb(workbench.action.files.revealActiveFileInWindows) workbench.action.files.revealActiveFileInWindows Show Opened File in New Window kb(workbench.action.files.showOpenedFileInNewWindow) workbench.action.files.showOpenedFileInNewWindow Compare Opened File With kb(workbench.files.action.compareFileWith) workbench.files.action.compareFileWith Display Command Key Command id Toggle Full Screen kb(workbench.action.toggleFullScreen) workbench.action.toggleFullScreen Toggle Zen Mode kb(workbench.action.toggleZenMode) workbench.action.toggleZenMode Leave Zen Mode kb(workbench.action.exitZenMode) workbench.action.exitZenMode Zoom in kb(workbench.action.zoomIn) workbench.action.zoomIn Zoom out kb(workbench.action.zoomOut) workbench.action.zoomOut Reset Zoom kb(workbench.action.zoomReset) workbench.action.zoomReset Toggle Sidebar Visibility kb(workbench.action.toggleSidebarVisibility) workbench.action.toggleSidebarVisibility Show Explorer / Toggle Focus kb(workbench.view.explorer) workbench.view.explorer Show Search kb(workbench.view.search) workbench.view.search Show Source Control kb(workbench.view.scm) workbench.view.scm Show Run kb(workbench.view.debug) workbench.view.debug Show Extensions kb(workbench.view.extensions) workbench.view.extensions Show Output kb(workbench.action.output.toggleOutput) workbench.action.output.toggleOutput Quick Open View kb(workbench.action.quickOpenView) workbench.action.quickOpenView Open New Command Prompt kb(workbench.action.terminal.openNativeConsole) workbench.action.terminal.openNativeConsole Toggle Markdown Preview kb(markdown.showPreview) markdown.showPreview Open Preview to the Side kb(markdown.showPreviewToSide) markdown.showPreviewToSide Toggle Integrated Terminal kb(workbench.action.terminal.toggleTerminal) workbench.action.terminal.toggleTerminal Search Command Key Command id Show Search kb(workbench.view.search) workbench.view.search Replace in Files kb(workbench.action.replaceInFiles) workbench.action.replaceInFiles Toggle Match Case kb(toggleSearchCaseSensitive) toggleSearchCaseSensitive Toggle Match Whole Word kb(toggleSearchWholeWord) toggleSearchWholeWord Toggle Use Regular Expression kb(toggleSearchRegex) toggleSearchRegex Toggle Search Details kb(workbench.action.search.toggleQueryDetails) workbench.action.search.toggleQueryDetails Focus Next Search Result kb(search.action.focusNextSearchResult) search.action.focusNextSearchResult Focus Previous Search Result kb(search.action.focusPreviousSearchResult) search.action.focusPreviousSearchResult Show Next Search Term kb(history.showNext) history.showNext Show Previous Search Term kb(history.showPrevious) history.showPrevious Search Editor Command Key Command id Open Results In Editor kb(search.action.openInEditor) search.action.openInEditor Focus Search Editor Input kb(search.action.focusQueryEditorWidget) search.action.focusQueryEditorWidget Search Again kb(rerunSearchEditorSearch) rerunSearchEditorSearch Delete File Results kb(search.searchEditor.action.deleteFileResults) search.searchEditor.action.deleteFileResults Preferences Command Key Command id Open Settings kb(workbench.action.openSettings) workbench.action.openSettings Open Workspace Settings kb(workbench.action.openWorkspaceSettings) workbench.action.openWorkspaceSettings Open Keyboard Shortcuts kb(workbench.action.openGlobalKeybindings) workbench.action.openGlobalKeybindings Open User Snippets kb(workbench.action.openSnippets) workbench.action.openSnippets Select Color Theme kb(workbench.action.selectTheme) workbench.action.selectTheme Configure Display Language kb(workbench.action.configureLocale) workbench.action.configureLocale Debug Command Key Command id Toggle Breakpoint kb(editor.debug.action.toggleBreakpoint) editor.debug.action.toggleBreakpoint Start kb(workbench.action.debug.start) workbench.action.debug.start Continue kb(workbench.action.debug.continue) workbench.action.debug.continue Start (without debugging) kb(workbench.action.debug.run) workbench.action.debug.run Pause kb(workbench.action.debug.pause) workbench.action.debug.pause Step Into kb(workbench.action.debug.stepInto) workbench.action.debug.stepInto Tasks Command Key Command id Run Build Task kb(workbench.action.tasks.build) workbench.action.tasks.build Run Test Task kb(workbench.action.tasks.test) workbench.action.tasks.test Extensions Command Key Command id Install Extension kb(workbench.extensions.action.installExtension) workbench.extensions.action.installExtension Show Installed Extensions kb(workbench.extensions.action.showInstalledExtensions) workbench.extensions.action.showInstalledExtensions Show Outdated Extensions kb(workbench.extensions.action.listOutdatedExtensions) workbench.extensions.action.listOutdatedExtensions Show Recommended Extensions kb(workbench.extensions.action.showRecommendedExtensions) workbench.extensions.action.showRecommendedExtensions Show Popular Extensions kb(workbench.extensions.action.showPopularExtensions) workbench.extensions.action.showPopularExtensions Update All Extensions kb(workbench.extensions.action.updateAllExtensions) workbench.extensions.action.updateAllExtensions Next steps Now that you know about our Key binding support, what's next... Language Support - Our Good, Better, Best language grid to see what you can expect Debugging - This is where VS Code really shines Node.js - End to end Node.js scenario with a sample app Common questions How can I find out what command is bound to a specific key? In the Keyboard Shortcut editor, you can filter on specific keystrokes to see which commands are bound to which keys. Below you can see that kbstyle(Ctrl+Shift+P) is bound to Show All Commands to bring up the Command Palette. How to add a key binding to an action, for example, add Ctrl+D to Delete Lines Find a rule that triggers the action in the Default Keyboard Shortcuts and write a modified version of it in your keybindings.json file: // Original, in Default Keyboard Shortcuts { \"key\": \"ctrl+shift+k\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus\" }, // Modified, in User/keybindings.json, Ctrl+D now will also trigger this action { \"key\": \"ctrl+d\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus\" }, How can I add a key binding for only certain file types? Use the editorLangId context key in your when clause: { \"key\": \"shift+alt+a\", \"command\": \"editor.action.blockComment\", \"when\": \"editorTextFocus && editorLangId == csharp\" }, I have modified my key bindings in keybindings.json ; why don't they work? The most common problem is a syntax error in the file. Otherwise, try removing the when clause or picking a different key . Unfortunately, at this point, it is a trial and error process."
  },
  "guides/vscode/getstarted/locales.html": {
    "href": "guides/vscode/getstarted/locales.html",
    "title": "Display Language | Fountain of Knowledge",
    "keywords": "Display Language Visual Studio Code ships by default with English as the display language and other languages rely on Language Pack extensions available from the Marketplace . VS Code detects the operating system's UI language and will prompt you to install the appropriate Language Pack, if available on the Marketplace. Below is an example recommending a Simplified Chinese Language Pack: After installing the Language Pack extension and following the prompt to restart, VS Code will use the Language Pack matching your operating system's UI language. Changing the Display Language You can also override the default UI language by explicitly setting the VS Code display language using the Configure Display Language command. Press kb(workbench.action.showCommands) to bring up the Command Palette then start typing \"display\" to filter and display the Configure Display Language command. Press kbstyle(Enter) and a list of installed languages by locale is displayed, with the current locale highlighted. Use the Install additional languages... option to install more Language Packs from the Marketplace , or select a different locale from the list. Changing the locale requires a restart of VS Code. You will be prompted to restart when you select a locale . The Configure Display Language command writes to the Runtime Configuration Arguments file argv.json in your user VS Code folder ( .vscode ). The locale can also be changed by editing the argv.json file directly ( Preferences: Configure Runtime Arguments ) and restarting VS Code. Available locales Display Language Locale English (US) en Simplified Chinese zh-CN Traditional Chinese zh-TW French fr German de Italian it Spanish es Japanese ja Korean ko Russian ru Bulgarian bg Hungarian hu Portuguese (Brazil) pt-br Turkish tr Marketplace Language Packs As described above, VS Code ships with English as the default display language, but other languages are available through Marketplace Language Packs . You can search for Language Packs in the Extensions view ( kb(workbench.view.extensions) ) by typing the language you are looking for along with category:\"Language Packs\" . You can have multiple Language Packs installed and select the current display language with the Configure Display Language command. Setting the Language If you want to use a specific language for a VS Code session, you can use the command-line switch --locale to specify a locale when you launch VS Code. Below is an example of using the --locale command-line switch to set the VS Code display language to French: code . --locale=fr Note : You must have the appropriate Language Pack installed for the language you specify with the command-line switch. If the matching Language Pack is not installed, VS Code will display English. Common questions Unable to write to file because the file is dirty This notification may mean that your argv.json file wasn't saved after a previous change. Check if there are any errors in the file ( Preferences: Configure Runtime Arguments ), make sure the file is saved, and try to install the Language Pack again. Can I contribute to a language pack's translations? Yes, the Visual Studio Code Community Localization Project is open to anyone, where contributors can provide new translations, vote on existing translations, or suggest process improvements."
  },
  "guides/vscode/getstarted/settings.html": {
    "href": "guides/vscode/getstarted/settings.html",
    "title": "User and Workspace Settings | Fountain of Knowledge",
    "keywords": "User and Workspace Settings You can configure Visual Studio Code to your liking through its various settings. Nearly every part of VS Code's editor, user interface, and functional behavior has options you can modify. VS Code provides two different scopes for settings: User Settings - Settings that apply globally to any instance of VS Code you open. Workspace Settings - Settings stored inside your workspace and only apply when the workspace is opened. Workspace settings override user settings. Workspace settings are specific to a project and can be shared across developers on a project. Note : A VS Code \"workspace\" is usually just your project root folder. Workspace settings as well as debugging and task configurations are stored at the root in a .vscode folder. You can also have more than one root folder in a VS Code workspace through a feature called Multi-root workspaces . You can learn more in the What is a VS Code \"workspace\"? article. Creating User and Workspace Settings To open your user and workspace settings, use the following VS Code menu command: On Windows/Linux - File > Preferences > Settings On macOS - Code > Preferences > Settings You can also open the Settings editor from the Command Palette ( kb(workbench.action.showCommands) ) with Preferences: Open Settings or use the keyboard shortcut ( kb(workbench.action.openSettings) ). In the example below, the color theme and the file icon theme have been changed. Changes to settings are reloaded by VS Code as you change them. Modified settings are now indicated with a blue line similar to modified lines in the editor. The gear icon opens a context menu with options to reset the setting to its default value as well as copy setting as JSON. Note: Workspace settings are useful for sharing project specific settings across a team. Settings editor When you open the settings editor, you can search and discover settings you are looking for. When you search using the Search bar, it will not only show and highlight the settings matching your criteria, but also filter out those which are not matching. This makes finding settings quick and easy. Note : VS Code extensions can also add their own custom settings and they will be visible under an Extensions section. Edit settings Each setting can be edited by either a checkbox , an input or by a dropdown . Edit the text or select the option you want to change to the desired settings. Settings groups Default settings are represented in groups so that you can navigate them easily. It has a Commonly Used group at the top, which shows popular customizations. Below is a copy of the default settings that come with VS Code. Settings file locations By default VS Code shows the Settings editor, but you can still edit the underlying settings.json file by using the Open Settings (JSON) command or by changing your default settings editor with the workbench.settings.editor setting. Depending on your platform, the user settings file is located here: Windows %APPDATA%\\Code\\User\\settings.json macOS $HOME/Library/Application Support/Code/User/settings.json Linux $HOME/.config/Code/User/settings.json The workspace settings file is located under the .vscode folder in your root folder. Note: In case of a Multi-root Workspace , workspace settings are located inside the workspace configuration file. Language-specific editor settings To customize your editor by language, run the global command Preferences: Configure Language Specific Settings (command ID: workbench.action.configureLanguageBasedSettings ) from the Command Palette ( kb(workbench.action.showCommands) ) which opens the language picker. Select the language you want, which then opens your user settings.json with the language entry where you can add applicable settings. Select the language via the dropdown: Add language-specific settings to your user settings: If you have a file open and you want to customize the editor for this file type, select the Language Mode in the Status Bar to the bottom-right of the VS Code window. This opens the Language Mode picker with an option Configure 'language_name' language based settings . Selecting this opens your user settings.json with the language entry where you can add applicable settings. Language-specific editor settings in your user settings override workspace settings. You can scope language-specific settings to the workspace by placing them in the workspace settings just like other settings. If you have settings defined for a language in both user and workspace scopes, then they are merged by giving precedence to the ones defined in the workspace. The following examples customize editor settings for language modes typescript and markdown . { \"[typescript]\": { \"editor.formatOnSave\": true, \"editor.formatOnPaste\": true }, \"[markdown]\": { \"editor.formatOnSave\": true, \"editor.wordWrap\": \"on\", \"editor.renderWhitespace\": \"all\", \"editor.acceptSuggestionOnEnter\": \"off\" } } You can use IntelliSense in settings.json to help you find allowed language-based settings. All editor settings and some non-editor settings are supported. Some languages have default language-specific settings already set, which you can review in defaultSettings.json opened with the Preferences: Open Default Settings command. Settings precedence Configurations can be overridden at multiple levels by the different setting scopes: User settings - Apply globally to all VS Code instances. Workspace setting - Apply to the open folder or workspace and override User settings. Workspace Folder settings - Apply to a specific folder of a multi-root workspace . Override User and Workspace settings. Setting values can be of various types: String - \"files.autoSave\": \"afterDelay\" Boolean - \"editor.minimap.enabled\": true Number - \"files.autoSaveDelay\": 1000 Array - \"editor.rulers\": [] Object - \"search.exclude\": { \"**/node_modules\": true, \"**/bower_components\": true } Values with primitive types and Array type are overridden but those with Object type are merged. For example, workbench.colorCustomizations takes an Object that specifies a group of UI elements and their desired colors. If your user settings set the editor backgrounds to blue and green: \"workbench.colorCustomizations\": { \"editor.background\": \"#000088\", \"editor.selectionBackground\": \"#008800\" } And your open workspace settings set the editor foreground to red: \"workbench.colorCustomizations\": { \"editor.foreground\": \"#880000\", \"editor.selectionBackground\": \"#00FF00\" } The result, when that workspace is open, is the combination of those two color customizations, as if you had specified: \"workbench.colorCustomizations\": { \"editor.background\": \"#000088\", \"editor.selectionBackground\": \"#00FF00\", \"editor.foreground\": \"#880000\" } If there are conflicting values, such as editor.selectionBackground in the example above, the usual override behavior occurs with workspace values taking precedence over user values. Settings and security Some settings allow you to specify an executable that VS Code will run to perform certain operations. For example, you can choose which shell the Integrated Terminal should use. For enhanced security, such settings can only be defined in user settings and not at workspace scope. Here is the list of settings not supported in workspace settings: git.path terminal.external.windowsExec terminal.external.osxExec terminal.external.linuxExec The first time you open a workspace that defines any of these settings, VS Code will warn you and then always ignore the values after that. Default settings Below are the Visual Studio Code default settings and their values. You can also view the default values in the Settings editor. { // Editor // Controls whether the editor shows CodeLens. \"diffEditor.codeLens\": false, // When enabled, the diff editor ignores changes in leading or trailing whitespace. \"diffEditor.ignoreTrimWhitespace\": true, // Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout. \"diffEditor.maxComputationTime\": 5000, // Controls whether the diff editor shows +/- indicators for added/removed changes. \"diffEditor.renderIndicators\": true, // Controls whether the diff editor shows the diff side by side or inline. \"diffEditor.renderSideBySide\": true, // - off: Lines will never wrap. // - on: Lines will wrap at the viewport width. // - inherit: Lines will wrap according to the `editor.wordWrap` setting. \"diffEditor.wordWrap\": \"inherit\", // Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character. \"editor.acceptSuggestionOnCommitCharacter\": true, // Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions. // - on // - smart: Only accept a suggestion with `Enter` when it makes a textual change. // - off \"editor.acceptSuggestionOnEnter\": \"on\", // Controls whether the editor should run in a mode where it is optimized for screen readers. Setting to on will disable word wrapping. // - auto: The editor will use platform APIs to detect when a Screen Reader is attached. // - on: The editor will be permanently optimized for usage with a Screen Reader. Word wrapping will be disabled. // - off: The editor will never be optimized for usage with a Screen Reader. \"editor.accessibilitySupport\": \"auto\", // Controls whether the editor should automatically close brackets after the user adds an opening bracket. // - always // - languageDefined: Use language configurations to determine when to autoclose brackets. // - beforeWhitespace: Autoclose brackets only when the cursor is to the left of whitespace. // - never \"editor.autoClosingBrackets\": \"languageDefined\", // Controls whether the editor should remove adjacent closing quotes or brackets when deleting. // - always // - auto: Remove adjacent closing quotes or brackets only if they were automatically inserted. // - never \"editor.autoClosingDelete\": \"auto\", // Controls whether the editor should type over closing quotes or brackets. // - always // - auto: Type over closing quotes or brackets only if they were automatically inserted. // - never \"editor.autoClosingOvertype\": \"auto\", // Controls whether the editor should automatically close quotes after the user adds an opening quote. // - always // - languageDefined: Use language configurations to determine when to autoclose quotes. // - beforeWhitespace: Autoclose quotes only when the cursor is to the left of whitespace. // - never \"editor.autoClosingQuotes\": \"languageDefined\", // Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines. // - none: The editor will not insert indentation automatically. // - keep: The editor will keep the current line's indentation. // - brackets: The editor will keep the current line's indentation and honor language defined brackets. // - advanced: The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages. // - full: The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages. \"editor.autoIndent\": \"full\", // Controls whether the editor should automatically surround selections when typing quotes or brackets. // - languageDefined: Use language configurations to determine when to automatically surround selections. // - quotes: Surround with quotes but not brackets. // - brackets: Surround with brackets but not quotes. // - never \"editor.autoSurround\": \"languageDefined\", // Code action kinds to be run on save. \"editor.codeActionsOnSave\": {}, // Controls whether the editor shows CodeLens. \"editor.codeLens\": true, // Controls the font family for CodeLens. \"editor.codeLensFontFamily\": \"\", // Controls the font size in pixels for CodeLens. When set to `0`, the 90% of `editor.fontSize` is used. \"editor.codeLensFontSize\": 0, // Controls whether the editor should render the inline color decorators and color picker. \"editor.colorDecorators\": true, // Enable that the selection with the mouse and keys is doing column selection. \"editor.columnSelection\": false, // Controls if empty lines should be ignored with toggle, add or remove actions for line comments. \"editor.comments.ignoreEmptyLines\": true, // Controls whether a space character is inserted when commenting. \"editor.comments.insertSpace\": true, // Controls whether syntax highlighting should be copied into the clipboard. \"editor.copyWithSyntaxHighlighting\": true, // Control the cursor animation style. \"editor.cursorBlinking\": \"blink\", // Controls whether the smooth caret animation should be enabled. \"editor.cursorSmoothCaretAnimation\": false, // Controls the cursor style. \"editor.cursorStyle\": \"line\", // Controls the minimal number of visible leading and trailing lines surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors. \"editor.cursorSurroundingLines\": 0, // Controls when `cursorSurroundingLines` should be enforced. // - default: `cursorSurroundingLines` is enforced only when triggered via the keyboard or API. // - all: `cursorSurroundingLines` is enforced always. \"editor.cursorSurroundingLinesStyle\": \"default\", // Controls the width of the cursor when `editor.cursorStyle` is set to `line`. \"editor.cursorWidth\": 0, // Defines a default formatter which takes precedence over all other formatter settings. Must be the identifier of an extension contributing a formatter. \"editor.defaultFormatter\": null, // Controls whether the Go to Definition mouse gesture always opens the peek widget. \"editor.definitionLinkOpensInPeek\": false, // Controls whether `editor.tabSize#` and `#editor.insertSpaces` will be automatically detected when a file is opened based on the file contents. \"editor.detectIndentation\": true, // Controls whether the editor should allow moving selections via drag and drop. \"editor.dragAndDrop\": true, // Controls whether copying without a selection copies the current line. \"editor.emptySelectionClipboard\": true, // Scrolling speed multiplier when pressing `Alt`. \"editor.fastScrollSensitivity\": 5, // Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible. \"editor.find.addExtraSpaceOnTop\": true, // Controls the condition for turning on Find in Selection automatically. // - never: Never turn on Find in Selection automatically (default). // - always: Always turn on Find in Selection automatically. // - multiline: Turn on Find in Selection automatically when multiple lines of content are selected. \"editor.find.autoFindInSelection\": \"never\", // Controls whether the cursor should jump to find matches while typing. \"editor.find.cursorMoveOnType\": true, // Controls whether the Find Widget should read or modify the shared find clipboard on macOS. \"editor.find.globalFindClipboard\": false, // Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found. \"editor.find.loop\": true, // Controls whether the search string in the Find Widget is seeded from the editor selection. // - never: Never seed search string from the editor selection. // - always: Always seed search string from the editor selection, including word at cursor position. // - selection: Only seed search string from the editor selection. \"editor.find.seedSearchStringFromSelection\": \"always\", // Controls whether the editor has code folding enabled. \"editor.folding\": true, // Controls whether the editor should highlight folded ranges. \"editor.foldingHighlight\": true, // Controls whether the editor should auto collapse folded ranges or not. \"editor.foldingImportsByDefault\": false, // Controls the strategy for computing folding ranges. // - auto: Use a language-specific folding strategy if available, else the indentation-based one. // - indentation: Use the indentation-based folding strategy. \"editor.foldingStrategy\": \"auto\", // Controls the font family. \"editor.fontFamily\": \"Consolas, 'Courier New', monospace\", // Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property. \"editor.fontLigatures\": false, // Controls the font size in pixels. \"editor.fontSize\": 14, // Controls the font weight. Accepts \"normal\" and \"bold\" keywords or numbers between 1 and 1000. \"editor.fontWeight\": \"normal\", // Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document. \"editor.formatOnPaste\": false, // Format a file on save. A formatter must be available, the file must not be saved after delay, and the editor must not be shutting down. \"editor.formatOnSave\": false, // Controls if format on save formats the whole file or only modifications. Only applies when `editor.formatOnSave` is enabled. // - file: Format the whole file. // - modifications: Format modifications (requires source control). // - modificationsIfAvailable: Will attempt to format modifications only (requires source control). If source control can't be used, then the whole file will be formatted. \"editor.formatOnSaveMode\": \"file\", // Controls whether the editor should automatically format the line after typing. \"editor.formatOnType\": false, // Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging. \"editor.glyphMargin\": true, // Alternative command id that is being executed when the result of 'Go to Declaration' is the current location. \"editor.gotoLocation.alternativeDeclarationCommand\": \"editor.action.goToReferences\", // Alternative command id that is being executed when the result of 'Go to Definition' is the current location. \"editor.gotoLocation.alternativeDefinitionCommand\": \"editor.action.goToReferences\", // Alternative command id that is being executed when the result of 'Go to Implementation' is the current location. \"editor.gotoLocation.alternativeImplementationCommand\": \"\", // Alternative command id that is being executed when the result of 'Go to Reference' is the current location. \"editor.gotoLocation.alternativeReferenceCommand\": \"\", // Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location. \"editor.gotoLocation.alternativeTypeDefinitionCommand\": \"editor.action.goToReferences\", // Controls the behavior the 'Go to Declaration'-command when multiple target locations exist. // - peek: Show peek view of the results (default) // - gotoAndPeek: Go to the primary result and show a peek view // - goto: Go to the primary result and enable peek-less navigation to others \"editor.gotoLocation.multipleDeclarations\": \"peek\", // Controls the behavior the 'Go to Definition'-command when multiple target locations exist. // - peek: Show peek view of the results (default) // - gotoAndPeek: Go to the primary result and show a peek view // - goto: Go to the primary result and enable peek-less navigation to others \"editor.gotoLocation.multipleDefinitions\": \"peek\", // Controls the behavior the 'Go to Implementations'-command when multiple target locations exist. // - peek: Show peek view of the results (default) // - gotoAndPeek: Go to the primary result and show a peek view // - goto: Go to the primary result and enable peek-less navigation to others \"editor.gotoLocation.multipleImplementations\": \"peek\", // Controls the behavior the 'Go to References'-command when multiple target locations exist. // - peek: Show peek view of the results (default) // - gotoAndPeek: Go to the primary result and show a peek view // - goto: Go to the primary result and enable peek-less navigation to others \"editor.gotoLocation.multipleReferences\": \"peek\", // Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist. // - peek: Show peek view of the results (default) // - gotoAndPeek: Go to the primary result and show a peek view // - goto: Go to the primary result and enable peek-less navigation to others \"editor.gotoLocation.multipleTypeDefinitions\": \"peek\", // Controls whether the cursor should be hidden in the overview ruler. \"editor.hideCursorInOverviewRuler\": false, // Controls whether the editor should highlight the active indent guide. \"editor.highlightActiveIndentGuide\": true, // Controls the delay in milliseconds after which the hover is shown. \"editor.hover.delay\": 300, // Controls whether the hover is shown. \"editor.hover.enabled\": true, // Controls whether the hover should remain visible when mouse is moved over it. \"editor.hover.sticky\": true, // Enables the inlay hints in the editor. \"editor.inlayHints.enabled\": true, // Controls font family of inlay hints in the editor. When set to empty, the `editor.fontFamily` is used. \"editor.inlayHints.fontFamily\": \"\", // Controls font size of inlay hints in the editor. When set to `0`, the 90% of `editor.fontSize` is used. \"editor.inlayHints.fontSize\": 0, // Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when `editor.detectIndentation` is on. \"editor.insertSpaces\": true, // Controls the letter spacing in pixels. \"editor.letterSpacing\": 0, // Enables the code action lightbulb in the editor. \"editor.lightbulb.enabled\": true, // Controls the line height. // - Use 0 to automatically compute the line height from the font size. // - Values between 0 and 8 will be used as a multiplier with the font size. // - Values greater than or equal to 8 will be used as effective values. \"editor.lineHeight\": 0, // Controls the display of line numbers. // - off: Line numbers are not rendered. // - on: Line numbers are rendered as absolute number. // - relative: Line numbers are rendered as distance in lines to cursor position. // - interval: Line numbers are rendered every 10 lines. \"editor.lineNumbers\": \"on\", // Controls whether the editor has linked editing enabled. Depending on the language, related symbols, e.g. HTML tags, are updated while editing. \"editor.linkedEditing\": false, // Controls whether the editor should detect links and make them clickable. \"editor.links\": true, // Highlight matching brackets. \"editor.matchBrackets\": \"always\", // Controls whether the minimap is shown. \"editor.minimap.enabled\": true, // Limit the width of the minimap to render at most a certain number of columns. \"editor.minimap.maxColumn\": 120, // Render the actual characters on a line as opposed to color blocks. \"editor.minimap.renderCharacters\": true, // Scale of content drawn in the minimap: 1, 2 or 3. \"editor.minimap.scale\": 1, // Controls when the minimap slider is shown. \"editor.minimap.showSlider\": \"mouseover\", // Controls the side where to render the minimap. \"editor.minimap.side\": \"right\", // Controls the size of the minimap. // - proportional: The minimap has the same size as the editor contents (and might scroll). // - fill: The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling). // - fit: The minimap will shrink as necessary to never be larger than the editor (no scrolling). \"editor.minimap.size\": \"proportional\", // A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events. \"editor.mouseWheelScrollSensitivity\": 1, // Zoom the font of the editor when using mouse wheel and holding `Ctrl`. \"editor.mouseWheelZoom\": false, // The modifier to be used to add multiple cursors with the mouse. The Go To Definition and Open Link mouse gestures will adapt such that they do not conflict with the multicursor modifier. // - ctrlCmd: Maps to `Control` on Windows and Linux and to `Command` on macOS. // - alt: Maps to `Alt` on Windows and Linux and to `Option` on macOS. \"editor.multiCursorModifier\": \"alt\", // Controls pasting when the line count of the pasted text matches the cursor count. // - spread: Each cursor pastes a single line of the text. // - full: Each cursor pastes the full text. \"editor.multiCursorPaste\": \"spread\", // Controls whether the editor should highlight semantic symbol occurrences. \"editor.occurrencesHighlight\": true, // Controls whether a border should be drawn around the overview ruler. \"editor.overviewRulerBorder\": true, // Controls the amount of space between the bottom edge of the editor and the last line. \"editor.padding.bottom\": 0, // Controls the amount of space between the top edge of the editor and the first line. \"editor.padding.top\": 0, // Controls whether the parameter hints menu cycles or closes when reaching the end of the list. \"editor.parameterHints.cycle\": false, // Enables a pop-up that shows parameter documentation and type information as you type. \"editor.parameterHints.enabled\": true, // Controls whether to focus the inline editor or the tree in the peek widget. // - tree: Focus the tree when opening peek // - editor: Focus the editor when opening peek \"editor.peekWidgetDefaultFocus\": \"tree\", // Controls whether suggestions should automatically show up while typing. \"editor.quickSuggestions\": { \"other\": true, \"comments\": false, \"strings\": false }, // Controls the delay in milliseconds after which quick suggestions will show up. \"editor.quickSuggestionsDelay\": 10, // Enable/disable the ability to preview changes before renaming \"editor.rename.enablePreview\": true, // Controls whether the editor should render control characters. \"editor.renderControlCharacters\": false, // Render last line number when the file ends with a newline. \"editor.renderFinalNewline\": true, // Controls whether the editor should render indent guides. \"editor.renderIndentGuides\": true, // Controls how the editor should render the current line highlight. // - none // - gutter // - line // - all: Highlights both the gutter and the current line. \"editor.renderLineHighlight\": \"line\", // Controls if the editor should render the current line highlight only when the editor is focused. \"editor.renderLineHighlightOnlyWhenFocus\": false, // Controls how the editor should render whitespace characters. // - none // - boundary: Render whitespace characters except for single spaces between words. // - selection: Render whitespace characters only on selected text. // - trailing: Render only trailing whitespace characters. // - all \"editor.renderWhitespace\": \"selection\", // Controls whether selections should have rounded corners. \"editor.roundedSelection\": true, // Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty. \"editor.rulers\": [], // Controls the visibility of the horizontal scrollbar. // - auto: The horizontal scrollbar will be visible only when necessary. // - visible: The horizontal scrollbar will always be visible. // - hidden: The horizontal scrollbar will always be hidden. \"editor.scrollbar.horizontal\": \"auto\", // The height of the horizontal scrollbar. \"editor.scrollbar.horizontalScrollbarSize\": 12, // Controls whether clicks scroll by page or jump to click position. \"editor.scrollbar.scrollByPage\": false, // Controls the visibility of the vertical scrollbar. // - auto: The vertical scrollbar will be visible only when necessary. // - visible: The vertical scrollbar will always be visible. // - hidden: The vertical scrollbar will always be hidden. \"editor.scrollbar.vertical\": \"auto\", // The width of the vertical scrollbar. \"editor.scrollbar.verticalScrollbarSize\": 14, // Controls the number of extra characters beyond which the editor will scroll horizontally. \"editor.scrollBeyondLastColumn\": 5, // Controls whether the editor will scroll beyond the last line. \"editor.scrollBeyondLastLine\": true, // Controls whether the Linux primary clipboard should be supported. \"editor.selectionClipboard\": true, // Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad. \"editor.scrollPredominantAxis\": true, // Controls whether the editor should highlight matches similar to the selection. \"editor.selectionHighlight\": true, // Controls whether the semanticHighlighting is shown for the languages that support it. // - true: Semantic highlighting enabled for all color themes. // - false: Semantic highlighting disabled for all color themes. // - configuredByTheme: Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting. \"editor.semanticHighlighting.enabled\": \"configuredByTheme\", // Overrides editor semantic token color and styles from the currently selected color theme. \"editor.semanticTokenColorCustomizations\": {}, // Controls strikethrough deprecated variables. \"editor.showDeprecated\": true, // Controls when the folding controls on the gutter are shown. // - always: Always show the folding controls. // - mouseover: Only show the folding controls when the mouse is over the gutter. \"editor.showFoldingControls\": \"mouseover\", // Controls fading out of unused code. \"editor.showUnused\": true, // Whether leading and trailing whitespace should always be selected. \"editor.smartSelect.selectLeadingAndTrailingWhitespace\": true, // Controls whether the editor will scroll using an animation. \"editor.smoothScrolling\": false, // Controls whether snippets are shown with other suggestions and how they are sorted. // - top: Show snippet suggestions on top of other suggestions. // - bottom: Show snippet suggestions below other suggestions. // - inline: Show snippets suggestions with other suggestions. // - none: Do not show snippet suggestions. \"editor.snippetSuggestions\": \"inline\", // Keep peek editors open even when double clicking their content or when hitting `Escape`. \"editor.stablePeek\": false, // Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops. \"editor.stickyTabStops\": false, // Controls whether filtering and sorting suggestions accounts for small typos. \"editor.suggest.filterGraceful\": true, // Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature. // - insert: Insert suggestion without overwriting text right of the cursor. // - replace: Insert suggestion and overwrite text right of the cursor. \"editor.suggest.insertMode\": \"insert\", // Controls whether sorting favors words that appear close to the cursor. \"editor.suggest.localityBonus\": false, // Controls whether to preview the suggestion outcome in the editor. \"editor.suggest.preview\": false, // Controls which mode to use for rendering the suggest preview. // - prefix: Only render a preview if the replace text is a prefix of the insert text. // - subword: Only render a preview if the replace text is a subword of the insert text. // - subwordSmart: Render a preview if the replace text is a subword of the insert text, or if it is a prefix of the insert text. \"editor.suggest.previewMode\": \"subwordSmart\", // Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `editor.suggestSelection`). \"editor.suggest.shareSuggestSelections\": false, // When enabled IntelliSense shows `class`-suggestions. \"editor.suggest.showClasses\": true, // When enabled IntelliSense shows `color`-suggestions. \"editor.suggest.showColors\": true, // When enabled IntelliSense shows `constant`-suggestions. \"editor.suggest.showConstants\": true, // When enabled IntelliSense shows `constructor`-suggestions. \"editor.suggest.showConstructors\": true, // When enabled IntelliSense shows `customcolor`-suggestions. \"editor.suggest.showCustomcolors\": true, // When enabled IntelliSense shows `deprecated`-suggestions. \"editor.suggest.showDeprecated\": true, // When enabled IntelliSense shows `enumMember`-suggestions. \"editor.suggest.showEnumMembers\": true, // When enabled IntelliSense shows `enum`-suggestions. \"editor.suggest.showEnums\": true, // When enabled IntelliSense shows `event`-suggestions. \"editor.suggest.showEvents\": true, // When enabled IntelliSense shows `field`-suggestions. \"editor.suggest.showFields\": true, // When enabled IntelliSense shows `file`-suggestions. \"editor.suggest.showFiles\": true, // When enabled IntelliSense shows `folder`-suggestions. \"editor.suggest.showFolders\": true, // When enabled IntelliSense shows `function`-suggestions. \"editor.suggest.showFunctions\": true, // Controls whether to show or hide icons in suggestions. \"editor.suggest.showIcons\": true, // Controls whether suggest details show inline with the label or only in the details widget. \"editor.suggest.showInlineDetails\": true, // When enabled IntelliSense shows `interface`-suggestions. \"editor.suggest.showInterfaces\": true, // When enabled IntelliSense shows `issues`-suggestions. \"editor.suggest.showIssues\": true, // When enabled IntelliSense shows `keyword`-suggestions. \"editor.suggest.showKeywords\": true, // When enabled IntelliSense shows `method`-suggestions. \"editor.suggest.showMethods\": true, // When enabled IntelliSense shows `module`-suggestions. \"editor.suggest.showModules\": true, // When enabled IntelliSense shows `operator`-suggestions. \"editor.suggest.showOperators\": true, // When enabled IntelliSense shows `property`-suggestions. \"editor.suggest.showProperties\": true, // When enabled IntelliSense shows `reference`-suggestions. \"editor.suggest.showReferences\": true, // When enabled IntelliSense shows `snippet`-suggestions. \"editor.suggest.showSnippets\": true, // Controls the visibility of the status bar at the bottom of the suggest widget. \"editor.suggest.showStatusBar\": false, // When enabled IntelliSense shows `struct`-suggestions. \"editor.suggest.showStructs\": true, // When enabled IntelliSense shows `typeParameter`-suggestions. \"editor.suggest.showTypeParameters\": true, // When enabled IntelliSense shows `unit`-suggestions. \"editor.suggest.showUnits\": true, // When enabled IntelliSense shows `user`-suggestions. \"editor.suggest.showUsers\": true, // When enabled IntelliSense shows `value`-suggestions. \"editor.suggest.showValues\": true, // When enabled IntelliSense shows `variable`-suggestions. \"editor.suggest.showVariables\": true, // When enabled IntelliSense shows `text`-suggestions. \"editor.suggest.showWords\": true, // Controls whether an active snippet prevents quick suggestions. \"editor.suggest.snippetsPreventQuickSuggestions\": true, // Font size for the suggest widget. When set to `0`, the value of `editor.fontSize` is used. \"editor.suggestFontSize\": 0, // Line height for the suggest widget. When set to `0`, the value of `editor.lineHeight` is used. The minimum value is 8. \"editor.suggestLineHeight\": 0, // Controls whether suggestions should automatically show up when typing trigger characters. \"editor.suggestOnTriggerCharacters\": true, // Controls how suggestions are pre-selected when showing the suggest list. // - first: Always select the first suggestion. // - recentlyUsed: Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently. // - recentlyUsedByPrefix: Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`. \"editor.suggestSelection\": \"recentlyUsed\", // Enables tab completions. // - on: Tab complete will insert the best matching suggestion when pressing tab. // - off: Disable tab completions. // - onlySnippets: Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled. \"editor.tabCompletion\": \"off\", // The number of spaces a tab is equal to. This setting is overridden based on the file contents when `editor.detectIndentation` is on. \"editor.tabSize\": 4, // Overrides editor syntax colors and font style from the currently selected color theme. \"editor.tokenColorCustomizations\": {}, // Remove trailing auto inserted whitespace. \"editor.trimAutoWhitespace\": true, // Controls whether clicking on the empty content after a folded line will unfold the line. \"editor.unfoldOnClickAfterEndOfLine\": false, // Remove unusual line terminators that might cause problems. // - auto: Unusual line terminators are automatically removed. // - off: Unusual line terminators are ignored. // - prompt: Unusual line terminators prompt to be removed. \"editor.unusualLineTerminators\": \"prompt\", // Inserting and deleting whitespace follows tab stops. \"editor.useTabStops\": true, // Controls whether completions should be computed based on words in the document. \"editor.wordBasedSuggestions\": true, // Controls from which documents word based completions are computed. // - currentDocument: Only suggest words from the active document. // - matchingDocuments: Suggest words from all open documents of the same language. // - allDocuments: Suggest words from all open documents. \"editor.wordBasedSuggestionsMode\": \"matchingDocuments\", // Characters that will be used as word separators when doing word related navigations or operations. \"editor.wordSeparators\": \"`~!@#$%^&*()-=+[{]}\\\\|;:'\\\",.<>/?\", // Controls how lines should wrap. // - off: Lines will never wrap. // - on: Lines will wrap at the viewport width. // - wordWrapColumn: Lines will wrap at `editor.wordWrapColumn`. // - bounded: Lines will wrap at the minimum of viewport and `editor.wordWrapColumn`. \"editor.wordWrap\": \"off\", // Controls the wrapping column of the editor when `editor.wordWrap` is `wordWrapColumn` or `bounded`. \"editor.wordWrapColumn\": 80, // Controls the indentation of wrapped lines. // - none: No indentation. Wrapped lines begin at column 1. // - same: Wrapped lines get the same indentation as the parent. // - indent: Wrapped lines get +1 indentation toward the parent. // - deepIndent: Wrapped lines get +2 indentation toward the parent. \"editor.wrappingIndent\": \"same\", // Controls the algorithm that computes wrapping points. // - simple: Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width. // - advanced: Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases. \"editor.wrappingStrategy\": \"simple\", // SCM // Controls whether inline actions are always visible in the Source Control view. \"scm.alwaysShowActions\": false, // Controls whether repositories should always be visible in the SCM view. \"scm.alwaysShowRepositories\": false, // Controls whether the SCM view should automatically reveal and select files when opening them. \"scm.autoReveal\": true, // Controls the count badge on the Source Control icon on the Activity Bar. // - all: Show the sum of all Source Control Provider count badges. // - focused: Show the count badge of the focused Source Control Provider. // - off: Disable the Source Control count badge. \"scm.countBadge\": \"all\", // Controls the default Source Control repository view mode. // - tree: Show the repository changes as a tree. // - list: Show the repository changes as a list. \"scm.defaultViewMode\": \"list\", // Controls diff decorations in the editor. // - all: Show the diff decorations in all available locations. // - gutter: Show the diff decorations only in the editor gutter. // - overview: Show the diff decorations only in the overview ruler. // - minimap: Show the diff decorations only in the minimap. // - none: Do not show the diff decorations. \"scm.diffDecorations\": \"all\", // Controls the behavior of Source Control diff gutter decorations. // - diff: Show the inline diff peek view on click. // - none: Do nothing. \"scm.diffDecorationsGutterAction\": \"diff\", // Controls the visibility of the Source Control diff decorator in the gutter. // - always: Show the diff decorator in the gutter at all times. // - hover: Show the diff decorator in the gutter only on hover. \"scm.diffDecorationsGutterVisibility\": \"always\", // Controls the width(px) of diff decorations in gutter (added & modified). \"scm.diffDecorationsGutterWidth\": 3, // Controls the font for the input message. Use `default` for the workbench user interface font family, `editor` for the `editor.fontFamily`'s value, or a custom font family. \"scm.inputFontFamily\": \"default\", // Controls the font size for the input message in pixels. \"scm.inputFontSize\": 13, // Controls the count badges on Source Control Provider headers. These headers only appear when there is more than one provider. // - hidden: Hide Source Control Provider count badges. // - auto: Only show count badge for Source Control Provider when non-zero. // - visible: Show Source Control Provider count badges. \"scm.providerCountBadge\": \"hidden\", // Controls how many repositories are visible in the Source Control Repositories section. Set to `0` to be able to manually resize the view. \"scm.repositories.visible\": 10, // Security // Controls when the restricted mode banner is shown. // - always: Show the banner every time an untrusted workspace is open. // - untilDismissed: Show the banner when an untrusted workspace is opened until dismissed. // - never: Do not show the banner when an untrusted workspace is open. \"security.workspace.trust.banner\": \"untilDismissed\", // Controls whether or not the empty window is trusted by default within VS Code. When used with `security.workspace.trust.untrustedFiles`, you can enable the full functionality of VS Code without prompting in an empty window. \"security.workspace.trust.emptyWindow\": true, // Controls whether or not Workspace Trust is enabled within VS Code. \"security.workspace.trust.enabled\": true, // Controls when the startup prompt to trust a workspace is shown. // - always: Ask for trust every time an untrusted workspace is opened. // - once: Ask for trust the first time an untrusted workspace is opened. // - never: Do not ask for trust when an untrusted workspace is opened. \"security.workspace.trust.startupPrompt\": \"once\", // Controls how to handle opening untrusted files in a trusted workspace. This setting also applies to opening files in an empty window which is trusted via `security.workspace.trust.emptyWindow`. // - prompt: Ask how to handle untrusted files for each workspace. Once untrusted files are introduced to a trusted workspace, you will not be prompted again. // - open: Always allow untrusted files to be introduced to a trusted workspace without prompting. // - newWindow: Always open untrusted files in a separate window in restricted mode without prompting. \"security.workspace.trust.untrustedFiles\": \"prompt\", // Workbench // Controls the behavior of clicking an activity bar icon in the workbench. // - toggle: Hide the side bar if the clicked item is already visible. // - focus: Focus side bar if the clicked item is already visible. \"workbench.activityBar.iconClickBehavior\": \"toggle\", // Controls the visibility of the activity bar in the workbench. \"workbench.activityBar.visible\": true, // Overrides colors from the currently selected color theme. \"workbench.colorCustomizations\": {}, // Specifies the color theme used in the workbench. \"workbench.colorTheme\": \"Default Dark+\", // Controls the number of recently used commands to keep in history for the command palette. Set to 0 to disable command history. \"workbench.commandPalette.history\": 50, // Controls whether the last typed input to the command palette should be restored when opening it the next time. \"workbench.commandPalette.preserveInput\": false, // Controls if the centered layout should automatically resize to maximum width when more than one group is open. Once only one group is open it will resize back to the original centered width. \"workbench.editor.centeredLayoutAutoResize\": true, // Controls the behavior of empty editor groups when the last tab in the group is closed. When enabled, empty groups will automatically close. When disabled, empty groups will remain part of the grid. \"workbench.editor.closeEmptyGroups\": true, // Controls whether editors showing a file that was opened during the session should close automatically when getting deleted or renamed by some other process. Disabling this will keep the editor open on such an event. Note that deleting from within the application will always close the editor and that dirty files will never close to preserve your data. \"workbench.editor.closeOnFileDelete\": false, // Controls whether editor file decorations should use badges. \"workbench.editor.decorations.badges\": true, // Controls whether editor file decorations should use colors. \"workbench.editor.decorations.colors\": true, // Controls whether opened editors show as preview. Preview editors do not keep open and are reused until explicitly set to be kept open (e.g. via double click or editing) and show up with an italic font style. \"workbench.editor.enablePreview\": true, // Controls whether editors remain in preview when a code navigation is started from them. Preview editors do not keep open and are reused until explicitly set to be kept open (e.g. via double click or editing). This value is ignored when `workbench.editor.enablePreview` is disabled. \"workbench.editor.enablePreviewFromCodeNavigation\": false, // Controls whether editors opened from Quick Open show as preview. Preview editors do not keep open and are reused until explicitly set to be kept open (e.g. via double click or editing). This value is ignored when `workbench.editor.enablePreview` is disabled. \"workbench.editor.enablePreviewFromQuickOpen\": false, // Controls whether tabs are closed in most recently used order or from left to right. \"workbench.editor.focusRecentEditorAfterClose\": true, // Controls whether a top border is drawn on modified (dirty) editor tabs or not. This value is ignored when `workbench.editor.showTabs` is disabled. \"workbench.editor.highlightModifiedTabs\": false, // Controls the format of the label for an editor. // - default: Show the name of the file. When tabs are enabled and two files have the same name in one group the distinguishing sections of each file's path are added. When tabs are disabled, the path relative to the workspace folder is shown if the editor is active. // - short: Show the name of the file followed by its directory name. // - medium: Show the name of the file followed by its path relative to the workspace folder. // - long: Show the name of the file followed by its absolute path. \"workbench.editor.labelFormat\": \"default\", // Controls if the number of opened editors should be limited or not. When enabled, less recently used editors that are not dirty will close to make space for newly opening editors. \"workbench.editor.limit.enabled\": false, // Controls if the limit of maximum opened editors should apply per editor group or across all editor groups. \"workbench.editor.limit.perEditorGroup\": false, // Controls the maximum number of opened editors. Use the `workbench.editor.limit.perEditorGroup` setting to control this limit per editor group or across all groups. \"workbench.editor.limit.value\": 10, // Navigate between open files using mouse buttons four and five if provided. \"workbench.editor.mouseBackForwardToNavigate\": true, // Controls where editors open. Select `left` or `right` to open editors to the left or right of the currently active one. Select `first` or `last` to open editors independently from the currently active one. \"workbench.editor.openPositioning\": \"right\", // Controls the default direction of editors that are opened side by side (for example, from the Explorer). By default, editors will open on the right hand side of the currently active one. If changed to `down`, the editors will open below the currently active one. \"workbench.editor.openSideBySideDirection\": \"right\", // Controls the sizing of pinned editor tabs. Pinned tabs are sorted to the beginning of all opened tabs and typically do not close until unpinned. This value is ignored when `workbench.editor.showTabs` is disabled. // - normal: A pinned tab inherits the look of non pinned tabs. // - compact: A pinned tab will show in a compact form with only icon or first letter of the editor name. // - shrink: A pinned tab shrinks to a compact fixed size showing parts of the editor name. \"workbench.editor.pinnedTabSizing\": \"normal\", // Restores the last editor view state (e.g. scroll position) when re-opening editors after they have been closed. Editor view state is stored per editor group and discarded when a group closes. Use the `workbench.editor.sharedViewState` setting to use the last known view state across all editor groups in case no previous view state was found for a editor group. \"workbench.editor.restoreViewState\": true, // Controls whether an editor is revealed in any of the visible groups if opened. If disabled, an editor will prefer to open in the currently active editor group. If enabled, an already opened editor will be revealed instead of opened again in the currently active editor group. Note that there are some cases where this setting is ignored, e.g. when forcing an editor to open in a specific group or to the side of the currently active group. \"workbench.editor.revealIfOpen\": false, // Controls whether scrolling over tabs will open them or not. By default tabs will only reveal upon scrolling, but not open. You can press and hold the Shift-key while scrolling to change this behavior for that duration. This value is ignored when `workbench.editor.showTabs` is disabled. \"workbench.editor.scrollToSwitchTabs\": false, // Preserves the most recent editor view state (e.g. scroll position) across all editor groups and restores that if no specific editor view state is found for the editor group. \"workbench.editor.sharedViewState\": false, // Controls whether opened editors should show with an icon or not. This requires a file icon theme to be enabled as well. \"workbench.editor.showIcons\": true, // Controls whether opened editors should show in tabs or not. \"workbench.editor.showTabs\": true, // Controls if editor groups can be split from drag and drop operations by dropping an editor or file on the edges of the editor area. \"workbench.editor.splitOnDragAndDrop\": true, // Controls the sizing of editor groups when splitting them. // - distribute: Splits all the editor groups to equal parts. // - split: Splits the active editor group to equal parts. \"workbench.editor.splitSizing\": \"distribute\", // Controls the position of the editor's tabs close buttons, or disables them when set to 'off'. This value is ignored when `workbench.editor.showTabs` is disabled. \"workbench.editor.tabCloseButton\": \"right\", // Controls the sizing of editor tabs. This value is ignored when `workbench.editor.showTabs` is disabled. // - fit: Always keep tabs large enough to show the full editor label. // - shrink: Allow tabs to get smaller when the available space is not enough to show all tabs at once. \"workbench.editor.tabSizing\": \"fit\", // Controls the height of the scrollbars used for tabs and breadcrumbs in the editor title area. // - default: The default size. // - large: Increases the size, so it can be grabbed more easily with the mouse. \"workbench.editor.titleScrollbarSizing\": \"default\", // Controls if the untitled hint should be inline text in the editor or a floating button or hidden. \"workbench.editor.untitled.hint\": \"text\", // Controls the format of the label for an untitled editor. // - content: The name of the untitled file is derived from the contents of its first line unless it has an associated file path. It will fallback to the name in case the line is empty or contains no word characters. // - name: The name of the untitled file is not derived from the contents of the file. \"workbench.editor.untitled.labelFormat\": \"content\", // Controls whether tabs should be wrapped over multiple lines when exceeding available space or whether a scrollbar should appear instead. This value is ignored when `workbench.editor.showTabs` is disabled. \"workbench.editor.wrapTabs\": false, // Configure glob patterns to editors (e.g. `\"*.hex\": \"hexEditor.hexEdit\"`). These have precedence over the default behavior. \"workbench.editorAssociations\": {}, // Configure the opener to use for external URIs (http, https). \"workbench.externalUriOpeners\": {}, // Controls font aliasing method in the workbench. // - default: Sub-pixel font smoothing. On most non-retina displays this will give the sharpest text. // - antialiased: Smooth the font on the level of the pixel, as opposed to the subpixel. Can make the font appear lighter overall. // - none: Disables font smoothing. Text will show with jagged sharp edges. // - auto: Applies `default` or `antialiased` automatically based on the DPI of displays. \"workbench.fontAliasing\": \"default\", // Controls the delay in milliseconds after which the hover is shown for workbench items (ex. some extension provided tree view items). Already visible items may require a refresh before reflecting this setting change. \"workbench.hover.delay\": 500, // Specifies the file icon theme used in the workbench or 'null' to not show any file icons. // - null: No file icons // - vs-minimal // - vs-seti \"workbench.iconTheme\": \"vs-seti\", // Controls whether keyboard navigation in lists and trees is automatically triggered simply by typing. If set to `false`, keyboard navigation is only triggered when executing the `list.toggleKeyboardNavigation` command, for which you can assign a keyboard shortcut. \"workbench.list.automaticKeyboardNavigation\": true, // Scrolling speed multiplier when pressing Alt. \"workbench.list.fastScrollSensitivity\": 5, // Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication. \"workbench.list.horizontalScrolling\": false, // Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter. // - simple: Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes. // - highlight: Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements. // - filter: Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input. \"workbench.list.keyboardNavigation\": \"highlight\", // A multiplier to be used on the deltaX and deltaY of mouse wheel scroll events. \"workbench.list.mouseWheelScrollSensitivity\": 1, // The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier. // - ctrlCmd: Maps to `Control` on Windows and Linux and to `Command` on macOS. // - alt: Maps to `Alt` on Windows and Linux and to `Option` on macOS. \"workbench.list.multiSelectModifier\": \"ctrlCmd\", // Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable. \"workbench.list.openMode\": \"singleClick\", // Controls whether lists and trees have smooth scrolling. \"workbench.list.smoothScrolling\": false, // Controls the default location of the panel (terminal, debug console, output, problems). It can either show at the bottom, right, or left of the workbench. \"workbench.panel.defaultLocation\": \"bottom\", // Controls whether the panel opens maximized. It can either always open maximized, never open maximized, or open to the last state it was in before being closed. // - always: Always maximize the panel when opening it. // - never: Never maximize the panel when opening it. The panel will open un-maximized. // - preserve: Open the panel to the state that it was in, before it was closed. \"workbench.panel.opensMaximized\": \"preserve\", // Specifies the preferred color theme for dark OS appearance when `window.autoDetectColorScheme` is enabled. \"workbench.preferredDarkColorTheme\": \"Default Dark+\", // Specifies the preferred color theme used in high contrast mode when `window.autoDetectHighContrast` is enabled. \"workbench.preferredHighContrastColorTheme\": \"Default High Contrast\", // Specifies the preferred color theme for light OS appearance when `window.autoDetectColorScheme` is enabled. \"workbench.preferredLightColorTheme\": \"Default Light+\", // Specifies the product icon theme used. // - Default: Default \"workbench.productIconTheme\": \"Default\", // Controls whether Quick Open should close automatically once it loses focus. \"workbench.quickOpen.closeOnFocusLost\": true, // Controls whether the last typed input to Quick Open should be restored when opening it the next time. \"workbench.quickOpen.preserveInput\": false, // Controls the hover feedback delay in milliseconds of the dragging area in between views/editors. \"workbench.sash.hoverDelay\": 300, // Controls the feedback area size in pixels of the dragging area in between views/editors. Set it to a larger value if you feel it's hard to resize views using the mouse. \"workbench.sash.size\": 4, // Determines which settings editor to use by default. // - ui: Use the settings UI editor. // - json: Use the JSON file editor. \"workbench.settings.editor\": \"ui\", // Controls whether to enable the natural language search mode for settings. The natural language search is provided by a Microsoft online service. \"workbench.settings.enableNaturalLanguageSearch\": true, // Controls whether opening keybinding settings also opens an editor showing all default keybindings. \"workbench.settings.openDefaultKeybindings\": false, // Controls whether opening settings also opens an editor showing all default settings. \"workbench.settings.openDefaultSettings\": false, // Controls the behavior of the settings editor Table of Contents while searching. // - hide: Hide the Table of Contents while searching. // - filter: Filter the Table of Contents to just categories that have matching settings. Clicking a category will filter the results to that category. \"workbench.settings.settingsSearchTocBehavior\": \"filter\", // Controls whether to use the split JSON editor when editing settings as JSON. \"workbench.settings.useSplitJSON\": false, // Controls the location of the sidebar and activity bar. They can either show on the left or right of the workbench. \"workbench.sideBar.location\": \"left\", // Controls which editor is shown at startup, if none are restored from the previous session. // - none: Start without an editor. // - welcomePage: Open the Welcome page, with content to aid in getting started with VS Code and extensions. // - readme: Open the README when opening a folder that contains one, fallback to 'welcomePage' otherwise. Note: This is only observed as a global configuration, it will be ignored if set in a workspace or folder configuration. // - newUntitledFile: Open a new untitled file (only applies when opening an empty window). // - welcomePageInEmptyWorkbench: Open the Welcome page when opening an empty workbench. \"workbench.startupEditor\": \"welcomePage\", // Controls the visibility of the status bar at the bottom of the workbench. \"workbench.statusBar.visible\": true, // When enabled, will show the watermark tips when no editor is open. \"workbench.tips.enabled\": true, // Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable. \"workbench.tree.expandMode\": \"singleClick\", // Controls tree indentation in pixels. \"workbench.tree.indent\": 8, // Controls whether the tree should render indent guides. \"workbench.tree.renderIndentGuides\": \"onHover\", // When enabled, trusted domain prompts will appear when opening links in trusted workspaces. \"workbench.trustedDomains.promptInTrustedWorkspace\": false, // Controls the visibility of view header actions. View header actions may either be always visible, or only visible when that view is focused or hovered over. \"workbench.view.alwaysShowHeaderActions\": false, // When enabled, reduce motion in welcome page. \"workbench.welcomePage.preferReducedMotion\": false, // When enabled, an extension's walkthrough will open upon install the extension. \"workbench.welcomePage.walkthroughs.openOnInstall\": true, // Window // If set, automatically switch to the preferred color theme based on the OS appearance. If the OS appearance is dark, the theme specified at `workbench.preferredDarkColorTheme` is used, for light `workbench.preferredLightColorTheme`. \"window.autoDetectColorScheme\": false, // If enabled, will automatically change to high contrast theme if the OS is using a high contrast theme. The high contrast theme to use is specified by `workbench.preferredHighContrastColorTheme`. \"window.autoDetectHighContrast\": true, // If enabled, clicking on an inactive window will both activate the window and trigger the element under the mouse if it is clickable. If disabled, clicking anywhere on an inactive window will activate it only and a second click is required on the element. \"window.clickThroughInactive\": true, // Controls whether closing the last editor should also close the window. This setting only applies for windows that do not show folders. \"window.closeWhenEmpty\": false, // Controls whether the menu bar will be focused by pressing the Alt-key. This setting has no effect on toggling the menu bar with the Alt-key. \"window.customMenuBarAltFocus\": true, // Adjust the appearance of dialog windows. \"window.dialogStyle\": \"native\", // If enabled, double clicking the application icon in the title bar will close the window and the window cannot be dragged by the icon. This setting only has an effect when `window.titleBarStyle` is set to `custom`. \"window.doubleClickIconToClose\": false, // Controls if native full-screen should be used on macOS. Disable this option to prevent macOS from creating a new space when going full-screen. \"window.nativeFullScreen\": true, // Enables macOS Sierra window tabs. Note that changes require a full restart to apply and that native tabs will disable a custom title bar style if configured. \"window.nativeTabs\": false, // Controls whether the main menus can be opened via Alt-key shortcuts. Disabling mnemonics allows to bind these Alt-key shortcuts to editor commands instead. \"window.enableMenuBarMnemonics\": true, // Control the visibility of the menu bar. A setting of 'toggle' means that the menu bar is hidden and a single press of the Alt key will show it. A setting of 'compact' will move the menu into the sidebar. // - classic: Menu is displayed at the top of the window and only hidden in full screen mode. // - visible: Menu is always visible at the top of the window even in full screen mode. // - toggle: Menu is hidden but can be displayed at the top of the window via the Alt key. // - hidden: Menu is always hidden. // - compact: Menu is displayed as a compact button in the sidebar. This value is ignored when `window.titleBarStyle` is `native`. \"window.menuBarVisibility\": \"classic\", // Controls the dimensions of opening a new window when at least one window is already opened. Note that this setting does not have an impact on the first window that is opened. The first window will always restore the size and location as you left it before closing. // - default: Open new windows in the center of the screen. // - inherit: Open new windows with same dimension as last active one. // - offset: Open new windows with same dimension as last active one with an offset position. // - maximized: Open new windows maximized. // - fullscreen: Open new windows in full screen mode. \"window.newWindowDimensions\": \"default\", // Controls whether files should open in a new window. // Note that there can still be cases where this setting is ignored (e.g. when using the `--new-window` or `--reuse-window` command line option). // - on: Files will open in a new window. // - off: Files will open in the window with the files' folder open or the last active window. // - default: Files will open in a new window unless picked from within the application (e.g. via the File menu). \"window.openFilesInNewWindow\": \"off\", // Controls whether folders should open in a new window or replace the last active window. // Note that there can still be cases where this setting is ignored (e.g. when using the `--new-window` or `--reuse-window` command line option). // - on: Folders will open in a new window. // - off: Folders will replace the last active window. // - default: Folders will open in a new window unless a folder is picked from within the application (e.g. via the File menu). \"window.openFoldersInNewWindow\": \"default\", // Controls whether a new empty window should open when starting a second instance without arguments or if the last running instance should get focus. // Note that there can still be cases where this setting is ignored (e.g. when using the `--new-window` or `--reuse-window` command line option). // - on: Open a new empty window. // - off: Focus the last active running instance. \"window.openWithoutArgumentsInNewWindow\": \"on\", // Controls whether a window should restore to full screen mode if it was exited in full screen mode. \"window.restoreFullscreen\": false, // Controls how windows are being reopened after starting for the first time. This setting has no effect when the application is already running. // - preserve: Always reopen all windows. If a folder or workspace is opened (e.g. from the command line) it opens as a new window unless it was opened before. If files are opened they will open in one of the restored windows. // - all: Reopen all windows unless a folder, workspace or file is opened (e.g. from the command line). // - folders: Reopen all windows that had folders or workspaces opened unless a folder, workspace or file is opened (e.g. from the command line). // - one: Reopen the last active window unless a folder, workspace or file is opened (e.g. from the command line). // - none: Never reopen a window. Unless a folder or workspace is opened (e.g. from the command line), an empty window will appear. \"window.restoreWindows\": \"all\", // Controls the window title based on the active editor. Variables are substituted based on the context: // - `${activeEditorShort}`: the file name (e.g. myFile.txt). // - `${activeEditorMedium}`: the path of the file relative to the workspace folder (e.g. myFolder/myFileFolder/myFile.txt). // - `${activeEditorLong}`: the full path of the file (e.g. /Users/Development/myFolder/myFileFolder/myFile.txt). // - `${activeFolderShort}`: the name of the folder the file is contained in (e.g. myFileFolder). // - `${activeFolderMedium}`: the path of the folder the file is contained in, relative to the workspace folder (e.g. myFolder/myFileFolder). // - `${activeFolderLong}`: the full path of the folder the file is contained in (e.g. /Users/Development/myFolder/myFileFolder). // - `${folderName}`: name of the workspace folder the file is contained in (e.g. myFolder). // - `${folderPath}`: file path of the workspace folder the file is contained in (e.g. /Users/Development/myFolder). // - `${rootName}`: name of the opened workspace or folder (e.g. myFolder or myWorkspace). // - `${rootPath}`: file path of the opened workspace or folder (e.g. /Users/Development/myWorkspace). // - `${appName}`: e.g. VS Code. // - `${remoteName}`: e.g. SSH // - `${dirty}`: a dirty indicator if the active editor is dirty. // - `${separator}`: a conditional separator (\" - \") that only shows when surrounded by variables with values or static text. \"window.title\": \"${dirty}${activeEditorShort}${separator}${rootName}${separator}${appName}\", // Adjust the appearance of the window title bar. On Linux and Windows, this setting also affects the application and context menu appearances. Changes require a full restart to apply. \"window.titleBarStyle\": \"custom\", // Separator used by `window.title`. \"window.titleSeparator\": \" - \", // Adjust the zoom level of the window. The original size is 0 and each increment above (e.g. 1) or below (e.g. -1) represents zooming 20% larger or smaller. You can also enter decimals to adjust the zoom level with a finer granularity. \"window.zoomLevel\": 0, // Files // Configure file associations to languages (e.g. `\"*.extension\": \"html\"`). These have precedence over the default associations of the languages installed. \"files.associations\": {}, // When enabled, the editor will attempt to guess the character set encoding when opening files. This setting can also be configured per language. Note, this setting is not respected by text search. Only `files.encoding` is respected. \"files.autoGuessEncoding\": false, // Controls auto save of dirty editors. // - off: A dirty editor is never automatically saved. // - afterDelay: A dirty editor is automatically saved after the configured `files.autoSaveDelay`. // - onFocusChange: A dirty editor is automatically saved when the editor loses focus. // - onWindowChange: A dirty editor is automatically saved when the window loses focus. \"files.autoSave\": \"off\", // Controls the delay in ms after which a dirty editor is saved automatically. Only applies when `files.autoSave` is set to `afterDelay`. \"files.autoSaveDelay\": 1000, // The default language mode that is assigned to new files. If configured to `${activeEditorLanguage}`, will use the language mode of the currently active text editor if any. \"files.defaultLanguage\": \"\", // Moves files/folders to the OS trash (recycle bin on Windows) when deleting. Disabling this will delete files/folders permanently. \"files.enableTrash\": true, // The default character set encoding to use when reading and writing files. This setting can also be configured per language. \"files.encoding\": \"utf8\", // The default end of line character. // - \\n: LF // - \\r\\n: CRLF // - auto: Uses operating system specific end of line character. \"files.eol\": \"auto\", // Configure glob patterns for excluding files and folders. For example, the file Explorer decides which files and folders to show or hide based on this setting. Refer to the `search.exclude` setting to define search specific excludes. \"files.exclude\": { \"**/.git\": true, \"**/.svn\": true, \"**/.hg\": true, \"**/CVS\": true, \"**/.DS_Store\": true }, // Controls whether unsaved files are remembered between sessions, allowing the save prompt when exiting the editor to be skipped. // - off: Disable hot exit. A prompt will show when attempting to close a window with dirty files. // - onExit: Hot exit will be triggered when the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu). All windows without folders opened will be restored upon next launch. A list of previously opened windows with unsaved files can be accessed via `File > Open Recent > More...` // - onExitAndWindowClose: Hot exit will be triggered when the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu), and also for any window with a folder opened regardless of whether it's the last window. All windows without folders opened will be restored upon next launch. A list of previously opened windows with unsaved files can be accessed via `File > Open Recent > More...` \"files.hotExit\": \"onExit\", // When enabled, insert a final new line at the end of the file when saving it. \"files.insertFinalNewline\": false, // Controls the memory available to VS Code after restart when trying to open large files. Same effect as specifying `--max-memory=NEWSIZE` on the command line. \"files.maxMemoryForLargeFilesMB\": 4096, // Timeout in milliseconds after which file participants for create, rename, and delete are cancelled. Use `0` to disable participants. \"files.participants.timeout\": 60000, // Restore the undo stack when a file is reopened. \"files.restoreUndoStack\": true, // A save conflict can occur when a file is saved to disk that was changed by another program in the meantime. To prevent data loss, the user is asked to compare the changes in the editor with the version on disk. This setting should only be changed if you frequently encounter save conflict errors and may result in data loss if used without caution. // - askUser: Will refuse to save and ask for resolving the save conflict manually. // - overwriteFileOnDisk: Will resolve the save conflict by overwriting the file on disk with the changes in the editor. \"files.saveConflictResolution\": \"askUser\", // Enables the simple file dialog. The simple file dialog replaces the system file dialog when enabled. \"files.simpleDialog.enable\": false, // When enabled, will trim all new lines after the final new line at the end of the file when saving it. \"files.trimFinalNewlines\": false, // When enabled, will trim trailing whitespace when saving a file. \"files.trimTrailingWhitespace\": false, // Configure glob patterns of file paths to exclude from file watching. Patterns must match on absolute paths, i.e. prefix with `**/` or the full path to match properly and suffix with `/**` to match files within a path (for example `**/build/output/**` or `/Users/name/workspaces/project/build/output/**`). Changing this setting requires a restart. When you experience Code consuming lots of CPU time on startup, you can exclude large folders to reduce the initial load. \"files.watcherExclude\": { \"**/.git/objects/**\": true, \"**/.git/subtree-cache/**\": true, \"**/node_modules/*/**\": true, \"**/.hg/store/**\": true }, // Screencast Mode // Controls the font size (in pixels) of the screencast mode keyboard. \"screencastMode.fontSize\": 56, // Controls how long (in milliseconds) the keyboard overlay is shown in screencast mode. \"screencastMode.keyboardOverlayTimeout\": 800, // Controls the color in hex (#RGB, #RGBA, #RRGGBB or #RRGGBBAA) of the mouse indicator in screencast mode. \"screencastMode.mouseIndicatorColor\": \"#FF0000\", // Controls the size (in pixels) of the mouse indicator in screencast mode. \"screencastMode.mouseIndicatorSize\": 20, // Only show keyboard shortcuts in screencast mode. \"screencastMode.onlyKeyboardShortcuts\": false, // Controls the vertical offset of the screencast mode overlay from the bottom as a percentage of the workbench height. \"screencastMode.verticalOffset\": 20, // Zen Mode // Controls whether turning on Zen Mode also centers the layout. \"zenMode.centerLayout\": true, // Controls whether turning on Zen Mode also puts the workbench into full screen mode. \"zenMode.fullScreen\": true, // Controls whether turning on Zen Mode also hides the activity bar either at the left or right of the workbench. \"zenMode.hideActivityBar\": true, // Controls whether turning on Zen Mode also hides the editor line numbers. \"zenMode.hideLineNumbers\": true, // Controls whether turning on Zen Mode also hides the status bar at the bottom of the workbench. \"zenMode.hideStatusBar\": true, // Controls whether turning on Zen Mode also hides workbench tabs. \"zenMode.hideTabs\": true, // Controls whether a window should restore to zen mode if it was exited in zen mode. \"zenMode.restore\": true, // Controls whether notifications are shown while in zen mode. If true, only error notifications will pop out. \"zenMode.silentNotifications\": true, // File Explorer // Controls whether the explorer should automatically reveal and select files when opening them. // - true: Files will be revealed and selected. // - false: Files will not be revealed and selected. // - focusNoScroll: Files will not be scrolled into view, but will still be focused. \"explorer.autoReveal\": true, // Controls whether the explorer should render folders in a compact form. In such a form, single child folders will be compressed in a combined tree element. Useful for Java package structures, for example. \"explorer.compactFolders\": true, // Controls whether the explorer should ask for confirmation when deleting a file via the trash. \"explorer.confirmDelete\": true, // Controls whether the explorer should ask for confirmation to move files and folders via drag and drop. \"explorer.confirmDragAndDrop\": true, // The path separation character used when copying relative file paths. // - /: Use slash as path separation character. // - \\: Use backslash as path separation character. // - auto: Uses operating system specific path separation character. \"explorer.copyRelativePathSeparator\": \"auto\", // Controls whether file decorations should use badges. \"explorer.decorations.badges\": true, // Controls whether file decorations should use colors. \"explorer.decorations.colors\": true, // Controls whether the explorer should allow to move files and folders via drag and drop. This setting only effects drag and drop from inside the explorer. \"explorer.enableDragAndDrop\": true, // Controls what naming strategy to use when a giving a new name to a duplicated explorer item on paste. // - simple: Appends the word \"copy\" at the end of the duplicated name potentially followed by a number // - smart: Adds a number at the end of the duplicated name. If some number is already part of the name, tries to increase that number \"explorer.incrementalNaming\": \"simple\", // Controls the sorting order of editors in the Open Editors pane. // - editorOrder: Editors are ordered in the same order editor tabs are shown. // - alphabetical: Editors are ordered in alphabetical order inside each editor group. \"explorer.openEditors.sortOrder\": \"editorOrder\", // Number of editors shown in the Open Editors pane. Setting this to 0 hides the Open Editors pane. \"explorer.openEditors.visible\": 9, // Controls the property-based sorting of files and folders in the explorer. // - default: Files and folders are sorted by their names. Folders are displayed before files. // - mixed: Files and folders are sorted by their names. Files are interwoven with folders. // - filesFirst: Files and folders are sorted by their names. Files are displayed before folders. // - type: Files and folders are grouped by extension type then sorted by their names. Folders are displayed before files. // - modified: Files and folders are sorted by last modified date in descending order. Folders are displayed before files. \"explorer.sortOrder\": \"default\", // Controls the lexicographic sorting of file and folder names in the Explorer. // - default: Uppercase and lowercase names are mixed together. // - upper: Uppercase names are grouped together before lowercase names. // - lower: Lowercase names are grouped together before uppercase names. // - unicode: Names are sorted in unicode order. \"explorer.sortOrderLexicographicOptions\": \"default\", // Search // Controls the positioning of the actionbar on rows in the search view. // - auto: Position the actionbar to the right when the search view is narrow, and immediately after the content when the search view is wide. // - right: Always position the actionbar to the right. \"search.actionsPosition\": \"right\", // Controls whether the search results will be collapsed or expanded. // - auto: Files with less than 10 results are expanded. Others are collapsed. // - alwaysCollapse // - alwaysExpand \"search.collapseResults\": \"alwaysExpand\", // Configure glob patterns for excluding files and folders in fulltext searches and quick open. Inherits all glob patterns from the `files.exclude` setting. \"search.exclude\": { \"**/node_modules\": true, \"**/bower_components\": true, \"**/*.code-search\": true }, // Controls whether to follow symlinks while searching. \"search.followSymlinks\": true, // Controls whether the search view should read or modify the shared find clipboard on macOS. \"search.globalFindClipboard\": false, // Controls where new `Search: Find in Files` and `Find in Folder` operations occur: either in the sidebar's search view, or in a search editor // - view: Search in the search view, either in the panel or sidebar. // - reuseEditor: Search in an existing search editor if present, otherwise in a new search editor. // - newEditor: Search in a new search editor. \"search.mode\": \"view\", // Controls sorting order of editor history in quick open when filtering. // - default: History entries are sorted by relevance based on the filter value used. More relevant entries appear first. // - recency: History entries are sorted by recency. More recently opened entries appear first. \"search.quickOpen.history.filterSortOrder\": \"default\", // Whether to include results from recently opened files in the file results for Quick Open. \"search.quickOpen.includeHistory\": true, // Whether to include results from a global symbol search in the file results for Quick Open. \"search.quickOpen.includeSymbols\": false, // The default number of surrounding context lines to use when creating new Search Editors. If using `search.searchEditor.reusePriorSearchConfiguration`, this can be set to `null` (empty) to use the prior Search Editor's configuration. \"search.searchEditor.defaultNumberOfContextLines\": 1, // Configure effect of double clicking a result in a search editor. // - selectWord: Double clicking selects the word under the cursor. // - goToLocation: Double clicking opens the result in the active editor group. // - openLocationToSide: Double clicking opens the result in the editor group to the side, creating one if it does not yet exist. \"search.searchEditor.doubleClickBehaviour\": \"goToLocation\", // When enabled, new Search Editors will reuse the includes, excludes, and flags of the previously opened Search Editor. \"search.searchEditor.reusePriorSearchConfiguration\": false, // Search all files as you type. \"search.searchOnType\": true, // When `search.searchOnType` is enabled, controls the timeout in milliseconds between a character being typed and the search starting. Has no effect when `search.searchOnType` is disabled. \"search.searchOnTypeDebouncePeriod\": 300, // Update the search query to the editor's selected text when focusing the search view. This happens either on click or when triggering the `workbench.views.search.focus` command. \"search.seedOnFocus\": false, // Enable seeding search from the word nearest the cursor when the active editor has no selection. \"search.seedWithNearestWord\": false, // Controls whether to show line numbers for search results. \"search.showLineNumbers\": false, // Search case-insensitively if the pattern is all lowercase, otherwise, search case-sensitively. \"search.smartCase\": false, // Controls sorting order of search results. // - default: Results are sorted by folder and file names, in alphabetical order. // - fileNames: Results are sorted by file names ignoring folder order, in alphabetical order. // - type: Results are sorted by file extensions, in alphabetical order. // - modified: Results are sorted by file last modified date, in descending order. // - countDescending: Results are sorted by count per file, in descending order. // - countAscending: Results are sorted by count per file, in ascending order. \"search.sortOrder\": \"default\", // Controls whether to use global `.gitignore` and `.ignore` files when searching for files. \"search.useGlobalIgnoreFiles\": false, // Controls whether to use `.gitignore` and `.ignore` files when searching for files. \"search.useIgnoreFiles\": true, // Controls whether to open Replace Preview when selecting or replacing a match. \"search.useReplacePreview\": true, // HTTP // The proxy setting to use. If not set, will be inherited from the `http_proxy` and `https_proxy` environment variables. \"http.proxy\": \"\", // The value to send as the `Proxy-Authorization` header for every network request. \"http.proxyAuthorization\": null, // Controls whether the proxy server certificate should be verified against the list of supplied CAs. \"http.proxyStrictSSL\": true, // Use the proxy support for extensions. // - off: Disable proxy support for extensions. // - on: Enable proxy support for extensions. // - fallback: Enable proxy support for extensions, fall back to request options, when no proxy found. // - override: Enable proxy support for extensions, override request options. \"http.proxySupport\": \"override\", // Controls whether CA certificates should be loaded from the OS. (On Windows and macOS, a reload of the window is required after turning this off.) \"http.systemCertificates\": true, // Keyboard // Controls the dispatching logic for key presses to use either `code` (recommended) or `keyCode`. \"keyboard.dispatch\": \"code\", // Enables the macOS touchbar buttons on the keyboard if available. \"keyboard.touchbar.enabled\": true, // A set of identifiers for entries in the touchbar that should not show up (for example `workbench.action.navigateBack`). \"keyboard.touchbar.ignored\": [], // Update // Enable to download and install new VS Code versions in the background on Windows. \"update.enableWindowsBackgroundUpdates\": true, // Configure whether you receive automatic updates. Requires a restart after change. The updates are fetched from a Microsoft online service. // - none: Disable updates. // - manual: Disable automatic background update checks. Updates will be available if you manually check for updates. // - start: Check for updates only on startup. Disable automatic background update checks. // - default: Enable automatic update checks. Code will check for updates automatically and periodically. \"update.mode\": \"default\", // Show Release Notes after an update. The Release Notes are fetched from a Microsoft online service. \"update.showReleaseNotes\": true, // Debug // Controls when the comments panel should open. \"comments.openPanel\": \"openOnSessionStartWithComments\", // Allow setting breakpoints in any file. \"debug.allowBreakpointsEverywhere\": false, // Controls if the debug console should be automatically closed when the debug session ends. \"debug.console.closeOnEnd\": false, // Controls if the debug console should collapse identical lines and show a number of occurrences with a badge. \"debug.console.collapseIdenticalLines\": true, // Controls the font family in the debug console. \"debug.console.fontFamily\": \"default\", // Controls the font size in pixels in the debug console. \"debug.console.fontSize\": 14, // Controls if the debug console should suggest previously typed input. \"debug.console.historySuggestions\": true, // Controls the line height in pixels in the debug console. Use 0 to compute the line height from the font size. \"debug.console.lineHeight\": 0, // Controls if the lines should wrap in the debug console. \"debug.console.wordWrap\": true, // Controls whether the workbench window should be focused when the debugger breaks. \"debug.focusWindowOnBreak\": true, // Show variable values inline in editor while debugging. // - true: Always show variable values inline in editor while debugging. // - false: Never show variable values inline in editor while debugging. // - auto: Show variable values inline in editor while debugging when the language supports inline value locations. \"debug.inlineValues\": \"auto\", // Controls when the internal debug console should open. \"debug.internalConsoleOptions\": \"openOnFirstSessionStart\", // Controls what to do when errors are encountered after running a preLaunchTask. // - debugAnyway: Ignore task errors and start debugging. // - showErrors: Show the Problems view and do not start debugging. // - prompt: Prompt user. // - abort: Cancel debugging. \"debug.onTaskErrors\": \"prompt\", // Controls when the debug view should open. \"debug.openDebug\": \"openOnDebugBreak\", // Automatically open the explorer view at the end of a debug session. \"debug.openExplorerOnEnd\": false, // Controls what editors to save before starting a debug session. // - allEditorsInActiveGroup: Save all editors in the active group before starting a debug session. // - nonUntitledEditorsInActiveGroup: Save all editors in the active group except untitled ones before starting a debug session. // - none: Don't save any editors before starting a debug session. \"debug.saveBeforeStart\": \"allEditorsInActiveGroup\", // Controls whether breakpoints should be shown in the overview ruler. \"debug.showBreakpointsInOverviewRuler\": false, // Controls whether inline breakpoints candidate decorations should be shown in the editor while debugging. \"debug.showInlineBreakpointCandidates\": true, // Controls when the debug status bar should be visible. // - never: Never show debug in status bar // - always: Always show debug in status bar // - onFirstSessionStart: Show debug in status bar only after debug was started for the first time \"debug.showInStatusBar\": \"onFirstSessionStart\", // Controls whether the debug sub-sessions are shown in the debug tool bar. When this setting is false the stop command on a sub-session will also stop the parent session. \"debug.showSubSessionsInToolBar\": false, // Before starting a new debug session in an integrated or external terminal, clear the terminal. \"debug.terminal.clearBeforeReusing\": false, // Controls the location of the debug toolbar. Either `floating` in all views, `docked` in the debug view, or `hidden`. \"debug.toolBarLocation\": \"floating\", // Global debug launch configuration. Should be used as an alternative to 'launch.json' that is shared across workspaces. \"launch\": { \"configurations\": [], \"compounds\": [] }, // HTML // Enable/disable autoclosing of HTML tags. \"html.autoClosingTags\": true, // A list of relative file paths pointing to JSON files following the custom data format. // VS Code loads custom data on startup to enhance its HTML support for the custom HTML tags, attributes and attribute values you specify in the JSON files. // The file paths are relative to workspace and only workspace folder settings are considered. \"html.customData\": [], // List of tags, comma separated, where the content shouldn't be reformatted. `null` defaults to the `pre` tag. \"html.format.contentUnformatted\": \"pre,code,textarea\", // Enable/disable default HTML formatter. \"html.format.enable\": true, // End with a newline. \"html.format.endWithNewline\": false, // List of tags, comma separated, that should have an extra newline before them. `null` defaults to `\"head, body, /html\"`. \"html.format.extraLiners\": \"head, body, /html\", // Format and indent `{{#foo}}` and `{{/foo}}`. \"html.format.indentHandlebars\": false, // Indent `<head>` and `<body>` sections. \"html.format.indentInnerHtml\": false, // Maximum number of line breaks to be preserved in one chunk. Use `null` for unlimited. \"html.format.maxPreserveNewLines\": null, // Controls whether existing line breaks before elements should be preserved. Only works before elements, not inside tags or for text. \"html.format.preserveNewLines\": true, // Honor django, erb, handlebars and php templating language tags. \"html.format.templating\": false, // List of tags, comma separated, that shouldn't be reformatted. \"html.format.unformatted\": \"wbr\", // Keep text content together between this string. \"html.format.unformattedContentDelimiter\": \"\", // Wrap attributes. // - auto: Wrap attributes only when line length is exceeded. // - force: Wrap each attribute except first. // - force-aligned: Wrap each attribute except first and keep aligned. // - force-expand-multiline: Wrap each attribute. // - aligned-multiple: Wrap when line length is exceeded, align attributes vertically. // - preserve: Preserve wrapping of attributes. // - preserve-aligned: Preserve wrapping of attributes but align. \"html.format.wrapAttributes\": \"auto\", // Alignment size when using 'force aligned' and 'aligned multiple' in `html.format.wrapAttributes` or `null` to use the default indent size. \"html.format.wrapAttributesIndentSize\": null, // Maximum amount of characters per line (0 = disable). \"html.format.wrapLineLength\": 120, // Show tag and attribute documentation in hover. \"html.hover.documentation\": true, // Show references to MDN in hover. \"html.hover.references\": true, // Controls whether the built-in HTML language support suggests HTML5 tags, properties and values. \"html.suggest.html5\": true, // Traces the communication between VS Code and the HTML language server. \"html.trace.server\": \"off\", // Controls whether the built-in HTML language support validates embedded scripts. \"html.validate.scripts\": true, // Controls whether the built-in HTML language support validates embedded styles. \"html.validate.styles\": true, // JSON // Enable/disable default JSON formatter \"json.format.enable\": true, // The maximum number of outline symbols and folding regions computed (limited for performance reasons). \"json.maxItemsComputed\": 5000, // When enabled, JSON schemas can be fetched from http and https locations. \"json.schemaDownload.enable\": true, // Associate schemas to JSON files in the current project. \"json.schemas\": [], // Traces the communication between VS Code and the JSON language server. \"json.trace.server\": \"off\", // Markdown // Controls where links in Markdown files should be opened. // - currentGroup: Open links in the active editor group. // - beside: Open links beside the active editor. \"markdown.links.openLocation\": \"currentGroup\", // Enable/disable rendering math in the built-in Markdown preview. \"markdown.math.enabled\": true, // Sets how line-breaks are rendered in the Markdown preview. Setting it to 'true' creates a <br> for newlines inside paragraphs. \"markdown.preview.breaks\": false, // Double click in the Markdown preview to switch to the editor. \"markdown.preview.doubleClickToSwitchToEditor\": true, // Controls the font family used in the Markdown preview. \"markdown.preview.fontFamily\": \"-apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif\", // Controls the font size in pixels used in the Markdown preview. \"markdown.preview.fontSize\": 14, // Controls the line height used in the Markdown preview. This number is relative to the font size. \"markdown.preview.lineHeight\": 1.6, // Enable or disable conversion of URL-like text to links in the Markdown preview. \"markdown.preview.linkify\": true, // Mark the current editor selection in the Markdown preview. \"markdown.preview.markEditorSelection\": true, // Controls how links to other Markdown files in the Markdown preview should be opened. // - inPreview: Try to open links in the Markdown preview. // - inEditor: Try to open links in the editor. \"markdown.preview.openMarkdownLinks\": \"inPreview\", // When a Markdown preview is scrolled, update the view of the editor. \"markdown.preview.scrollEditorWithPreview\": true, // When a Markdown editor is scrolled, update the view of the preview. \"markdown.preview.scrollPreviewWithEditor\": true, // Enable or disable some language-neutral replacement and quotes beautification in the Markdown preview. \"markdown.preview.typographer\": false, // A list of URLs or local paths to CSS style sheets to use from the Markdown preview. Relative paths are interpreted relative to the folder open in the Explorer. If there is no open folder, they are interpreted relative to the location of the Markdown file. All '\\' need to be written as '\\\\'. \"markdown.styles\": [], // Enable debug logging for the Markdown extension. \"markdown.trace\": \"off\", // PHP // Controls whether the built-in PHP language suggestions are enabled. The support suggests PHP globals and variables. \"php.suggest.basic\": true, // Enable/disable built-in PHP validation. \"php.validate.enable\": true, // Points to the PHP executable. \"php.validate.executablePath\": null, // Whether the linter is run on save or on type. \"php.validate.run\": \"onSave\", // TypeScript // Enable/disable automatic closing of JSX tags. \"javascript.autoClosingTags\": true, // Enable/disable default JavaScript formatter. \"javascript.format.enable\": true, // Defines space handling after a comma delimiter. \"javascript.format.insertSpaceAfterCommaDelimiter\": true, // Defines space handling after the constructor keyword. \"javascript.format.insertSpaceAfterConstructor\": false, // Defines space handling after function keyword for anonymous functions. \"javascript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions\": true, // Defines space handling after keywords in a control flow statement. \"javascript.format.insertSpaceAfterKeywordsInControlFlowStatements\": true, // Defines space handling after opening and before closing empty braces. \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces\": true, // Defines space handling after opening and before closing JSX expression braces. \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces\": false, // Defines space handling after opening and before closing non-empty braces. \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces\": true, // Defines space handling after opening and before closing non-empty brackets. \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets\": false, // Defines space handling after opening and before closing non-empty parenthesis. \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis\": false, // Defines space handling after opening and before closing template string braces. \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces\": false, // Defines space handling after a semicolon in a for statement. \"javascript.format.insertSpaceAfterSemicolonInForStatements\": true, // Defines space handling after a binary operator. \"javascript.format.insertSpaceBeforeAndAfterBinaryOperators\": true, // Defines space handling before function argument parentheses. \"javascript.format.insertSpaceBeforeFunctionParenthesis\": false, // Defines whether an open brace is put onto a new line for control blocks or not. \"javascript.format.placeOpenBraceOnNewLineForControlBlocks\": false, // Defines whether an open brace is put onto a new line for functions or not. \"javascript.format.placeOpenBraceOnNewLineForFunctions\": false, // Defines handling of optional semicolons. Requires using TypeScript 3.7 or newer in the workspace. // - ignore: Don't insert or remove any semicolons. // - insert: Insert semicolons at statement ends. // - remove: Remove unnecessary semicolons. \"javascript.format.semicolons\": \"ignore\", // Preferred path style for auto imports. // - shortest: Prefers a non-relative import only if one is available that has fewer path segments than a relative import. // - relative: Prefers a relative path to the imported file location. // - non-relative: Prefers a non-relative import based on the `baseUrl` or `paths` configured in your `jsconfig.json` / `tsconfig.json`. // - project-relative: Prefers a non-relative import only if the relative import path would leave the package or project directory. Requires using TypeScript 4.2+ in the workspace. \"javascript.preferences.importModuleSpecifier\": \"shortest\", // Preferred path ending for auto imports. // - auto: Use project settings to select a default. // - minimal: Shorten `./component/index.js` to `./component`. // - index: Shorten `./component/index.js` to `./component/index`. // - js: Do not shorten path endings; include the `.js` extension. \"javascript.preferences.importModuleSpecifierEnding\": \"auto\", // Preferred quote style to use for quick fixes: `single` quotes, `double` quotes, or `auto` infer quote type from existing imports. \"javascript.preferences.quoteStyle\": \"auto\", // The setting 'typescript.preferences.renameShorthandProperties' has been deprecated in favor of 'typescript.preferences.useAliasesForRenames' // Enable/disable introducing aliases for object shorthand properties during renames. Requires using TypeScript 3.4 or newer in the workspace. \"javascript.preferences.renameShorthandProperties\": true, // Enable/disable introducing aliases for object shorthand properties during renames. Requires using TypeScript 3.4 or newer in the workspace. \"javascript.preferences.useAliasesForRenames\": true, // Enable/disable references CodeLens in JavaScript files. \"javascript.referencesCodeLens.enabled\": false, // Enable/disable references CodeLens on all functions in JavaScript files. \"javascript.referencesCodeLens.showOnAllFunctions\": false, // Enable/disable auto import suggestions. \"javascript.suggest.autoImports\": true, // Complete functions with their parameter signature. \"javascript.suggest.completeFunctionCalls\": false, // Enable/disable suggestion to complete JSDoc comments. \"javascript.suggest.completeJSDocs\": true, // Enabled/disable autocomplete suggestions. \"javascript.suggest.enabled\": true, // Enable/disable showing completions on potentially undefined values that insert an optional chain call. Requires TS 3.7+ and strict null checks to be enabled. \"javascript.suggest.includeAutomaticOptionalChainCompletions\": true, // Enable/disable auto-import-style completions on partially-typed import statements. Requires using TypeScript 4.3+ in the workspace. \"javascript.suggest.includeCompletionsForImportStatements\": true, // Enable/disable generating `@return` annotations for JSDoc templates. Requires using TypeScript 4.2+ in the workspace. \"javascript.suggest.jsdoc.generateReturns\": true, // Enable/disable including unique names from the file in JavaScript suggestions. Note that name suggestions are always disabled in JavaScript code that is semantically checked using `@ts-check` or `checkJs`. \"javascript.suggest.names\": true, // Enable/disable suggestions for paths in import statements and require calls. \"javascript.suggest.paths\": true, // Enable/disable suggestion diagnostics for JavaScript files in the editor. \"javascript.suggestionActions.enabled\": true, // Enable/disable automatic updating of import paths when you rename or move a file in VS Code. // - prompt: Prompt on each rename. // - always: Always update paths automatically. // - never: Never rename paths and don't prompt. \"javascript.updateImportsOnFileMove.enabled\": \"prompt\", // Enable/disable JavaScript validation. \"javascript.validate.enable\": true, // Enable/disable semantic checking of JavaScript files. Existing `jsconfig.json` or `tsconfig.json` files override this setting. \"js/ts.implicitProjectConfig.checkJs\": false, // Enable/disable strict function types in JavaScript and TypeScript files that are not part of a project. Existing `jsconfig.json` or `tsconfig.json` files override this setting. \"js/ts.implicitProjectConfig.strictFunctionTypes\": true, // Enable/disable strict null checks in JavaScript and TypeScript files that are not part of a project. Existing `jsconfig.json` or `tsconfig.json` files override this setting. \"js/ts.implicitProjectConfig.strictNullChecks\": false, // Enable/disable automatic closing of JSX tags. \"typescript.autoClosingTags\": true, // Check if npm is installed for Automatic Type Acquisition. \"typescript.check.npmIsInstalled\": true, // Disables automatic type acquisition. Automatic type acquisition fetches `@types` packages from npm to improve IntelliSense for external libraries. \"typescript.disableAutomaticTypeAcquisition\": false, // Enables prompting of users to use the TypeScript version configured in the workspace for Intellisense. \"typescript.enablePromptUseWorkspaceTsdk\": false, // Enable/disable default TypeScript formatter. \"typescript.format.enable\": true, // Defines space handling after a comma delimiter. \"typescript.format.insertSpaceAfterCommaDelimiter\": true, // Defines space handling after the constructor keyword. \"typescript.format.insertSpaceAfterConstructor\": false, // Defines space handling after function keyword for anonymous functions. \"typescript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions\": true, // Defines space handling after keywords in a control flow statement. \"typescript.format.insertSpaceAfterKeywordsInControlFlowStatements\": true, // Defines space handling after opening and before closing empty braces. \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingEmptyBraces\": true, // Defines space handling after opening and before closing JSX expression braces. \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces\": false, // Defines space handling after opening and before closing non-empty braces. \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces\": true, // Defines space handling after opening and before closing non-empty brackets. \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets\": false, // Defines space handling after opening and before closing non-empty parenthesis. \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis\": false, // Defines space handling after opening and before closing template string braces. \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces\": false, // Defines space handling after a semicolon in a for statement. \"typescript.format.insertSpaceAfterSemicolonInForStatements\": true, // Defines space handling after type assertions in TypeScript. \"typescript.format.insertSpaceAfterTypeAssertion\": false, // Defines space handling after a binary operator. \"typescript.format.insertSpaceBeforeAndAfterBinaryOperators\": true, // Defines space handling before function argument parentheses. \"typescript.format.insertSpaceBeforeFunctionParenthesis\": false, // Defines whether an open brace is put onto a new line for control blocks or not. \"typescript.format.placeOpenBraceOnNewLineForControlBlocks\": false, // Defines whether an open brace is put onto a new line for functions or not. \"typescript.format.placeOpenBraceOnNewLineForFunctions\": false, // Defines handling of optional semicolons. Requires using TypeScript 3.7 or newer in the workspace. // - ignore: Don't insert or remove any semicolons. // - insert: Insert semicolons at statement ends. // - remove: Remove unnecessary semicolons. \"typescript.format.semicolons\": \"ignore\", // Enable/disable implementations CodeLens. This CodeLens shows the implementers of an interface. \"typescript.implementationsCodeLens.enabled\": false, // Sets the locale used to report JavaScript and TypeScript errors. Default of `null` uses VS Code's locale. \"typescript.locale\": null, // Specifies the path to the npm executable used for Automatic Type Acquisition. \"typescript.npm\": null, // Preferred path style for auto imports. // - shortest: Prefers a non-relative import only if one is available that has fewer path segments than a relative import. // - relative: Prefers a relative path to the imported file location. // - non-relative: Prefers a non-relative import based on the `baseUrl` or `paths` configured in your `jsconfig.json` / `tsconfig.json`. // - project-relative: Prefers a non-relative import only if the relative import path would leave the package or project directory. Requires using TypeScript 4.2+ in the workspace. \"typescript.preferences.importModuleSpecifier\": \"shortest\", // Preferred path ending for auto imports. // - auto: Use project settings to select a default. // - minimal: Shorten `./component/index.js` to `./component`. // - index: Shorten `./component/index.js` to `./component/index`. // - js: Do not shorten path endings; include the `.js` extension. \"typescript.preferences.importModuleSpecifierEnding\": \"auto\", // Enable/disable searching `package.json` dependencies for available auto imports. // - auto: Search dependencies based on estimated performance impact. // - on: Always search dependencies. // - off: Never search dependencies. \"typescript.preferences.includePackageJsonAutoImports\": \"auto\", // Preferred quote style to use for quick fixes: `single` quotes, `double` quotes, or `auto` infer quote type from existing imports. \"typescript.preferences.quoteStyle\": \"auto\", // Enable/disable introducing aliases for object shorthand properties during renames. Requires using TypeScript 3.4 or newer in the workspace. \"typescript.preferences.useAliasesForRenames\": true, // Enable/disable references CodeLens in TypeScript files. \"typescript.referencesCodeLens.enabled\": false, // Enable/disable references CodeLens on all functions in TypeScript files. \"typescript.referencesCodeLens.showOnAllFunctions\": false, // Report style checks as warnings. \"typescript.reportStyleChecksAsWarnings\": true, // Enable/disable auto import suggestions. \"typescript.suggest.autoImports\": true, // Complete functions with their parameter signature. \"typescript.suggest.completeFunctionCalls\": false, // Enable/disable suggestion to complete JSDoc comments. \"typescript.suggest.completeJSDocs\": true, // Enabled/disable autocomplete suggestions. \"typescript.suggest.enabled\": true, // Enable/disable showing completions on potentially undefined values that insert an optional chain call. Requires TS 3.7+ and strict null checks to be enabled. \"typescript.suggest.includeAutomaticOptionalChainCompletions\": true, // Enable/disable auto-import-style completions on partially-typed import statements. Requires using TypeScript 4.3+ in the workspace. \"typescript.suggest.includeCompletionsForImportStatements\": true, // Enable/disable snippet completions from TS Server. Requires using TypeScript 4.3+ in the workspace. \"typescript.suggest.includeCompletionsWithSnippetText\": true, // Enable/disable generating `@return` annotations for JSDoc templates. Requires using TypeScript 4.2+ in the workspace. \"typescript.suggest.jsdoc.generateReturns\": true, // Enable/disable suggestions for paths in import statements and require calls. \"typescript.suggest.paths\": true, // Enable/disable suggestion diagnostics for TypeScript files in the editor. \"typescript.suggestionActions.enabled\": true, // Controls auto detection of tsc tasks. // - on: Create both build and watch tasks. // - off: Disable this feature. // - build: Only create single run compile tasks. // - watch: Only create compile and watch tasks. \"typescript.tsc.autoDetect\": \"on\", // Specifies the folder path to the tsserver and `lib*.d.ts` files under a TypeScript install to use for IntelliSense, for example: `./node_modules/typescript/lib`. // - When specified as a user setting, the TypeScript version from `typescript.tsdk` automatically replaces the built-in TypeScript version. // - When specified as a workspace setting, `typescript.tsdk` allows you to switch to use that workspace version of TypeScript for IntelliSense with the `TypeScript: Select TypeScript version` command. \"typescript.tsdk\": null, // Enables tracing TS server performance to a directory. These trace files can be used to diagnose TS Server performance issues. The log may contain file paths, source code, and other potentially sensitive information from your project. \"typescript.tsserver.enableTracing\": false, // Enables logging of the TS server to a file. This log can be used to diagnose TS Server issues. The log may contain file paths, source code, and other potentially sensitive information from your project. \"typescript.tsserver.log\": \"off\", // The maximum amount of memory (in MB) to allocate to the TypeScript server process. \"typescript.tsserver.maxTsServerMemory\": 3072, // Additional paths to discover TypeScript Language Service plugins. \"typescript.tsserver.pluginPaths\": [], // Enables tracing of messages sent to the TS server. This trace can be used to diagnose TS Server issues. The trace may contain file paths, source code, and other potentially sensitive information from your project. \"typescript.tsserver.trace\": \"off\", // Enable/disable spawning a separate TypeScript server that can more quickly respond to syntax related operations, such as calculating folding or computing document symbols. Requires using TypeScript 3.4.0 or newer in the workspace. \"typescript.tsserver.useSeparateSyntaxServer\": true, // Configure which watching strategies should be used to keep track of files and directories. Requires using TypeScript 3.8+ in the workspace. \"typescript.tsserver.watchOptions\": {}, // Enable/disable automatic updating of import paths when you rename or move a file in VS Code. // - prompt: Prompt on each rename. // - always: Always update paths automatically. // - never: Never rename paths and don't prompt. \"typescript.updateImportsOnFileMove.enabled\": \"prompt\", // Enable/disable TypeScript validation. \"typescript.validate.enable\": true, // Controls which files are searched by go to symbol in workspace. // - allOpenProjects: Search all open JavaScript or TypeScript projects for symbols. Requires using TypeScript 3.9 or newer in the workspace. // - currentProject: Only search for symbols in the current JavaScript or TypeScript project. \"typescript.workspaceSymbols.scope\": \"allOpenProjects\", // Testing // Configures when the error Peek view is automatically opened. // - failureAnywhere: Open automatically no matter where the failure is. // - failureInVisibleDocument: Open automatically when a test fails in a visible document. \"testing.automaticallyOpenPeekView\": \"failureInVisibleDocument\", // Controls whether to automatically open the Peek view during auto-run mode. \"testing.automaticallyOpenPeekViewDuringAutoRun\": false, // How long to wait, in milliseconds, after a test is marked as outdated and starting a new run. \"testing.autoRun.delay\": 1000, // Controls which tests are automatically run. // - all: Automatically runs all discovered test when auto-run is toggled. Reruns individual tests when they are changed. // - rerun: Reruns individual tests when they are changed. Will not automatically run any tests that have not been already executed. \"testing.autoRun.mode\": \"all\", // Controls the action to take when left-clicking on a test decoration in the gutter. // - run: Run the test. // - debug: Debug the test. // - contextMenu: Open the context menu for more options. \"testing.defaultGutterClickAction\": \"run\", // Controls whether the running test should be followed in the Test Explorer view. \"testing.followRunningTest\": true, // CSS // Insert semicolon at end of line when completing CSS properties. \"css.completion.completePropertyWithSemicolon\": true, // By default, VS Code triggers property value completion after selecting a CSS property. Use this setting to disable this behavior. \"css.completion.triggerPropertyValueCompletion\": true, // A list of relative file paths pointing to JSON files following the custom data format. // VS Code loads custom data on startup to enhance its CSS support for the custom CSS properties, at directives, pseudo classes and pseudo elements you specify in the JSON files. // The file paths are relative to workspace and only workspace folder settings are considered. \"css.customData\": [], // Show tag and attribute documentation in CSS hovers. \"css.hover.documentation\": true, // Show references to MDN in CSS hovers. \"css.hover.references\": true, // Invalid number of parameters. \"css.lint.argumentsInColorFunction\": \"error\", // Do not use `width` or `height` when using `padding` or `border`. \"css.lint.boxModel\": \"ignore\", // When using a vendor-specific prefix make sure to also include all other vendor-specific properties. \"css.lint.compatibleVendorPrefixes\": \"ignore\", // Do not use duplicate style definitions. \"css.lint.duplicateProperties\": \"ignore\", // Do not use empty rulesets. \"css.lint.emptyRules\": \"warning\", // Avoid using `float`. Floats lead to fragile CSS that is easy to break if one aspect of the layout changes. \"css.lint.float\": \"ignore\", // `@font-face` rule must define `src` and `font-family` properties. \"css.lint.fontFaceProperties\": \"warning\", // Hex colors must consist of three or six hex numbers. \"css.lint.hexColorLength\": \"error\", // Selectors should not contain IDs because these rules are too tightly coupled with the HTML. \"css.lint.idSelector\": \"ignore\", // IE hacks are only necessary when supporting IE7 and older. \"css.lint.ieHack\": \"ignore\", // Avoid using `!important`. It is an indication that the specificity of the entire CSS has gotten out of control and needs to be refactored. \"css.lint.important\": \"ignore\", // Import statements do not load in parallel. \"css.lint.importStatement\": \"ignore\", // Property is ignored due to the display. E.g. with `display: inline`, the `width`, `height`, `margin-top`, `margin-bottom`, and `float` properties have no effect. \"css.lint.propertyIgnoredDueToDisplay\": \"warning\", // The universal selector (`*`) is known to be slow. \"css.lint.universalSelector\": \"ignore\", // Unknown at-rule. \"css.lint.unknownAtRules\": \"warning\", // Unknown property. \"css.lint.unknownProperties\": \"warning\", // Unknown vendor specific property. \"css.lint.unknownVendorSpecificProperties\": \"ignore\", // A list of properties that are not validated against the `unknownProperties` rule. \"css.lint.validProperties\": [], // When using a vendor-specific prefix, also include the standard property. \"css.lint.vendorPrefix\": \"warning\", // No unit for zero needed. \"css.lint.zeroUnits\": \"ignore\", // Traces the communication between VS Code and the CSS language server. \"css.trace.server\": \"off\", // Enables or disables all validations. \"css.validate\": true, // LESS // Insert semicolon at end of line when completing CSS properties. \"less.completion.completePropertyWithSemicolon\": true, // By default, VS Code triggers property value completion after selecting a CSS property. Use this setting to disable this behavior. \"less.completion.triggerPropertyValueCompletion\": true, // Show tag and attribute documentation in LESS hovers. \"less.hover.documentation\": true, // Show references to MDN in LESS hovers. \"less.hover.references\": true, // Invalid number of parameters. \"less.lint.argumentsInColorFunction\": \"error\", // Do not use `width` or `height` when using `padding` or `border`. \"less.lint.boxModel\": \"ignore\", // When using a vendor-specific prefix make sure to also include all other vendor-specific properties. \"less.lint.compatibleVendorPrefixes\": \"ignore\", // Do not use duplicate style definitions. \"less.lint.duplicateProperties\": \"ignore\", // Do not use empty rulesets. \"less.lint.emptyRules\": \"warning\", // Avoid using `float`. Floats lead to fragile CSS that is easy to break if one aspect of the layout changes. \"less.lint.float\": \"ignore\", // `@font-face` rule must define `src` and `font-family` properties. \"less.lint.fontFaceProperties\": \"warning\", // Hex colors must consist of three or six hex numbers. \"less.lint.hexColorLength\": \"error\", // Selectors should not contain IDs because these rules are too tightly coupled with the HTML. \"less.lint.idSelector\": \"ignore\", // IE hacks are only necessary when supporting IE7 and older. \"less.lint.ieHack\": \"ignore\", // Avoid using `!important`. It is an indication that the specificity of the entire CSS has gotten out of control and needs to be refactored. \"less.lint.important\": \"ignore\", // Import statements do not load in parallel. \"less.lint.importStatement\": \"ignore\", // Property is ignored due to the display. E.g. with `display: inline`, the `width`, `height`, `margin-top`, `margin-bottom`, and `float` properties have no effect. \"less.lint.propertyIgnoredDueToDisplay\": \"warning\", // The universal selector (`*`) is known to be slow. \"less.lint.universalSelector\": \"ignore\", // Unknown at-rule. \"less.lint.unknownAtRules\": \"warning\", // Unknown property. \"less.lint.unknownProperties\": \"warning\", // Unknown vendor specific property. \"less.lint.unknownVendorSpecificProperties\": \"ignore\", // A list of properties that are not validated against the `unknownProperties` rule. \"less.lint.validProperties\": [], // When using a vendor-specific prefix, also include the standard property. \"less.lint.vendorPrefix\": \"warning\", // No unit for zero needed. \"less.lint.zeroUnits\": \"ignore\", // Enables or disables all validations. \"less.validate\": true, // SCSS (Sass) // Insert semicolon at end of line when completing CSS properties. \"scss.completion.completePropertyWithSemicolon\": true, // By default, VS Code triggers property value completion after selecting a CSS property. Use this setting to disable this behavior. \"scss.completion.triggerPropertyValueCompletion\": true, // Show tag and attribute documentation in SCSS hovers. \"scss.hover.documentation\": true, // Show references to MDN in SCSS hovers. \"scss.hover.references\": true, // Invalid number of parameters. \"scss.lint.argumentsInColorFunction\": \"error\", // Do not use `width` or `height` when using `padding` or `border`. \"scss.lint.boxModel\": \"ignore\", // When using a vendor-specific prefix make sure to also include all other vendor-specific properties. \"scss.lint.compatibleVendorPrefixes\": \"ignore\", // Do not use duplicate style definitions. \"scss.lint.duplicateProperties\": \"ignore\", // Do not use empty rulesets. \"scss.lint.emptyRules\": \"warning\", // Avoid using `float`. Floats lead to fragile CSS that is easy to break if one aspect of the layout changes. \"scss.lint.float\": \"ignore\", // `@font-face` rule must define `src` and `font-family` properties. \"scss.lint.fontFaceProperties\": \"warning\", // Hex colors must consist of three or six hex numbers. \"scss.lint.hexColorLength\": \"error\", // Selectors should not contain IDs because these rules are too tightly coupled with the HTML. \"scss.lint.idSelector\": \"ignore\", // IE hacks are only necessary when supporting IE7 and older. \"scss.lint.ieHack\": \"ignore\", // Avoid using `!important`. It is an indication that the specificity of the entire CSS has gotten out of control and needs to be refactored. \"scss.lint.important\": \"ignore\", // Import statements do not load in parallel. \"scss.lint.importStatement\": \"ignore\", // Property is ignored due to the display. E.g. with `display: inline`, the `width`, `height`, `margin-top`, `margin-bottom`, and `float` properties have no effect. \"scss.lint.propertyIgnoredDueToDisplay\": \"warning\", // The universal selector (`*`) is known to be slow. \"scss.lint.universalSelector\": \"ignore\", // Unknown at-rule. \"scss.lint.unknownAtRules\": \"warning\", // Unknown property. \"scss.lint.unknownProperties\": \"warning\", // Unknown vendor specific property. \"scss.lint.unknownVendorSpecificProperties\": \"ignore\", // A list of properties that are not validated against the `unknownProperties` rule. \"scss.lint.validProperties\": [], // When using a vendor-specific prefix, also include the standard property. \"scss.lint.vendorPrefix\": \"warning\", // No unit for zero needed. \"scss.lint.zeroUnits\": \"ignore\", // Enables or disables all validations. \"scss.validate\": true, // Extensions // When enabled, automatically checks extensions for updates. If an extension has an update, it is marked as outdated in the Extensions view. The updates are fetched from a Microsoft online service. \"extensions.autoCheckUpdates\": true, // Controls the automatic update behavior of extensions. The updates are fetched from a Microsoft online service. // - true: Download and install updates automatically for all extensions. // - onlyEnabledExtensions: Download and install updates automatically only for enabled extensions. Disabled extensions will not be updated automatically. // - false: Extensions are not automatically updated. \"extensions.autoUpdate\": true, // When enabled, editors with extension details will be automatically closed upon navigating away from the Extensions View. \"extensions.closeExtensionDetailsOnViewChange\": false, // When an extension is listed here, a confirmation prompt will not be shown when that extension handles a URI. \"extensions.confirmedUriHandlerExtensionIds\": [], // When enabled, the notifications for extension recommendations will not be shown. \"extensions.ignoreRecommendations\": false, // Override the untrusted workspace support of an extension. Extensions using `true` will always be enabled. Extensions using `limited` will always be enabled, and the extension will hide functionality that requires trust. Extensions using `false` will only be enabled only when the workspace is trusted. \"extensions.supportUntrustedWorkspaces\": {}, // Override the virtual workspaces support of an extension. \"extensions.supportVirtualWorkspaces\": { \"pub.name\": false }, // Output // Enable/disable the ability of smart scrolling in the output view. Smart scrolling allows you to lock scrolling automatically when you click in the output view and unlocks when you click in the last line. \"output.smartScroll.enabled\": true, // Settings Sync // List of extensions to be ignored while synchronizing. The identifier of an extension is always `${publisher}.${name}`. For example: `vscode.csharp`. \"settingsSync.ignoredExtensions\": [], // Configure settings to be ignored while synchronizing. \"settingsSync.ignoredSettings\": [], // Synchronize keybindings for each platform. \"settingsSync.keybindingsPerPlatform\": true, // Notebooks // When enabled notebook breadcrumbs contain code cells. \"notebook.breadcrumbs.showCodeCells\": true, // Control whether to render the focus indicator as a cell border or a highlight bar on the left gutter \"notebook.cellFocusIndicator\": \"gutter\", // Where the cell toolbar should be shown, or whether it should be hidden. \"notebook.cellToolbarLocation\": { \"default\": \"right\" }, // Whether the cell toolbar should appear on hover or click. \"notebook.cellToolbarVisibility\": \"click\", // Control whether the notebook editor should be rendered in a compact form. \"notebook.compactView\": true, // Control whether outputs action should be rendered in the output toolbar. \"notebook.consolidatedOutputButton\": true, // Control whether extra actions are shown in a dropdown next to the run button. \"notebook.consolidatedRunButton\": false, // Whether to use the enhanced text diff editor for notebook. \"notebook.diff.enablePreview\": true, // Hide Metadata Differences \"notebook.diff.ignoreMetadata\": false, // Hide Outputs Differences \"notebook.diff.ignoreOutputs\": false, // Priority list for output mime types \"notebook.displayOrder\": [], // Control whether the notebook editor should allow moving cells through drag and drop. \"notebook.dragAndDropEnabled\": true, // Settings for code editors used in notebooks. This can be used to customize most editor.* settings. \"notebook.editorOptionsCustomizations\": {}, // Enable/disable using the new extensible Markdown renderer. \"notebook.experimental.useMarkdownRenderer\": true, // Control whether to render a global toolbar inside the notebook editor. \"notebook.globalToolbar\": true, // Control whether the actions on the notebook toolbar should render label or not. \"notebook.globalToolbarShowLabel\": true, // Control where the insert cell actions should appear. // - betweenCells: A toolbar that appears on hover between cells. // - notebookToolbar: The toolbar at the top of the notebook editor. // - both: Both toolbars. // - hidden: The insert actions don't appear anywhere. \"notebook.insertToolbarLocation\": \"both\", // Controls the display of line numbers in the cell editor. \"notebook.lineNumbers\": \"off\", // When enabled cursor can navigate to the next/previous cell when the current cursor in the cell editor is at the first/last line. \"notebook.navigation.allowNavigateToSurroundingCells\": true, // When enabled notebook outline shows code cells. \"notebook.outline.showCodeCells\": false, // Control how many lines of text in a text output is rendered. \"notebook.output.textLineLimit\": 30, // Whether the cell status bar should be shown. // - hidden: The cell Status bar is always hidden. // - visible: The cell Status bar is always visible. // - visibleAfterExecute: The cell Status bar is hidden until the cell has executed. Then it becomes visible to show the execution status. \"notebook.showCellStatusBar\": \"visible\", // Controls when the Markdown header folding arrow is shown. // - always: The folding controls are always visible. // - mouseover: The folding controls are visible only on mouseover. \"notebook.showFoldingControls\": \"mouseover\", // Whether to use separate undo/redo stack for each cell. \"notebook.undoRedoPerCell\": true, // Terminal // Customizes what kind of terminal to launch. // - integrated: Use VS Code's integrated terminal. // - external: Use the configured external terminal. \"terminal.explorerKind\": \"integrated\", // External Terminal // Customizes which terminal to run on Linux. \"terminal.external.linuxExec\": \"xterm\", // Customizes which terminal application to run on macOS. \"terminal.external.osxExec\": \"Terminal.app\", // Customizes which terminal to run on Windows. \"terminal.external.windowsExec\": \"C:\\\\Windows\\\\System32\\\\cmd.exe\", // Integrated Terminal // Whether or not to allow chord keybindings in the terminal. Note that when this is true and the keystroke results in a chord it will bypass `terminal.integrated.commandsToSkipShell`, setting this to false is particularly useful when you want ctrl+k to go to your shell (not VS Code). \"terminal.integrated.allowChords\": true, // Whether to allow menubar mnemonics (eg. alt+f) to trigger the open the menubar. Note that this will cause all alt keystrokes to skip the shell when true. This does nothing on macOS. \"terminal.integrated.allowMnemonics\": false, // If enabled, alt/option + click will reposition the prompt cursor to underneath the mouse when `editor.multiCursorModifier` is set to `'alt'` (the default value). This may not work reliably depending on your shell. \"terminal.integrated.altClickMovesCursor\": true, // A path that when set will override `terminal.integrated.shell.linux` and ignore `shellArgs` values for automation-related terminal usage like tasks and debug. \"terminal.integrated.automationShell.linux\": null, // A path that when set will override `terminal.integrated.shell.osx` and ignore `shellArgs` values for automation-related terminal usage like tasks and debug. \"terminal.integrated.automationShell.osx\": null, // A path that when set will override `terminal.integrated.shell.windows` and ignore `shellArgs` values for automation-related terminal usage like tasks and debug. \"terminal.integrated.automationShell.windows\": null, // The number of milliseconds to show the bell within a terminal tab when triggered. \"terminal.integrated.bellDuration\": 1000, // A set of command IDs whose keybindings will not be sent to the shell but instead always be handled by VS Code. This allows keybindings that would normally be consumed by the shell to act instead the same as when the terminal is not focused, for example `Ctrl+P` to launch Quick Open. \"terminal.integrated.commandsToSkipShell\": [], // Controls whether to confirm when the window closes if there are active terminal sessions. // - never: Never confirm. // - always: Always confirm if there are terminals. // - hasChildProcesses: Confirm if there are any terminals that have child processes. \"terminal.integrated.confirmOnExit\": \"never\", // Controls whether to confirm killing terminals when they have child processes. When set to editor, terminals in the editor area will be marked as dirty when they have child processes. Note that child process detection may not work well for shells like Git Bash which don't run their processes as child processes of the shell. // - never: Never confirm. // - editor: Confirm if the terminal is in the editor. // - panel: Confirm if the terminal is in the panel. // - always: Confirm if the terminal is either in the editor or panel. \"terminal.integrated.confirmOnKill\": \"editor\", // Controls whether text selected in the terminal will be copied to the clipboard. \"terminal.integrated.copyOnSelection\": false, // Controls whether the terminal cursor blinks. \"terminal.integrated.cursorBlinking\": false, // Controls the style of terminal cursor. \"terminal.integrated.cursorStyle\": \"block\", // Controls the width of the cursor when `terminal.integrated.cursorStyle` is set to `line`. \"terminal.integrated.cursorWidth\": 1, // An explicit start path where the terminal will be launched, this is used as the current working directory (cwd) for the shell process. This may be particularly useful in workspace settings if the root directory is not a convenient cwd. \"terminal.integrated.cwd\": \"\", // Controls where newly created terminals will appear. // - editor: Create terminals in the editor // - view: Create terminals in the terminal view \"terminal.integrated.defaultLocation\": \"view\", // The default profile used on Linux. This setting will currently be ignored if either `terminal.integrated.shell.linux` or `terminal.integrated.shellArgs.linux` are set. \"terminal.integrated.defaultProfile.linux\": null, // The default profile used on macOS. This setting will currently be ignored if either `terminal.integrated.shell.osx` or `terminal.integrated.shellArgs.osx` are set. \"terminal.integrated.defaultProfile.osx\": null, // The default profile used on Windows. This setting will currently be ignored if either `terminal.integrated.shell.windows` or `terminal.integrated.shellArgs.windows` are set. \"terminal.integrated.defaultProfile.windows\": null, // Controls whether to detect and set the `$LANG` environment variable to a UTF-8 compliant option since VS Code's terminal only supports UTF-8 encoded data coming from the shell. // - auto: Set the `$LANG` environment variable if the existing variable does not exist or it does not end in `'.UTF-8'`. // - off: Do not set the `$LANG` environment variable. // - on: Always set the `$LANG` environment variable. \"terminal.integrated.detectLocale\": \"auto\", // Controls whether bold text in the terminal will always use the \"bright\" ANSI color variant. \"terminal.integrated.drawBoldTextInBrightColors\": true, // Controls whether the terminal bell is enabled, this shows up as a visual bell next to the terminal's name. \"terminal.integrated.enableBell\": false, // Whether to enable file links in the terminal. Links can be slow when working on a network drive in particular because each file link is verified against the file system. Changing this will take effect only in new terminals. \"terminal.integrated.enableFileLinks\": true, // Persist terminal sessions for the workspace across window reloads. \"terminal.integrated.enablePersistentSessions\": true, // Object with environment variables that will be added to the VS Code process to be used by the terminal on Linux. Set to `null` to delete the environment variable. \"terminal.integrated.env.linux\": {}, // Object with environment variables that will be added to the VS Code process to be used by the terminal on macOS. Set to `null` to delete the environment variable. \"terminal.integrated.env.osx\": {}, // Object with environment variables that will be added to the VS Code process to be used by the terminal on Windows. Set to `null` to delete the environment variable. \"terminal.integrated.env.windows\": {}, // Whether to display the environment changes indicator on each terminal which explains whether extensions have made, or want to make changes to the terminal's environment. // - off: Disable the indicator. // - on: Enable the indicator. // - warnonly: Only show the warning indicator when a terminal's environment is 'stale', not the information indicator that shows a terminal has had its environment modified by an extension. \"terminal.integrated.environmentChangesIndicator\": \"warnonly\", // Whether to relaunch terminals automatically if extension want to contribute to their environment and have not been interacted with yet. \"terminal.integrated.environmentChangesRelaunch\": true, // Scrolling speed multiplier when pressing `Alt`. \"terminal.integrated.fastScrollSensitivity\": 5, // Controls the font family of the terminal, this defaults to `editor.fontFamily`'s value. \"terminal.integrated.fontFamily\": \"\", // Controls the font size in pixels of the terminal. \"terminal.integrated.fontSize\": 14, // The font weight to use within the terminal for non-bold text. Accepts \"normal\" and \"bold\" keywords or numbers between 1 and 1000. \"terminal.integrated.fontWeight\": \"normal\", // The font weight to use within the terminal for bold text. Accepts \"normal\" and \"bold\" keywords or numbers between 1 and 1000. \"terminal.integrated.fontWeightBold\": \"bold\", // Controls whether the terminal will leverage the GPU to do its rendering. // - auto: Let VS Code detect which renderer will give the best experience. // - on: Enable GPU acceleration within the terminal. // - off: Disable GPU acceleration within the terminal. // - canvas: Use the fallback canvas renderer within the terminal. This uses a 2d context instead of webgl and may be better on some systems. \"terminal.integrated.gpuAcceleration\": \"auto\", // Whether new shells should inherit their environment from VS Code, which may source a login shell to ensure $PATH and other development variables are initialized. This has no effect on Windows. \"terminal.integrated.inheritEnv\": true, // Controls the letter spacing of the terminal, this is an integer value which represents the amount of additional pixels to add between characters. \"terminal.integrated.letterSpacing\": 0, // Controls the line height of the terminal, this number is multiplied by the terminal font size to get the actual line-height in pixels. \"terminal.integrated.lineHeight\": 1, // Controls whether to force selection when using Option+click on macOS. This will force a regular (line) selection and disallow the use of column selection mode. This enables copying and pasting using the regular terminal selection, for example, when mouse mode is enabled in tmux. \"terminal.integrated.macOptionClickForcesSelection\": false, // Controls whether to treat the option key as the meta key in the terminal on macOS. \"terminal.integrated.macOptionIsMeta\": false, // When set the foreground color of each cell will change to try meet the contrast ratio specified. Example values: // // - 1: The default, do nothing. // - 4.5: WCAG AA compliance (minimum). // - 7: WCAG AAA compliance (enhanced). // - 21: White on black or black on white. \"terminal.integrated.minimumContrastRatio\": 1, // A multiplier to be used on the `deltaY` of mouse wheel scroll events. \"terminal.integrated.mouseWheelScrollSensitivity\": 1, // The Linux profiles to present when creating a new terminal via the terminal dropdown. When set, these will override the default detected profiles. They are comprised of a `path` and optional `args`. \"terminal.integrated.profiles.linux\": { }, // The macOS profiles to present when creating a new terminal via the terminal dropdown. When set, these will override the default detected profiles. They are comprised of a `path` and optional `args`. \"terminal.integrated.profiles.osx\": { }, // The Windows profiles to present when creating a new terminal via the terminal dropdown. Set to null to exclude them, use the `source` property to use the default detected configuration. Or, set the `path` and optional `args`. \"terminal.integrated.profiles.windows\": { }, // Controls how terminal reacts to right click. // - default: Show the context menu. // - copyPaste: Copy when there is a selection, otherwise paste. // - paste: Paste on right click. // - selectWord: Select the word under the cursor and show the context menu. \"terminal.integrated.rightClickBehavior\": \"copyPaste\", // Controls the maximum amount of lines the terminal keeps in its buffer. \"terminal.integrated.scrollback\": 1000, // Dispatches most keybindings to the terminal instead of the workbench, overriding `terminal.integrated.commandsToSkipShell`, which can be used alternatively for fine tuning. \"terminal.integrated.sendKeybindingsToShell\": false, // Controls whether to show the alert \"The terminal process terminated with exit code\" when exit code is non-zero. \"terminal.integrated.showExitAlert\": true, // Whether to show hovers for links in the terminal output. \"terminal.integrated.showLinkHover\": true, // Controls the working directory a split terminal starts with. // - workspaceRoot: A new split terminal will use the workspace root as the working directory. In a multi-root workspace a choice for which root folder to use is offered. // - initial: A new split terminal will use the working directory that the parent terminal started with. // - inherited: On macOS and Linux, a new split terminal will use the working directory of the parent terminal. On Windows, this behaves the same as initial. \"terminal.integrated.splitCwd\": \"inherited\", // Controls whether terminal tab statuses support animation (eg. in progress tasks). \"terminal.integrated.tabs.enableAnimation\": true, // Controls whether terminal tabs display as a list to the side of the terminal. When this is disabled a dropdown will display instead. \"terminal.integrated.tabs.enabled\": true, // Controls whether focusing the terminal of a tab happens on double or single click. // - singleClick: Focus the terminal when clicking a terminal tab // - doubleClick: Focus the terminal when double clicking a terminal tab \"terminal.integrated.tabs.focusMode\": \"doubleClick\", // Controls whether the terminal tabs view will hide under certain conditions. // - never: Never hide the terminal tabs view // - singleTerminal: Hide the terminal tabs view when there is only a single terminal opened // - singleGroup: Hide the terminal tabs view when there is only a single terminal group opened \"terminal.integrated.tabs.hideCondition\": \"singleTerminal\", // Controls the location of the terminal tabs, either to the left or right of the actual terminal(s). // - left: Show the terminal tabs view to the left of the terminal // - right: Show the terminal tabs view to the right of the terminal \"terminal.integrated.tabs.location\": \"right\", // Controls whether terminal split and kill buttons are displays next to the new terminal button. // - always: Always show the actions // - singleTerminal: Show the actions when it is the only terminal opened // - singleTerminalOrNarrow: Show the actions when it is the only terminal opened or when the tabs view is in its narrow textless state // - never: Never show the actions \"terminal.integrated.tabs.showActions\": \"singleTerminalOrNarrow\", // Shows the active terminal information in the view, this is particularly useful when the title within the tabs aren't visible. // - always: Always show the active terminal // - singleTerminal: Show the active terminal when it is the only terminal opened // - singleTerminalOrNarrow: Show the active terminal when it is the only terminal opened or when the tabs view is in its narrow textless state // - never: Never show the active terminal \"terminal.integrated.tabs.showActiveTerminal\": \"singleTerminalOrNarrow\", // Determines how the terminal's title is set, this shows up in the terminal's tab or dropdown entry. // - executable: The title is set by the terminal, the name of the detected foreground process will be used. // - sequence: The title is set by the process via an escape sequence, this is useful if your shell dynamically sets the title. \"terminal.integrated.titleMode\": \"executable\", // Controls what version of unicode to use when evaluating the width of characters in the terminal. If you experience emoji or other wide characters not taking up the right amount of space or backspace either deleting too much or too little then you may want to try tweaking this setting. // - 6: Version 6 of unicode, this is an older version which should work better on older systems. // - 11: Version 11 of unicode, this version provides better support on modern systems that use modern versions of unicode. \"terminal.integrated.unicodeVersion\": \"11\", // Controls whether or not WSL distros are shown in the terminal dropdown \"terminal.integrated.useWslProfiles\": true, // Whether to use ConPTY for Windows terminal process communication (requires Windows 10 build number 18309+). Winpty will be used if this is false. \"terminal.integrated.windowsEnableConpty\": true, // A string containing all characters to be considered word separators by the double click to select word feature. \"terminal.integrated.wordSeparators\": \" ()[]{}',\\\"`─\", // Tasks // Controls enablement of `provideTasks` for all task provider extension. If the Tasks: Run Task command is slow, disabling auto detect for task providers may help. Individual extensions may also provide settings that disable auto detection. \"task.autoDetect\": \"on\", // Configures whether to show the problem matcher prompt when running a task. Set to `true` to never prompt, or use a dictionary of task types to turn off prompting only for specific task types. \"task.problemMatchers.neverPrompt\": false, // Controls whether to show the task detail for tasks that have a detail in task quick picks, such as Run Task. \"task.quickOpen.detail\": true, // Controls the number of recent items tracked in task quick open dialog. \"task.quickOpen.history\": 30, // Causes the Tasks: Run Task command to use the slower \"show all\" behavior instead of the faster two level picker where tasks are grouped by provider. \"task.quickOpen.showAll\": false, // Controls whether the task quick pick is skipped when there is only one task to pick from. \"task.quickOpen.skip\": false, // Save all dirty editors before running a task. // - always: Always saves all editors before running. // - never: Never saves editors before running. // - prompt: Prompts whether to save editors before running. \"task.saveBeforeRun\": \"always\", // Configures whether a warning is shown when a provider is slow \"task.slowProviderWarning\": true, // Problems // Controls whether Problems view should automatically reveal files when opening them. \"problems.autoReveal\": true, // Show Errors & Warnings on files and folder. \"problems.decorations.enabled\": true, // When enabled shows the current problem in the status bar. \"problems.showCurrentInStatus\": false, // Breadcrumb Navigation // Enable/disable navigation breadcrumbs. \"breadcrumbs.enabled\": true, // Controls whether and how file paths are shown in the breadcrumbs view. // - on: Show the file path in the breadcrumbs view. // - off: Do not show the file path in the breadcrumbs view. // - last: Only show the last element of the file path in the breadcrumbs view. \"breadcrumbs.filePath\": \"on\", // Render breadcrumb items with icons. \"breadcrumbs.icons\": true, // When enabled breadcrumbs show `array`-symbols. \"breadcrumbs.showArrays\": true, // When enabled breadcrumbs show `boolean`-symbols. \"breadcrumbs.showBooleans\": true, // When enabled breadcrumbs show `class`-symbols. \"breadcrumbs.showClasses\": true, // When enabled breadcrumbs show `constant`-symbols. \"breadcrumbs.showConstants\": true, // When enabled breadcrumbs show `constructor`-symbols. \"breadcrumbs.showConstructors\": true, // When enabled breadcrumbs show `enumMember`-symbols. \"breadcrumbs.showEnumMembers\": true, // When enabled breadcrumbs show `enum`-symbols. \"breadcrumbs.showEnums\": true, // When enabled breadcrumbs show `event`-symbols. \"breadcrumbs.showEvents\": true, // When enabled breadcrumbs show `field`-symbols. \"breadcrumbs.showFields\": true, // When enabled breadcrumbs show `file`-symbols. \"breadcrumbs.showFiles\": true, // When enabled breadcrumbs show `function`-symbols. \"breadcrumbs.showFunctions\": true, // When enabled breadcrumbs show `interface`-symbols. \"breadcrumbs.showInterfaces\": true, // When enabled breadcrumbs show `key`-symbols. \"breadcrumbs.showKeys\": true, // When enabled breadcrumbs show `method`-symbols. \"breadcrumbs.showMethods\": true, // When enabled breadcrumbs show `module`-symbols. \"breadcrumbs.showModules\": true, // When enabled breadcrumbs show `namespace`-symbols. \"breadcrumbs.showNamespaces\": true, // When enabled breadcrumbs show `null`-symbols. \"breadcrumbs.showNull\": true, // When enabled breadcrumbs show `number`-symbols. \"breadcrumbs.showNumbers\": true, // When enabled breadcrumbs show `object`-symbols. \"breadcrumbs.showObjects\": true, // When enabled breadcrumbs show `operator`-symbols. \"breadcrumbs.showOperators\": true, // When enabled breadcrumbs show `package`-symbols. \"breadcrumbs.showPackages\": true, // When enabled breadcrumbs show `property`-symbols. \"breadcrumbs.showProperties\": true, // When enabled breadcrumbs show `string`-symbols. \"breadcrumbs.showStrings\": true, // When enabled breadcrumbs show `struct`-symbols. \"breadcrumbs.showStructs\": true, // When enabled breadcrumbs show `typeParameter`-symbols. \"breadcrumbs.showTypeParameters\": true, // When enabled breadcrumbs show `variable`-symbols. \"breadcrumbs.showVariables\": true, // Controls whether and how symbols are shown in the breadcrumbs view. // - on: Show all symbols in the breadcrumbs view. // - off: Do not show symbols in the breadcrumbs view. // - last: Only show the current symbol in the breadcrumbs view. \"breadcrumbs.symbolPath\": \"on\", // Controls how symbols are sorted in the breadcrumbs outline view. // - position: Show symbol outline in file position order. // - name: Show symbol outline in alphabetical order. // - type: Show symbol outline in symbol type order. \"breadcrumbs.symbolSortOrder\": \"position\", // Telemetry // Enable crash reports to be collected. This helps us improve stability. // This option requires restart to take effect. \"telemetry.enableCrashReporter\": true, // Enable diagnostic data to be collected. This helps us to better understand how Visual Studio Code is performing and where improvements need to be made. \"telemetry.enableTelemetry\": true, // Outline // Render Outline Elements with Icons. \"outline.icons\": true, // Use badges for Errors & Warnings. \"outline.problems.badges\": true, // Use colors for Errors & Warnings. \"outline.problems.colors\": true, // Show Errors & Warnings on Outline Elements. \"outline.problems.enabled\": true, // When enabled outline shows `array`-symbols. \"outline.showArrays\": true, // When enabled outline shows `boolean`-symbols. \"outline.showBooleans\": true, // When enabled outline shows `class`-symbols. \"outline.showClasses\": true, // When enabled outline shows `constant`-symbols. \"outline.showConstants\": true, // When enabled outline shows `constructor`-symbols. \"outline.showConstructors\": true, // When enabled outline shows `enumMember`-symbols. \"outline.showEnumMembers\": true, // When enabled outline shows `enum`-symbols. \"outline.showEnums\": true, // When enabled outline shows `event`-symbols. \"outline.showEvents\": true, // When enabled outline shows `field`-symbols. \"outline.showFields\": true, // When enabled outline shows `file`-symbols. \"outline.showFiles\": true, // When enabled outline shows `function`-symbols. \"outline.showFunctions\": true, // When enabled outline shows `interface`-symbols. \"outline.showInterfaces\": true, // When enabled outline shows `key`-symbols. \"outline.showKeys\": true, // When enabled outline shows `method`-symbols. \"outline.showMethods\": true, // When enabled outline shows `module`-symbols. \"outline.showModules\": true, // When enabled outline shows `namespace`-symbols. \"outline.showNamespaces\": true, // When enabled outline shows `null`-symbols. \"outline.showNull\": true, // When enabled outline shows `number`-symbols. \"outline.showNumbers\": true, // When enabled outline shows `object`-symbols. \"outline.showObjects\": true, // When enabled outline shows `operator`-symbols. \"outline.showOperators\": true, // When enabled outline shows `package`-symbols. \"outline.showPackages\": true, // When enabled outline shows `property`-symbols. \"outline.showProperties\": true, // When enabled outline shows `string`-symbols. \"outline.showStrings\": true, // When enabled outline shows `struct`-symbols. \"outline.showStructs\": true, // When enabled outline shows `typeParameter`-symbols. \"outline.showTypeParameters\": true, // When enabled outline shows `variable`-symbols. \"outline.showVariables\": true, // Timeline // An array of Timeline sources that should be excluded from the Timeline view. \"timeline.excludeSources\": null, // The number of items to show in the Timeline view by default and when loading more items. Setting to `null` (the default) will automatically choose a page size based on the visible area of the Timeline view. \"timeline.pageSize\": null, // Default Configuration Overrides // Configure settings to be overridden for [css] language. \"[css]\": { \"editor.suggest.insertMode\": \"replace\" }, // Configure settings to be overridden for [dockercompose] language. \"[dockercompose]\": { \"editor.insertSpaces\": true, \"editor.tabSize\": 2, \"editor.autoIndent\": \"advanced\" }, // Configure settings to be overridden for [dockerfile] language. \"[dockerfile]\": { \"editor.quickSuggestions\": { \"strings\": true } }, // Configure settings to be overridden for [git-commit] language. \"[git-commit]\": { \"editor.rulers\": [ 72 ], \"workbench.editor.restoreViewState\": false }, // Configure settings to be overridden for [git-rebase] language. \"[git-rebase]\": { \"workbench.editor.restoreViewState\": false }, // Configure settings to be overridden for [go] language. \"[go]\": { \"editor.insertSpaces\": false }, // Configure settings to be overridden for [handlebars] language. \"[handlebars]\": { \"editor.suggest.insertMode\": \"replace\" }, // Configure settings to be overridden for [html] language. \"[html]\": { \"editor.suggest.insertMode\": \"replace\" }, // Configure settings to be overridden for [json] language. \"[json]\": { \"editor.quickSuggestions\": { \"strings\": true }, \"editor.suggest.insertMode\": \"replace\" }, // Configure settings to be overridden for [jsonc] language. \"[jsonc]\": { \"editor.quickSuggestions\": { \"strings\": true }, \"editor.suggest.insertMode\": \"replace\" }, // Configure settings to be overridden for [less] language. \"[less]\": { \"editor.suggest.insertMode\": \"replace\" }, // Configure settings to be overridden for [makefile] language. \"[makefile]\": { \"editor.insertSpaces\": false }, // Configure settings to be overridden for [markdown] language. \"[markdown]\": { \"editor.wordWrap\": \"on\", \"editor.quickSuggestions\": false }, // Configure settings to be overridden for [scss] language. \"[scss]\": { \"editor.suggest.insertMode\": \"replace\" }, // Configure settings to be overridden for [search-result] language. \"[search-result]\": { \"editor.lineNumbers\": \"off\" }, // Configure settings to be overridden for [shellscript] language. \"[shellscript]\": { \"files.eol\": \"\\n\" }, // Configure settings to be overridden for [yaml] language. \"[yaml]\": { \"editor.insertSpaces\": true, \"editor.tabSize\": 2, \"editor.autoIndent\": \"advanced\" }, // Remote // When enabled, new running processes are detected and ports that they listen on are automatically forwarded. Disabling this setting will not prevent all ports from being forwarded. Even when disabled, extensions will still be able to cause ports to be forwarded, and opening some URLs will still cause ports to forwarded. \"remote.autoForwardPorts\": true, // Sets the source from which ports are automatically forwarded when `remote.autoForwardPorts` is true. On Windows and Mac remotes, the `process` option has no effect and `output` will be used. Requires a reload to take effect. // - process: Ports will be automatically forwarded when discovered by watching for processes that are started and include a port. // - output: Ports will be automatically forwarded when discovered by reading terminal and debug output. Not all processes that use ports will print to the integrated terminal or debug console, so some ports will be missed. Ports forwarded based on output will not be \"un-forwarded\" until reload or until the port is closed by the user in the Ports view. \"remote.autoForwardPortsSource\": \"process\", // When enabled extensions are downloaded locally and installed on remote. \"remote.downloadExtensionsLocally\": false, // Override the kind of an extension. `ui` extensions are installed and run on the local machine while `workspace` extensions are run on the remote. By overriding an extension's default kind using this setting, you specify if that extension should be installed and enabled locally or remotely. \"remote.extensionKind\": { \"pub.name\": [ \"ui\" ] }, // Specifies the local host name that will be used for port forwarding. \"remote.localPortHost\": \"localhost\", // Set default properties that are applied to all ports that don't get properties from the setting `remote.portsAttributes`. \"remote.otherPortsAttributes\": {}, // Set properties that are applied when a specific port number is forwarded. \"remote.portsAttributes\": {}, // Restores the ports you forwarded in a workspace. \"remote.restoreForwardedPorts\": true, // Emmet // An array of languages where Emmet abbreviations should not be expanded. \"emmet.excludeLanguages\": [ \"markdown\" ], // An array of paths, where each path can contain Emmet syntaxProfiles and/or snippet files. // In case of conflicts, the profiles/snippets of later paths will override those of earlier paths. \"emmet.extensionsPath\": [], // Enable Emmet abbreviations in languages that are not supported by default. Add a mapping here between the language and Emmet supported language. // For example: `{\"vue-html\": \"html\", \"javascript\": \"javascriptreact\"}` \"emmet.includeLanguages\": {}, // When set to `false`, the whole file is parsed to determine if current position is valid for expanding Emmet abbreviations. When set to `true`, only the content around the current position in CSS/SCSS/Less files is parsed. \"emmet.optimizeStylesheetParsing\": true, // Preferences used to modify behavior of some actions and resolvers of Emmet. \"emmet.preferences\": {}, // Shows possible Emmet abbreviations as suggestions. Not applicable in stylesheets or when emmet.showExpandedAbbreviation is set to `\"never\"`. \"emmet.showAbbreviationSuggestions\": true, // Shows expanded Emmet abbreviations as suggestions. // The option `\"inMarkupAndStylesheetFilesOnly\"` applies to html, haml, jade, slim, xml, xsl, css, scss, sass, less and stylus. // The option `\"always\"` applies to all parts of the file regardless of markup/css. \"emmet.showExpandedAbbreviation\": \"always\", // If `true`, then Emmet suggestions will show up as snippets allowing you to order them as per `editor.snippetSuggestions` setting. \"emmet.showSuggestionsAsSnippets\": false, // Define profile for specified syntax or use your own profile with specific rules. \"emmet.syntaxProfiles\": {}, // When enabled, Emmet abbreviations are expanded when pressing TAB. \"emmet.triggerExpansionOnTab\": false, // Variables to be used in Emmet snippets. \"emmet.variables\": {}, // Git // Controls whether force push (with or without lease) is enabled. \"git.allowForcePush\": false, // Controls whether commits without running pre-commit and commit-msg hooks are allowed. \"git.allowNoVerifyCommit\": false, // Always show the Staged Changes resource group. \"git.alwaysShowStagedChangesResourceGroup\": false, // Controls the signoff flag for all commits. \"git.alwaysSignOff\": false, // When set to true, commits will automatically be fetched from the default remote of the current Git repository. Setting to `all` will fetch from all remotes. \"git.autofetch\": false, // Duration in seconds between each automatic git fetch, when `git.autofetch` is enabled. \"git.autofetchPeriod\": 180, // Whether auto refreshing is enabled. \"git.autorefresh\": true, // Configures when repositories should be automatically detected. // - true: Scan for both subfolders of the current opened folder and parent folders of open files. // - false: Disable automatic repository scanning. // - subFolders: Scan for subfolders of the currently opened folder. // - openEditors: Scan for parent folders of open files. \"git.autoRepositoryDetection\": true, // Stash any changes before pulling and restore them after successful pull. \"git.autoStash\": false, // Controls the sort order for branches. \"git.branchSortOrder\": \"committerdate\", // A regular expression to validate new branch names. \"git.branchValidationRegex\": \"\", // The character to replace whitespace in new branch names. \"git.branchWhitespaceChar\": \"-\", // Controls what type of git refs are listed when running `Checkout to...`. // - local: Local branches // - tags: Tags // - remote: Remote branches \"git.checkoutType\": [ \"local\", \"remote\", \"tags\" ], // Always confirm the creation of empty commits for the 'Git: Commit Empty' command. \"git.confirmEmptyCommits\": true, // Controls whether to ask for confirmation before force-pushing. \"git.confirmForcePush\": true, // Controls whether to ask for confirmation before committing without verification. \"git.confirmNoVerifyCommit\": true, // Confirm before synchronizing git repositories. \"git.confirmSync\": true, // Controls the Git count badge. // - all: Count all changes. // - tracked: Count only tracked changes. // - off: Turn off counter. \"git.countBadge\": \"all\", // Controls whether Git contributes colors and badges to the Explorer and the Open Editors view. \"git.decorations.enabled\": true, // The default location to clone a git repository. \"git.defaultCloneDirectory\": null, // Controls whether to automatically detect git submodules. \"git.detectSubmodules\": true, // Controls the limit of git submodules detected. \"git.detectSubmodulesLimit\": 10, // Enables commit signing with GPG or X.509. \"git.enableCommitSigning\": false, // Whether git is enabled. \"git.enabled\": true, // Commit all changes when there are no staged changes. \"git.enableSmartCommit\": false, // Controls whether the Git Sync command appears in the status bar. \"git.enableStatusBarSync\": true, // When enabled, fetch all branches when pulling. Otherwise, fetch just the current one. \"git.fetchOnPull\": false, // Follow push all tags when running the sync command. \"git.followTagsWhenSync\": false, // List of git repositories to ignore. \"git.ignoredRepositories\": [], // Ignores the legacy Git warning. \"git.ignoreLegacyWarning\": false, // Ignores the warning when there are too many changes in a repository. \"git.ignoreLimitWarning\": false, // Ignores the warning when Git is missing. \"git.ignoreMissingGitWarning\": false, // Ignores the warning when it looks like the branch might have been rebased when pulling. \"git.ignoreRebaseWarning\": false, // Ignore modifications to submodules in the file tree. \"git.ignoreSubmodules\": false, // Ignores the warning when Git 2.25 - 2.26 is installed on Windows. \"git.ignoreWindowsGit27Warning\": false, // Controls when to show commit message input validation. \"git.inputValidation\": \"warn\", // Controls the commit message length threshold for showing a warning. \"git.inputValidationLength\": 72, // Controls the commit message subject length threshold for showing a warning. Unset it to inherit the value of `config.inputValidationLength`. \"git.inputValidationSubjectLength\": 50, // Controls whether to open a repository automatically after cloning. // - always: Always open in current window. // - alwaysNewWindow: Always open in a new window. // - whenNoFolderOpen: Only open in current window when no folder is opened. // - prompt: Always prompt for action. \"git.openAfterClone\": \"prompt\", // Controls whether the diff editor should be opened when clicking a change. Otherwise the regular editor will be opened. \"git.openDiffOnClick\": true, // Path and filename of the git executable, e.g. `C:\\Program Files\\Git\\bin\\git.exe` (Windows). This can also be an array of string values containing multiple paths to look up. \"git.path\": null, // Runs a git command after a successful commit. // - none: Don't run any command after a commit. // - push: Run 'Git Push' after a successful commit. // - sync: Run 'Git Sync' after a successful commit. \"git.postCommitCommand\": \"none\", // Controls whether Git should check for unsaved files before committing. // - always: Check for any unsaved files. // - staged: Check only for unsaved staged files. // - never: Disable this check. \"git.promptToSaveFilesBeforeCommit\": \"always\", // Controls whether Git should check for unsaved files before stashing changes. // - always: Check for any unsaved files. // - staged: Check only for unsaved staged files. // - never: Disable this check. \"git.promptToSaveFilesBeforeStash\": \"always\", // Prune when fetching. \"git.pruneOnFetch\": false, // Fetch all tags when pulling. \"git.pullTags\": true, // Force git to use rebase when running the sync command. \"git.rebaseWhenSync\": false, // Controls whether to require explicit Git user configuration or allow Git to guess if missing. \"git.requireGitUserConfig\": true, // List of paths to search for git repositories in. \"git.scanRepositories\": [], // Controls whether to show the commit input in the Git source control panel. \"git.showCommitInput\": true, // Controls whether to show an inline Open File action in the Git changes view. \"git.showInlineOpenFileAction\": true, // Controls whether git actions should show progress. \"git.showProgress\": true, // Controls whether to show a notification when a push is successful. \"git.showPushSuccessNotification\": false, // Control which changes are automatically staged by Smart Commit. // - all: Automatically stage all changes. // - tracked: Automatically stage tracked changes only. \"git.smartCommitChanges\": \"all\", // Suggests to enable smart commit (commit all changes when there are no staged changes). \"git.suggestSmartCommit\": true, // Controls whether a notification comes up when running the Sync action, which allows the user to cancel the operation. \"git.supportCancellation\": false, // Controls whether to enable VS Code to be the authentication handler for git processes spawned in the integrated terminal. Note: terminals need to be restarted to pick up a change in this setting. \"git.terminalAuthentication\": true, // Controls which date to use for items in the Timeline view. // - committed: Use the committed date // - authored: Use the authored date \"git.timeline.date\": \"committed\", // Controls whether to show the commit author in the Timeline view. \"git.timeline.showAuthor\": true, // Controls how untracked changes behave. // - mixed: All changes, tracked and untracked, appear together and behave equally. // - separate: Untracked changes appear separately in the Source Control view. They are also excluded from several actions. // - hidden: Untracked changes are hidden and excluded from several actions. \"git.untrackedChanges\": \"mixed\", // Controls whether to use the message from the commit input box as the default stash message. \"git.useCommitInputAsStashMessage\": false, // Controls whether force pushing uses the safer force-with-lease variant. \"git.useForcePushWithLease\": true, // Controls whether to enable automatic GitHub authentication for git commands within VS Code. \"github.gitAuthentication\": true, // URI of your GitHub Enterprise Instance \"github-enterprise.uri\": \"\", // Grunt // Controls enablement of Grunt task detection. Grunt task detection can cause files in any open workspace to be executed. \"grunt.autoDetect\": \"off\", // Gulp // Controls enablement of Gulp task detection. Gulp task detection can cause files in any open workspace to be executed. \"gulp.autoDetect\": \"off\", // Jake // Controls enablement of Jake task detection. Jake task detection can cause files in any open workspace to be executed. \"jake.autoDetect\": \"off\", // Merge Conflict // Whether to automatically navigate to the next merge conflict after resolving a merge conflict. \"merge-conflict.autoNavigateNextConflict.enabled\": false, // Create a CodeLens for merge conflict blocks within editor. \"merge-conflict.codeLens.enabled\": true, // Create decorators for merge conflict blocks within editor. \"merge-conflict.decorators.enabled\": true, // Controls where the diff view should be opened when comparing changes in merge conflicts. // - Current: Open the diff view in the current editor group. // - Beside: Open the diff view next to the current editor group. // - Below: Open the diff view below the current editor group. \"merge-conflict.diffViewPosition\": \"Current\", // JavaScript Debugger // Configures which processes to automatically attach and debug when `debug.node.autoAttach` is on. A Node process launched with the `--inspect` flag will always be attached to, regardless of this setting. // - always: Auto attach to every Node.js process launched in the terminal. // - smart: Auto attach when running scripts that aren't in a node_modules folder. // - onlyWithFlag: Only auto attach when the `--inspect` is given. // - disabled: Auto attach is disabled and not shown in status bar. \"debug.javascript.autoAttachFilter\": \"disabled\", // Configures glob patterns for determining when to attach in \"smart\" `debug.javascript.autoAttachFilter` mode. `$KNOWN_TOOLS$` is replaced with a list of names of common test and code runners. \"debug.javascript.autoAttachSmartPattern\": [ \"${workspaceFolder}/**\", \"!**/node_modules/**\", \"**/$KNOWN_TOOLS$/**\" ], // Configures whether property getters will be expanded automatically. If this is false, the getter will appear as `get propertyName` and will only be evaluated when you click on it. \"debug.javascript.autoExpandGetters\": false, // When debugging a remote web app, configures whether to automatically tunnel the remote server to your local machine. \"debug.javascript.automaticallyTunnelRemoteServer\": true, // Whether to stop when conditional breakpoints throw an error. Note: your launch.json `type` must be prefixed with `pwa-` to use this, such as `pwa-node`. \"debug.javascript.breakOnConditionalError\": false, // Where a \"Run\" and \"Debug\" code lens should be shown in your npm scripts. It may be on \"all\", scripts, on \"top\" of the script section, or \"never\". \"debug.javascript.codelens.npmScripts\": \"top\", // Options used when debugging open links clicked from inside the JavaScript Debug Terminal. Can be set to \"off\" to disable this behavior, or \"always\" to enable debugging in all terminals. \"debug.javascript.debugByLinkOptions\": \"on\", // The default `runtimeExecutable` used for launch configurations, if unspecified. This can be used to config custom paths to Node.js or browser installations. \"debug.javascript.defaultRuntimeExecutable\": { \"pwa-node\": \"node\" }, // Default options used when debugging a process through the `Debug: Attach to Node.js Process` command. \"debug.javascript.pickAndAttachOptions\": {}, // Request options to use when loading resources, such as source maps, in the debugger. You may need to configure this if your sourcemaps require authentication or use a self-signed certificate, for instance. Options are used to create a request using the `got`library. // A common case to disable certificate verification can be done by passing `{ \"https\": { \"rejectUnauthorized\": false } }`. \"debug.javascript.resourceRequestOptions\": {}, // Whether to suggest pretty printing JavaScript code that looks minified when you step into it. \"debug.javascript.suggestPrettyPrinting\": true, // Default launch options for the JavaScript debug terminal and npm scripts. \"debug.javascript.terminalOptions\": {}, // Configures whether sourcemapped file where the original file can't be read will automatically be unmapped. If this is false (default), a prompt is shown. \"debug.javascript.unmapMissingSources\": false, // Use the new in-preview JavaScript debugger for Node.js and Chrome. \"debug.javascript.usePreview\": true, // Controls whether to show a warning when the 'useWSL' attribute is used. \"debug.node.showUseWslIsDeprecatedWarning\": true, // References Search View // Controls whether 'Peek References' or 'Find References' is invoked when selecting CodeLens references. // - peek: Show references in peek editor. // - view: Show references in separate view. \"references.preferredLocation\": \"peek\", // Npm // Controls whether npm scripts should be automatically detected. \"npm.autoDetect\": \"on\", // Enable running npm scripts contained in a folder from the Explorer context menu. \"npm.enableRunFromFolder\": false, // The NPM Script Explorer is now available in 'Views' menu in the Explorer in all folders. // Enable an explorer view for npm scripts when there is no top-level 'package.json' file. \"npm.enableScriptExplorer\": false, // Configure glob patterns for folders that should be excluded from automatic script detection. \"npm.exclude\": \"\", // Fetch data from https://registry.npmjs.org and https://registry.bower.io to provide auto-completion and information on hover features on npm dependencies. \"npm.fetchOnlinePackageInfo\": true, // The package manager used to run scripts. // - auto: Auto-detect which package manager to use for running scripts based on lock files and installed package managers. // - npm: Use npm as the package manager for running scripts. // - yarn: Use yarn as the package manager for running scripts. // - pnpm: Use pnpm as the package manager for running scripts. \"npm.packageManager\": \"auto\", // Run npm commands with the `--silent` option. \"npm.runSilent\": false, // The default click action used in the npm scripts explorer: `open` or `run`, the default is `open`. \"npm.scriptExplorerAction\": \"open\", } Common questions VS Code says \"Unable to write settings.\" If you try to change a setting (for example turning on Auto Save or selecting a new Color Theme) and you see \"Unable to write settings. Please open User Settings to correct errors/warnings in the file and try again.\", it means your settings.json file is ill-formed or has errors. The errors can be as simple as a missing comma or setting value. Open the Settings editor File > Preferences > Settings ( Code > Preferences > Settings on macOS) ( kb(workbench.action.openSettings) ) and you should see the error highlighted with red squiggles. How can I reset my user settings? The easiest way to reset VS Code back to the default settings is to clear your user settings.json file contents in the Settings editor. Delete everything between the two curly braces, save the file, and VS Code will go back to using the default values. When does it make sense to use workspace settings? If you're using a workspace that needs custom settings but you don't want to apply them to your other VS Code projects. A good example is language-specific linting rules."
  },
  "guides/vscode/getstarted/telemetry.html": {
    "href": "guides/vscode/getstarted/telemetry.html",
    "title": "Telemetry | Fountain of Knowledge",
    "keywords": "Telemetry Visual Studio Code collects telemetry data, which is used to help understand how to improve the product. For example, this usage data helps to debug issues, such as slow start-up times, and to prioritize new features. While we appreciate the insights this data provides, we also know that not everyone wants to send usage data and you can disable telemetry as described in disable telemetry reporting . You can also read our privacy statement to learn more. Disable telemetry reporting If you don't want to send usage data to Microsoft, you can set the telemetry.enableTelemetry user setting to false . From File > Preferences > Settings (macOS: Code > Preferences > Settings ), search for telemetry , and uncheck the Telemetry: Enable Telemetry setting. This will silence all telemetry events from VS Code going forward. Telemetry information may have been collected and sent up until the point when you disable the setting. If you use the JSON editor for your settings, add the following line: \"telemetry.enableTelemetry\": false Disable crash reporting VS Code collects data about any crashes that occur and sends it to Microsoft to help improve our products and services. If you don't want to send crash data to Microsoft, you can change the enable-crash-reporter runtime argument to false Open the Command Palette ( kb(workbench.action.showCommands) ). Run the Preferences: Configure Runtime Arguments command. This command will open a argv.json file to configure runtime arguments. Edit \"enable-crash-reporter\": false . Restart VS Code. Extensions and telemetry VS Code lets you add features to the product by installing Microsoft and third-party extensions. These extensions may be collecting their own usage data and are not controlled by the telemetry.enableTelemetry setting. Consult the specific extension's documentation to learn about its telemetry reporting and whether it can be disabled. For example, the GitHub Pull Requests extension has a setting to disable its telemetry collection: Output channel for telemetry events If you'd like to review the telemetry events in VS Code as they are sent, you can enable tracing and it will record telemetry events. Set the log level to Trace using the Developer: Set Log Level... command and then in the Output panel ( kb(workbench.action.output.toggleOutput) ), pick Log (Telemetry) from the dropdown. When tracing telemetry events, the events are also logged to a local file telemetry.log , which you can view using the Developer: Open Log File... command and choosing Telemetry from the dropdown. Viewing all telemetry events If you'd like to view all the possible telemetry events that VS Code could send, you can use the --telemetry flag in the CLI. This will generate a JSON report that you can then view within VS Code. These reports are generated per build and do not contain extension telemetry unless the extension author adds a telemetry.json file to their root build directory. For example, running code --telemetry > telemetry.json && code telemetry.json will create a telemetry.json file in your current working directory and then open it in VS Code. You cannot pipe the output like this, code --telemetry | code - , due to the length of the telemetry report. GDPR and VS Code In addition to supporting the General Data Protection Regulation (GDPR), the VS Code team takes privacy very seriously. That's both for Microsoft as a company and specifically within the VS Code team. To ensure GDPR compliance, we made several updates to VS Code, these include: Making it easier to opt out of telemetry collection by placing a notification in product for all existing and new users. Reviewing and classifying the telemetry that we send (documented in our OSS codebase ). Ensuring that we have valid data retention policies in place for any data we do collect, for example crash dumps. In short, we have worked hard to do the right thing, for all users, as these practices apply to all geographies, not just Europe. One question we expect people to ask is to see the data we collect. However, we don't have a reliable way to do this as VS Code does not have a 'sign-in' experience that would uniquely identify a user. We do send information that helps us approximate a single user for diagnostic purposes (this is based on a hash of the network adapter NIC) but this is not guaranteed to be unique. For example, virtual machines (VMs) often rotate NIC IDs or allocate from a pool. This technique is sufficient to help us when working through problems, but it is not reliable enough for us to 'provide your data'. We expect our approach to evolve as we learn more about GDPR and the expectations of our users. We greatly appreciate the data users do send to us, as it is very valuable and VS Code is a better product for everyone because of it. And again, if you are worried about privacy, we offer the ability to disable sending telemetry as described in disable telemetry reporting . You can find more information about how the Visual Studio family approaches GDPR at Visual Studio Family Data Subject Requests for the GDPR . Managing online services Beyond crash reporting and telemetry, VS Code uses online services for various other purposes such as downloading product updates, finding, installing, and updating extensions, Settings Sync, or providing Natural Language Search within the Settings editor. You can choose to turn on/off features that use these services. Please note, that turning off these features does not put VS Code into offline mode. For example, if you search for extensions in the Extensions view, VS Code still searches the online VS Code Marketplace. The settings ensure that VS Code does not talk to online services without you requesting it. From File > Preferences > Settings (macOS: Code > Preferences > Settings ), and type the tag @tag:usesOnlineServices . This will display all settings that control the usage of online services and you can individually switch them on or off. Note : VS Code extensions may also use online services and may not provide settings to configure the usage of these online services, or they may not register their settings to show up when searching for @tag:usesOnlineServices . Consult the specific extension's documentation to learn about its usage of online services. Non-Microsoft online services used by VS Code The built-in npm support for VS Code extension sends requests to https://registry.npmjs.org and https://registry.bower.io . The built-in TypeScript and JavaScript Language Features extension queries the @types domain at https://registry.npmjs.org . When you use Developer: Toggle Developer Tools or Developer: Open Webview Developer Tools , VS Code may talk to Google servers to fetch data needed to launch Developer Tools. Extension recommendations VS Code provides extension recommendations based on your file types, your workspace, and your environment. File type recommendations are either precomputed or dynamic. Workspace and environment recommendations are always precomputed. If you want to know why an extension is being recommended, open the extension's detail page. You can find the recommendation reason in the page header. Precomputed recommendations VS Code collects telemetry about which extensions are being activated for what file types and what workspaces/folders. Specific folders are identified by computing a hash of each of the folder's Git remotes. We use this information to precompute anonymous recommendations. Precomputed recommendations are instructions that spell out under which conditions an extension should be recommended. For example, when we see an interesting correlation between two extensions A and B, one instruction might be: Recommend extension B if the user has installed extension A but not B. Some precomputed recommendations are shipped as part of the product while additional precomputed recommendations are fetched at runtime from an online Microsoft service. VS Code independently evaluates and executes precomputed recommendations without sending any user information to any online service. Dynamic recommendations When you open a file type for which VS Code does not have any precomputed recommendation, it asks the Extension Marketplace for extensions that declare that they support this file type. If the query returns extensions you don't have installed, VS Code will provide a notification. For extension authors If you have created a VS Code extension, you can use the VS Code telemetry infrastructure for reporting through the vscode-extension-telemetry npm module. This module provides a consistent way for extensions to report telemetry over Azure Monitor and Application Insights . The module respects the user's decision about whether or not to send telemetry data via the telemetry.enableTelemetry setting. Follow this guide to set up Azure Monitor and get your Application Insights instrumentation key. If you would prefer to not utilize the npm module, it is still recommended that extension authors respect the user's choice by utilizing the isTelemetryEnabled and onDidChangeTelemetryEnabled API. Additionally, telemetry authors can add a telemetry.json file to their root build directory for their telemetry to show up in the --telemetry dump that VS Code produces. Next steps Visual Studio Code FAQ - Consult the Frequently Asked Questions to learn more. User and Workspace Settings - Read about available options to customize VS Code. Key Bindings - You can easily modify commonly used keyboard shortcuts."
  },
  "guides/vscode/getstarted/themes.html": {
    "href": "guides/vscode/getstarted/themes.html",
    "title": "Color Themes | Fountain of Knowledge",
    "keywords": "Color Themes Color themes let you modify the colors in Visual Studio Code's user interface to suit your preferences and work environment. Selecting the Color Theme In VS Code, open the Color Theme picker with File > Preferences > Color Theme . ( Code > Preferences > Color Theme on macOS). You can also use the keyboard shortcut kb(workbench.action.selectTheme) to display the picker. Use the cursor keys to preview the colors of the theme. Select the theme you want and press kbstyle(Enter) . The active color theme is stored in your user settings (keyboard shortcut kb(workbench.action.openSettings) ). // Specifies the color theme used in the workbench. \"workbench.colorTheme\": \"Default Dark+\" Tip: By default, the theme is stored in your user settings and applies globally to all workspaces. You can also configure a workspace specific theme. To do so, set a theme in the Workspace settings . Color Themes from the Marketplace There are several out-of-the-box color themes in VS Code for you to try. Many more themes have been uploaded to the VS Code Extension Marketplace by the community. If you find one you want to use, install it and restart VS Code and the new theme will be available. You can search for themes in the Extensions view ( kb(workbench.view.extensions) ) search box using the @category:\"themes\" filter. Customizing a Color Theme Workbench colors You can customize your active color theme with the workbench.colorCustomizations and editor.tokenColorCustomizations user settings . To set the colors of VS Code UI elements such as list & trees (File Explorer, suggestions widget), diff editor, Activity Bar, notifications, scroll bar, split view, buttons, and more, use workbench.colorCustomizations . You can use IntelliSense while setting workbench.colorCustomizations values or, for a list of all customizable colors, see the Theme Color Reference . To customize a specific theme only, use the following syntax: \"workbench.colorCustomizations\": { \"[Monokai]\": { \"sideBar.background\": \"#347890\" } } Editor syntax highlighting To tune the editor's syntax highlighting colors, use editor.tokenColorCustomizations in your user settings settings.json file: A pre-configured set of syntax tokens ('comments', 'strings', ...) is available for the most common constructs. If you want more, you can do so by directly specifying TextMate theme color rules: Note : Directly configuring TextMate rules is an advanced skill as you need to understand on how TextMate grammars work. Go to the Color Theme guide for more information. Again, to customize a specific theme only, use the following syntax: \"editor.tokenColorCustomizations\": { \"[Monokai]\": { \"comments\": \"#229977\" } }, Editor semantic highlighting Some languages (currently: TypeScript, JavaScript, Java) provide semantic tokens. Semantic tokens are based on the language service's symbol understanding and are more accurate than the syntax tokens coming from the TextMate grammars that are driven by regular expressions. The semantic highlighting that is computed from the semantic tokens goes on top of syntax highlighting and can correct and enrich the highlighting as seen in the following example: The \"Tomorrow Night Blue\" color theme without semantic highlighting: The \"Tomorrow Night Blue\" color theme with semantic highlighting: Notice the color differences based on language service symbol understanding: line 10: languageModes is colored as a parameter. line 11: Range and Position are colored as classes and document as a parameter. line 13: getFoldingRanges is colored as a function. The settings editor.semanticHighlighting.enabled serves as the main control on whether semantic highlighting is applied. It can have values true , false , and configuredByTheme . true and false turn semantic highlighting on or off for all themes. configuredByTheme is the default and lets each theme control whether semantic highlighting is enabled or not. All the themes that ship with VS Code (for example, the \"Dark+\" default) have semantic highlighting enabled by default. Users can override the theme setting by: \"editor.semanticTokenColorCustomizations\": { \"[Rouge]\": { \"enabled\": true } }, When semantic highlighting is enabled and available for a language, it is up to the theme to configure whether and how semantic tokens are colored. Some semantic tokens are standardized and map to well-established TextMate scopes. If the theme has a coloring rule for these TextMate scopes, the semantic token will be rendered with that color, without the need for any additional coloring rules. Additional styling rules can be configured by the user in editor.semanticTokenColorCustomizations\" : \"editor.semanticTokenColorCustomizations\": { \"[Rouge]\": { \"enabled\": true, \"rules\": { \"*.declaration\": { \"bold\": true } } } }, To see what semantic tokens are computed and how they are styled, users can use the scope inspector ( Developer: Inspect Editor Tokens and Scopes ), which displays information for the text at the current cursor position. If semantic tokens are available for the language at the given position and enabled by theme, the inspect tool shows a section semantic token type . The section shows the semantic token information (type and any number of modifiers) as well as the styling rules that apply. More information on semantic tokens and styling rule syntax can be found in the Semantic Highlighting Guide . Creating your own Color Theme Creating and publishing a theme extension is easy. Customize your colors in your user settings then generate a theme definition file with the Developer: Generate Color Theme From Current Settings command. VS Code's Yeoman extension generator will help you generate the rest of the extension. See the Create a new Color Theme topic in our Extension API section to learn more. Remove default Color Themes If you'd like to remove some of the default themes shipped with VS Code from the Color Theme picker, you can disable them from the Extensions view ( kb(workbench.view.extensions) ). Open the ... More Actions dropdown menu from the top of the Extensions view, select Show Built-in Extensions , and you'll see a THEMES section listing the default themes. You can disable a built-in theme extension as you would any other VS Code extension with the Disable command on the gear context menu. File Icon Themes File icon themes can be contributed by extensions and selected by users as their favorite set of file icons. File icons are shown in the File Explorer and tabbed headings. Selecting the File Icon Theme In VS Code, open the File Icon Theme picker with File > Preferences > File Icon Theme . ( Code > Preferences > File Icon Theme on macOS). You can also use the Preferences: File Icon Theme command from the Command Palette ( kb(workbench.action.showCommands) ). Use the cursor keys to preview the icons of the theme. Select the theme you want and hit kbstyle(Enter) . By default, the Seti file icon set is used and those are the icons you see in the File Explorer. Once a file icon theme is selected, the selected theme will be remembered and appear again whenever VS Code is restarted. You can disable file icons by selecting None . VS code ships with two file icon themes; Minimal and Seti . To install more file icon themes, select the Install Additional File Icon Themes item in the file icon theme picker and you'll see a query for file icon themes (tag:icon-theme) in the Extensions view. You can also browse the VS Code Marketplace site directly to find available themes. The active File Icon theme is persisted in your user settings (keyboard shortcut kb(workbench.action.openSettings) ). // Specifies the file icon theme used in the workbench. \"workbench.iconTheme\": \"vs-seti\" Creating your own File Icon Theme You can create your own File Icon Theme from icons (preferably SVG), see the File Icon Theme topic in our Extension API section for details. Next steps Themes are just one way to customize VS Code. If you'd like to learn more about VS Code customization and extensibility, try these topics: Settings - Learn how to configure VS Code to your preferences through user and workspace settings. Snippets - Add additional snippets to your favorite language. Extension API - Learn about other ways to extend VS Code. Color Theme - Color Theme extension API. File Icon Theme - File Icon Theme extension API."
  },
  "guides/vscode/getstarted/tips-and-tricks.html": {
    "href": "guides/vscode/getstarted/tips-and-tricks.html",
    "title": "Visual Studio Code Tips and Tricks | Fountain of Knowledge",
    "keywords": "Visual Studio Code Tips and Tricks \"Tips and Tricks\" lets you jump right in and learn how to be productive with Visual Studio Code. You'll become familiar with its powerful editing, code intelligence, and source code control features and learn useful keyboard shortcuts. This topic goes pretty fast and provides a broad overview, so be sure to look at the other in-depth topics in Getting Started and the User Guide to learn more. If you don't have Visual Studio Code installed, go to the Download page. You can find platform specific setup instructions at Running VS Code on Linux , macOS , and Windows . Prefer a video? You can watch a recent Microsoft Build talk Visual Studio Code tips and tricks , which describes 20 tips and tricks for working productively with VS Code. Basics Getting started Open the Welcome page to get started with the basics of VS Code. Help > Welcome . In the bottom right of the Welcome page, there is a link to the Interactive playground where you can interactively try out VS Code's features. Help > Interactive Playground . Command Palette Access all available commands based on your current context. Keyboard Shortcut: kb(workbench.action.showCommands) Default keyboard shortcuts All of the commands are in the Command Palette with the associated key binding (if it exists). If you forget a keyboard shortcut, use the Command Palette to help you out. Keyboard reference sheets Download the keyboard shortcut reference sheet for your platform ( macOS , Windows , Linux ). Quick Open Quickly open files. Keyboard Shortcut: kb(workbench.action.quickOpen) Tip: Type kbstyle(?) to view commands suggestions. Typing commands such as edt and term followed by a space will bring up dropdown lists. Navigate between recently opened files Repeat the Quick Open keyboard shortcut to cycle quickly between recently opened files. Open multiple files from Quick Open You can open multiple files from Quick Open by pressing the Right arrow key. This will open the currently selected file in the background and you can continue selecting files from Quick Open . Navigate between recently opened folders and workspaces Open Recent Keyboard Shortcut: kb(workbench.action.openRecent) Displays a Quick Pick dropdown with the list from File > Open Recent with recently opened folders and workspaces followed by files. Command line VS Code has a powerful command line interface (CLI) which allows you to customize how the editor is launched to support various scenarios. Make sure the VS Code binary is on your path so you can simply type 'code' to launch VS Code. See the platform specific setup topics if VS Code is added to your environment path during installation ( Running VS Code on Linux , macOS , Windows ). # open code with current directory code . # open the current directory in the most recently used code window code -r . # create a new window code -n # change the language code --locale=es # open diff editor code --diff <file1> <file2> # open file at specific line and column <file:line[:character]> code --goto package.json:10:5 # see help options code --help # disable all extensions code --disable-extensions . .vscode folder Workspace specific files are in a .vscode folder at the root. For example, tasks.json for the Task Runner and launch.json for the debugger. Status Bar Errors and warnings Keyboard Shortcut: kb(workbench.actions.view.problems) Quickly jump to errors and warnings in the project. Cycle through errors with kb(editor.action.marker.nextInFiles) or kb(editor.action.marker.prevInFiles) You can filter problems either by type ('errors', 'warnings') or text matching. Change language mode Keyboard Shortcut: kb(workbench.action.editor.changeLanguageMode) If you want to persist the new language mode for that file type, you can use the Configure File Association for command to associate the current file extension with an installed language. Customization There are many things you can do to customize VS Code. Change your theme Change your keyboard shortcuts Tune your settings Add JSON validation Create snippets Install extensions Change your theme Keyboard Shortcut: kb(workbench.action.selectTheme) You can install more themes from the VS Code extension Marketplace . Additionally, you can install and change your File Icon themes. Keymaps Are you used to keyboard shortcuts from another editor? You can install a Keymap extension that brings the keyboard shortcuts from your favorite editor to VS Code. Go to Preferences > Keymaps to see the current list on the Marketplace . Some of the more popular ones: Vim Sublime Text Keymap Emacs Keymap Atom Keymap Brackets Keymap Eclipse Keymap Visual Studio Keymap Customize your keyboard shortcuts Keyboard Shortcut: kb(workbench.action.openGlobalKeybindings) You can search for shortcuts and add your own keybindings to the keybindings.json file. See more in Key Bindings for Visual Studio Code . Tune your settings By default VS Code shows the Settings editor, you can find settings listed below in a search bar, but you can still edit the underlying settings.json file by using the Open Settings (JSON) command or by changing your default settings editor with the workbench.settings.editor setting. Open User Settings settings.json Keyboard Shortcut: kb(workbench.action.openSettings) Change the font size of various UI elements // Main editor \"editor.fontSize\": 18, // Terminal panel \"terminal.integrated.fontSize\": 14, // Output panel \"[Log]\": { \"editor.fontSize\": 15 } Change the zoom level \"window.zoomLevel\": 5 Font ligatures \"editor.fontFamily\": \"Fira Code\", \"editor.fontLigatures\": true Tip: You will need to have a font installed that supports font ligatures. FiraCode is a popular font on the VS Code team. Auto Save \"files.autoSave\": \"afterDelay\" You can also toggle Auto Save from the top-level menu with the File > Auto Save . Format on save \"editor.formatOnSave\": true Format on paste \"editor.formatOnPaste\": true Change the size of Tab characters \"editor.tabSize\": 4 Spaces or Tabs \"editor.insertSpaces\": true Render whitespace \"editor.renderWhitespace\": \"all\" Whitespace characters are rendered by default in text selection. Ignore files / folders Removes these files / folders from your editor window. \"files.exclude\": { \"somefolder/\": true, \"somefile\": true } Remove these files / folders from search results. \"search.exclude\": { \"someFolder/\": true, \"somefile\": true } And many, many other customizations . Language specific settings You can scope the settings that you only want for specific languages by the language identifier. You can find a list of commonly used language ids in the Language Identifiers reference. \"[languageid]\": { } Tip: You can also create language specific settings with the Configure Language Specific Settings command. Add JSON validation Enabled by default for many file types. Create your own schema and validation in settings.json \"json.schemas\": [ { \"fileMatch\": [ \"/bower.json\" ], \"url\": \"https://json.schemastore.org/bower\" } ] or for a schema defined in your workspace \"json.schemas\": [ { \"fileMatch\": [ \"/foo.json\" ], \"url\": \"./myschema.json\" } ] or a custom schema \"json.schemas\": [ { \"fileMatch\": [ \"/.myconfig\" ], \"schema\": { \"type\": \"object\", \"properties\": { \"name\" : { \"type\": \"string\", \"description\": \"The name of the entry\" } } } }, See more in the JSON documentation. Extensions Keyboard Shortcut: kb(workbench.view.extensions) Find extensions In the VS Code Marketplace . Search inside VS Code in the Extensions view. View extension recommendations Community curated extension lists, such as awesome-vscode . Install extensions In the Extensions view, you can search via the search bar or click the More Actions (...) button to filter and sort by install count. Extension recommendations In the Extensions view, click Show Recommended Extensions in the More Actions (...) button menu. Creating my own extension Are you interested in creating your own extension? You can learn how to do this in the Extension API documentation , specifically check out the documentation on contribution points . configuration commands keybindings languages debuggers grammars themes snippets jsonValidation Files and folders Integrated Terminal Keyboard Shortcut: kb(workbench.action.terminal.toggleTerminal) Further reading: Integrated Terminal documentation Mastering VS Code's Terminal article Toggle Sidebar Keyboard Shortcut: kb(workbench.action.toggleSidebarVisibility) Toggle Panel Keyboard Shortcut: kb(workbench.action.togglePanel) Zen mode Keyboard Shortcut: kb(workbench.action.toggleZenMode) Enter distraction free Zen mode. Press kbstyle(Esc) twice to exit Zen Mode. Side by side editing Keyboard Shortcut: kb(workbench.action.splitEditor) You can also drag and drop editors to create new editor groups and move editors between groups. Switch between editors Keyboard Shortcut: kb(workbench.action.focusFirstEditorGroup) , kb(workbench.action.focusSecondEditorGroup) , kb(workbench.action.focusThirdEditorGroup) Move to Explorer window Keyboard Shortcut: kb(workbench.view.explorer) Create or open a file Keyboard Shortcut: kbstyle(Ctrl+click) ( kbstyle(Cmd+click) on macOS) You can quickly open a file or image or create a new file by moving the cursor to the file link and using kbstyle(Ctrl+click) . Close the currently opened folder Keyboard Shortcut: kb(workbench.action.closeActiveEditor) Navigation history Navigate entire history: kb(workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup) Navigate back: kb(workbench.action.navigateBack) Navigate forward: kb(workbench.action.navigateForward) File associations Create language associations for files that aren't detected correctly. For example, many configuration files with custom file extensions are actually JSON. \"files.associations\": { \".database\": \"json\" } Preventing dirty writes VS Code will show you an error message when you try to save a file that cannot be saved because it has changed on disk. VS Code blocks saving the file to prevent overwriting changes that have been made outside of the editor. In order to resolve the save conflict, click the Compare action in the error message to open a diff editor that will show you the contents of the file on disk (to the left) compared to the contents in VS Code (on the right): Use the actions in the editor toolbar to resolve the save conflict. You can either Accept your changes and thereby overwriting any changes on disk, or Revert to the version on disk. Reverting means that your changes will be lost. Note: The file will remain dirty and cannot be saved until you pick one of the two actions to resolve the conflict. Editing hacks Here is a selection of common features for editing code. If the keyboard shortcuts aren't comfortable for you, consider installing a keymap extension for your old editor. Tip : You can see recommended keymap extensions in the Extensions view with kb(workbench.extensions.action.showRecommendedKeymapExtensions) which filters the search to @recommended:keymaps . Multi cursor selection To add cursors at arbitrary positions, select a position with your mouse and use kbstyle(Alt+Click) ( kbstyle(Option+click) on macOS). To set cursors above or below the current position use: Keyboard Shortcut: kb(editor.action.insertCursorAbove) or kb(editor.action.insertCursorBelow) You can add additional cursors to all occurrences of the current selection with kb(editor.action.selectHighlights) . Note: You can also change the modifier to kbstyle(Ctrl/Cmd) for applying multiple cursors with the editor.multiCursorModifier setting . See Multi-cursor Modifier for details. If you do not want to add all occurrences of the current selection, you can use kb(editor.action.addSelectionToNextFindMatch) instead. This only selects the next occurrence after the one you selected so you can add selections one by one. Column (box) selection You can select blocks of text by holding kbstyle(Shift+Alt) ( kbstyle(Shift+Option) on macOS) while you drag your mouse. A separate cursor will be added to the end of each selected line. You can also use keyboard shortcuts to trigger column selection. Vertical rulers You can add vertical column rulers to the editor with the editor.rulers setting, which takes an array of column character positions where you'd like vertical rulers. { \"editor.rulers\": [ 20, 40, 60 ] } Fast scrolling Pressing the kbstyle(Alt) key enables fast scrolling in the editor and Explorers. By default, fast scrolling uses a 5X speed multiplier but you can control the multiplier with the Editor: Fast Scroll Sensitivity ( editor.fastScrollSensitivity ) setting. Copy line up / down Keyboard Shortcut: kb(editor.action.copyLinesUpAction) or kb(editor.action.copyLinesDownAction) The commands Copy Line Up/Down are unbound on Linux because the VS Code default keybindings would conflict with Ubuntu keybindings, see Issue #509 . You can still set the commands editor.action.copyLinesUpAction and editor.action.copyLinesDownAction to your own preferred keyboard shortcuts. Move line up and down Keyboard Shortcut: kb(editor.action.moveLinesUpAction) or kb(editor.action.moveLinesDownAction) Shrink / expand selection Keyboard Shortcut: kb(editor.action.smartSelect.shrink) or kb(editor.action.smartSelect.expand) You can learn more in the Basic Editing documentation. Go to Symbol in File Keyboard Shortcut: kb(workbench.action.gotoSymbol) You can group the symbols by kind by adding a colon, @: . Go to Symbol in Workspace Keyboard Shortcut: kb(workbench.action.showAllSymbols) Outline view The Outline view in the File Explorer (default collapsed at the bottom) shows you the symbols of the currently open file. You can sort by symbol name, category, and position in the file and allows quick navigation to symbol locations. Navigate to a specific line Keyboard Shortcut: kb(workbench.action.gotoLine) Undo cursor position Keyboard Shortcut: kb(cursorUndo) Trim trailing whitespace Keyboard Shortcut: kb(editor.action.trimTrailingWhitespace) Transform text commands You can change selected text to uppercase, lowercase, and title case with the Transform commands from the Command Palette. Code formatting Currently selected source code: kb(editor.action.formatSelection) Whole document format: kb(editor.action.formatDocument) Code folding Keyboard Shortcut: kb(editor.fold) and kb(editor.unfold) You can also fold/unfold all regions in the editor with Fold All ( kb(editor.foldAll) ) and Unfold All ( kb(editor.unfoldAll) ). You can fold all block comments with Fold All Block Comments ( kb(editor.foldAllBlockComments) ). Select current line Keyboard Shortcut: kb(expandLineSelection) Navigate to beginning and end of file Keyboard Shortcut: kb(cursorTop) and kb(cursorBottom) Open Markdown preview In a Markdown file, use Keyboard Shortcut: kb(markdown.showPreview) Side by side Markdown edit and preview In a Markdown file, use Keyboard Shortcut: kb(markdown.showPreviewToSide) The preview and editor will synchronize with your scrolling in either view. IntelliSense kb(editor.action.triggerSuggest) to trigger the Suggestions widget. You can view available methods, parameter hints, short documentation, etc. Peek Select a symbol then type kb(editor.action.peekDefinition) . Alternatively, you can use the context menu. Go to Definition Select a symbol then type kb(editor.action.revealDefinition) . Alternatively, you can use the context menu or kbstyle(Ctrl+click) ( kbstyle(Cmd+click) on macOS). You can go back to your previous location with the Go > Back command or kb(workbench.action.navigateBack) . You can also see the type definition if you press kbstyle(Ctrl) ( kbstyle(Cmd) on macOS) when you are hovering over the type. Go to References Select a symbol then type kb(editor.action.goToReferences) . Alternatively, you can use the context menu. Find All References view Select a symbol then type kb(references-view.findReferences) to open the References view showing all your file's symbols in a dedicated view. Rename Symbol Select a symbol then type kb(editor.action.rename) . Alternatively, you can use the context menu. Search and modify Besides searching and replacing expressions, you can also search and reuse parts of what was matched, using regular expressions with capturing groups. Enable regular expressions in the search box by clicking the Use Regular Expression .* button ( kb(toggleSearchRegex) ) and then write a regular expression and use parenthesis to define groups. You can then reuse the content matched in each group by using $1 , $2 , etc. in the Replace field. .eslintrc.json Install the ESLint extension . Configure your linter however you'd like. Consult the ESLint specification for details on its linting rules and options. Here is configuration to use ES6. { \"env\": { \"browser\": true, \"commonjs\": true, \"es6\": true, \"node\": true }, \"parserOptions\": { \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": { \"jsx\": true, \"classes\": true, \"defaultParams\": true } }, \"rules\": { \"no-const-assign\": 1, \"no-extra-semi\": 0, \"semi\": 0, \"no-fallthrough\": 0, \"no-empty\": 0, \"no-mixed-spaces-and-tabs\": 0, \"no-redeclare\": 0, \"no-this-before-super\": 1, \"no-undef\": 1, \"no-unreachable\": 1, \"no-use-before-define\": 0, \"constructor-super\": 1, \"curly\": 0, \"eqeqeq\": 0, \"func-names\": 0, \"valid-typeof\": 1 } } package.json See IntelliSense for your package.json file. Emmet syntax Support for Emmet syntax . Snippets Create custom snippets File > Preferences > User Snippets ( Code > Preferences > User Snippets on macOS), select the language, and create a snippet. \"create component\": { \"prefix\": \"component\", \"body\": [ \"class $1 extends React.Component {\", \"\", \"\\trender() {\", \"\\t\\treturn ($2);\", \"\\t}\", \"\", \"}\" ] }, See more details in Creating your own Snippets . Git integration Keyboard Shortcut: kb(workbench.view.scm) Git integration comes with VS Code \"out-of-the-box\". You can install other SCM providers from the Extension Marketplace. This section describes the Git integration but much of the UI and gestures are shared by other SCM providers. Diffs From the Source Control view, select a file to open the diff. Alternatively, click the Open Changes button in the top right corner to diff the current open file. Views The default view for diffs is the side by side view . Toggle inline view by clicking the More Actions (...) button in the top right and selecting Toggle Inline View . If you prefer the inline view, you can set \"diffEditor.renderSideBySide\": false . Review pane Navigate through diffs with kb(editor.action.diffReview.next) and kb(editor.action.diffReview.prev) . This will present them in a unified patch format. Lines can be navigated with arrow keys and pressing kbstyle(Enter) will jump back in the diff editor and the selected line. Edit pending changes You can make edits directly in the pending changes of the diff view. Branches Easily switch between Git branches via the Status Bar. Staging Stage file changes Hover over the number of files and click the plus button. Click the minus button to unstage changes. Stage selected Stage a portion of a file by selecting that file (using the arrows) and then choosing Stage Selected Ranges from the Command Palette . Undo last commit Click the (...) button and then select Undo Last Commit to undo the previous commit. The changes are added to the Staged Changes section. See Git output VS Code makes it easy to see what Git commands are actually running. This is helpful when learning Git or debugging a difficult source control issue. Use the Toggle Output command ( kb(workbench.action.output.toggleOutput) ) and select Git in the dropdown. Gutter indicators View diff decorations in editor. See documentation for more details. Resolve merge conflicts During a merge, go to the Source Control view ( kb(workbench.view.scm) ) and make changes in the diff view. You can resolve merge conflicts with the inline CodeLens which lets you Accept Current Change , Accept Incoming Change , Accept Both Changes , and Compare Changes . Set VS Code as default merge tool git config --global merge.tool vscode git config --global mergetool.vscode.cmd 'code --wait $MERGED' Set VS Code as default diff tool git config --global diff.tool vscode git config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE' Debugging Configure debugger Open the Command Palette ( kb(workbench.action.showCommands) ) and select Debug: Open launch.json , which will prompt you to select the environment that matches your project (Node.js, Python, C++, etc). This will generate a launch.json file. Node.js support is built-in and other environments require installing the appropriate language extensions. See the debugging documentation for more details. Breakpoints and stepping through Place breakpoints next to the line number. Navigate forward with the Debug widget. Data inspection Inspect variables in the Run panels and in the console. Logpoints Logpoints act much like breakpoints but instead of halting the debugger when they are hit, they log a message to the console. Logpoints are especially useful for injecting logging while debugging production servers that cannot be modified or paused. Add a logpoint with the Add Logpoint command in the left editor gutter and it will be displayed as a \"diamond\" shaped icon. Log messages are plain text but can include expressions to be evaluated within curly braces ('{}'). Task runner Auto detect tasks Select Terminal from the top-level menu, run the command Configure Tasks , then select the type of task you'd like to run. This will generate a tasks.json file with content like the following. See the Tasks documentation for more details. { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"npm\", \"script\": \"install\", \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } There are occasionally issues with auto generation. Check out the documentation for getting things to work properly. Run tasks from the Terminal menu Select Terminal from the top-level menu, run the command Run Task , and select the task you want to run. Terminate the running task by running the command Terminate Task Define keyboard shortcuts for tasks You can define a keyboard shortcut for any task. From the Command Palette ( kb(workbench.action.showCommands) ), select Preferences: Open Keyboard Shortcuts File , bind the desired shortcut to the workbench.action.tasks.runTask command, and define the Task as args . For example, to bind kbstyle(Ctrl+H) to the Run tests task, add the following: { \"key\": \"ctrl+h\", \"command\": \"workbench.action.tasks.runTask\", \"args\": \"Run tests\" } Run npm scripts as tasks from the Explorer From the explorer you can open a script in the editor, run it as a task, and launch it with the node debugger (when the script defines a debug option like --inspect-brk ). The default action on click is to open the script. To run a script on a single click, set npm.scriptExplorerAction to \"run\". Use the setting npm.exclude to exclude scripts in package.json files contained in particular folders. With the setting npm.enableRunFromFolder , you can enable to run npm scripts from the File Explorer's context menu for a folder. The setting enables the command Run NPM Script in Folder... when a folder is selected. The command shows a Quick Pick list of the npm scripts contained in this folder and you can select the script to be executed as a task. Portable mode VS Code has a Portable mode which lets you keep settings and data in the same location as your installation, for example, on a USB drive. Insiders builds The Visual Studio Code team uses the Insiders version to test the latest features and bug fixes of VS Code. You can also use the Insiders version by downloading it here . For Early Adopters - Insiders has the most recent code changes for users and extension authors to try out. Frequent Builds - New builds every day with the latest bug fixes and features. Side-by-side install - Insiders installs next to the Stable build allowing you to use either independently."
  },
  "guides/vscode/getstarted/userinterface.html": {
    "href": "guides/vscode/getstarted/userinterface.html",
    "title": "User Interface | Fountain of Knowledge",
    "keywords": "User Interface At its heart, Visual Studio Code is a code editor. Like many other code editors, VS Code adopts a common user interface and layout of an explorer on the left, showing all of the files and folders you have access to, and an editor on the right, showing the content of the files you have opened. Basic Layout VS Code comes with a simple and intuitive layout that maximizes the space provided for the editor while leaving ample room to browse and access the full context of your folder or project. The UI is divided into five areas: Editor - The main area to edit your files. You can open as many editors as you like side by side vertically and horizontally. Side Bar - Contains different views like the Explorer to assist you while working on your project. Status Bar - Information about the opened project and the files you edit. Activity Bar - Located on the far left-hand side, this lets you switch between views and gives you additional context-specific indicators, like the number of outgoing changes when Git is enabled. Panels - You can display different panels below the editor region for output or debug information, errors and warnings, or an integrated terminal. Panel can also be moved to the right for more vertical space. Each time you start VS Code, it opens up in the same state it was in when you last closed it. The folder, layout, and opened files are preserved. Open files in each editor are displayed with tabbed headers (Tabs) at the top of the editor region. To learn more about tabbed headers, see the Tabs section below. Tip: You can move the Side Bar to the right hand side ( View > Move Side Bar Right ) or toggle its visibility ( kb(workbench.action.toggleSidebarVisibility) ). Side by side editing You can open as many editors as you like side by side vertically and horizontally. If you already have one editor open, there are multiple ways of opening another editor to the side of the existing one: kbstyle(Alt) click on a file in the Explorer. kb(workbench.action.splitEditor) to split the active editor into two. Open to the Side ( kb(explorer.openToSide) ) from the Explorer context menu on a file. Click the Split Editor button in the upper right of an editor. Drag and drop a file to any side of the editor region. kbstyle(Ctrl+Enter) (macOS: kbstyle(Cmd+Enter) ) in the Quick Open ( kb(workbench.action.quickOpen) ) file list. Whenever you open another file, the editor that is active will display the content of that file. So if you have two editors side by side and you want to open file 'foo.cs' into the right-hand editor, make sure that editor is active (by clicking inside it) before opening file 'foo.cs'. By default editors will open to the right-hand side of the active one. You can change this behavior through the setting workbench.editor.openSideBySideDirection and configure to open new editors to the bottom of the active one instead. When you have more than one editor open you can switch between them quickly by holding the kbstyle(Ctrl) (macOS: kbstyle(Cmd) ) key and pressing kbstyle(1) , kbstyle(2) , or kbstyle(3) . Tip: You can resize editors and reorder them. Drag and drop the editor title area to reposition or resize the editor. Minimap A Minimap (code outline) gives you a high-level overview of your source code, which is useful for quick navigation and code understanding. A file's minimap is shown on the right side of the editor. You can click or drag the shaded area to quickly jump to different sections of your file. Tip: You can move the minimap to the left hand side or disable it completely by respectively setting \"editor.minimap.side\": \"left\" or \"editor.minimap.enabled\": false in your user or workspace settings . Indent Guides The image above also shows indentation guides (vertical lines) which help you quickly see matching indent levels. If you would like to disable indent guides, you can set \"editor.renderIndentGuides\": false in your user or workspace settings . Breadcrumbs The editor has a navigation bar above its contents called Breadcrumbs . It shows the current location and allows you to quickly navigate between folders, files, and symbols. Breadcrumbs always show the file path and if the current file type has language support for symbols, the symbol path up to the cursor position. You can disable breadcrumbs with the View > Show Breadcrumbs toggle command. For more information about the breadcrumbs feature, such as how to customize their appearance, see the Breadcrumbs section of the Code Navigation article. Explorer The Explorer is used to browse, open, and manage all of the files and folders in your project. VS Code is file and folder based - you can get started immediately by opening a file or folder in VS Code. After opening a folder in VS Code, the contents of the folder are shown in the Explorer. You can do many things from here: Create, delete, and rename files and folders. Move files and folders with drag and drop. Use the context menu to explore all options. Tip: You can drag and drop files into the Explorer from outside VS Code to copy them (if the explorer is empty VS Code will open them instead) VS Code works very well with other tools that you might use, especially command-line tools. If you want to run a command-line tool in the context of the folder you currently have open in VS Code, right-click the folder and select Open in Command Prompt (or Open in Terminal on macOS or Linux). You can also navigate to the location of a file or folder in the native Explorer by right-clicking on a file or folder and selecting Reveal in Explorer (or Reveal in Finder on macOS or Open Containing Folder on Linux). Tip: Type kb(workbench.action.quickOpen) ( Quick Open ) to quickly search and open a file by its name. By default, VS Code excludes some folders from the Explorer (for example. .git ). Use the files.exclude setting to configure rules for hiding files and folders from the Explorer. Tip: This is really useful to hide derived resources files, like \\*.meta in Unity, or \\*.js in a TypeScript project. For Unity to exclude the \\*.cs.meta files, the pattern to choose would be: \"**/*.cs.meta\": true . For TypeScript, you can exclude generated JavaScript for TypeScript files with: \"**/*.js\": {\"when\": \"$(basename).ts\"} . Multi-selection You can select multiple files in the File Explorer and OPEN EDITORS view to run actions (Delete, Drag and Drop, Open to the Side) on multiple items. Use the Ctrl/Cmd key with click to select individual files and Shift + click to select a range. If you select two items, you can now use the context menu Compare Selected command to quickly diff two files. Note: In earlier VS Code releases, clicking with the Ctrl/Cmd key pressed would open a file in a new Editor Group to the side. If you would still like this behavior, you can use the workbench.list.multiSelectModifier setting to change multi-selection to use the Alt key. \"workbench.list.multiSelectModifier\": \"alt\" Filtering the document tree You can type to filter the currently visible files in the File Explorer . With the focus on the File Explorer start to type part of the file name you want to match. You will see a filter box in the top-right of the File Explorer showing what you have typed so far and matching file names will be highlighted. When you press the cursor keys to move up and down the file list, it will jump between matching files or folders. Hovering over the filter box and selecting Enable Filter on Type will show only matching files/folders. Use the 'X' Clear button to clear the filter. Outline view The Outline view is a separate section in the bottom of the File Explorer. When expanded, it will show the symbol tree of the currently active editor. The Outline view has different Sort By modes, optional cursor tracking, and supports the usual open gestures. It also includes an input box which finds or filters symbols as you type. Errors and warnings are also shown in the Outline view, letting you see at a glance a problem's location. For symbols, the view relies on information computed by your installed extensions for different file types. For example, the built-in Markdown support returns the Markdown header hierarchy for a Markdown file's symbols. There are several Outline view settings which allow you to enable/disable icons and control the errors and warnings display (all enabled by default): outline.icons - Toggle rendering outline elements with icons. outline.problems.enabled - Show errors and warnings on outline elements. outline.problems.badges - Toggle using badges for errors and warnings. outline.problems.colors - Toggle using colors for errors and warnings. Open Editors At the top of the Explorer is a view labeled OPEN EDITORS . This is a list of active files or previews. These are files you previously opened in VS Code that you were working on. For example, a file will be listed in the OPEN EDITORS view if you: Make a change to a file. Double-click a file's header. Double-click a file in the Explorer. Open a file that is not part of the current folder. Just click an item in the OPEN EDITORS view, and it becomes active in VS Code. Once you are done with your task, you can remove files individually from the OPEN EDITORS view, or you can remove all files by using the View: Close All Editors or View: Close All Editors in Group actions. Views The File Explorer is just one of the Views available in VS Code. There are also Views for: Search - Provides global search and replace across your open folder. Source Control - VS Code includes Git source control by default. Run - VS Code's Run and Debug View displays variables, call stacks, and breakpoints. Extensions - Install and manage your extensions within VS Code. Custom views - Views contributed by extensions. Tip: You can open any view using the View: Open View command. You can show or hide views from within the main view and also reorder them by drag and drop. Activity Bar The Activity Bar on the left lets you quickly switch between Views. You can also reorder Views by dragging and dropping them on the Activity Bar or remove a View entirely (right click Hide from Activity Bar ). Command Palette VS Code is equally accessible from the keyboard. The most important key combination to know is kb(workbench.action.showCommands) , which brings up the Command Palette . From here, you have access to all of the functionality of VS Code, including keyboard shortcuts for the most common operations. The Command Palette provides access to many commands. You can execute editor commands, open files, search for symbols, and see a quick outline of a file, all using the same interactive window. Here are a few tips: kb(workbench.action.quickOpen) will let you navigate to any file or symbol by typing its name kb(workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup) will cycle you through the last set of files opened kb(workbench.action.showCommands) will bring you directly to the editor commands kb(workbench.action.gotoSymbol) will let you navigate to a specific symbol in a file kb(workbench.action.gotoLine) will let you navigate to a specific line in a file Type ? into the input field to get a list of available commands you can execute from here: Configuring the editor VS Code gives you many options to configure the editor. From the View menu, you can hide or toggle various parts of the user interface, such as the Side Bar , Status Bar , and Activity Bar . Hide the Menu Bar (Windows, Linux) You can hide the Menu Bar on Windows and Linux by changing the setting window.menuBarVisibility from classic to toggle . A setting of toggle means that a single press of the kbstyle(Alt) key will show the Menu Bar again. You can also hide the Menu Bar on Windows and Linux with the View > Toggle Menu Bar command. This command sets window.menuBarVisibility from classic to compact , resulting in the Menu Bar moving into the Activity Bar. To return the Menu Bar to the classic position, you can execute the View > Toggle Menu Bar command again. Settings Most editor configurations are kept in settings which can be modified directly. You can set options globally through user settings or per project/folder through workspace settings. Settings values are kept in a settings.json file . Select File > Preferences > Settings (or press kb(workbench.action.openSettings) ) to edit the user settings.json file. To edit workspace settings, select the WORKSPACE SETTINGS tab to edit the workspace settings.json file. Note for macOS users: The Preferences menu is under Code not File . For example, Code > Preferences > Settings . You will see the VS Code Default Settings in the left window and your editable settings.json on the right. You can easily filter settings in the Default Settings using the search box at the top. Copy a setting over to the editable settings.json on the right by clicking on the edit icon to the left of the setting. Settings with a fixed set of values allow you to pick a value as part of their edit icon menu. After editing your settings, type kb(workbench.action.files.save) to save your changes. The changes will take effect immediately. Note: Workspace settings will override User settings and are useful for sharing project specific settings across a team. Zen Mode Zen Mode lets you focus on your code by hiding all UI except the editor (no Activity Bar, Status Bar, Side Bar and Panel), going to full screen and centering the editor layout. Zen mode can be toggled using View menu, Command Palette or by the shortcut kb(workbench.action.toggleZenMode) . Double kbstyle(Esc) exits Zen Mode. The transition to full screen can be disabled via zenMode.fullScreen . Zen Mode can be further tuned by the following settings: zenMode.hideStatusBar , zenMode.hideTabs , zenMode.fullScreen , zenMode.restore , and zenMode.centerLayout . Centered editor layout Centered editor layout allows you to center align the editor area. This is particularly useful when working with a single editor on a large monitor. You can use the sashes on the side to resize the view (hold down the Alt key to independently move the sashes). Tabs Visual Studio Code shows open items with Tabs (tabbed headings) in the title area above the editor. When you open a file, a new Tab is added for that file. Tabs let you quickly navigate between items and you can Drag and Drop Tabs to reorder them. When you have more open items than can fit in the title area, you can use the Show Opened Editors command (available through the ... More button) to display a dropdown list of tabbed items. If you don't want to use Tabs, you can disable the feature by setting the workbench.editor.showTabs setting to false: \"workbench.editor.showTabs\": false See the section below to optimize VS Code when working without Tabs . Tab ordering By default, new Tabs are added to the right of the existing Tabs but you can control where you'd like new Tabs to appear with the workbench.editor.openPositioning setting. For example, you might like new tabbed items to appear on the left: \"workbench.editor.openPositioning\": \"left\" Preview mode When you single-click or select a file in the Explorer, it is shown in a preview mode and reuses an existing Tab. This is useful if you are quickly browsing files and don't want every visited file to have its own Tab. When you start editing the file or use double-click to open the file from the Explorer, a new Tab is dedicated to that file. Preview mode is indicated by italics in the Tab heading: If you'd prefer to not use preview mode and always create a new Tab, you can control the behavior with these settings: workbench.editor.enablePreview to globally enable or disable preview editors workbench.editor.enablePreviewFromQuickOpen to enable or disable preview editors when opened from Quick Open Editor Groups When you split an editor (using the Split Editor or Open to the Side commands), a new editor region is created which can hold a group of items. You can open as many editor regions as you like side by side vertically and horizontally. You can see these clearly in the OPEN EDITORS section at the top of the Explorer view: You can Drag and Drop editor groups on the workbench, move individual Tabs between groups and quickly close entire groups ( Close All ). Note: VS Code uses editor groups whether or not you have enabled Tabs. Without Tabs, editor groups are a stack of your open items with the most recently selected item visible in the editor pane. Grid editor layout By default, editor groups are laid out in vertical columns (for example when you split an editor to open it to the side). You can easily arrange editor groups in any layout you like, both vertically and horizontally: To support flexible layouts, you can create empty editor groups. By default, closing the last editor of an editor group will also close the group itself, but you can change this behavior with the new setting workbench.editor.closeEmptyGroups: false : There are a predefined set of editor layouts in the new View > Editor Layout menu: Editors that open to the side (for example by clicking the editor toolbar Split Editor action) will by default open to the right-hand side of the active editor. If you prefer to open editors below the active one, configure the new setting workbench.editor.openSideBySideDirection: down . There are many keyboard commands for adjusting the editor layout with the keyboard alone, but if you prefer to use the mouse, drag and drop is a fast way to split the editor into any direction: Pro Tip : If you press and hold the Alt key while hovering over the toolbar action to split an editor, it will offer to split to the other orientation. This is a fast way to split either to the right or to the bottom. Keyboard shortcuts Here are some handy keyboard shortcuts to quickly navigate between editors and editor groups. If you'd like to modify the default keyboard shortcuts, see Key Bindings for details. kb(workbench.action.nextEditor) go to the right editor. kb(workbench.action.previousEditor) go to the left editor. kb(workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup) open the previous editor in the editor group MRU list. kb(workbench.action.focusFirstEditorGroup) go to the leftmost editor group. kb(workbench.action.focusSecondEditorGroup) go to the center editor group. kb(workbench.action.focusThirdEditorGroup) go to the rightmost editor group. kb(workbench.action.closeActiveEditor) close the active editor. kb(workbench.action.closeEditorsInGroup) close all editors in the editor group. kb(workbench.action.closeAllEditors) close all editors. Working without Tabs If you prefer not to use Tabs (tabbed headings), you can disable Tabs (tabbed headings) entirely by setting workbench.editor.showTabs to false. Disable Preview mode Without Tabs, the OPEN EDITORS section of the File Explorer is a quick way to do file navigation. With preview editor mode , files are not added to the OPEN EDITOR list nor editor group on single-click open. You can disable this feature through the workbench.editor.enablePreview and workbench.editor.enablePreviewFromQuickOpen settings. Ctrl+Tab to navigate in entire editor history You can change keybindings for kbstyle(Ctrl+Tab) to show you a list of all opened editors from the history independent from the active editor group. Edit your keybindings and add the following: { \"key\": \"ctrl+tab\", \"command\": \"workbench.action.openPreviousEditorFromHistory\" }, { \"key\": \"ctrl+tab\", \"command\": \"workbench.action.quickOpenNavigateNext\", \"when\": \"inQuickOpen\" }, Close an entire group instead of a single editor If you liked the behavior of VS Code closing an entire group when closing one editor, you can bind the following in your keybindings . macOS: { \"key\": \"cmd+w\", \"command\": \"workbench.action.closeEditorsInGroup\" } Windows/Linux: { \"key\": \"ctrl+w\", \"command\": \"workbench.action.closeEditorsInGroup\" } Window management VS Code has some options to control how windows (instances) should be opened or restored between sessions. The settings window.openFoldersInNewWindow and window.openFilesInNewWindow are provided to configure opening new windows or reusing the last active window for files or folders and possible values are default , on and off . If configured to be default , we will make the best guess about reusing a window or not based on the context from where the open request was made. Flip this to on or off to always behave the same. For example, if you feel that picking a file or folder from the File menu should always open into a new window, set this to on . Note: There can still be cases where this setting is ignored (for example, when using the -new-window or -reuse-window command-line option). The window.restoreWindows setting tells VS Code how to restore the opened windows of your previous session. By default, VS Code will restore all windows you worked on during your previous session (setting: all ). Change this setting to none to never reopen any windows and always start with an empty VS Code instance. Change it to one to reopen the last opened window you worked on or folders to only restore windows that had folders opened. Next steps Now that you know the overall layout of VS Code, start to customize the editor to how you like to work by looking at the following topics: Changing the Theme - Set a Color and/or File Icon theme to your preference. Common questions How can I change the color of the indent guides? The indent guide colors are customizable as are most VS Code UI elements. To customize the indent guides color for your active color theme, use the workbench.colorCustomizations setting and modify the editorIndentGuide.background value. For example, to make the indent guides bright blue, add the following to your settings.json : \"workbench.colorCustomizations\": { \"editorIndentGuide.background\": \"#0000ff\" } Can I hide the OPEN EDITORS section in the Explorer? Yes, you can hide the OPEN EDITORS list with the explorer.openEditors.visible setting , which declares how many items to display before a scroll bar appears. Setting \"explorer.openEditors.visible\": 0 will hide OPEN EDITORS when you have an open folder. The list will still be displayed if you are using VS Code to view individual loose files, since they won't be displayed in the folder pane."
  },
  "guides/vscode/index.html": {
    "href": "guides/vscode/index.html",
    "title": "Visual Studio Code | Fountain of Knowledge",
    "keywords": "Visual Studio Code"
  },
  "guides/vscode/introvideos/basics.html": {
    "href": "guides/vscode/introvideos/basics.html",
    "title": "Getting started with Visual Studio Code | Fountain of Knowledge",
    "keywords": "Getting started with Visual Studio Code In this tutorial, we walk you through setting up Visual Studio Code and give an overview of the basic features. Next video: Code Editing in Visual Studio Code Video outline Download and install VS Code. Create a new file. See an overview of the user interface. Install support for your favorite programming language. Change your keyboard shortcuts and easily migrate from other editors using keybinding extensions. Customize your editor with themes. Explore VS Code features in the Interactive Editor Playground . Next video Code Editing in Visual Studio Code - Learn about the advanced code editing features in VS Code. Related resources User Interface - View the documentation for VS Code. Setup Overview - Documentation for getting up and running with VS Code, including platform specific setup. Keyboard Shortcuts - Customize your own shortcuts, download a reference sheet, or install a Keymap extension. Keybinding extensions - Install a Keymap extension to bring the keybindings from your previous editor to VS Code."
  },
  "guides/vscode/introvideos/codeediting.html": {
    "href": "guides/vscode/introvideos/codeediting.html",
    "title": "Code editing in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Code editing in Visual Studio Code In this Visual Studio Code tutorial, we cover how to edit and run a small piece of code, including the features outlined below. After viewing this overview, read on in the Learn More section to see more features. Next video: Personalize Visual Studio Code Video outline Open a folder Create a new file Create a simple \"Hello world\" console log using Node.js Turn on Auto Save Automatically format your code Hover over elements to see IntelliSense in action Run code in the Integrated Terminal Next video Personalize Visual Studio Code - Learn how to personalize VS Code to your work style with themes. Related resources Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Emmet Snippets - Use Emmet Snippets. Tasks - Create tasks to use external tools inside VS Code. JavaScript Linters - Install linters for JavaScript. Code Folding - See the details of source code folding. Tips and Tricks - Helpful tips and tricks for VS Code."
  },
  "guides/vscode/introvideos/configure.html": {
    "href": "guides/vscode/introvideos/configure.html",
    "title": "Personalize Visual Studio Code | Fountain of Knowledge",
    "keywords": "Personalize Visual Studio Code In this Visual Studio Code tutorial, we show you how to personalize Visual Studio Code with themes. Next video: Extensions in Visual Studio Code Video outline Change your Color Theme. Install a new Color Theme from the VS Code Extension Marketplace. Change your File Icon Theme. Next video Extensions in Visual Studio Code - Add features to VS Code through Extensions. Related resources User and Workspace Settings - Configure user and workspace settings. Key Bindings - See the default keyboard shortcuts (key bindings) for editing, navigation, and more. Snippets - Create your own custom snippets. Themes - Change your Color Theme to customize VS Code's background text and language syntax colorization."
  },
  "guides/vscode/introvideos/customize.html": {
    "href": "guides/vscode/introvideos/customize.html",
    "title": "Customize Visual Studio Code | Fountain of Knowledge",
    "keywords": "Customize Visual Studio Code In this Visual Studio Code tutorial, we show you how to customize Visual Studio Code with settings and keyboard shortcuts. Next video: Productivity Tips Video outline Find a keyboard shortcut in the Command Palette Learn about common keyboard shortcuts Change a keyboard shortcut using the keyboard shortcut editor Use a JSON file to customize keyboard shortcuts Learn about keyboard shortcut extensions Customize your settings using the settings editor Use a JSON file to customize settings Configure language specific settings Related resources Key Bindings for Visual Studio Code - See a list of defined keyboard shortcuts and learn how to update them. User and Workspace Settings - Learn how to customize user and workspace settings."
  },
  "guides/vscode/introvideos/debugging.html": {
    "href": "guides/vscode/introvideos/debugging.html",
    "title": "Debugging in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Debugging in Visual Studio Code Debugging is a core feature of Visual Studio Code. In this tutorial, we will show you how to run and debug a program in VS Code. We’ll take a tour of the Run View, explore some debugging features, and end by setting a breakpoint. Tip: To use the debugging features demonstrated in this video for Node.js, you will need to first install Node.js . To follow along with the Python portion of the video, you'll need to install Python . Next video: Version Control Video outline Debugging that \"just works\". Run a sample Node.js app. Use a launch.json configuration file. Single file debugging. Set a breakpoint. Next video Version Control - Learn the basics of Git version control. Related resources Debugging - Official documentation for VS Code debugging. Integrated Terminal - Use the integrated terminal inside VS Code."
  },
  "guides/vscode/introvideos/extend.html": {
    "href": "guides/vscode/introvideos/extend.html",
    "title": "Using extensions in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Using extensions in Visual Studio Code Use Visual Studio Code extensions to add new features, themes and more. In this tutorial, we will show you how to find extensions, install the ones you like, and disable extensions you don't want to use all the time. Next video: Debugging Video outline Find extensions to install using the Extensions view. Install an extension from the VS Code Extension Marketplace. See what features are added via the Features Contributions tab or Command Palette ( kb(workbench.action.showCommands) ). See recommendations for other extensions. Next video Debugging - Learn how to debug your application, including setting breakpoints and inspecting variables. Related resources Extension Marketplace Documentation - Official documentation for the VS Code Extension Marketplace. Marketplace - Browse extensions online."
  },
  "guides/vscode/introvideos/productivity.html": {
    "href": "guides/vscode/introvideos/productivity.html",
    "title": "Productivity Tips | Fountain of Knowledge",
    "keywords": "Productivity Tips In this Visual Studio Code tutorial, we describe Visual Studio Code features that help increase your coding productivity. Learning just a few tips can speed up your workflow and help you discover the full power of the VS Code editor. Video outline Find features and keyboard shortcuts in the Command Palette Quick open recent files or search by filename Go to Line or Go to Symbol in a file Multi-cursor selection Auto Save changes Format On Type and Format On Paste IntelliSense smart code completions Related resources Tips and Tricks - Learn more productivity tips and tricks. Code Editing - Discover the full power of the VS Code editor. IntelliSense - Smart code completions and methods signatures."
  },
  "guides/vscode/introvideos/quicktour.html": {
    "href": "guides/vscode/introvideos/quicktour.html",
    "title": "Quick tour of VS Code using JavaScript | Fountain of Knowledge",
    "keywords": "Quick tour of VS Code using JavaScript This tutorial gives you an overview of the core features of Visual Studio Code, including IntelliSense, debugging, Git version control integration, and more. You'll see these features as we add an endpoint to a JavaScript web app using Express web framework . Outline See IntelliSense in action. Start and run the debugger. Commit source code changes with Git integration. Run shell commands in the Integrated Terminal . Add new features with VS Code extensions. Learn more IntelliSense - Learn more about IntelliSense and how to use it effectively for your language. JavaScript IntelliSense - Define a JavaScript project with jsconfig.json to get IntelliSense across files. Debugging - Official documentation for VS Code debugging. Extension Marketplace - Find and install new extensions. Integrated Terminal - Use the Integrated Terminal inside VS Code. Next video Setup and Basics - Install and learn the basics of your new editor."
  },
  "guides/vscode/introvideos/versioncontrol.html": {
    "href": "guides/vscode/introvideos/versioncontrol.html",
    "title": "Version control in VS Code | Fountain of Knowledge",
    "keywords": "Version control in VS Code In this tutorial, we will learn how to use the basics of Git version control in Visual Studio Code. For more information about integrated Git support, including how to work with remote repositories, read on in the related resources section below. Next video: Customize Video outline Create a branch Change branches View diffs between two files in side by side and inline views Stage and clean changes Commit to your local branch Merge local branches Next video Customize - Customize VS Code with settings and keyboard shortcuts. Related resources Version Control - Read more about integrated Git support. Setup Overview - Set up and start using VS Code."
  },
  "guides/vscode/java/extensions.html": {
    "href": "guides/vscode/java/extensions.html",
    "title": "Java extensions for Visual Studio Code | Fountain of Knowledge",
    "keywords": "Java extensions for Visual Studio Code Visual Studio Code provides many features as a Java language editor. You can also install VS Code extensions to add more features for Java development. Tip: To learn how to install and manage your extensions, refer to the extension documentation . Thanks to the great Java community around VS Code, you can search for a large number of Java extensions easily within VS Code: Go to the Extensions view ( kb(workbench.view.extensions) ). Filter the extensions list by typing \"java\". Recommended extensions To help set up Java on VS Code, there is the Microsoft Java Extension Pack , which contains these popular extensions: Language Support for Java(TM) by Red Hat Debugger for Java Java Test Runner Maven for Java Project Manager for Java Visual Studio IntelliCode Install the Java Extension Pack There are also great extensions provided by Pivotal and Microsoft for Spring Boot development, including: Spring Boot Tools Spring Initializr Java Support Spring Boot Dashboard Popular extensions from the community Thanks to the great Java community around VS Code, there are many great community-created extensions as well. You can search for more Java extensions easily within the VS Code: Go to the Extensions view ( kb(workbench.view.extensions) ). Filter the extensions list by typing 'java'. Here are a few useful extensions: Tomcat Jetty Server Connector Community Server Connectors Extension Pack for MicroProfile CheckStyle SonarLint Java Decompiler Lombok Annotations Support Java Properties Bazel We also appreciate contributions to any of our existing extensions and we hope you'll create new Java extensions if you don't find what you're looking for in the Marketplace. We're especially looking for help in areas such as support for Gradle and other Java application servers. Recommended extensions with great Java support We'd also like to recommend a couple of other extensions we believe are great to make VS Code even better for Java developers. Live Share is a great tool to use when you need to collaborate with someone else on the same code base. The Remote Development extensions let you use VS Code to access a container, a remote machine, or the Windows Subsystem for Linux. Extension for container development You can use Docker extension to build docker images and work with image registries. Kubernetes extension provides an explorer view to manage clusters and the nodes inside. It also provides advanced syntax support for editing Kubernetes manifest files. Recommended extensions for cloud (Azure) development Team development The Azure Repos extension makes it easy to connect to your Azure DevOps Servers, allowing you to easily monitor builds, pull requests, and work items for your TFVC or Git source repositories. Internet of Things The Azure IoT Toolkit for VS Code makes it easy to develop and connect your IoT applications to Azure . With this extension, you can interact with Azure IoT Hub, manage devices connected to Azure IoT Hub, and develop with code snippets for Azure IoT Hub. General tools The Azure Tools Extension Pack provides a rich set of extensions that makes it easy to discover and interact with Azure services to power your applications. The Azure Resource Manager Tools provide a rich editing experience for Azure Resource Manager deployment templates and template language expressions. For example, IntelliSense for TLE function names, parameter references, signature help, Go to Definition, Peek Definition, and Peek References as well as Errors and Warnings, making it quick and easy to author Azure Resource Manager templates in VS Code. Visit Azure Extensions to find more Azure extensions."
  },
  "guides/vscode/java/java-build.html": {
    "href": "guides/vscode/java/java-build.html",
    "title": "Java build tools in VS Code | Fountain of Knowledge",
    "keywords": "Java build tools in VS Code This document will give you an overview of how work with your Java build tools in Visual Studio Code. It covers the Maven for Java extension as well as other tools. If you run into any issues when using the features below, you can contact us by clicking the Report an issue button below. Report an issue Maven Maven is a software tool that helps you manage Java projects and automate application builds. The Maven for Java extension for Visual Studio Code provides fully integrated Maven support, allowing you to explore Maven projects, execute Maven commands, and perform the goals of build lifecycle and plugins. Install the Maven for Java extension Exploring Maven project Once a Maven project is loaded, the extension will be activated and it will automatically scan for pom.xml files in your workspace and displays all Maven projects and their modules in the side bar. Resolve unknown type The Maven extension also supports searching Maven Central to resolve unknown types in your source code. You can do this by selecting the Resolve unknown type link shown on hover. Working with POM.xml The extension provides code snippets and auto completion for adding Maven dependencies based on local Maven repositories. See how easy it is to add a new dependency to your pom.xml with those convenient features. The extension also enables you to generate effective POM. You can also use the command Maven: Add a Dependency (or maven.project.addDependency ) to help add a new dependency to pom.xml . The process is interactive. You can also add dependencies through the project view, which calls the same Maven command. Furthermore, VS Code also supports showing dependencies in a tree view, which allows you to inspect all dependencies in your project at a single place and check for potential issues. Execute Maven commands and goals By right-clicking each Maven project in the explorer, you can conveniently run Maven goals. The extension also preserves the history of goals for each project, so you can quickly rerun the previous command, which is useful when you're running a long custom goal. There are two ways to rerun a goal: Command Palette > Select Maven: History > Select a project > Select command from the history. Right-click a project > Click History > Select command from history. You can also specify your favorite commands in settings for future execution. For each plug-in you use with your project, the extension also provides you an easy way to access the goals within each plugin. To debug Maven goals, right-click on a goal and start debugging. The Maven extension will call the Java debugger with the right parameters. This is a handy, time-saving feature. Generate project from Maven Archetype Another handy feature provided by this extension is to generate a Maven project from Archetype . The extension loads archetypes listed in local/remote catalogs. After selection, the extension sends mvn archetype:generate -D... to the terminal. There are two ways to generate a Maven project: From the Maven explore, click + . Right-click on a folder and select Generate from Maven Archetype . Gradle VS Code supports basic Gradle Java project (not including Android). There are also a couple third party extensions available for writing .gradle files as well as running Gradle tasks. Gradle Language Support Gradle Tasks Additional resources Visit the GitHub Repo of the Maven extension for additional configurations and a troubleshooting guide . In addition to Maven, there's also a Bazel extension if you use Bazel to build and test your project. Next steps Read on to find out more about: Java Editing - Explore the editing features for Java in VS Code. Java Debugging - Find out how to debug your Java project with VS Code. Java Testing - Use VS Code for your JUnit and TestNG cases. Java Extensions - Learn about more useful Java extensions for VS Code."
  },
  "guides/vscode/java/java-debugging.html": {
    "href": "guides/vscode/java/java-debugging.html",
    "title": "Running and debugging Java | Fountain of Knowledge",
    "keywords": "Running and debugging Java Visual Studio Code allows you to debug Java applications through the Debugger for Java extension. It's a lightweight Java debugger based on Java Debug Server , which extends the Language Support for Java by Red Hat . Here's a list of supported debugging features: Launch/Attach Breakpoints Exceptions Pause & Continue Step In/Out/Over Variables Call Stacks Threads Debug Console Evaluation Hot Code Replace The Java debugger is an open-source project, which welcomes contributors to collaborate through GitHub repositories: Debugger for Java Extension Java Debugger Server for Visual Studio Code If you run into any issues when using the features below, you can contact us by clicking the Report an issue button below. Report an issue Install For the debugger to work, you also need to have the Language Support for Java(TM) by Red Hat extension installed. To make it easier, there is a Java Extension Pack , which bundles the Language Support for Java(TM) by Red Hat , the Debugger for Java and several other popular Java extensions . You can manually install the extension pack from the Extensions view ( kb(workbench.view.extensions) ) by typing vscode-java-pack in the search box. You will also be prompted to install the Java Extension Pack when you edit a Java file in VS Code for the first time. For more details, please read Java tutorial . Configure By default, the debugger will run out-of-box by automatically finding the main class and generate the default configuration for you to launch your application. If you would like to create your configuration and save it, you can click the create a launch.json file link in the Run view where you will also find the Debug and Run buttons. The launch.json file is located in a .vscode folder in your workspace (project root folder) or in your user settings or workspace settings . It's possible to create multiple debugging configurations for your project and select the desired one to run. If you want to debug current file , there is a convenient setting, so the editor will choose currently active file as the entry point. For more details on how to create the launch.json , please read Launch configurations ; for more details on configuraiton options for Java, please read Configuration options . Use To run and debug your Java application, there are several entry points for starting a debugging session. CodeLens You will find Run|Debug on the CodeLens of your main() function. You can disable the CodeLens if you prefer, with the Enable Run Debug CodeLens setting. While CodeLens is disabled, you can still access the Run|Debug actions by hovering over your main() function. Context menu Another way to start debugging is to right-click a Java file in the File Explorer or editor and select Run or Debug in the context menu. Pressing F5 Pressing kb(workbench.action.debug.start) , the debugger will automatically find the entry point of your project and start debugging. You can also start a debugging session from the Run menu or the Run view opened by the Run icon in the Activity Bar on the side of VS Code. See more at Debugging in VS Code . Debugging single files VS Code can run and debug single Java files without any project. Debugging external files The Java debugger also supports external source files. This lets you debug third-party classes when they are inside a JAR or a source attachment. Set your breakpoints in those classes before you start debugging. You can also attach missing source code with a zip/jar file using the Context menu Attach Source action. Java 9 and newer versions are supported with VS Code Java Debugger as well. Threads You can see all the running threads in the Call Stack pane and work with individual thread using the context menu. Debug session inputs The default Debug Console in VS Code doesn't support inputs. If your program need inputs from a terminal, you can use the Integrated Terminal ( kb(workbench.action.terminal.toggleTerminal) ) within VS Code or an external terminal to launch it. Step filtering Step filter is supported by the extension to filter out types that you do not want to see or step through while debugging. With this feature, you can configure the packages to filter within your launch.json so they could be skipped when you step through. Expression evaluation The debugger also lets you evaluate expressions in the WATCH window as well as the Debug Console. You can also use this feature for conditional breakpoint setting. Currently, the VS Code Java Debugger uses the Integrated Terminal as the default console, which doesn't support expression evaluation. In order for the console to use this feature, you need to change the console to use the Internal Console in launch.json . \"console\": \"internalConsole\" If you'd like to use that setting each time you launch a Java program, you can configure it as a global user setting with java.debug.settings.console . Conditional breakpoint With the help of expression evaluation, the debugger also supports conditional breakpoint. You can set your breakpoint to break when expression evaluates to true. Data breakpoint You can have the debugger break when a variable change its value. Note that the data breakpoint can only be set inside a debug session. This means you need to launch your application and break on a regular breakpoint first. You can then pick a field in the VARIABLES view and set a data breakpoint. Hot Code replacement Another advanced feature the debugger supports is 'Hot Code' replacement. Hot code replacement (HCR) is a debugging technique whereby the Java debugger transmits new class files over the debugging channel to another Java Virtual Machine (JVM). HCR facilitates experimental development and fosters iterative trial-and-error coding. With this new feature, you can start a debugging session and change a Java file in your development environment, and the debugger will replace the code in the running JVM. No restart is required, which is why it's called \"hot\". Below is an illustration of how you can use HCR with Debugger for Java in VS Code. You may use the debug setting java.debug.settings.hotCodeReplace to control how to trigger Hot Code replacement. The possible setting values are: manual - Click the toolbar to apply the changes (default). auto - Automatically apply the changes after compilation. never - Disable Hot Code replacement. Logpoints Logpoints is also supported by Java Debugger. Logpoints allow you to send output to debug console without editing code. They're different from breakpoints because they don't stop the execution flow of your application. Configuration options There are many options and settings available to configure the debugger. For example, configuring the current working directory (cwd) and environment variables is easily done with launch options. Consult the documentation for the Language Support for Java by Red Hat extension for help with setting up your project. For many commonly used setups, there are samples available in VS Code Java Debugger Configuration . The document explains how the Java debugger automatically generates configurations for you, and if you need to modify them, how to do so with Main class, different arguments, environment, attaching to other Java processes, and usage of more advanced features. Below are all the configurations available for Launch and Attach . For more information about how to write the launch.json file, refer to Debugging . Launch mainClass (required) - The fully qualified class name (for example [java module name/]com.xyz.MainApp) or the java file path of the program entry. args - The command-line arguments passed to the program. Use \"${command:SpecifyProgramArgs}\" to prompt for program arguments. It accepts a string or an array of string. sourcePaths - The extra source directories of the program. The debugger looks for source code from project settings by default. This option allows the debugger to look for source code in extra directories. modulePaths - The modulepaths for launching the JVM. If not specified, the debugger will automatically resolve from current project. classPaths - The classpaths for launching the JVM. If not specified, the debugger will automatically resolve from current project. encoding - The file.encoding setting for the JVM. If not specified, 'UTF-8' will be used. Possible values can be found in Supported Encodings . vmArgs - The extra options and system properties for the JVM (for example -Xms<size> -Xmx<size> -D<name>=<value>), it accepts a string or an array of string. projectName - The preferred project in which the debugger searches for classes. There could be duplicated class names in different projects. This setting also works when the debugger looks for the specified main class when launching a program. It is required when the workspace has multiple Java projects, otherwise the expression evaluation and conditional breakpoint may not work. cwd - The working directory of the program. Defaults to ${workspaceFolder} . env - The extra environment variables for the program. stopOnEntry - Automatically pause the program after launching. console - The specified console to launch the program. If not specified, use the console specified by the java.debug.settings.console user setting. internalConsole - VS Code debug console (input stream not supported). integratedTerminal - VS Code Integrated Terminal. externalTerminal - External terminal that can be configured in user settings. shortenCommandLine - When the project has long classpath or big VM arguments, the command line to launch the program may exceed the maximum command-line string limitation allowed by the OS. This configuration item provides multiple approaches to shorten the command line. Defaults to auto . none - Launch the program with the standard command line 'java [options] classname [args]'. jarmanifest - Generate the classpath parameters to a temporary classpath.jar file, and launch the program with the command line 'java -cp classpath.jar classname [args]'. argfile - Generate the classpath parameters to a temporary argument file, and launch the program with the command line 'java @argfile [args]'. This value only applies to Java 9 and higher. auto - Automatically detect the command-line length and determine whether to shorten the command line via an appropriate approach. stepFilters - Skip specified classes or methods when stepping. classNameFilters - Skip the specified classes when stepping. Class names should be fully qualified. Wildcard is supported. skipSynthetics - Skip synthetic methods when stepping. skipStaticInitializers - Skip static initializer methods when stepping. skipConstructors - Skip constructor methods when stepping. Attach hostName (required) - The host name or IP address of remote debuggee. port (required) - The debug port of remote debuggee. timeout - Time out value before reconnecting, in milliseconds (default to 30000 ms). sourcePaths - The extra source directories of the program. The debugger looks for source code from project settings by default. This option allows the debugger to look for source code in extra directories. projectName - The preferred project in which the debugger searches for classes. There could be duplicated class names in different projects. It is required when the workspace has multiple Java projects, otherwise the expression evaluation and conditional breakpoint may not work. stepFilters - Skip specified classes or methods when stepping. classNameFilters - Skip the specified classes when stepping. Class names should be fully qualified. Wildcard is supported. skipSynthetics - Skip synthetic methods when stepping. skipStaticInitializers - Skip static initializer methods when stepping. skipConstructors - Skip constructor methods when stepping. User Settings java.debug.logLevel : Minimum level of debugger logs that are sent to VS Code, defaults to warn . java.debug.settings.showHex : Show numbers in hex format in Variables , defaults to false . java.debug.settings.showStaticVariables : Show static variables in Variables , defaults to false . java.debug.settings.showQualifiedNames : Show fully qualified class names in Variables , defaults to false . java.debug.settings.showLogicalStructure : Show the logical structure for the Collection and Map classes in Variables , defaults to true . java.debug.settings.showToString : Show 'toString()' value for all classes that override 'toString' method in Variables , defaults to true . java.debug.settings.maxStringLength : The maximum length of strings displayed in Variables or Debug Console . Strings longer than this limit will be trimmed. The default is 0 , which means no trim is performed. java.debug.settings.hotCodeReplace : Reload the changed Java classes during debugging, defaults to manual . Make sure java.autobuild.enabled is not disabled for VSCode Java . See the Hot Code Replace wiki page for more information about usages and limitations. manual - Click the toolbar to apply the changes. auto - Automatically apply the changes after compilation. never - Never apply the changes. java.debug.settings.enableHotCodeReplace : Enable hot code replace for Java code. Make sure the auto build is not disabled for VS Code Java . See the Hot Code Replace wiki page for more information about usages and limitations. java.debug.settings.enableRunDebugCodeLens : Enable the CodeLens provider for the run and debug buttons over main entry points, defaults to true . java.debug.settings.forceBuildBeforeLaunch : Force building the workspace before launching java program, defaults to true . java.debug.settings.console : The specified console to launch a Java program, defaults to integratedTerminal . If you want to customize the console for a specific debug session, please modify the console configuration in launch.json . internalConsole - VS Code debug console (input stream not supported). integratedTerminal - VS Code Integrated Terminal. externalTerminal - External terminal that can be configured in user settings. Troubleshooting If you encounter issues when using the debugger, a detailed troubleshooting guide can be found in the vscode-java-debug GitHub repository . Common issues explained include: Java Language Support extension fails to start. Build failed, do you want to continue? *.java isn't on the classpath. Only syntax errors will be reported. Program Error: Could not find or load main class X. Program throws ClassNotFoundException. Failed to complete hot code replace. Please specify the host name and the port of the remote debuggee in the launch.json. Failed to evaluate. Reason: Cannot evaluate because the thread is resumed. Cannot find a class with the main method. No delegateCommandHandler for vscode.java.startDebugSession when starting Debugger. Failed to resolve classpath. Request type \"X\" is not supported. Only \"launch\" and \"attach\" are supported. Feedback and questions You can find the full list of issues at Issue Tracker . You can submit a bug or feature suggestion and participate in the community driven vscode-java-debug Gitter channel . Next steps Read on to find out about: Debugging - Find out how to use the debugger in VS Code with your project for any language. And for Java: Java Testing - Test Java within VS Code with the Java Test Runner extension. Java Extensions - Learn about more useful Java extensions for VS Code."
  },
  "guides/vscode/java/java-editing.html": {
    "href": "guides/vscode/java/java-editing.html",
    "title": "Navigate and edit Java source code | Fountain of Knowledge",
    "keywords": "Navigate and edit Java source code Visual Studio Code is a source code editor first and foremost with rich editing features . In this document, we will go through a few Java-specific features, which are helpful when working with Java. If you run into any issues when using the features below, you can contact us by clicking the Report an issue button below. Report an issue Code navigation With the Outline view , you can conveniently navigate your methods within the same class. Project view also provide a great overview of your project. As a Java editor, it also supports CodeLens (references) and Javadoc hovers and highlights out of box. Once you open your Java project or any source files with VS Code, all code navigation features as well as syntax check and documentation (hover to see Javadoc) would be available immediately by its Lightweight Mode . Search for symbols You can search for symbols in the current file or workspace to navigate your code more quickly. To search for a symbol in the current file, use Quick Open ( kb(workbench.action.quickOpen) ) then enter the '@' command, then enter the name of the symbol you're looking for. A list of potential matches will appear and be filtered as you type. Choose from the list of matches to navigate to its location. To search for a symbol in the current workspace, start by pressing kb(workbench.action.showAllSymbols) , then enter the name of the symbol. A list of potential matches will appear as before. If you choose a match that was found in a file that's not already open, the file will be opened before navigating to the match's location. Alternatively, you can also use Quick Open ( kb(workbench.action.quickOpen) ) then enter the '#' command to search the current workspace. kb(workbench.action.showAllSymbols) is just the shortcut for the '#' commands, so everything works the same. Peek Definition You can take a quick look at how a symbol was defined by using the Peek Definition feature. This feature displays a few lines of code near the definition inside a peek window, so you can take a look without navigating away from your current location. To peek at a symbol's definition, place your cursor on the symbol anywhere it's used in your source code and then press kb(editor.action.peekDefinition) . Alternatively, you can choose Peek Definition from the context menu (right-click, then choose Peek Definition ). Go to Definition You can also quickly navigate to where a symbol is defined by using the Go to Definition feature. To go to a symbol's definition, place your cursor on the symbol anywhere it is used in your source code and then press kb(editor.action.revealDefinition) . Alternatively, you can choose Go to Definition from the context menu (right-click, then choose Go to Definition ). When there's only one definition of the symbol, you'll navigate directly to its location, otherwise the competing definitions are displayed in a peek window as described in the previous section and you have to choose the definition that you want to go to. Go to Super Implementation You can keep track of class implementations and overriding methods by clicking the Go to Super Implementation link on hover. Call Hierarchy A Call Hierarchy view shows all calls from or to a function and allows you to drill into callers of callers and call of calls. Right-click on a function and select Peek > Peek Call Hierarchy . You can also right-click in a function body and pick Show Call Hierarchy . Folding regions Folding regions allows you to fold or unfold code snippet to better view the source code. Smart Selection With Smart Selection (semantic selection), you can expand or shrink the selection range based on the semantic information of the caret position in your source code. To expand the selection, use kb(editor.action.smartSelect.expand) . To shrink the selection, use kb(editor.action.smartSelect.shrink) . Semantic Highlighting Syntax highlighting is a very important feature that allows you to read code more efficiently. With the help of Semantic Highlighting , VS Code can provide more accurate source code coloring based on symbol information from the Java language service. Below is just one example, left is the behavior after enabling semantic highlighting and right is the one with only syntax highlighting. To enable semantic highlighting, you can toggle the java.semanticHighlighting.enabled setting. You will also be prompted to enable or disable semantic highlighting on startup: You can learn more about the details of Java semantic highlighting on the Java extension wiki . Navigating code with Spring Boot The Spring Boot Tools extension provides enhanced navigation and code completion support for Spring Boot projects. @/ shows all defined request mappings (mapped path, request method, source location) @+ shows all defined beans (bean name, bean type, source location) @> shows all functions (prototype implementation) @ shows all Spring annotations in the code To learn more about Spring Boot support with Visual Studio Code, read Spring Boot in Visual Studio Code . Code editing Editing code is also easy with IntelliSense for smart code completions and signature details. You can use code snippets as well as various code actions such as generating Getters/Setters and organizing imports to further boost your productivity. Java support in Visual Studio Code detects issues within your code automatically, and provides you with Quick Fix suggestions. For more details about refactoring and code actions, see Refactoring and Source Actions . IntelliSense Code completion in Visual Studio Code for Java is provided by Language Support for Java(TM) by Red Hat . The extension is powered by the same Java development tools (JDT) behind Eclipse, so you can expect the same level of support. In addition, there's also AI-assisted IntelliSense called IntelliCode . It saves you time by putting what you're most likely to use at the top of your completion list. IntelliCode recommendations are based on thousands of open-source projects on GitHub each with over 100 stars, so it's trained on the most common usages from high quality projects. When combined with the context of your code, the completion list is tailored to promote those practices. Here's IntelliCode for Java in action. IntelliCode works well with popular Java libraries and frameworks like Java SE and Spring. It will help you whether you are doing monolithic web apps or modern microservices. Create new file VS Code supports applying templates when you create a Java source file. When you create a .java file in the File Explorer, the language server will automatically generate the class body, and fill the package info for you: Code snippets Visual Studio Code supports a wide range of popular Java code snippets to make you more productive, such as class/interface, syserr, sysout, if/else, try/catch, static main method. Leveraging information from Java language server, it also provides a preview of the code snippet during the selection."
  },
  "guides/vscode/java/java-faq.html": {
    "href": "guides/vscode/java/java-faq.html",
    "title": "Frequent Asked Questions | Fountain of Knowledge",
    "keywords": "Frequent Asked Questions Thanks for your interest in Java on Visual Studio Code! This FAQ will hopefully answer some of the questions you may have. Are these Java extensions open source? Yes. All the Java Extensions provided by Red Hat, Microsoft, and Pivotal are open source, as well as most extensions supported by the community. You can find their corresponding repositories on GitHub from the Marketplace pages. Are there any other features coming to Java on Visual Studio Code? Definitely. We use GitHub issues to track incoming requests and planned work for each of our extensions. Currently we're working on adding more refactoring and linting features to enhance the editing productivity, as well as some performance improvements to make it even faster. Most of our work is collected from and prioritized by customer feedback. If you're interested in providing your thoughts, you can go directly to our project repositories to submit a new issue to share your thoughts. We do have limited capacity within the team and we'd really like to encourage more contributions from the great Java community. If you're passionate about your idea and would like to help fellow Java developers, you're welcome to join us! Some areas worth considering including Gradle support, code analysis and test coverage tools, profiler, and additional framework support including DropWizard, JavaFX, JPA, Play, Akka, OSGi. Can I use keyboard shortcuts from other IDE? Sure. Keymap extensions in VS Code modify the VS Code shortcuts to match those of other editors. You can find IntelliJ IDEA Keybindings , Eclipse Keymap as well as keymaps for other popular editors in Keymaps category of extensions in the Marketplace. Where can I find the latest progress of Java support on Visual Studio Code? You can follow us on the Java at Microsoft blog, which will keep you updated on our progress. While you're using Java within VS Code, you may also see a Release Notes section after you update the Java Extension Pack . The notes will give you an overview on the notable updates included in the extensions. How can I use Visual Studio Code with new Java versions? Thanks to the upstream update from JDT, you can now build your project up to Java 14 with VS Code as well. To use the experimental/preview language features, you need to modify your project settings. Maven - modify pom.xml : <build> <pluginManagement> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <configuration> <release>14</release> <compilerArgs>--enable-preview</compilerArgs> </configuration> </plugin> </plugins> </pluginManagement> </build> Gradle: sourceCompatibility = 14 tasks.withType(JavaCompile) { options.compilerArgs += '--enable-preview' } tasks.withType(Test) { jvmArgs += \"--enable-preview\" } Note: If you are modifying a project that was already opened in VS Code, you may need to force clean the workspace and reload. To do so, run command Java: Clean Java Language Server Workspace . How can I use it behind a corporate proxy? When using the Java extension behind a corporate proxy, you might need to let the Java Language server know how to connect to the Internet, in order to download build runtimes, Java dependencies, and their sources through that proxy. This is done by configuring the java.jdt.ls.vmargs setting in VS Code preferences (all on one line): { \"java.jdt.ls.vmargs\": \"-Dhttp.proxyHost=webproxy.corp.net -Dhttp.proxyPort=proxyport -Dhttp.proxyUser=user -Dhttp.proxyPassword=password -Dhttps.proxyHost=webproxy.corp.net -Dhttps.proxyPort=proxyport -Dhttps.proxyUser=user -Dhttps.proxyPassword=password\" } Will this be available for Visual Studio? Currently we don't plan to extend the Java support to Visual Studio. There are already great IDEs for Java and we're focusing on VS Code to provide a lightweight experience in a polyglot editor. Does VS Code Java support other display languages? Currently we support Chinese in addition to English for a few extensions including Debugger for Java , Java Test Runner , Maven for Java , Project Manager for Java . To learn how to switch the VS Code display language, see Display Languages . You can contribute to the extension repositories if you're interested in additional display language support. How to troubleshoot and contribute to the Java Language Server You can visit the Java for Visual Studio Code wiki to find answers regarding: \"Classpath is incomplete\" warning Annotation Processing support for Maven projects Contribute a Java extension Formatter settings Lombok Support Using a Proxy Troubleshooting"
  },
  "guides/vscode/java/java-linting.html": {
    "href": "guides/vscode/java/java-linting.html",
    "title": "Java formatting and linting | Fountain of Knowledge",
    "keywords": "Java formatting and linting Language Support for Java(TM) by Red Hat also provides formatting settings . You can export an Eclipse formatter file and then use it for your project in VS Code. In addition, there are also the Checkstyle for Java and SonarLint extensions, which provide features for live linting and code analysis. Checkstyle With the Checkstyle for Java extension, you can use either existing checkstyle configurations (Google's or Sun's Check) or your own customized files for your project. When editing a Java file, the extension will check the file format and provide Quick Fixes if possible on the fly. Set Checkstyle configuration file. The Checkstyle for Java extension supports live linting. And batch check. The Problems panel will open when you click the Checkstyle status icon in the Status bar. Set Checkstyle configuration file To set the configuration file, right-click the .xml file and select Set the Checkstyle Configuration File . You can also trigger the command Checkstyle: Set Checkstyle Configuration File to choose the configuration file in the File Explorer. The extension looks for a checkstyle.xml file in your workspace to make Checkstyle configuration easier. You will also see the two built-in configurations: Google's Check Sun's Check Command Checkstyle: Set the Checkstyle Configuration detects potential Checkstyle configuration files and lists them. You can also provide a configuration file by directly writing a URL in the input box. You can also set the Checkstyle version by using the command Checkstyle: Set the Checkstyle Version . The command will: List the latest Checkstyle version from the main repo. List all the downloaded versions. List all the supported versions. Mark the currently used version with a check symbol. In addition, you can also bring any 3rd-party modules for Checkstyle by configuring its path. For example, after using the configuration below, you can add <module name=\"SingleBreakOrContinueCheck\"/> or <module name=\"com.github.sevntu.checkstyle.checks.naming.SingleBreakOrContinueCheck\"/> to checkstyle.xml to leverage those checks. \"java.checkstyle.modules\": [ \"${workspaceFolder}/src/main/resources/sevntu-checks-1.35.0.jar\" ] Check the style and fix the violations When editing a Java file, the extension will check the file format and provide Quick Fixes if possible. You can click the lightbulb button in the editor to show the available Quick Fixes. For more details about Checkstyle for Java , visit its GitHub Repository . SonarLint The SonarLint extension lets you detect bugs and vulnerabilities as you write code in VS Code. Java is one of the languages supported, and the extension will run in the background and highlight source code that poses a quality or security concern. Code Analysis on the fly Issues are highlighted directly in the editor with hovers to provide detailed explanations. Issues found in the opened file can also be reviewed through the Problems panel of VS Code. When applicable, secondary code locations are mentioned so you can understand where the issue originates from (for example, the code path that led to a bug). Rule documentation and remediation guidance For any issue detected, SonarLint provides full documentation about the rule that was violated, and the coding best practice it relates to. This lets you understand why an issue is raised, and most importantly how to best fix it. Enabling more quality and security rules By default, SonarLint provides a wide array of rules to detect bugs and vulnerabilities. More checks can be enabled through the SonarLint Rules view. For more details about the SonarLint for VS Code extension , visit the SonarLint website . Formatter Currently, you need an Eclipse formatter file like Google Style . Set the following property: \"java.format.settings.url\": \"https://raw.githubusercontent.com/google/styleguide/gh-pages/eclipse-java-google-style.xml\", The property can point to a URL or a local file path. If the formatter XML file contains more than one profile, you can set the profile name: \"java.format.settings.profile\": \"GoogleStyle\", You can also define the formatting preferences in your project's .settings/org.eclipse.jdt.core.prefs . It will override the global formatting settings. We are working on a solution to allow editing your formatting preferences from within VS Code. For now, the best way to edit them is to use Eclipse. See Formatter Settings for details."
  },
  "guides/vscode/java/java-on-azure.html": {
    "href": "guides/vscode/java/java-on-azure.html",
    "title": "Deploy Java to Azure | Fountain of Knowledge",
    "keywords": "Deploy Java to Azure The Azure Tools extensions for Visual Studio Code make it easy to deploy Java applications (including containers) to Azure App Service , deploy Spring microservices to Azure Spring Cloud , and deploy serverless code to Azure Functions . Deployment tutorials The following tutorials below walk you though the details. Please also check the Java Azure Developer's Center for all things on Azure for Java developers. Tutorial Description Deploy Java web apps to Azure App Service Deploy a web app using the Azure App Service extension. Deploy Spring Microservices to Azure Spring Cloud Deploy a web app using the Azure Spring Cloud extension. Create an Azure Functions project using Visual Studio Code Deploy serverless code using the Azure Functions extension."
  },
  "guides/vscode/java/java-project.html": {
    "href": "guides/vscode/java/java-project.html",
    "title": "Java project management in VS Code | Fountain of Knowledge",
    "keywords": "Java project management in VS Code This document will give you an overview of how to manage your Java project in Visual Studio Code. If you run into any issues when using the features below, you can contact us by clicking the Report an issue button below. Report an issue Project management Managing a project in VS Code requires the Project Manager for Java extension. The extension helps manage class paths and dependencies, and create new projects, packages, and classes. Install the Project Manager for Java Project view Project view helps you view your project and its dependencies, and provides entry points for project management tasks. You can switch between a hierarchy view and flat view. Create a project You can create a project or source only workload by clicking the + sign on project view, or through the command: Java: Create Java Project... . During creation, VS Code will facilitate installing required extension(s) per your project type, if the extension(s) weren't installed. Import a project or module A project or module is imported to a workspace through File > Open Folder or File > Open Workspace menu. VS Code for Java will detect your project type automatically. As a tip, you can run the command Java: Import Java projects in workspace to reimport a project and alert the language server that there were changes to the project, without reloading your window. Add a dependency For Maven project, you can add a dependency by clicking the + sign next to Maven Dependencies node in project view. Add a JAR JAR file(s) can be added by clicking the + sign next to Referenced Libraries node in project view. For more details on library, refer to Library Configuration . Export to JAR You can export your build to JAR from the project view or by running the command Java: Export Jar... . Configure JDK As Java evolves, it's common that developers work with multiple versions of JDK. To correctly configure your environment and project, you have to know two configurations, java.configuration.runtimes and java.home . The former specifies options for your project's execution environment; the latter specifies your language server's execution environment. Note : Although the Java language server requires JDK version 11 or above to run, this is NOT a requirement to your project's runtime. The easiest way for you to configure the JDK is to use the Java Runtime Configuration wizard. You can launch the wizard by opening the Command Palette ( kb(workbench.action.showCommands) ) and typing the command Java: Configure Java Runtime , which will bring up the configuration user interface shown below. If you want to configure without the wizard, please refer below for details. JDK for projects VS Code will detect the runtime required for your project and choose the appropriate configuration from java.configuration.runtimes . \"java.configuration.runtimes\": [ { \"name\": \"JavaSE-1.8\", \"path\": \"/usr/local/jdk1.8.0_201\" }, { \"name\": \"JavaSE-11\", \"path\": \"/usr/local/jdk-11.0.3\", \"sources\" : \"/usr/local/jdk-11.0.3/lib/src.zip\", \"javadoc\" : \"https://docs.oracle.com/en/java/javase/11/docs/api\", \"default\": true }, { \"name\": \"JavaSE-12\", \"path\": \"/usr/local/jdk-12.0.2\" }, { \"name\": \"JavaSE-13\", \"path\": \"/usr/local/jdk-13\" } ] Runtime names must be one of: \"J2SE-1.5\", \"JavaSE-1.6\", \"JavaSE-1.7\", \"JavaSE-1.8\", \"JavaSE-9\", \"JavaSE-10\", \"JavaSE-11\", \"JavaSE-12\", \"JavaSE-13\", \"JavaSE-14\", \"JavaSE-15\". We will update the list with each supported release of the JDK. Note : To enable Java preview features, see How can I use VS Code with new Java versions . JDK for source only If you only work with source files and don't use a build tool, VS Code will apply an appropriate runtime using the default configuration of java.configuration.runtimes . If a default isn't specified, VS Code will use the runtime used by the language server, which is determined by the order shown below: Library configuration Behind the scene, there's a setting java.project.referencedLibaries in settings.json . Below are details on how to customize this setting. Include libraries The libraries to reference are described using a set of glob patterns. For example: \"java.project.referencedLibraries\": [ \"library/**/*.jar\", \"/home/username/lib/foo.jar\" ] The settings above will add all .jar files in workspace's library folder along with foo.jar from a specified absolute path to the project's external dependencies. The referenced libraries are then watched by VS Code, and the project will be refreshed if there is a change to any of these dependent files. By default, VS Code will reference all JAR files in workspace's lib directory using the glob pattern lib/**/*.jar . Exclude some libraries If you want to exclude some libraries from the project, you can expand java.project.referencedLibraries to use include/exclude fields and add an exclude glob pattern: \"java.project.referencedLibraries\": { \"include\": [ \"library/**/*.jar\", \"/home/username/lib/foo.jar\" ], \"exclude\": [ \"library/sources/**\" ] } In the example above, any binary JAR files in the library/sources folder are ignored as the project's external dependencies. Attach source jars By default, a referenced {binary}.jar will try to search {binary}-sources.jar under the same directory, and attach it as source if one match is found. If you want to manually specify a JAR file as a source attachment, you can provide a key-value map in the sources field: \"java.project.referencedLibraries\": { \"include\": [ \"library/**/*.jar\", \"/home/username/lib/foo.jar\" ], \"exclude\": [ \"library/sources/**\" ], \"sources\": { \"library/bar.jar\": \"library/sources/bar-src.jar\" } } In this way, bar-src.jar is attached to bar.jar as its source. In case VS Code throws an error for a classpath issue, try setting your classpath manually by either setting the CLASSPATH environment variable or editing the .classpath file with the path to the JAR file: <classpathentry kind=\"lib\" path=\"lib/log4j.jar\"/> In some rare cases, you may need to clean the Java workspace by executing the Java: Clean Java Language Server Workspace command from the Command Palette ( kb(workbench.action.showCommands) ) to let the language server rebuild your dependencies. Lightweight Mode VS Code for Java supports two modes, lightweight and standard. With lightweight mode, only source files and JDK are resolved by the language server; with standard mode, imported dependencies are resolved and the project is built by the language server. Lightweight mode works best when you need a super quick-to-start and lightweight environment to work with your source files, for example, reading source code, navigating among source code and JDK, viewing outline and Javadoc, and detecting and fixing syntax errors. Also, code completion is supported within the scope of source files and JDK. Lightweight mode doesn't resolve imported dependencies nor build the project, so it does not support running, debugging, refactoring, linting, or detecting semantic errors. For these features to be available, you need to switch your workspace from lightweight mode to standard mode. You can control which mode to launch with by configuring java.server.launchMode with the options below: Hybrid (default) - Firstly, a workspace is opened with lightweight mode. You will be asked whether to switch to standard mode if your workspace contains unresolved Java projects. If you choose Later , it will stay in lightweight mode. You can click the server mode icon on the Status bar to manually switch to standard mode. Standard - A workspace is opened with standard mode. LightWeight - A workspace is opened with lightweight mode. You can click the server mode icon on the Status bar to manually switch to standard mode. The Status bar indicates which mode the current workspace is in using different icons. - workspace opened with lightweight mode. - workspace in the process of being opened with standard mode. - workspace opened with standard mode. Clicking the lightweight mode icon switches to standard mode. Build Status When you edit Java source code in Visual Studio Code, the Java language server is building your workspace to provide you with the necessary language features. You can see the detailed build task status and watch what is happening behind the scene by clicking the language server Status bar icon in the lower right. Additional resources Visit the GitHub Repo of the Maven extension for additional configurations and a troubleshooting guide . In addition to Maven, there's also a Bazel extension if you use Bazel to build and test your project. Next steps Read on to find out more about: Java Editing - Explore the editing features for Java in VS Code. Java Debugging - Find out how to debug your Java project with VS Code. Java Testing - Use VS Code for your JUnit and TestNG cases. Java Extensions - Learn about more useful Java extensions for VS Code."
  },
  "guides/vscode/java/java-refactoring.html": {
    "href": "guides/vscode/java/java-refactoring.html",
    "title": "Java refactoring and Source Actions | Fountain of Knowledge",
    "keywords": "Java refactoring and Source Actions Visual Studio Code provide many options to refactor your source code as well as Source Actions to generate code and fix issues while you're coding. To access them, click on the light bulb 💡 whenever you see it. Or right-click the editor view and pick Source Action... . Refactoring The goal of the Java program refactoring is to make system-wide code changes without affecting behavior of the program. The Java Language Support for VS Code provides a lot of easily accessible refactoring options. Invoke refactoring Refactoring commands are available from the context menu of the editor. Select the element you want to refactor, right-click to open the context menu and choose Refactor... : Then you will see all the available refactoring options. List of Supported Code Actions Assign to variable Change modifiers to final Convert anonymous to nested class Convert to anonymous class creation Convert to enhanced for loop Convert to lambda expression Convert to static import Extract refactorings Extract to constant Extract to field Extract to method Extract to local variable Inline refactorings Inline constant Inline local variable Inline method Invert boolean Invert conditions Invert local variable Move Rename Type change Change resolved type to var type Change var type to resolved type Assign to variable Assigns an expression to a local variable or a field. Example Before Arrays.asList(\"apple\", \"lemon\", \"banana\"); After List<String> fruits = Arrays.asList(\"apple\", \"lemon\", \"banana\"); It can also be used to assigns a parameter to a new field for unused parameter(s) in a constructor. Change modifiers to final Adds final modifier to all the variables and parameters in the current source file. Example Before public class Clazz { public void method(int value) { boolean notValid = value > 5; if (notValid) { // do something } } } After public class Clazz { public void method(final int value) { final boolean notValid = value > 5; if (notValid) { // do something } } } Convert anonymous to nested class Converts an anonymous inner class to a member class. Example Let's convert the anonymous class Interface(){...} to a member of the class Clazz . Before public class Clazz { public Interface method() { final boolean isValid = true; return new Interface() { public boolean isValid() { return isValid; } }; } } After public class Clazz { private final class MyInterface extends Interface { private final boolean isValid; private MyInterface(boolean isValid) { this.isValid = isValid; } public boolean isValid() { return isValid; } } public Interface method() { final boolean isValid = true; return new MyInterface(isValid); } } Convert to anonymous class creation Converts lambda expression to anonymous class creation. Example The variable runnable is assigned with a lambda expression. Let's convert it to an anonymous class creation. Before public void method() { Runnable runnable = () -> { // do something }; } After public void method() { Runnable runnable = new Runnable() { @Override public void run() { // do something } }; } Also see: Convert to lambda expression Convert to enhanced for loop Converts the simple for loop to for-each style. Example Before public void order(String[] books) { for (int i = 0; i < books.length; i++) { // do something } } After public void order(String[] books) { for (String book : books) { // do something } } Convert to lambda expression Converts an anonymous class creation to the lambda expression. Example Let's convert the anonymous class Runnable(){...} to a lamda expression. Before public void method() { Runnable runnable = new Runnable(){ @Override public void run() { // do something } }; } After public void method() { Runnable runnable = () -> { // do something }; } Also see: Convert to anonymous class creation Convert to static import Converts the field or method to static import. Example Let's transform the Assert.assertEquals() invocation to a static import. Before import org.junit.Assert; ... public void test() { Assert.assertEquals(expected, actual); } After import static org.junit.Assert.assertEquals; ... public void test() { assertEquals(expected, actual); } Extract to constant Creates a static final field from the selected expression and substitutes a field reference, then rewrites other places where the same expression occurs. Examples Let's extract the value of π: 3.14 to a constant. Before public double getArea(double r) { return 3.14 * r * r; } After private static final double PI = 3.14; public double getArea(double r) { return PI * r * r; } Also see: Inline constant Extract to field Declares a new field and initializes it with the selected expression. The original expression is replaced with the usage of the field. Examples Let's extract the variable area to a field of the class Square . Before class Square { public void calculateArea() { int height = 1; int width = 2; int area = height * width; } } After class Square { private int area; public void calculateArea() { int height = 1; int width = 2; area = height * width; } } When selecting a variable declaration, convert the variable to field. Extract to method Creates a new method containing the statements or expressions currently selected and replaces the selection with a reference to the new method. This feature is useful for cleaning up lengthy, cluttered, or overly-complicated methods. Examples Let's extract the expression height * width to a new method. Before public void method() { int height = 1; int width = 2; int area = height * width; } After public void method() { int height = 1; int width = 2; int area = getArea(height, width); } private int getArea(int height, int width) { return height * width; } Also see: Inline method Extract to local variable Creates a new variable assigned to the expression currently selected and replaces the selection with a reference to the new variable. Examples Let's extract the expression platform.equalsIgnoreCase(\"MAC\") to a new variable. Before public void method() { if (platform.equalsIgnoreCase(\"MAC\")) { // do something } } After public void method() { boolean isMac = platform.equalsIgnoreCase(\"MAC\"); if (isMac) { // do something } } After the extraction, you can also perform a rename in the same transaction. Also see: Inline local variable Inline constant Replaces a constant reference with its defined value. Examples Let's replace the constant PI to its defined value: 3.14 . Before private static final double PI = 3.14; public double getArea(double r) { return PI * r * r; } After private static final double PI = 3.14; public double getArea(double r) { return 3.14 * r * r; } Also see: Extract to constant Inline local variable Replaces redundant variable usage with its initializer. Examples Let's replace the variable isMac directly to the boolean expression. Before public void method() { boolean isMac = platform.equalsIgnoreCase(\"MAC\"); if (isMac) { // do something } } After public void method() { if (platform.equalsIgnoreCase(\"MAC\")) { // do something } } Also see: Extract to local variable Inline method Replaces calls to the method with the method’s body. Example Let's replace the method getArea(int height, int width) directly to the expression height * width . Before public void method() { int height = 1; int width = 2; int area = getArea(height, width); } private int getArea(int height, int width) { return height * width; } After public void method() { int height = 1; int width = 2; int area = height * width; } Also see: Extract to method Invert conditions Inverts the boolean expression in the conditions. Example Let's invert the boolean expression in the if statement. Before public void method(int value) { if (value > 5 && value < 15) { // do something } } After public void method(int value) { if (value <= 5 || value >= 15) { // do something } } Invert local variable Inverts the local boolean variable. Example Let's invert the variable valid . Before public void method(int value) { boolean valid = value > 5 && value < 15; } After public void method(int value) { boolean notValid = value <= 5 || value >= 15; } Move Moves the selected elements and corrects all references to the elements (also in other files). Available actions are: Move class to another package Move static or instance method to another class Move inner class to a new file Example Let's move the static method print() from class Office to class Printer . Before public class Office { public static void main(String[] args) { print(); } public static void print() { System.out.println(\"This is printer\"); } static class Printer { } } After public class Office { public static void main(String[] args) { Printer.print(); } static class Printer { public static void print() { System.out.println(\"This is printer\"); } } } Move refactoring on a static method if it is used more in another class than in its own class. Move a class to another package. Currently, move refactoring is not supported from file explorer. Move an inner class to new a new file. Rename Default shortcut: kb(editor.action.rename) Renames the selected element and corrects all references to the elements (also in other files). Example Let's rename the class Foo to Bar Before public class Foo { // ... } public void myMethod() { Foo myClass = new Foo(); } After public class Bar { // ... } public void myMethod() { Bar myClass = new Bar(); } The shortcut to invoke the Rename refactoring is kb(editor.action.rename) . When you invoke the shortcut on an identifier in the editor, a small box displays within the editor itself where you can change the identifier name. When you press kbstyle(Enter) , all references to that identifier are changed too. Rename refactoring is also supported from the File Explorer for folders and files. After requesting the change, a preview of impacted files will be provided and you can decide how to apply those changes. Change resolved type to var type Uses var to declare local variables. Example Before String s = \"\"; After var s = \"\"; Also see: Change var type to resolved type Change var type to resolved type Uses the resolved type to declare local variables. Example Before var s = \"\"; After String s = \"\"; Also see: Change resolved type to var type Source Actions Source Actions could be used to generate common code structures and recurring elements. Some of them are quick fixes which helps you fix your code issues on the fly. Generate constructor from super class Add a constructor from super class. Generate delegate methods Generate delegate methods Override/implement methods With this Source Action, all the candidates are presented to you with a checklist. You can then decide what to override or implement. Organize imports You can use this Source Action to clean up your imports. It can also deal with ambiguous imports, in that case, a dropdown list will be presented for you to pick the right one. The code line with the unresolved type is also presented to you to help you decide. Generate getters and setters You can bulk generate getters and setters for all new member variables. If the class has more than one field, the Source Action will prompt a Quick Pick for you to select the target fields to use to generate the accessor methods. Generate hashCode() and equals() hashCode() and equals() can be generated with default implementations. All the non-static member variables are listed, and you can customize the generated code using the check list. There are two options for you to customize the generated code: If you use Java 7+, you can set java.codeGeneration.hashCodeEquals.useJava7Objects to true to generate shorter code that calls Objects.hash and Objects.equals . You can also set java.codeGeneration.hashCodeEquals.useInstanceof to true to use instanceOf operator to check the object types instead of calling Object.getClass() . Generate toString() There is a new Source Action to generate the toString() method. Customization is possible with a check list of all the member variables. Fix non-accessible reference This Quick Fix helps you fix non-accessible reference. Create non-existing package When your package name doesn't match the folder name, you have the options to either change the package name in your source code, or move the folder in the file system (even when the destination folder doesn't exist yet). Other Code Actions supported The list of Code Actions supported by VS Code keeps growing and only listed the most popular ones above. Other notable supported actions include (but not limited to): Create unresolved types Remove the final modifier Remove unnecessary cast Remove redundant interfaces Add missing case labels in switch statements Jump to definition on break/continue Correct access to static elements"
  },
  "guides/vscode/java/java-spring-boot.html": {
    "href": "guides/vscode/java/java-spring-boot.html",
    "title": "Spring Boot in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Spring Boot in Visual Studio Code Visual Studio Code is an ideal lightweight development environment for Spring Boot application developers and there are several useful VS Code extensions including: Spring Boot Tools Spring Initializr Spring Boot Dashboard If you run into any issues when using the features below, you can contact us by clicking the Report an issue button below. Report an issue Prerequisites A working Java environment with essential extensions installed is needed, including: Java Development Kit (JDK) , version 11 or later. Apache Maven , version 3.0 or later. Java Extension Pack For more details, please refer to Java Tutorial Note : More information about JDK can be found at supported Java versions . Create the project The Spring Initializr extension allows you to search for dependencies and generate new Spring Boot projects. To install, launch VS Code and from the Extensions view ( kb(workbench.view.extensions) ), search for vscode-spring-initializr . Once you have the extension installed, open the Command Palette ( kb(workbench.action.showCommands) ) and type Spring Initializr to start generating a Maven or Gradle project and then follow the wizard. Edit the project The Spring Initializr extension allows you to edit dependencies after generating a new Spring Boot project. Navigate to your pom.xml file and right-click to select Edit starters . The Command Palette will show the dependencies you already have beginning with a √ . You can search for other dependencies you want to add to your project. Or you can click on the existing dependencies to remove them. Develop the application The Spring Boot Tools extension includes rich language support for working with Spring Boot application.properties , application.yml , and .java files. The extension supports quick navigate through source code, smart code completions, quick access to running apps, live application information, and code templates. Similar code completion and validation features are also available for .properties and .yml files. Run the application In addition to click kb(workbench.action.debug.start) to run your application, there's another convenient extension Spring Boot Dashboard with which you can view and manage all available Spring Boot projects in your workspace as well as quickly start, stop, or debug your project. Next steps To deploy your web app, see the Deploy a Java Application to Azure tutorial. To containerize a web app and deploy as a Docker container, check out the Working with Docker . To learn more about Java Debugging features, see Java Debugging Tutorial ."
  },
  "guides/vscode/java/java-spring-cloud.html": {
    "href": "guides/vscode/java/java-spring-cloud.html",
    "title": "Java on Azure Spring Cloud | Fountain of Knowledge",
    "keywords": "Java on Azure Spring Cloud This tutorial shows you how to create a Java web application with Visual Studio Code. You'll learn how to run, debug, and edit the Java web app locally and then on a fully managed Microservices platform built for Java workloads: Azure Spring Cloud . Scenario We will deploy a simple Spring Boot Getting Started web app to Azure Spring Cloud. Azure Spring Cloud makes it easy to deploy Spring Boot microservice applications to Azure without any code changes. The service manages the infrastructure of Spring Cloud applications so developers can focus on their code. Other benefits include: Efficiently migrate existing Spring apps and manage cloud scaling and costs. Modernize apps with Spring Cloud patterns to improve agility and speed of delivery. Run Java at cloud scale and drive higher usage without complicated infrastructure. Develop and deploy rapidly without containerization dependencies. Monitor production workloads efficiently and effortlessly. Before you begin Before running and deploying this sample, you must have the Java SE Development Kit (JDK) version 11 or above and Apache Maven build tools on your local development environment. If you don't already have them, install these tools first. Download and install the Java Extension Pack . Note : The JAVA_HOME environment variable must be set to the install location of the JDK to complete this tutorial. Download Apache Maven version 3 or greater: Download Apache Maven Install Apache Maven for your local development environment: Install Apache Maven Download and test the Spring Boot app Clone the Spring Boot Getting Started sample project to your local machine. You can clone a Git repository with the Git: Clone command in the Command Palette ( kb(workbench.action.showCommands) ). Paste https://github.com/spring-guides/gs-spring-boot.git as the URL of the remote repository and then decide the parent directory under which to put the local repository. After that, open the complete folder within the cloned repository in VS Code by navigating to the folder and typing code . . Note : You can install Visual Studio Code from https://code.visualstudio.com and Git from https://git-scm.com . From within VS Code, open any of the Java files within the complete folder (for example src\\main\\java\\hello\\Application.java ). If you don't have the Java language extensions installed for VS Code, you will be prompted to install the Microsoft Java Extension Pack . Follow the instructions and reload VS Code after the installation. Once you have the Java Extension Pack installed, it will automatically build the project for you (the build may take several minutes). You can run the application within VS Code by pressing kb(workbench.action.debug.start) and selecting the Java environment. The Java Debug extension will generate a debugging configuration file launch.json for you under a .vscode folder in your project. You can see build progress in the VS Code Status bar and when everything is finished, the final active debug configuration is displayed. You can learn more about how VS Code launches your application in Debugging Launch Configurations . Press kb(workbench.action.debug.start) again to launch the debugger. Test the web app by browsing to http://localhost:8080 using a web browser. You should see the following message displayed: \"Greetings from Spring Boot!\". Make a change Let's now edit HelloController.java to change \"Greetings from Spring Boot!\" to something else like \"Hello World\". VS Code provides a great editing experience for Java, check out Editing and Navigating Code to learn about VS Code's editing and code navigation features. Select the Restart button on the top of the editor to relaunch the app and see result by reloading the browser. Debug the application Set a breakpoint ( kb(editor.debug.action.toggleBreakpoint) ) in the application source code, and reload your browser to hit the breakpoint. If you would like to learn more about debugging Java with VS Code, you can read Java Debugging . Congratulations, you have your first Spring Boot web app running locally! Read on to learn how to host it in the cloud. Deploy to Azure Spring Cloud We just built a Java web application and ran it locally. Now you will learn how to deploy from Visual Studio Code and run it on Azure Spring Cloud . Install the Azure Spring Cloud extension The Azure Spring Cloud extension is used to create, manage, and deploy to Azure Spring Cloud with key features including: Create/View/Delete apps in Azure Spring Cloud Deploy Jar to the app Access the app with public/private endpoint Start, stop, and restart the app Scale the app in/out, up/down Config application settings such as environment variables and JVM options Stream logs from the app To install the Azure Spring Cloud extension, open the Extensions view ( kb(workbench.view.extensions) ) and search for azure spring cloud to filter the results. Select the Microsoft Azure Spring Cloud extension. For a command-line experience, you can also check out the Azure Spring Cloud quickstart with Azure CLI . Sign in to your Azure subscription The deploy process uses the Azure Account extension (installed along with the Spring Cloud extension as a dependency) and you need to sign in with your Azure subscription. If you don't have an Azure subscription, you can sign up for a free Azure account . Create your free Azure account To sign in to Azure, run Azure: Sign In from the Command Palette ( kb(workbench.action.showCommands) ). You can then sign in to your account using the Device Login flow. Select Copy & Open to open your default browser. Paste in the access code and continue the sign in process. Create an app on Azure Spring Cloud Once you are signed in to your Azure account and you have your app open in Visual Studio Code, select the Azure icon in the Activity Bar to open the Azure Explorer and you will see the Azure Spring Cloud panel. Right-click on your subscription and select Create Service in Portal . Finish the following steps on the Azure Portal to create an Azure Spring Cloud service instance. After the service instance is created, refresh the Azure Explorer to display the new service instance. Right-click on the service instance and select Create App . Type the app name, select the Java version, and then press kbstyle(Enter) to start creating. The app will be ready in a few minutes. Build and deploy the app You can open the command prompt or terminal window and build the project using Maven commands. The build will generate a new war or jar artifact in the target directory. mvn clean package Right-click on the App in Azure Explorer, select Deploy , and pick your built Jar file when prompted. You can watch the deployment status on the bottom right. Once done, select Access Public Endpoint to test the app running on Azure and Yes when prompted to assign a public endpoint. Be aware that only Spring Boot fat Jar is supported, learn more about apps on Azure Spring Cloud . Scale the app You can easily scale the app by right-clicking on the Instance count under Scale Settings and selecting Edit . Type \"2\" and press kbstyle(Enter) to scale the app. Stream your application logs Expand the App Instances node, right-click the instance you want to see logs, and select Start Streaming Logs . The Visual Studio Code output window opens with a connection to the log stream. Next steps Explore more powerful features of Azure Spring Cloud with Microservices . To learn more about Java Debugging features, read the Java Debugging Tutorial ."
  },
  "guides/vscode/java/java-testing.html": {
    "href": "guides/vscode/java/java-testing.html",
    "title": "Testing Java with Visual Studio Code | Fountain of Knowledge",
    "keywords": "Testing Java with Visual Studio Code Testing Java in Visual Studio Code is enabled by the Java Test Runner extension. It's a lightweight extension to run and debug Java test cases. Overview The extension supports the following test frameworks: JUnit 4 (v4.8.0+) JUnit 5 (v5.1.0+) TestNG (v6.8.0+) Note: JUnit 3 styled tests are not supported in this extension (for example, extends junit.framework.TestCase ). The Java Test Runner works with the Language Support for Java by Red Hat and Debugger for Java extensions to provide the following features: Run/Debug test cases Customize test configurations View test report View tests in Test Explorer Install the Java Test Runner If you run into any issues when using the features below, you can contact us by clicking the Report an issue button below. Report an issue Requirements JDK (version 11 or later) VS Code (version 1.59.0 or later) Language Support for Java by Red Hat Debugger for Java Features Run/Debug Test Cases The extension will generate shortcuts (the green play button) on the left side of the class and method definition. To run the target test cases, select the green play button. You can also right-click on the play button to see more options. Test Explorer The Test Explorer shows all the test cases in your workspace. You can also run/debug your test cases from there. Customize test configurations Sometimes you may want to customize the configuration to run your test cases. To achieve this, you can add the configuration into your workspace settings under the section: java.test.config . More details can be found on the vscode-java-test Wiki . View test results After running/debugging the test cases, the state of the related test items will be updated in both editor decorations and the Test Explorer. You can trigger the command Test: Peek Output to peek the results view. You can select the links in the stack trace to navigate to the source location. VS Code testing commands There are other testing commands (for example, Run Tests in Current File ) that can be found by searching for 'Test:' in the Command Palette ( kb(workbench.action.showCommands) ). Settings Setting Name Description Default Value java.test.config Specify the configuration for the test cases to run with. More details . {} java.test.defaultConfig Specify the name of the default test configuration. \"\" VS Code testing settings There are VS Code settings specific to testing that can be found by searching for 'testing' in the Settings editor ( kb(workbench.action.openSettings) ). Project Setup JUnit 5 Please refer to Getting Started from the JUnit 5's official website for getting started documentation. Note: If your project does not use build tools (Maven/Gradle/...), make sure junit-platform-console-standalone.jar is on your project classpath. JUnit 4 Refer to Download and Install from the JUnit 4's official website for the getting started documentation. TestNG Refer to the TestNG documentation from the TestNG official website for getting started information. FAQ If you meet any problem when using the extension, you can review the FAQ and our issue list to check if there is an answer to your problem. Contributing and Feedback If you are interested in providing feedback or contributing directly to the code base, please read Contributing to Java Test Runner , which covers the following: Questions and Feedback Reporting Issues Contributing Fixes Next steps Read on to find out about: Debugging - Find out how to debug your Java project with VS Code. Java Extensions - Learn about more useful Java extensions for VS Code."
  },
  "guides/vscode/java/java-tomcat-jetty.html": {
    "href": "guides/vscode/java/java-tomcat-jetty.html",
    "title": "Working with Application Servers in VS Code | Fountain of Knowledge",
    "keywords": "Working with Application Servers in VS Code Visual Studio Code is a code editor-centric development tool, so it doesn't come with any embedded application server. For most servers, you will need to deploy them using the command line, and then use the appropriate debugger configuration if you want to attach to it. On the other hand, we know that for certain Java workloads, server integration is very useful. With Visual Studio Code, you can find third party extensions for popular application servers, for example Tomcat , Jetty , and Open Liberty , which are helpful when working with those servers locally. For Spring Boot Dashboard , see Spring Boot in Visual Studio Code . If you run into any issues when using the features below, you can contact us by clicking the Report an issue button below. Report an issue Tomcat With the Tomcat extension, you can manage all your local Tomcat servers within the editor and easily debug and run your war package on Tomcat and link Tomcat into your workspace. You can also create a new Tomcat server from the explorer using the Add button and run a war package on it. You can also create the server during the deployment. For running and debugging a package, you can right-click a server to select a war package to debug. More details could be found in the GitHub repository of the Tomcat extension. Jetty The Jetty for Java extension for Visual Studio Code makes it much easier for you to run and deploy your war package, operate your Jetty Server, and interact with your application within the editor. The extension includes the following features: Add Jetty Server from download directory Start/Restart/Stop/Delete Jetty Server Run/Debug/Delete war package Reveal war package in file explorer Open Server homepage Open war package homepage More details could be found in the GitHub repository of the Jetty for Java extension. Open Liberty The Open Liberty Tools extension lets you run your application on Open Liberty, allowing you to deploy, test, and debug your application from Visual Studio Code. After you start your application with the Open Liberty Tools extension, your source code is automatically compiled and deployed to the running server, making it easy to iterate on your changes. You can run tests on demand or automatically, so that you can get immediate feedback on your changes. You can also attach a debugger at any time to debug your running application. More details can be found in the GitHub repository of the Open Liberty Tools extension. Other servers You can use the Community Server Connectors extension from Red Hat to deploy projects to Apache Felix, Tomcat, and Karaf in VS Code. The Server Connector extension by Red Hat allows you to start, stop, and deploy to a Red Hat server and runtime products like WildFly, JBoss EAP, Minishift, CDK. Extension Pack for MicroProfile provides tools for creating MicroProfile projects to develop and deploy to runtimes such as Open Liberty, Quarkus, and Payara."
  },
  "guides/vscode/java/java-tutorial.html": {
    "href": "guides/vscode/java/java-tutorial.html",
    "title": "Getting Started with Java in VS Code | Fountain of Knowledge",
    "keywords": "Getting Started with Java in VS Code This tutorial shows you how to write and run Hello World program in Java with Visual Studio Code. It also covers a few advanced features, which you can explore by reading other documents in this section. For an overview of the features available for Java in VS Code, see Java Language Overview If you run into any issues when following this tutorial, you can contact us by clicking the Report an issue button below. Report an issue Setting up VS Code for Java development Coding Pack for Java To help you set up quickly, you can install the Coding Pack for Java , which includes VS Code, the Java Development Kit (JDK), and essential Java extensions. The Coding Pack can be used as a clean installation, or to update or repair an existing development environment. Install the Coding Pack for Java - Windows Install the Coding Pack for Java - macOS Note : The Coding Pack for Java is only available for Windows and macOS. For other operating systems, you will need to manually install a JDK, VS Code, and Java extensions. Installing extensions If you are an existing VS Code user, you can also add Java support by installing Java Extension Pack , which includes these extensions: Language Support for Java(TM) by Red Hat Debugger for Java Java Test Runner Maven for Java Project Manager for Java Install the Java Extension Pack The Java Extension Pack provides a Quick Start guide and tips for code editing and debugging. It also has a FAQ that answers some frequently asked questions. Use the command Java: Getting Started from the Command Palette ( kb(workbench.action.showCommands) ) to launch the guide. You can also install extensions separately. The Extension Guide is provided to help you. You can launch the guide with the Java: Extension Guide command. For this tutorial, the only required extensions are: Language Support for Java(TM) by Red Hat Debugger for Java Settings for the JDK Supported Java versions The supported version for running the VS Code for Java extension and the supported version for your projects are two separate runtimes. To run VS Code for Java, Java SE 11 or above version is required; for projects, VS Code for Java supports projects with version 1.5 or above. For more details, refer to Configure JDK . Using Java runtime configuration wizard To help you configure correctly, we provide a runtime configuration wizard. You can launch the wizard by opening the Command Palette ( kb(workbench.action.showCommands) ) and typing the command Java: Configure Java Runtime , which will display the configuration user interface below. Note : To configure multiple JDKs, see Configure JDK . To enable Java preview features, see How can I use VS Code with new Java versions Using VS Code settings Alternatively, you can configure JDK settings using the VS Code Settings editor. A common way to do this is setting the value of the JAVA_HOME system environment variable to the install location of the JDK, for example, C:\\Program Files\\Java\\jdk-13.0.2 . Or if you want to configure only VS Code to use the JDK, use the java.home setting in VS Code's User or Workspace settings . Installing a Java Development Kit (JDK) When you need to install a JDK, we recommend you to consider installing from one of these sources: Oracle Java SE AdoptOpenJDK Azul Zulu for Azure - Enterprise Edition Creating a source code file Create a folder for your Java program and open the folder with VS Code. Then in VS Code, create a new file and save it with the name Hello.java . When you open that file, the Java Language Server automatically starts loading, and you should see a loading icon on the right side of the Status Bar. After it finishes loading, you will see a thumbs-up icon. Note : If you open a Java file in VS Code without opening its folder, the Java Language Server might not work properly. VS Code will also try to figure out the correct package for the new type and fill the new file from a template. See Create new file . You can also create a Java project using the Java: Create Java Project command. Bring up the Command Palette ( kb(workbench.action.showCommands) ) and then type java to search for this command. After selecting the command, you will be prompted for the location and name of the project. You can also choose your build tool from this command. Visual Studio Code also supports more complex Java projects, see Project Management . Editing source code You can use code snippets to scaffold your classes and methods. VS Code also provides IntelliSense for code completion, and various refactor methods. To learn more about editing Java, see Java Editing . Running and debugging your program To run and debug Java code, set a breakpoint, then either press kb(workbench.action.debug.start) on your keyboard or use the Run > Start Debugging menu item. You can also use the Run|Debug CodeLens options in the editor. After the code compiles, you can see all your variables and threads in the Run view. The debugger also supports advanced features such as Hot Code replacement and conditional breakpoints. For more information, see Java Debugging . More features The editor also has much more capability for your Java workload. Editing Java explains how to navigate and edit Java in more details Debugging illustrates all the key features of the Java Debugger Testing provides comprehensive support for JUnit and TestNG framework Java Project Management shows you how to use a project view and work with Maven Spring Boot and Tomcat and Jetty demonstrate great framework support Java Web Apps shows how to work with Java Web App in VS Code"
  },
  "guides/vscode/java/java-webapp.html": {
    "href": "guides/vscode/java/java-webapp.html",
    "title": "Java Web Apps with Visual Studio Code | Fountain of Knowledge",
    "keywords": "Java Web Apps with Visual Studio Code This tutorial shows you how to create a Java web application with Visual Studio Code. You'll learn how to run, debug, and edit the Java web app locally and eventually on the cloud. Scenario A simple Spring Boot Getting Started web app Before you begin Before running and deploying this sample, you must have the Java SE Development Kit (JDK) and Apache Maven build tools on your local development environment. If you don't have, please install them. Download and install the Java Extension Pack , which has JDK 11 included. Note : The JAVA_HOME environment variable must be set to the install location of the JDK to complete this tutorial. Download Apache Maven version 3 or greater: Download Apache Maven Install Apache Maven for your local development environment: Install Apache Maven Download and test the Spring Boot app Clone the Spring Boot Getting Started sample project to your local machine. You can clone a Git repository with the Git: Clone command in the Command Palette ( kb(workbench.action.showCommands) ). Paste https://github.com/spring-guides/gs-spring-boot.git as the URL of the remote repository and then decide the parent directory under which to put the local repository. After that, open the complete folder within the cloned repository in VS Code by navigating to the folder and typing code . . Note : You can install Visual Studio Code from https://code.visualstudio.com and Git from https://git-scm.com . From within VS Code, open any of the Java files within the complete folder (for example src\\main\\java\\hello\\Application.java ). If you don't have the Java language extensions installed for VS Code, you will be prompted to install the Microsoft Java Extension Pack . Follow the instructions and reload VS Code after the installation. Once you have the Java Extension Pack installed, it will automatically build the project for you (this may take several minutes). You can run the application within VS Code by pressing kb(workbench.action.debug.start) and selecting the Java environment. The Java Debug extension will generate a debugging configuration file launch.json for you under a .vscode folder in your project. You can see build progress in the VS Code Status Bar and when everything is finished, the final active debug configuration is displayed. You can learn more about how VS Code launches your application in Debugging Launch Configurations . Press kb(workbench.action.debug.start) again to launch the debugger. Test the web app by browsing to http://localhost:8080 using a web browser. You should see the following message displayed: \"Greetings from Spring Boot!\". Make a change Let's now edit HelloController.java to change \"Greetings from Spring Boot!\" to something else like \"Hello World\". VS Code provides a great editing experience for Java, check out Editing and Navigating Code to learn about VS Code's editing and code navigation features. Click the Restart button on the top of the editor to relaunch the app and see result by reloading the browser. Debug the application Set a breakpoint ( kb(editor.debug.action.toggleBreakpoint) ) in the application source code, and reload your browser to hit the breakpoint. If you would like to learn more about debugging Java with VS Code, you can read Java Debugging . Congratulations, you have your first Spring Boot web app running locally! Read on to learn how to host it in the cloud. Deploy Web Apps to the cloud We just built a Java web application and ran it locally. Now you will learn how to deploy from Visual Studio Code and run it on Azure in the cloud. If you don't have an Azure subscription, you can sign up for a free Azure account . Create your free Azure account Install the Azure App Service extension The Azure App Service extension is used to create, manage, and deploy to Azure App Service with key features including: Create new Azure Web App/Deployment Slot Deploy to Azure Web App/Deployment Slot Start, stop, and restart the Azure Web App/Deployment Slot View a Web App's log files Swap Deployment Slots To install the Azure App Service extension, open the Extensions view ( kb(workbench.view.extensions) ) and search for azure app service to filter the results. Select the Microsoft Azure App Service extension. For a more command-line Maven-centric experience, you can also check out the Maven plugin for Azure App Service Linux tutorial . Create a new Web App on Azure Once the extension is installed, you can take the following steps to create a new Web App on Azure. Click Create New Project button on the APP SERVICE Explorer view. Select a subscription. Enter a unique name for the new Web App. Select a location for the new Web App. Select the OS as Linux . Select the runtime of the Web App, for example Tomcat 8.5 (JRE8) . Build and deploy to a Web App The deploy process leverages the Azure Account extension (installed along with the Azure App Service extension as a dependency) and you need to sign in with your Azure subscription. If you do not have an Azure subscription, sign up today for a free 30 day account and get $200 in Azure Credits to try out any combination of Azure services. To sign in to Azure, run Azure: Sign In from the Command Palette ( kb(workbench.action.showCommands) ). You can then sign in to your account using the Device Login flow. Select Copy & Open to open your default browser. Paste in the access code and continue the sign in process. Once you have signed in, you can open the command prompt or terminal window and build the project using Maven commands. This will generate a new war or jar artifact in the target directory. mvn clean package After building the project, open the target directory in VS Code Explorer. Right-click on the artifact and choose Deploy to Web App , and follow the prompts to choose the Web App for your deployment. Open the Output window in VS Code to view the deployment logs. Once the deployment is completed, it will print out the URL for your Web App. Click the link to open it in a browser, you can see the web app running on Azure! Note: For more advanced features of App Service, you can check out the Azure App Service extension. Connect with data services Azure Cosmos DB is a globally distributed database service that allows developers to work with data using a variety of standard APIs, such as SQL, MongoDB, Cassandra, Graph, and Table. The Spring Boot Starter makes it easy to store data in and retrieve data from your Azure Cosmos DB with SQL API. Create an Azure Cosmos DB entity on Azure Go to Azure portal and click the '+' to Create a resource . Click Databases , and then click Azure Cosmos DB to create your database. Select SQL (Document DB) API and type in other information for your database. Navigate to the database you have created, click Keys , and copy your URI and PRIMARY KEY for your database. Config your project You can start from the Spring Data Azure Cosmos DB Sample Project . Navigate to src/main/resources and open application.properties . Replace below properties in application.properties with information of your database. azure.documentdb.uri=your-documentdb-uri azure.documentdb.key=your-documentdb-key azure.documentdb.database=your-documentdb-databasename Run and debug the application You can press kb(workbench.action.debug.start) to run your application. To check the result, open Azure portal and access your Cosmos DB. Click Data Explorer , and next choose Documents . You will see data being shown if it is successfully written into Cosmos DB. You can also browse your data entries in Cosmos DB with Azure Databases extension. After setting a breakpoint ( kb(editor.debug.action.toggleBreakpoint) ) in your source code, refresh your browser to hit the breakpoint. Details about debugging can be found in Java Debugging Alternatively, you can also use Maven to package and run your project as steps below: Navigate to the directory azure-spring-boot and run the command. mvn install Navigate to the directory azure-documentdb-spring-boot-sample and run the command. mvn package java -jar target/azure-documentdb-spring-boot-sample-0.0.1-SNAPSHOT.jar Next steps To containerize and deploy a web application, check out the Docker Container Tutorial . To learn more about Java Debugging features, see the Java Debugging Tutorial ."
  },
  "guides/vscode/languages/cpp.html": {
    "href": "guides/vscode/languages/cpp.html",
    "title": "C/C++ for Visual Studio Code | Fountain of Knowledge",
    "keywords": "C/C++ for Visual Studio Code C/C++ support for Visual Studio Code is provided by a Microsoft C/C++ extension to enable cross-platform C and C++ development on Windows, Linux, and macOS. Install the extension Open VS Code. Select the Extensions view icon on the Activity bar or use the keyboard shortcut ( kb(workbench.view.extensions) ). Search for 'C++' . Select Install . After you install the extension, when you open or create a *.cpp file, you will have syntax highlighting (colorization), smart completions and hovers (IntelliSense), and error checking. Install a compiler C++ is a compiled language meaning your program's source code must be translated (compiled) before it can be run on your computer. VS Code is first and foremost an editor, and relies on command-line tools to do much of the development workflow. The C/C++ extension does not include a C++ compiler or debugger. You will need to install these tools or use those already installed on your computer. There may already be a C++ compiler and debugger provided by your academic or work development environment. Check with your instructors or colleagues for guidance on installing the recommended C++ toolset (compiler, debugger, project system, linter). Some platforms, such as Linux or macOS, have a C++ compiler already installed. Most Linux distributions have the GNU Compiler Collection (GCC) installed and macOS users can get the Clang tools with Xcode . Check if you have a compiler installed Make sure your compiler executable is in your platform path ( %PATH on Windows, $PATH on Linux and macOS) so that the C/C++ extension can find it. You can check availability of your C++ tools by opening the Integrated Terminal ( kb(workbench.action.terminal.toggleTerminal) ) in VS Code and trying to directly run the compiler. Checking for the GCC compiler g++ : g++ --version Checking for the Clang compiler clang : clang --version Note : If you would prefer a full Integrated Development Environment (IDE), with built-in compilation, debugging, and project templates (File > New Project), there are many options available, such as the Visual Studio Community edition. If you don't have a compiler installed, in the example below, we describe how to install the Minimalist GNU for Windows (MinGW) C++ tools (compiler and debugger). MinGW is a popular, free toolset for Windows. If you are running VS Code on another platform, you can read the C++ tutorials , which cover C++ configurations for Linux and macOS. Example: Install MinGW-x64 We will install Mingw-w64 via MSYS2 , which provides up-to-date native builds of GCC, Mingw-w64, and other helpful C++ tools and libraries. Click here to download the MSYS2 installer. Then follow the instructions on the MSYS2 website to install Mingw-w64. Add the MinGW compiler to your path Add the path to your Mingw-w64 bin folder to the Windows PATH environment variable by using the following steps: In the Windows search bar, type 'settings' to open your Windows Settings. Search for Edit environment variables for your account . Choose the Path variable and then select Edit . Select New and add the Mingw-w64 destination folder path, with \\mingw64\\bin appended, to the system path. The exact path depends on which version of Mingw-w64 you have installed and where you installed it. If you used the settings above to install Mingw-w64, then add this to the path: C:\\msys64\\mingw64\\bin . Select OK to save the updated PATH. You will need to reopen any console windows for the new PATH location to be available. Check your MinGW installation To check that your Mingw-w64 tools are correctly installed and available, open a new Command Prompt and type: g++ --version gdb --version If you don't see the expected output or g++ or gdb is not a recognized command, make sure your PATH entry matches the Mingw-w64 binary location where the compiler tools are located. Hello World To make sure the compiler is installed and configured correctly, we'll create the simplest Hello World C++ program. Create a folder called \"HelloWorld\" and open VS Code in that folder ( code . opens VS Code in the current folder): mkdir HelloWorld cd HelloWorld code . Now create a new file called helloworld.cpp with the New File button in the File Explorer or File > New File command. Add Hello World source code Now paste in this source code: #include <iostream> using namespace std; int main() { cout << \"Hello World\" << endl; } Now press kb(workbench.action.files.save) to save the file. You can also enable Auto Save to automatically save your file changes, by checking Auto Save in the main File menu. Build Hello World Now that we have a simple C++ program, let's build it. Select the Terminal > Run Build Task command ( kb(workbench.action.tasks.build) ) from the main menu. This will display a dropdown with various compiler task options. If you are using a GCC toolset like MinGW, you would choose C/C++: g++.exe build active file . This will compile helloworld.cpp and create an executable file called helloworld.exe , which will appear in the File Explorer. Run Hello World From a command prompt or a new VS Code Integrated Terminal, you can now run your program by typing \".\\helloworld\". If everything is set up correctly, you should see the output \"Hello World\". This has been a very simple example to help you get started with C++ development in VS Code. The next step is to try one of the tutorials listed below on your platform (Windows, Linux, or macOS) with your preferred toolset (GCC, Clang, Microsoft C++) and learn more about the Microsoft C/C++ extension's language features such as IntelliSense, code navigation, build configuration, and debugging. Tutorials Get started with C++ and VS Code with tutorials for your environment: GCC on Windows via MinGW Microsoft C++ on Windows GCC on Linux GCC on Windows Subsystem For Linux Clang/LLVM on macOS CMake Tools on Linux Documentation You can find more documentation on using the Microsoft C/C++ extension under the C++ section of the VS Code website, where you'll find topics on: Debugging Editing Settings FAQ Remote Development VS Code and the C++ extension support Remote Development allowing you to work over SSH on a remote machine or VM, inside a Docker container, or in the Windows Subsystem for Linux (WSL). To install support for Remote Development: Install the VS Code Remote Development Extension Pack . If the remote source files are hosted in WSL, use the Remote - WSL extension. If you are connecting to a remote machine with SSH, use the Remote - SSH extension. If the remote source files are hosted in a container (for example, Docker), use the Remote - Containers extension. Feedback If you run into any issues or have suggestions for the Microsoft C/C++ extension, please file issues and suggestions on GitHub . If you haven't already provided feedback, please take this quick survey to help shape this extension for your needs."
  },
  "guides/vscode/languages/csharp.html": {
    "href": "guides/vscode/languages/csharp.html",
    "title": "Working with C# | Fountain of Knowledge",
    "keywords": "Working with C# The C# support in Visual Studio Code is optimized for cross-platform .NET Core development (see working with .NET Core and VS Code for another relevant article). Our focus with VS Code is to be a great editor for cross-platform C# development. VS Code supports debugging of C# applications running on either .NET Core or Mono. For detailed instructions on: .NET Core debugging - see the Microsoft C# extension's GitHub page . Mono debugging - see the Mono Debug extension's README . Note: VS Code has limited support for debugging applications running on the Desktop .NET Framework. Due to this focus, many standard C# project types are not recognized by VS Code. An example of a non-supported project type is an ASP.NET MVC Application (though ASP.NET Core is supported). In these cases, if you want to have a lightweight tool to edit a file - VS Code has you covered. If you want the best possible experience for those projects and development on Windows in general, we recommend you use Visual Studio Community . Installing C# support C# language support is an optional install from the Marketplace . You can install it from within VS Code by searching for 'C#' in the Extensions view ( kb(workbench.view.extensions) ) or if you already have a project with C# files, VS Code will prompt you to install the extension as soon as you open a C# file. Video Tutorial on Getting Started with C# in VS Code with .NET Core Roslyn and OmniSharp Visual Studio Code uses the power of Roslyn and OmniSharp to offer an enhanced C# experience. We offer support for: .NET Core projects MSBuild projects C# scripts (CSX) On startup the best matching projects are loaded automatically but you can also choose your projects manually. The status bar will show what projects have been loaded and also allows you to select a different set of projects. To do so, click on the status bar projects item and select Change projects… . In the image below a single project has been picked up: The available options include: Selecting a project.json file will open a .NET Core project and VS Code will load that project plus the referenced projects. Selecting a *.sln file opens a MSBuild-project. It will load the referenced *.csproj projects and sibling or descendant project.json files but no other project files that are referenced from the solution file. Selecting a folder will make VS Code scan for *.sln , project.json and *.csx files (C# scripts) and VS Code will attempt to load them all. Once the project is loaded the enhanced experiences light up... Editing Evolved There is a lot to discover with C# and the editor, such as format on type, IntelliSense, the rename-refactoring, etc. For a full description of our editing features, go to the Basic Editing and Code Navigation documentation. Here are a few highlights... IntelliSense IntelliSense just works: hit kb(editor.action.triggerSuggest) at any time to get context specific suggestions. Snippets for C# We have several built-in snippets included in VS Code that will come up as you type or you can press kb(editor.action.triggerSuggest) (Trigger Suggest) and we will give you a context specific list of suggestions. Tip: You can add in your own User Defined Snippets for C#. Take a look at User Defined Snippets to find out how. Search for Symbols There are also features outside the editor. One is the ability to search for symbols from wherever you are. Hit kb(workbench.action.showAllSymbols) , start typing, and see a list of matching C# symbols. Select one and you'll be taken straight to its code location. CodeLens Another cool feature is the ability to see the number of references to a method directly above the method. Click on the reference info to see the references in the Peek view. This reference information updates as you type. Note: Methods defined in object , such as equals and hashCode do not get reference information due to performance reasons. Tip: You can turn off references information displayed in CodeLens with the editor.codeLens setting . Find References/Peek Definition You can click on the references of an object to find the locations of its use in place without losing context. This same experience works in reverse where you can Peek the definition of an object and see it inline without leaving your location. Quick Fixes / Suggestions There are some basic quick fixes supported in VS Code. You will see a lightbulb and clicking on it, or pressing kb(editor.action.quickFix) provides you with a simple list of fixes/suggestions. Next steps Read on to find out about: .NET Core Development - get up and running with cross-platform .NET Basic Editing - Learn about the powerful VS Code editor. Tasks - Use tasks to build your project and more. Debugging - Find out how to use the debugger with your project. Unity development - Learn about using VS Code with your Unity projects. Common questions My Project won't load VS Code only supports a limited set of project types (primarily .NET Core). For full .NET project support, we suggest you use Visual Studio Community . IntelliSense is not working This is typically as a result of the current project type not being supported. You can see an indication in the OmniSharp flame in the bottom left hand side of the status bar. How do I build/run my project? VS Code supports tasks for build and natively understand the output of MSBuild, CSC, XBuild. Find out more in the Tasks documentation. I'm missing required assets to build and debug C# in VS Code. My debugger says \"No Configuration\" The Visual Studio Code C# extension can generate the assets you need to build and debug. If you missed the prompt when you first opened a new C# project, you can still perform this operation through the Command Palette ( View > Command Palette ) by typing '.NET', and running .NET: Generate Assets for Build and Debug . This command will generate the necessary launch.json and tasks.json configuration files (under the .vscode folder)."
  },
  "guides/vscode/languages/css.html": {
    "href": "guides/vscode/languages/css.html",
    "title": "CSS, SCSS and Less | Fountain of Knowledge",
    "keywords": "CSS, SCSS and Less Visual Studio Code has built-in support for editing style sheets in CSS .css , SCSS .scss and Less .less . In addition, you can install an extension for greater functionality. Tip: Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . IntelliSense VS Code has support for selectors, properties and values. Use kb(editor.action.triggerSuggest) to get a list of context specific options. Proposals contain extensive documentation, including a list of browsers that support the property. To see the full description text of the selected entry, use kb(toggleSuggestionDetails) . Syntax coloring & color preview As you type, there is syntax highlighting as well as in context preview of colors. Clicking on a color preview will launch the integrated color picker which supports configuration of hue, saturation and opacity. Tip: You can trigger between different color modes by clicking on the color string at the top of the picker. You can hide VS Code's color previews by setting the following setting : \"editor.colorDecorators\": false To just disable it for css, Less and SCSS, use \"[css]\": { \"editor.colorDecorators\": false } Folding You can fold regions of source code using the folding icons on the gutter between line numbers and line start. Folding regions are available for all declarations (for example, rule declarations) and for multiline comments in the source code. Additionally you can use the following region markers to define a folding region: /*#region*/ and /*#endregion*/ in CSS/SCSS/Less or // #region and // #endregion In SCSS/Less. If you prefer to switch to indentation based folding for CSS, Less and SCSS, use: \"[css]\": { \"editor.foldingStrategy\": \"indentation\" }, Emmet snippets Emmet abbreviation support is built into VS Code, suggestions are listed along with other suggestions and snippets in the editor auto-completion list. Tip: See the CSS section of the Emmet cheat sheet for valid abbreviations. VS Code also supports User Defined Snippets . Syntax Verification & Linting There is support for CSS version <= 2.1, Sass version <= 3.2 and Less version <= 2.3. Note: You can disable VS Code's default CSS, Sass or Less validation by setting the corresponding .validate User or Workspace setting to false. \"css.validate\": false Go to Symbol in file You can quickly navigate to the relevant CSS symbol in the current file by pressing kb(workbench.action.gotoSymbol) . Hovers Hovering over a selector or property will provide an HTML snippet that is matched by the CSS rule. Go to Declaration and Find References This is supported for Sass and Less variables in the same file. CSS variables per the draft standards proposal are also supported. There is jump to definition for @import and url() links in CSS, SCSS and Less. CSS custom data You can extend VS Code's CSS support through a declarative custom data format . By setting css.customData to a list of JSON files following the custom data format, you can enhance VS Code's understanding of new CSS properties, at-directives, pseudo-classes and pesudo-elements. VS Code will then offer language support such as completion & hover information for the provided properties, at-directives, pseudo-classes and pesudo-elements. You can read more about using custom data in the vscode-custom-data repository. Transpiling Sass and Less into CSS VS Code can integrate with Sass and Less transpilers through our integrated task runner . We can use this to transpile .scss or .less files into .css files. Let's walk through transpiling a simple Sass/Less file. Step 1: Install a Sass or Less transpiler For this walkthrough, let's use either the sass or less Node.js module. Note: If you don't have Node.js and the npm package manager already installed, you'll need to do so for this walkthrough. Install Node.js for your platform . The Node Package Manager (npm) is included in the Node.js distribution. You'll need to open a new terminal (command prompt) for npm to be on your PATH. npm install -g sass less Step 2: Create a simple Sass or Less file Open VS Code on an empty folder and create a styles.scss or styles.less file. Place the following code in that file: $padding: 6px; nav { ul { margin: 0; padding: $padding; list-style: none; } li { display: inline-block; } a { display: block; padding: $padding 12px; text-decoration: none; } } For the Less version of the above file, just change $padding to @padding . Note: This is a very simple example, which is why the source code is almost identical between both file types. In more advanced scenarios, the syntaxes and constructs will be much different. Step 3: Create tasks.json The next step is to set up the task configuration. To do this, run Terminal > Configure Tasks and click Create tasks.json file from template . In the selection dialog that shows up, select Others . This will create a sample tasks.json file in the workspace .vscode folder. The initial version of file has an example to run an arbitrary command. We will modify that configuration for transpiling Sass/Less instead: // Sass configuration { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Sass Compile\", \"type\": \"shell\", \"command\": \"sass styles.scss styles.css\", \"group\": \"build\" } ] } // Less configuration { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Less Compile\", \"type\": \"shell\", \"command\": \"lessc styles.less styles.css\", \"group\": \"build\" } ] } Step 4: Run the Build Task As this is the only command in the file, you can execute it by pressing kb(workbench.action.tasks.build) ( Run Build Task ). The sample Sass/Less file should not have any compile problems, so by running the task all that happens is a corresponding styles.css file is created. Since in more complex environments there can be more than one build task we prompt you to pick the task to execute after pressing kb(workbench.action.tasks.build) ( Run Build Task ). In addition, we allow you to scan the output for compile problems (errors and warnings). Depending on the compiler, select an appropriate entry in the list to scan the tool output for errors and warnings. If you don't want to scan the output, select Never scan the build output from the presented list. At this point, you should see an additional file show up in the file list styles.css . If you want to make the task the default build task to run execute Configure Default Build Task from the global Terminal menu and select the corresponding Sass or Less task from the presented list. Note: If your build fails or you see an error message such as \"An output directory must be specified when compiling a directory\", be sure the filenames in your tasks.json match the filenames on disk. You can always test your build by running sass styles.scss styles.css from the command line. Automating Sass/Less compilation Let's take things a little further and automate Sass/Less compilation with VS Code. We can do so with the same task runner integration as before, but with a few modifications. Step 1: Install Gulp and some plug-ins We will use Gulp to create a task that will automate Sass/Less compilation. We will also use the gulp-sass plug-in to make things a little easier. The Less plug-in is gulp-less . We need to install gulp both globally ( -g switch) and locally: npm install -g gulp npm install gulp gulp-sass gulp-less Note: gulp-sass and gulp-less are Gulp plug-ins for the sass and lessc modules we were using before. There are many other Gulp Sass and Less plug-ins you can use, as well as plug-ins for Grunt. You can test that your gulp installation was successful by typing gulp -v in the terminal. You should see a version displayed for both the global (CLI) and local installations. Step 2: Create a simple Gulp task Open VS Code on the same folder from before (contains styles.scss / styles.less and tasks.json under the .vscode folder), and create gulpfile.js at the root. Place the following code in the gulpfile.js file: // Sass configuration var gulp = require('gulp'); var sass = require('gulp-sass')(require('sass')); gulp.task('sass', function(cb) { gulp.src('*.scss') .pipe(sass()) .pipe(gulp.dest(function(f) { return f.base; })); cb(); }); gulp.task('default', gulp.series('sass', function(cb) { gulp.watch('*.scss', gulp.series('sass')); cb(); })); // Less configuration var gulp = require('gulp'); var less = require('gulp-less'); gulp.task('less', function(cb) { gulp.src('*.less') .pipe(less()) .pipe(gulp.dest(function(f) { return f.base; })); cb(); }); gulp.task('default', gulp.series('less', function(cb) { gulp.watch('*.less', gulp.series('less')); cb(); })); What is happening here? Our default gulp task first runs the sass or less task once when it starts up. It then watches for changes to any SCSS/Less file at the root of our workspace, for example the current folder open in VS Code. It takes the set of SCSS/Less files that have changed and runs them through our respective compiler, for example gulp-sass , gulp-less . We now have a set of CSS files, each named respectively after their original SCSS/Less file. We then put these files in the same directory. Step 3: Run the gulp default task To complete the tasks integration with VS Code, we will need to modify the task configuration from before to run the default Gulp task we just created. You can either delete the tasks.json file or empty it only keeping the \"version\": \"2.0.0\" property. Now execute Run Task from the global Terminal menu. Observe that you are presented with a picker listing the tasks defined in the gulp file. Select gulp: default to start the task. We allow you to scan the output for compile problems. Depending on the compiler, select an appropriate entry in the list to scan the tool output for errors and warnings. If you don't want to scan the output, select Never scan the build output from the presented list. At this point, if you create and/or modify Less or SASS files, you see the respective CSS files generated and/or changes reflected on save. You can also enable Auto Save to make things even more streamlined. If you want to make the gulp: default task the default build task executed when pressing kb(workbench.action.tasks.build) run Configure Default Build Task from the global Terminal menu and select gulp: default from the presented list. Step 4: Terminate the gulp default Task The gulp: default task runs in the background and watches for file changes to Sass/Less files. If you want to stop the task, you can use the Terminate Task from the global Terminal menu. Customizing CSS, SCSS and Less Settings You can configure the following lint warnings as User and Workspace Settings . The validate setting allows you turn off the built-in validation. You would do this if you rather use a different linter. Id Description Default css.validate Enables or disables all css validations true less.validate Enables or disables all less validations true scss.validate Enables or disables all scss validations true To configure an option for CSS, use css.lint. as the prefix to the id; for SCSS and Less, use scss.lint. and less.lint. . Set a setting to warning or error if you want to enable lint checking, use ignore to disable it. Lint checks are performed as you type. Id Description Default validate Enables or disables all validations true compatibleVendorPrefixes When using a property with a vendor-specific prefix (for example -webkit-transition ), make sure to also include all other vendor-specific properties e.g. -moz-transition , -ms-transition and -o-transition ignore vendorPrefix When using a property with a vendor-specific prefix for example -webkit-transition , make sure to also include the standard property if it exists e.g. transition warning duplicateProperties Warn about duplicate properties in the same ruleset ignore emptyRules Warn about empty rulesets warning importStatement Warn about using an import statement as import statements are loaded sequentially which has a negative impact on web page performance ignore boxModel Do not use width or height when using padding or border ignore universalSelector Warn when using the universal selector * as it is known to be slow and should be avoided ignore zeroUnits Warn when having zero with a unit e.g. 0em as zero does not need a unit. ignore fontFaceProperties Warn when using @font-face rule without defining a src and font-family property warning hexColorLength Warn when using hex numbers that don't consist of three or six hex numbers error argumentsInColorFunction Warn when an invalid number of parameters in color functions e.g. rgb error unknownProperties Warn when using an unknown property warning ieHack Warn when using an IE hack *propertyName or _propertyName ignore unknownVendorSpecificProperties Warn when using an unknown vendor-specific property ignore propertyIgnoredDueToDisplay Warn when using a property that is ignored due to the display. For example, with display: inline , the width , height , margin-top , margin-bottom , and float properties have no effect. warning important Warn when using !important as it is an indication that the specificity of the entire CSS has gotten out of control and needs to be refactored. ignore float Warn when using float as floats lead to fragile CSS that is easy to break if one aspect of the layout changes. ignore idSelector Warn when using selectors for an id #id as selectors should not contain IDs because these rules are too tightly coupled with the HTML. ignore Next steps Read on to find out about: Configure Tasks - Dig into Tasks to help you transpile your SCSS and Less to CSS. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. HTML - CSS is just the start, HTML is also very well supported in VS Code. Common questions Does VS Code provide a color picker? Yes, color picker has been added in version 1.15 . Is there support for the indentation based Sass syntax (.sass)? No, but there are several extensions in the Marketplace supporting the indented flavor of Sass, for example, the Sass extension originally created by Robin Bentley, now maintained by Leonard Grosoli."
  },
  "guides/vscode/languages/dotnet.html": {
    "href": "guides/vscode/languages/dotnet.html",
    "title": "Using .NET Core in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Using .NET Core in Visual Studio Code .NET Core provides a fast and modular platform for creating server apps that run on Windows, Linux, and macOS. Use Visual Studio Code with the C# and F# extensions to get a powerful editing experience with C# IntelliSense , F# IntelliSense (smart code completion), and debugging. Prerequisites Install the following: .NET Core SDK . The SDK also includes the Runtime. The C# extension from the VS Code Marketplace. The F# extension (Ionide) from the VS Code Marketplace. Create a C# \"Hello World\" app Initialize a C# project: Open a terminal/command prompt and navigate to the folder in which you'd like to create the app. Enter the following command in the command shell: dotnet new console When the project folder is first opened in VS Code: A \"Required assets to build and debug are missing. Add them?\" notification appears at the bottom right of the window. Select Yes . Run the app by entering the following command in the command shell: dotnet run Watch a video tutorial for further C# setup help on Windows , macOS , or Linux . Create an F# \"Hello World\" app Initialize an F# project: Open a terminal/command prompt and navigate to the folder in which you'd like to create the app. Enter the following command in the command shell: dotnet new console -lang \"F#\" Once it completes, open the project in Visual Studio Code: code . Run the app by entering the following command in the command shell: dotnet run Next steps Continue exploring C# development: Debug with VS Code and .NET Core Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Working with C# - Learn about the great C# support you'll have when working on your .NET Core application. Tasks - Running tasks with Gulp, Grunt, and Jake. Showing Errors and Warnings .NET Core Docs - Visit the .NET Core docs for more information on this powerful cross-platform development solution. Deploying Applications to Azure - Deploy your app to Azure . Get Started with F# in Visual Studio Code"
  },
  "guides/vscode/languages/go.html": {
    "href": "guides/vscode/languages/go.html",
    "title": "Go in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Go in Visual Studio Code Using the Go extension for Visual Studio Code, you get features like IntelliSense, code navigation, symbol search, testing, debugging, and many more that will help you in Go development. You can install the Go extension from the VS Code Marketplace . Watch \"Getting started with VS Code Go\" for an explanation of how to build your first Go application using VS Code Go. This article describes only a subset of the features the Go extension provides. See the extension's documentation for the full, up-to-date list of supported features. IntelliSense IntelliSense features are provided by the Go language server, gopls , maintained by the Go team. You can configure the behavior of gopls using the gopls settings . Auto completions As you type in a Go file, you can see IntelliSense providing you with suggested completions. This even works for members in current, imported, and not yet imported packages. Just type any package name followed by . , and you will get suggestions for the corresponding package members. Tip : Use kb(editor.action.triggerSuggest) to trigger the suggestions manually. Hover Information Hovering on any variable, function, or struct will give you information on that item such as documentation, signature, etc. Signature help When you open the ( while calling a function, a pop-up provides signature help for the function. As you keep typing the parameters, the hint (underline) moves to the next parameter. Tip : Use kb(editor.action.triggerParameterHints) to manually trigger the signature help when the cursor is inside the () in the function call. Code navigation Code navigation features are available in the context menu in the editor. Go To Definition kb(editor.action.revealDefinition) - Go to the source code of the type definition. Peek Definition kb(editor.action.peekDefinition) - Bring up a Peek window with the type definition. Go to References kb(editor.action.goToReferences) - Show all references for the type. Show Call Hierarchy kb(editor.showCallHierarchy) - Show all calls from or to a function. You can navigate via symbol search using the Go to Symbol commands from the Command Palette ( kb(workbench.action.showCommands) ). Go to Symbol in File - kb(workbench.action.gotoSymbol) Go to Symbol in Workspace - kb(workbench.action.showAllSymbols) You can also navigate back and forth between a Go file and its test implementation using the Go: Toggle Test File command. Build, test, and diagnose The Go language server ( gopls ) detects build and vet errors found on the workspace. The errors and warnings from running any/all of the above will be shown red/green squiggly lines in the editor. These diagnostics also show up in the Problems panel ( View > Problems ). You can add additional lint checks using the go.lintOnSave setting and configuring your choice of linting tool ( staticcheck , golangci-lint , or revive ) using the go.lintTool setting. You can configure the extension to run tests and compute test coverage using: go.testOnSave go.coverOnSave go.testFlags Formatting You can format your Go file using kb(editor.action.formatDocument) or by running the Format Document command from the Command Palette or the context menu in the editor. By default, formatting is run when you save your Go file. You can disable this behavior by setting editor.formatOnSave to false for the [go] language identifier. You can change this using your JSON setting files. \"[go]\": { \"editor.formatOnSave\": false } When you have multiple formatters activated for Go files, you can select the Go extension as the default formatter. \"[go]\": { \"editor.defaultFormatter\": \"golang.go\" } Formatting is provided by gopls . If you want gofumpt -style formatting, you can configure gopls to use gofumpt . \"gopls\": { \"formatting.gofumpt\": true } Test There are many test-related commands that you can explore by typing Go: test in the Command Palette . The first three above can be used to generate test skeletons for the functions in the current package, file, or at the cursor using gotests . The last few can be used to run tests in the current package, file, or at the cursor using go test . There is also a command for getting test coverage. Import packages Run the command Go: Add Import to get a list of packages that can be imported to your Go file. Choose one and it will get added in the import block of your Go file. Rename symbols You can rename symbols using kb(editor.action.rename) or by running the Rename Symbol command in the context menu in the editor. Debugging The Go extension lets you debug Go code as well. You will need to install the Delve debugger manually as a prerequisite. Read Debug Go programs in VS Code for setup steps, information on remote debugging and a troubleshooting guide. Next steps This has been a brief overview showing the Go extension features within VS Code. For more information, see the details provided in the Go extension README . To stay up to date on the latest features/bug fixes for the Go extension, see the CHANGELOG . If you have any issues or feature requests, feel free to log them in the Go extension vscode-go repo . If you'd like to learn more about VS Code, try these topics: Basic Editing - A quick introduction to the basics of the VS Code editor. Install an Extension - Learn about other extensions are available in the Marketplace . Code Navigation - Move quickly through your source code."
  },
  "guides/vscode/languages/html.html": {
    "href": "guides/vscode/languages/html.html",
    "title": "HTML in Visual Studio Code | Fountain of Knowledge",
    "keywords": "HTML in Visual Studio Code Visual Studio Code provides basic support for HTML programming out of the box. There is syntax highlighting, smart completions with IntelliSense, and customizable formatting. VS Code also includes great Emmet support. IntelliSense As you type in HTML, we offer suggestions via HTML IntelliSense. In the image below, you can see a suggested HTML element closure </div> as well as a context specific list of suggested elements. Document symbols are also available for HTML, allowing you to quickly navigate to DOM nodes by id and class name. You can also work with embedded CSS and JavaScript. However, note that script and style includes from other files are not followed, the language support only looks at the content of the HTML file. You can trigger suggestions at any time by pressing kb(editor.action.triggerSuggest) . You can also control which built-in code completion providers are active. Override these in your user or workspace settings if you prefer not to see the corresponding suggestions. // Configures if the built-in HTML language suggests HTML5 tags, properties and values. \"html.suggest.html5\": true Close tags Tag elements are automatically closed when > of the opening tag is typed. The matching closing tag is inserted when / of the closing tag is entered. You can turn off autoclosing tags with the following setting : \"html.autoClosingTags\": false Auto update tags When modifying a tag, the linked editing feature automatically updates the matching closing tag. The feature is optional and can be enabled by setting: \"editor.linkedEditing\": true Color picker The VS Code color picker UI is now available in HTML style sections. It supports configuration of hue, saturation and opacity for the color that is picked up from the editor. It also provides the ability to trigger between different color modes by clicking on the color string at the top of the picker. The picker appears on a hover when you are over a color definition. Hover Move the mouse over HTML tags or embedded styles and JavaScript to get more information on the symbol under the cursor. Validation The HTML language support performs validation on all embedded JavaScript and CSS. You can turn that validation off with the following settings: // Configures if the built-in HTML language support validates embedded scripts. \"html.validate.scripts\": true, // Configures if the built-in HTML language support validates embedded styles. \"html.validate.styles\": true Folding You can fold regions of source code using the folding icons on the gutter between line numbers and line start. Folding regions are available for all HTML elements for multiline comments in the source code. Additionally you can use the following region markers to define a folding region: <!-- #region --> and <!-- endregion --> If you prefer to switch to indentation based folding for HTML use: \"[html]\": { \"editor.foldingStrategy\": \"indentation\" }, Formatting To improve the formatting of your HTML source code, you can use the Format Document command kb(editor.action.formatDocument) to format the entire file or Format Selection kb(editor.action.formatSelection) to just format the selected text. The HTML formatter is based on js-beautify . The formatting options offered by that library are surfaced in the VS Code settings : html.format.wrapLineLength : Maximum amount of characters per line. html.format.unformatted : List of tags that shouldn't be reformatted. html.format.contentUnformatted : List of tags, comma separated, where the content shouldn't be reformatted. html.format.extraLiners : List of tags that should have an extra newline before them. html.format.preserveNewLines : Whether existing line breaks before elements should be preserved. html.format.maxPreserveNewLines : Maximum number of line breaks to be preserved in one chunk. html.format.endWithNewline : End with a newline. html.format.indentInnerHtml : Indent <head> and <body> sections. html.format.wrapAttributes : Wrapping strategy for attributes: auto : Wrap when the line length is exceeded force : Wrap all attributes, except first force-aligned : Wrap all attributes, except first, and align attributes force-expand-multiline : Wrap all attributes aligned-multiple : Wrap when line length is exceeded, align attributes vertically preserve : Preserve wrapping of attributes preserve-aligned : Preserve wrapping of attributes but align html.format.wrapAttributesIndentSize : Alignment size when using force aligned and aligned multiple in html.format.wrapAttributes or null to use the default indent size. html.format.templating : Honor django, erb, handlebars and php templating language tags. html.format.unformattedContentDelimiter : Keep text content together between this string. Tip: The formatter doesn't format the tags listed in the html.format.unformatted and html.format.contentUnformatted settings. Embedded JavaScript is formatted unless 'script' tags are excluded. The Marketplace has several alternative formatters to choose from. If you want to use a different formatter, define \"html.format.enable\": false in your settings to turn off the built-in formatter. Emmet snippets VS Code supports Emmet snippet expansion. Emmet abbreviations are listed along with other suggestions and snippets in the editor auto-completion list. Tip: See the HTML section of the Emmet cheat sheet for valid abbreviations. If you'd like to use HTML Emmet abbreviations with other languages, you can associate one of the Emmet modes (such as css , html ) with other languages with the emmet.includeLanguages setting . The setting takes a language id and associates it with the language id of an Emmet supported mode. For example, to use Emmet HTML abbreviations inside JavaScript: { \"emmet.includeLanguages\": { \"javascript\": \"html\" } } We also support User Defined Snippets . HTML custom data You can extend VS Code's HTML support through a declarative custom data format . By setting html.customData to a list of JSON files following the custom data format, you can enhance VS Code's understanding of new HTML tags, attributes and attribute values. VS Code will then offer language support such as completion & hover information for the provided tags, attributes and attribute values. You can read more about using custom data in the vscode-custom-data repository. HTML extensions Install an extension to add more functionality. Go to the Extensions view ( kb(workbench.view.extensions) ) and type 'html' to see a list of relevant extensions to help with creating and editing HTML. Tip: Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Next steps Read on to find out about: CSS, SCSS, and Less - VS Code has first class support for CSS including Less and SCSS. Emmet - Learn about VS Code's powerful built-in Emmet support. Emmet official documentation - Emmet, the essential toolkit for web-developers. Common questions Does VS Code have HTML preview? No, VS Code doesn't have built-in support for HTML preview but there are extensions available in the VS Code Marketplace . Open the Extensions view ( kb(workbench.view.extensions) ) and search on 'live preview' or 'html preview' to see a list of available HTML preview extensions."
  },
  "guides/vscode/languages/identifiers.html": {
    "href": "guides/vscode/languages/identifiers.html",
    "title": "Language Identifiers | Fountain of Knowledge",
    "keywords": "Language Identifiers In Visual Studio Code, each language mode has a unique specific language identifier. That identifier is rarely seen by the user except in the settings, for example, when associating file extensions to a language: \"files.associations\": { \"*.myphp\": \"php\" } Note that casing matters for exact identifier matching ('Markdown' != 'markdown') The language identifier becomes essential for VS Code extension developers when adding new language capabilities or when replacing a language support. Every language defines its id through the languages configuration point in the extension's package.json file: \"languages\": [{ \"id\": \"java\", \"extensions\": [ \".java\", \".jav\" ], \"aliases\": [ \"Java\", \"java\" ] }] Language supports are added using the language identifier: \"grammars\": [{ \"language\": \"groovy\", \"scopeName\": \"source.groovy\", \"path\": \"./syntaxes/Groovy.tmLanguage.json\" }], \"snippets\": [{ \"language\": \"groovy\", \"path\": \"./snippets/groovy.json\" }] languages.registerCompletionItemProvider('php', new PHPCompletionItemProvider(), '.', '$') New identifier guidelines When defining a new language identifier, use the following guidelines: Use the lowercased programming language name. Search for other extensions in the Marketplace to find out if a language identifier has already been used. Known language identifiers The following table lists known language identifiers: Language Identifier ABAP abap Windows Bat bat BibTeX bibtex Clojure clojure Coffeescript coffeescript C c C++ cpp C# csharp CSS css Diff diff Dockerfile dockerfile F# fsharp Git git-commit and git-rebase Go go Groovy groovy Handlebars handlebars Haml haml HTML html Ini ini Java java JavaScript javascript JavaScript React javascriptreact , jsx JSON json JSON with Comments jsonc LaTeX latex Less less Lua lua Makefile makefile Markdown markdown Objective-C objective-c Objective-C++ objective-cpp Perl perl and perl6 PHP php Plain Text plaintext PowerShell powershell Pug jade , pug Python python R r Razor (cshtml) razor Ruby ruby Rust rust SCSS scss (syntax using curly brackets), sass (indented syntax) ShaderLab shaderlab Shell Script (Bash) shellscript Slim slim SQL sql Stylus stylus Swift swift TypeScript typescript TypeScript React typescriptreact TeX tex Visual Basic vb Vue vue Vue HTML vue-html XML xml XSL xsl YAML yaml"
  },
  "guides/vscode/languages/java.html": {
    "href": "guides/vscode/languages/java.html",
    "title": "Java in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Java in Visual Studio Code Support for Java in Visual Studio Code is provided through a wide range of extensions . Combined with the power of core VS Code, these extensions give you a lightweight and performant code editor that also supports many of the most common Java development techniques. This article will give you an overview of different capabilities of Visual Studio Code for Java developers. For a quick walkthrough of editing, running, and debugging a Java program with Visual Studio Code, use the button below. Java Getting Started Tutorial Overview VS Code provides essential language features such as code completion, refactoring, linting, formatting, and code snippets along with convenient debugging and unit test support. VS Code also integrates with tooling and frameworks such as Maven, Tomcat, Jetty, and Spring Boot. Leveraging the power of Visual Studio Code, Java developers get an excellent tool for both quick code editing and also the full debugging and testing cycle. It's a great choice for your Java work if you're looking for a tool which: Is fast, lightweight, free, and open source. Supports many other languages, not just Java. Helps start your Java journey without installing and learning a complex IDE. Provides great microservices support including popular frameworks, container tooling, and cloud integration. Offers team-based collaboration features such as Visual Studio Live Share . Improves your productivity through IntelliSense and other code-aware editing features. Install Visual Studio Code for Java To help you set up quickly, we recommend you use the Coding Pack for Java , which is the bundle of VS Code, the Java Development Kit (JDK), and a collection of suggested extensions by Microsoft. The Coding Pack can also be used to fix an existing development environment. Install the Coding Pack for Java - Windows Install the Coding Pack for Java - macOS Note : The Coding Pack for Java is only available for Windows and macOS. For other operating systems, you will need to manually install a JDK, VS Code, and Java extensions. If you have already installed VS Code and want to add Java support to it, we recommend to use Java Extension Pack , a collection of extensions suggested by Microsoft: Language Support for Java(TM) by Red Hat Debugger for Java Java Test Runner Maven for Java Project Manager for Java Visual Studio IntelliCode Install the Java Extension Pack Alternatively, you can add Java language support to VS Code by installing the popular Java extensions by yourself. Download VS Code - If you haven't downloaded VS Code yet, quickly install for your platform (Windows, macOS, Linux). There are also other popular Java extensions you can pick for your own needs, including: Spring Boot Tools Spring Initializr Java Support Spring Boot Dashboard Tomcat Jetty Community Server Connectors Server Connector Extension Pack for MicroProfile CheckStyle SonarLint Thanks to the great Java community around VS Code, the list doesn't end there. You can search for more Java extensions easily within VS Code: Go to the Extensions view ( kb(workbench.view.extensions) ). Filter the extensions list by typing \"java\". This document describes some of the key features included in those Java extensions. Getting started NOTE: If you are using VS Code on Windows and want to take advantage of the Windows Subsystem for Linux, see Developing in WSL . Before you start, you must have the Java SE Development Kit (JDK) on your local environment. To run the VS Code for Java extension, Java SE 11 or above version is required; for projects, VS Code for Java supports projects with version 1.5 or above. For how to configure, refer to Configure JDK . For developers new to Java or new to VS Code, we provide a Getting Started experience. Once you've installed the Java Extension Pack , you can open the Getting Started experience from within VS Code with the Java: Getting Started command from the Command Palette. Open the Command Palette ( kb(workbench.action.showCommands) ) and type \"Java: Getting Started\". Working with Java source files You can use VS Code to read, write, run, and debug Java source file(s) without creating a project. VS Code for Java supports two modes, lightweight and standard. Lightweight mode is ideal for scenarios that only deal with source file(s). If you want to work with a full scale project, standard mode will be required. You can easily switch from lightweight mode to standard mode, when needed. To learn more, see Lightweight Mode . Working with Java project There are three things you must understand to work with Java in VS Code: How does VS Code handle Workspaces? How does VS Code handle Java? How does VS Code handle Workspaces that contain Java? VS Code Workspaces In Visual Studio Code, a \"Workspace\" means a collection of one or more filesystem folders (and their children) and all of the VS Code configurations that take effect when that \"Workspace\" is open in VS Code. There are two kinds of \"Workspaces\" in VS Code, \"folder workspaces\" and \"multi-root workspaces\". A \"folder workspace\" is presented by VS Code when you open a filesystem folder (directory) in VS Code. A \"multi-root workspace\" can refer to multiple folders (directories) from disparate parts of the file system and VS Code displays the contents of the folder(s) of the workspace together in the File Explorer . To learn more, see Multi-root Workspaces . Java project in VS Code In contrast to IDEs such as IntelliJ IDEA, NetBeans, or Eclipse, the concept of a \"Java project\" is provided entirely by extensions, and is not a core concept in the base VS Code. When working with \"Java projects\" in VS Code, you must have the necessary extensions installed to work with those project files. For example, Maven, Eclipse, and Gradle Java projects are supported through Language Support for Java(TM) by Red Hat , by utilizing M2Eclipse , which provides Maven support, and Buildship , which provides Gradle support through the Eclipse JDT Language Server . With Maven for Java , you can generate projects from Maven Archetypes , browse through all the Maven projects within your workspace, and execute Maven goals easily from an embedded explorer. Projects can also be created and managed with the Project Manager for Java extension. Visual Studio Code also supports working with standalone Java files outside of a Java project, described in the Java Tutorial with VS Code . VS Code Workspaces that contain Java project Assuming the necessary Java extensions are installed, opening a VS Code workspace that contains Java artifacts will cause those extensions to understand those artifacts and present options for working with them. More details about Java project support can be found in Java Project Management in Visual Studio Code and Build Tools . Editing Code Navigation Java in Visual Studio Code also supports source code navigation features such as search for symbol, Peek Definition, and Go to Definition. The Spring Boot Tools extension provides enhanced navigation and code completion support for Spring Boot projects. One of the key advantages of VS Code is speed. When you open your Java source file or folder, within a few seconds, with the help of Lightweight Mode , you will be able to navigate your code base with Outline view as well as commands such as Go to Definition and Go to Reference . This is especially useful when you open a project for the first time. Code Completion IntelliSense is a general term for language features, including intelligent code completion (in-context method and variable suggestions) across all your files and for built-in and third-party modules. VS Code supports code completion and IntelliSense for Java through Language Support for Java(TM) by Red Hat . It also provides AI-assisted IntelliSense called IntelliCode by putting what you're most likely to use at the top of your completion list. See also in Java Code Navigation and Editing . VS Code also supports a range of Refactoring and Linting features. Debugging Debugger for Java is a lightweight Java Debugger based on Java Debug Server . It works with Language Support for Java by Red Hat to allow users to debug Java code within Visual Studio Code. Starting a debugging session is easy, click on the Run|Debug button available at the CodeLens of your main() function, or press kb(workbench.action.debug.start) . The debugger will automatically generate the proper configuration for you. Although it's lightweight, the Java debugger supports advanced features such as expression evaluation, conditional breakpoints, and hot code replacement. For more debugging related information, visit Java Debugging . Testing With the support from the Java Test Runner extension, you can easily run, debug, and manage your JUnit and TestNG test cases. For more about testing, read Testing Java . Spring Boot, Tomcat, and Jetty To further improve your Java productivity in VS Code, there are extensions for most popular frameworks and tools such as Spring Boot , Tomcat , and Jetty created by the community. The Tomcat extension includes an explorer to easily navigate and manage your Tomcat servers. You can create, start, debug, stop, and rename your Tomcat server with the extension. See Application Servers to learn more about support for Tomcat and Jetty as well as other application servers with VS Code. Spring Boot support is provided by Pivotal . There are also Spring Initializr Java Support and Spring Boot Dashboard extensions available from Microsoft to further improve your experience with Spring Boot in Visual Studio Code. See Spring Boot with VS Code to learn more about Spring Boot support with VS Code and also Deploy to Azure Web Apps or Deploy to Azure Spring Cloud to learn more about deploying Spring apps to Azure from VS Code. Next steps You may Sign up to follow the latest of Java on Visual Studio Code. Learn more about Java in VS Code Java Tutorial with VS Code Code Editing and Navigation Java Debugging Java Testing Java Project Management Spring Boot with VS Code Tomcat and Jetty Support Azure with VS Code Read on to find out more about Visual Studio Code: Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Tasks - use tasks to build your project and more Debugging - find out how to use the debugger with your project"
  },
  "guides/vscode/languages/javascript.html": {
    "href": "guides/vscode/languages/javascript.html",
    "title": "JavaScript in Visual Studio Code | Fountain of Knowledge",
    "keywords": "JavaScript in Visual Studio Code Visual Studio Code includes built-in JavaScript IntelliSense, debugging, formatting, code navigation, refactorings, and many other advanced language features. Most of these features just work out of the box, while some may require basic configuration to get the best experience. This page summarizes the JavaScript features that VS Code ships with. Extensions from the VS Code Marketplace can augment or change most of these built-in features. For a more in-depth guide on how these features work and can be configured, see Working with JavaScript . IntelliSense IntelliSense shows you intelligent code completion, hover info, and signature information so that you can write code more quickly and correctly. Sorry, your browser doesn't support HTML 5 video. VS Code provides IntelliSense within your JavaScript projects; for many npm libraries such as React , lodash , and express ; and for other platforms such as node , serverless, or IoT. See Working with JavaScript for information about VS Code's JavaScript IntelliSense, how to configure it, and help troubleshooting common IntelliSense problems. JavaScript projects (jsconfig.json) A jsconfig.json file defines a JavaScript project in VS Code. While jsconfig.json files are not required, you will want to create one in cases such as: If not all JavaScript files in your workspace should be considered part of a single JavaScript project. jsconfig.json files let you exclude some files from showing up in IntelliSense. To ensure that a subset of JavaScript files in your workspace is treated as a single project. This is useful if you are working with legacy code that uses implicit globals dependencies instead of imports for dependencies. If your workspace contains more than one project context, such as front-end and back-end JavaScript code. For multi-project workspaces, create a jsconfig.json at the root folder of each project. You are using the TypeScript compiler to down-level compile JavaScript source code. To define a basic JavaScript project, add a jsconfig.json at the root of your workspace: { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\" }, \"exclude\": [ \"node_modules\" ] } See Working with JavaScript for more advanced jsconfig.json configuration. Tip: To check if a JavaScript file is part of JavaScript project, just open the file in VS Code and run the JavaScript: Go to Project Configuration command. This command opens the jsconfig.json that references the JavaScript file. A notification is shown if the file is not part of any jsconfig.json project. Snippets VS Code includes basic JavaScript snippets that are suggested as you type; Sorry, your browser doesn't support HTML 5 video. There are many extensions that provide additional snippets, including snippets for popular frameworks such as Redux or Angular. You can even define your own snippets . Tip : To disable snippets suggestions, set editor.snippetSuggestions to \"none\" in your settings file. The editor.snippetSuggestions setting also lets you change where snippets appear in the suggestions: at the top ( \"top\" ), at the bottom ( \"bottom\" ), or inlined ordered alphabetically ( \"inline\" ). The default is \"inline\" . JSDoc support VS Code understands many standard JSDoc annotations, and uses these annotations to provide rich IntelliSense . You can optionally even use the type information from JSDoc comments to type check your JavaScript . Sorry, your browser doesn't support HTML 5 video. Quickly create JSDoc comments for functions by typing /** before the function declaration, and select the JSDoc comment snippet suggestion: Sorry, your browser doesn't support HTML 5 video. To disable JSDoc comment suggestions, set \"javascript.suggest.completeJSDocs\": false . Hover Information Hover over a JavaScript symbol to quickly see its type information and relevant documentation. The kb(editor.action.showHover) keyboard shortcut shows this hover info at the current cursor position. Signature Help As you write JavaScript function calls, VS Code shows information about the function signature and highlights the parameter that you are currently completing: Signature help is shown automatically when you type a ( or , within a function call. Press kb(editor.action.triggerParameterHints) to manually trigger signature help. Auto imports Automatic imports speed up coding by suggesting available variables throughout your project and its dependencies. When you select one of these suggestions, VS Code automatically adds an import for it to the top of the file. Just start typing to see suggestions for all available JavaScript symbols in your current project. Auto import suggestions show where they will be imported from: If you choose one of these auto import suggestions, VS Code adds an import for it. In this example, VS Code adds an import for Button from material-ui to the top of the file: To disable auto imports, set \"javascript.suggest.autoImports\" to false . Tip: VS Code tries to infer the best import style to use. You can explicitly configure the preferred quote style and path style for imports added to your code with the javascript.preferences.quoteStyle and javascript.preferences.importModuleSpecifier settings. Formatting VS Code's built-in JavaScript formatter providers basic code formatting with reasonable defaults. The javascript.format.* settings configure the built-in formatter. Or, if the built-in formatter is getting in the way, set \"javascript.format.enable\" to false to disable it. For more specialized code formatting styles, try installing one of the JavaScript formatting extensions from the Marketplace . JSX and auto closing tags All of VS Code's JavaScript features also work with JSX : You can use JSX syntax in both normal *.js files and in *.jsx files. VS Code also includes JSX-specific features such as autoclosing of JSX tags: Sorry, your browser doesn't support HTML 5 video. Set \"javascript.autoClosingTags\" to false to disable JSX tag closing. Code navigation Code navigation lets you quickly navigate JavaScript projects. Go To Definition kb(editor.action.revealDefinition) - Go to the source code of a symbol definition. Peek Definition kb(editor.action.peekDefinition) - Bring up a Peek window that shows the definition of a symbol. Go to References kb(editor.action.goToReferences) - Show all references to a symbol. Go to Type Definition kb(editor.action.goToTypeDefinition) - Go to the type that defines a symbol. For an instance of a class, this will reveal the class itself instead of where the instance is defined. You can navigate via symbol search using the Go to Symbol commands from the Command Palette ( kb(workbench.action.showCommands) ). Go to Symbol in File kb(workbench.action.gotoSymbol) Go to Symbol in Workspace kb(workbench.action.showAllSymbols) Rename Press kb(editor.action.rename) to rename the symbol under the cursor across your JavaScript project: Refactoring VS Code includes some handy refactorings for JavaScript such as Extract function and Extract constant . Just select the source code you'd like to extract and then click on the lightbulb in the gutter or press ( kb(editor.action.quickFix) ) to see available refactorings. Available refactorings include: Extract to method or function. Extract to constant. Convert between named imports and namespace imports. Move to new file. See Refactorings for more information about refactorings and how you can configure keyboard shortcuts for individual refactorings. Unused variables and unreachable code Unused JavaScript code, such the else block of an if statement that is always true or an unreferenced import, is faded out in the editor: You can quickly remove this unused code by placing the cursor on it and triggering the Quick Fix command ( kb(editor.action.quickFix) ) or clicking on the lightbulb. To disable fading out of unused code, set \"editor.showUnused\" to false . You can also disable fading of unused code only in JavaScript by setting: \"[javascript]\": { \"editor.showUnused\": false }, \"[javascriptreact]\": { \"editor.showUnused\": false }, Organize Imports The Organize Imports Source Action sorts the imports in a JavaScript file and removes any unused imports: <!-- TODO: replace with js specific example --> Sorry, your browser doesn't support HTML 5 video. You can run Organize Imports from the Source Action context menu or with the kb(editor.action.organizeImports) keyboard shortcut. Organize imports can also be done automatically when you save a JavaScript file by setting: \"editor.codeActionsOnSave\": { \"source.organizeImports\": true } Code Actions on Save The editor.codeActionsOnSave setting lets you configure a set of Code Actions that are run when a file is saved. For example, you can enable organize imports on save by setting: // On save, run both fixAll and organizeImports source actions \"editor.codeActionsOnSave\": { \"source.fixAll\": true, \"source.organizeImports\": true, } You can also set editor.codeActionsOnSave to an array of Code Actions to execute in order. Here are some source actions: \"organizeImports\" - Enables organize imports on save. \"fixAll\" - Auto Fix on Save computes all possible fixes in one round (for all providers including ESLint). \"fixAll.eslint\" - Auto Fix only for ESLint. \"addMissingImports\" - Adds all missing imports on save. See Node.js/JavaScript for more information. Code suggestions VS Code automatically suggests some common code simplifications such as converting a chain of .then calls on a promise to use async and await Sorry, your browser doesn't support HTML 5 video. Set \"javascript.suggestionActions.enabled\" to false to disable suggestions. References CodeLens The JavaScript references CodeLens displays an inline count of reference for classes, methods, properties, and exported objects: To enable the references CodeLens, set \"javascript.referencesCodeLens.enabled\" to true . Click on the reference count to quickly browse a list of references: Update imports on file move When you move or rename a file that is imported by other files in your JavaScript project, VS Code can automatically update all import paths that reference the moved file: Sorry, your browser doesn't support HTML 5 video. The javascript.updateImportsOnFileMove.enabled setting controls this behavior. Valid settings values are: \"prompt\" - The default. Asks if paths should be updated for each file move. \"always\" - Always automatically update paths. \"never\" - Do not update paths automatically and do not prompt. Linters Linters provides warnings for suspicious looking code. While VS Code does not include a built-in JavaScript linter, many JavaScript linter extensions available in the marketplace. Tip: This list is dynamically queried from the VS Code Marketplace . Read the description and reviews to decide if the extension is right for you. Type checking You can leverage some of TypeScript's advanced type checking and error reporting functionality in regular JavaScript files too. This is a great way to catch common programming mistakes. These type checks also enable some exciting Quick Fixes for JavaScript, including Add missing import and Add missing property . TypeScript tried to infer types in .js files the same way it does in .ts files. When types cannot be inferred, they can be specified explicitly with JSDoc comments. You can read more about how TypeScript uses JSDoc for JavaScript type checking in Working with JavaScript . Type checking of JavaScript is optional and opt-in. Existing JavaScript validation tools such as ESLint can be used alongside built-in type checking functionality. Debugging VS Code comes with great debugging support for JavaScript. Set breakpoints, inspect objects, navigate the call stack, and execute code in the Debug Console. See the Debugging topic to learn more. Debug client side You can debug your client-side code using a browser debugger such as our built-in debugger for Edge and Chrome, or the Debugger for Firefox . Debug server side Debug Node.js in VS Code using the built-in debugger. Setup is easy and there is a Node.js debugging tutorial to help you. Popular extensions VS Code ships with excellent support for JavaScript but you can additionally install debuggers, snippets, linters, and other JavaScript tools through extensions . Tip: The extensions shown above are dynamically queried. Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Next steps Read on to find out about: Working with JavaScript - More detailed information about VS Code's JavaScript support and how to troubleshoot common issues. jsconfig.json - Detailed description of the jsconfig.json project file. IntelliSense - Learn more about IntelliSense and how to use it effectively for your language. Debugging - Learn how to set up debugging for your application. Node.js - A walkthrough to create an Express Node.js application. TypeScript - VS Code has great support for TypeScript, which brings structure and strong typing to your JavaScript code. Watch these introductory videos: IntelliSense - Tutorial on IntelliSense with JavaScript. Debugging - Learn how to debug a Node.js application. Common questions Does VS Code support JSX and React Native? VS Code supports JSX and React Native . You will get IntelliSense for React/JSX and React Native from automatically downloaded type declaration (typings) files from the npmjs type declaration file repository. Additionally, you can install the popular React Native extension from the Marketplace. To enable ES6 import statements for React Native , you need to set the allowSyntheticDefaultImports compiler option to true . This tells the compiler to create synthetic default members and you get IntelliSense. React Native uses Babel behind the scenes to create the proper run-time code with default members. If you also want to do debugging of React Native code, you can install the React Native Extension . Does VS Code support the Dart programming language and the Flutter framework? Yes, there are VS Code extensions for both Dart and Flutter development. You can learn more at the Flutter.dev documentation. IntelliSense is not working for external libraries Automatic Type Acquisition works for dependencies downloaded by npm (specified in package.json ), Bower (specified in bower.json ), and for many of the most common libraries listed in your folder structure (for example jquery-3.1.1.min.js ). ES6 Style imports are not working. When you want to use ES6 style imports but some type declaration (typings) files do not yet use ES6 style exports, then set the TypeScript compiler option allowSyntheticDefaultImports to true. { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\", // This is the line you want to add \"allowSyntheticDefaultImports\": true }, \"exclude\": [ \"node_modules\", \"**/node_modules/*\" ] } Can I debug minified/uglified JavaScript? Yes, you can. You can see this working using JavaScript source maps in the Node.js Debugging topic. How do I disable Syntax Validation when using non-ES6 constructs? Some users want to use syntax constructs like the proposed pipeline ( |> ) operator. However, these are currently not supported by VS Code's JavaScript language service and are flagged as errors. For users who still want to use these future features, we provide the javascript.validate.enable setting . With javascript.validate.enable: false , you disable all built-in syntax checking. If you do this, we recommend that you use a linter like ESLint to validate your source code. Can I use other JavaScript tools like Flow? Yes, but some of Flow's language features such as type and error checking may interfere with VS Code's built-in JavaScript support. To learn how to disable VS Code's built-in JavaScript support, see Disable JavaScript support ."
  },
  "guides/vscode/languages/jsconfig.html": {
    "href": "guides/vscode/languages/jsconfig.html",
    "title": "jsconfig.json | Fountain of Knowledge",
    "keywords": "jsconfig.json What is jsconfig.json? The presence of jsconfig.json file in a directory indicates that the directory is the root of a JavaScript Project. The jsconfig.json file specifies the root files and the options for the features provided by the JavaScript language service . Tip: If you are not using JavaScript, you do not need to worry about jsconfig.json . Tip: jsconfig.json is a descendant of tsconfig.json , which is a configuration file for TypeScript. jsconfig.json is tsconfig.json with \"allowJs\" attribute set to true . Why do I need a jsconfig.json file? Visual Studio Code's JavaScript support can run in two different modes: File Scope - no jsconfig.json : In this mode, JavaScript files opened in Visual Studio Code are treated as independent units. As long as a file a.js doesn't reference a file b.ts explicitly (either using import or CommonJS modules ), there is no common project context between the two files. Explicit Project - with jsconfig.json : A JavaScript project is defined via a jsconfig.json file. The presence of such a file in a directory indicates that the directory is the root of a JavaScript project. The file itself can optionally list the files belonging to the project, the files to be excluded from the project, as well as compiler options (see below). The JavaScript experience is improved when you have a jsconfig.json file in your workspace that defines the project context. For this reason, we offer a hint to create a jsconfig.json file when you open a JavaScript file in a fresh workspace. Location of jsconfig.json We define this part of our code, the client side of our website, as a JavaScript project by creating a jsconfig.json file. Place the file at the root of your JavaScript code as shown below. In more complex projects, you may have more than one jsconfig.json file defined inside a workspace. You will want to do this so that the code in one project is not suggested as IntelliSense to code in another project. Illustrated below is a project with a client and server folder, showing two separate JavaScript projects. Examples By default the JavaScript language service will analyze and provide IntelliSense for all files in your JavaScript project. You will want to specify which files to exclude or include in order to provide the proper IntelliSense. Using the \"exclude\" property The exclude attribute (a glob pattern) tells the language service what files are not part of your source code. This keeps performance at a high level. If IntelliSense is slow, add folders to your exclude list (VS Code will prompt you to do this if it detects the slow down). { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\" }, \"exclude\": [ \"node_modules\" ] } Tip: You will want to exclude files generated by a build process (for example, a dist directory). These files will cause suggestions to show up twice and will slow down IntelliSense. Using the \"include\" property Alternatively, you can explicitly set the files in your project using the include attribute (a glob pattern). If no include attribute is present, then this defaults to including all files in the containing directory and subdirectories. When a include attribute is specified, only those files are included. Here is an example with an explicit include attribute. { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\" }, \"include\": [ \"src/**/*\" ] } Tip: The file paths in exclude and include are relative to the location of jsconfig.json . jsconfig Options Below are jsconfig \"compilerOptions\" to configure the JavaScript language support. Tip: Do not be confused by compilerOptions . This attribute exists because jsconfig.json is a descendant of tsconfig.json , which is used for compiling TypeScript. Option Description noLib Do not include the default library file (lib.d.ts) target Specifies which default library (lib.d.ts) to use. The values are \"es3\", \"es5\", \"es6\", \"es2015\", \"es2016\", \"es2017\", \"es2018\", \"es2019\", \"es2020\", \"esnext\". module Specifies the module system, when generating module code. The values are \"amd\", \"commonJS\", \"es2015\", \"es6\", \"esnext\", \"none\", \"system\", \"umd\". moduleResolution Specifies how modules are resolved for imports. The values are \"node\" and \"classic\". checkJs Enable type checking on JavaScript files. experimentalDecorators Enables experimental support for proposed ES decorators. allowSyntheticDefaultImports Allow default imports from modules with no default export. This does not affect code emit, just type checking. baseUrl Base directory to resolve non-relative module names. paths Specify path mapping to be computed relative to baseUrl option. You can read more about the available compilerOptions in the TypeScript compilerOptions documentation . Using webpack aliases For IntelliSense to work with webpack aliases, you need to specify the paths keys with a glob pattern. For example, for alias 'ClientApp': { \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": { \"ClientApp/*\": [\"./ClientApp/*\"] } } } and then to use the alias import Something from 'ClientApp/foo' Best Practices Whenever possible, you should exclude folders with JavaScript files that are not part of the source code for your project. Tip: If you do not have a jsconfig.json in your workspace, VS Code will by default exclude the node_modules folder. Below is a table, mapping common project components to their installation folders that are recommended to exclude: Component folder to exclude node exclude the node_modules folder webpack , webpack-dev-server exclude the content folder, for example dist . bower exclude the bower_components folder ember exclude the tmp and temp folders jspm exclude the jspm_packages folder When your JavaScript project is growing too large and performance slows, it is often because of library folders like node_modules . If VS Code detects that your project is growing too large, it will prompt you to edit the exclude list."
  },
  "guides/vscode/languages/json.html": {
    "href": "guides/vscode/languages/json.html",
    "title": "Editing JSON with Visual Studio Code | Fountain of Knowledge",
    "keywords": "Editing JSON with Visual Studio Code JSON is a data format that is common in configuration files like package.json or project.json . We also use it extensively in Visual Studio Code for our configuration files. When opening a file that ends with .json , VS Code provides features to make it simpler to write or modify the file's content. IntelliSense and validation For properties and values, both for JSON data with or without a schema, we offer up suggestions as you type with IntelliSense. You can also manually see suggestions with the Trigger Suggestions command ( kb(editor.action.triggerSuggest) ). We also perform structural and value verification based on an associated JSON schema giving you red squiggles. Package and project dependencies We also offer IntelliSense for specific value sets such as package and project dependencies in package.json , project.json , and bower.json . Quick navigation JSON files can get large and we support quick navigation to properties using the Go to Symbol command ( kb(workbench.action.gotoSymbol) ). Hovers When you hover over properties and values for JSON data with or without schema, we will provide additional context. Formatting You can format your JSON document using kb(editor.action.formatDocument) or Format Document from the context menu. Folding You can fold regions of source code using the folding icons on the gutter between line numbers and line start. Folding regions are available for all object and array elements. JSON with Comments In addition to the default JSON mode following the JSON specification , VS Code also has a JSON with Comments (jsonc) mode. This mode is used for the VS Code configuration files such as settings.json , tasks.json , or launch.json . When in the JSON with Comments mode, you can use single line (//) as well as block comments (/* */) as used in JavaScript. The current editor mode is indicated in the editor's Status Bar. Select the mode indicator to change the mode and to configure how file names and extensions are associated to modes. JSON schemas and settings To understand the structure of JSON files, we use JSON schemas . JSON schemas describe the shape of the JSON file, as well as value sets, default values, and descriptions. The JSON support shipped with VS Code supports JSON Schema Draft 7. Servers like JSON Schema Store provide schemas for most of the common JSON-based configuration files. However, schemas can also be defined in a file in the VS Code workspace, as well as the VS Code settings files. The association of a JSON file to a schema can be done either in the JSON file itself using the $schema attribute, or in the User or Workspace settings ( File > Preferences > Settings ) under the property json.schemas . VS Code extensions can also define schemas and schema mapping. That's why VS Code already knows about the schema of some well-known JSON files such as package.json , bower.json , and tsconfig.json . Mapping in the JSON In the following example, the JSON file specifies that its contents follow the CoffeeLint schema. { \"$schema\": \"https://json.schemastore.org/coffeelint\", \"line_endings\": \"unix\" } Note that this syntax is VS Code-specific and not part of the JSON Schema specification . Adding the $schema key changes the JSON itself, which systems consuming the JSON might not expect, for example, schema validation might fail. If this is the case, you can use one of the other mapping methods. Mapping in the User Settings The following excerpt from User Settings shows how .babelrc files are mapped to the babelrc schema located on https://json.schemastore.org/babelrc . \"json.schemas\": [ { \"fileMatch\": [ \"/.babelrc\" ], \"url\": \"https://json.schemastore.org/babelrc\" } ] Tip: In addition to defining a schema for .babelrc , also make sure that .babelrc is associated to the JSON language mode. This is also done in the settings using the files.association array setting. Mapping to a schema in the workspace To map a schema that is located in the workspace, use a relative path. In this example, a file in the workspace root called myschema.json will be used as the schema for all files ending with .foo.json . \"json.schemas\": [ { \"fileMatch\": [ \"/*.foo.json\" ], \"url\": \"./myschema.json\" } ] Mapping to a schema defined in settings To map a schema that is defined in the User or Workspace settings, use the schema property. In this example, a schema is defined that will be used for all files named .myconfig . \"json.schemas\": [ { \"fileMatch\": [ \"/.myconfig\" ], \"schema\": { \"type\": \"object\", \"properties\": { \"name\" : { \"type\": \"string\", \"description\": \"The name of the entry\" } } } } ] Mapping a schema in an extension Schemas and schema associations can also be defined by an extension. Check out the jsonValidation contribution point . File match syntax The file match syntax supports the '*' wildcard. Also, you can define exclusion patterns, starting with '!'. For an association to match, at least one pattern needs to match and the last matching pattern must not be an exclusion pattern. \"json.schemas\": [ { \"fileMatch\": [ \"/receipts/*.json\", \"!/receipts/*.excluded.json\" ], \"url\": \"./receipts.schema.json\" } ] Define snippets in JSON schemas JSON schemas describe the shape of the JSON file, as well as value sets and default values, which are used by the JSON language support to provide completion proposals. If you are a schema author and want to provide even more customized completion proposals, you can also specify snippets in the schema. The following example shows a schema for a key binding settings file defining a snippet: { \"type\": \"array\", \"title\": \"Keybindings configuration\", \"items\": { \"type\": \"object\", \"required\": [\"key\"], \"defaultSnippets\": [ { \"label\": \"New keybinding\", \"description\": \"Binds a key to a command for a given state\", \"body\": { \"key\": \"$1\", \"command\": \"$2\", \"when\": \"$3\" } } ], \"properties\": { \"key\": { \"type\": \"string\" } ... } } } This is an example in a JSON schema: Use the property defaultSnippets to specify any number of snippets for the given JSON object. label and description will be shown in the completion selection dialog. If no label is provided, a stringified object representation of the snippet will be shown as label instead. body is the JSON object that is stringified and inserted when the completion is selected by the user. Snippet syntax can be used inside strings literals to define tabstops, placeholders, and variables. If a string starts with ^ , the string content will be inserted as-is, not stringified. You can use this to specify snippets for numbers and booleans. Note that defaultSnippets is not part of the JSON schema specification but a VS Code-specific schema extension. Use rich formatting in hovers VS Code will use the standard description field from the JSON Schema specification in order to provide information about properties on hover and during autocomplete. If you want your descriptions to support formatting like links, you can opt in by using Markdown in your formatting with the markdownDescription property. { \"$schema\": \"http://json-schema.org/schema\", \"type\": \"object\", \"properties\": { \"name\" : { \"type\": \"string\", \"description\": \"The name of the entry\", \"markdownDescription\": \"The name of the entry. [See the documentation](https://example.com)\" } } } Note that markdownDescription is not part of the JSON schema specification but a VS Code-specific schema extension. Offline mode json.schemaDownload.enable controls whether the JSON extension fetches JSON schemas from http and https . A warning triangle will show in the status bar when the current editor would like to use schemas that cannot be downloaded."
  },
  "guides/vscode/languages/markdown.html": {
    "href": "guides/vscode/languages/markdown.html",
    "title": "Markdown and Visual Studio Code | Fountain of Knowledge",
    "keywords": "Markdown and Visual Studio Code Working with Markdown files in Visual Studio Code is simple, straightforward, and fun. Besides VS Code's basic editing, there are a number of Markdown specific features that will help you be more productive. Markdown extensions In addition to the functionality VS Code provides out of the box, you can install an extension for greater functionality. Tip: Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Markdown preview VS Code supports Markdown files out of the box. You just start writing Markdown text, save the file with the .md extension and then you can toggle the visualization of the editor between the code and the preview of the Markdown file; obviously, you can also open an existing Markdown file and start working with it. To switch between views, press kb(markdown.showPreview) in the editor. You can view the preview side-by-side ( kb(markdown.showPreviewToSide) ) with the file you are editing and see changes reflected in real-time as you edit. Here is an example with a very simple file. Tip: You can also right-click on the editor Tab and select Open Preview ( kb(markdown.showPreview) ) or use the Command Palette ( kb(workbench.action.showCommands) ) to run the Markdown: Open Preview to the Side command ( kb(markdown.showPreviewToSide) ). Dynamic previews and preview locking By default, Markdown previews automatically update to preview the currently active Markdown file: You can lock a Markdown preview using the Markdown: Toggle Preview Locking command to keep it locked to its current Markdown document. Locked previews are indicated by [Preview] in the title: Editor and preview synchronization VS Code automatically synchronizes the Markdown editor and the preview panes. Scroll the Markdown preview and the editor is scrolled to match the preview's viewport. Scroll the Markdown editor and the preview is scrolled to match its viewport: You can disable scroll synchronization using the markdown.preview.scrollPreviewWithEditor and markdown.preview.scrollEditorWithPreview settings . The currently selected line in the editor is indicated in the Markdown preview by a light gray bar in the left margin: Additionally, double clicking an element in the Markdown preview will automatically open the editor for the file and scroll to the line nearest the clicked element. Outline view The Outline view is a separate section in the bottom of the File Explorer. When expanded, it will show the symbol tree of the currently active editor. For Markdown files, the symbol tree is the Markdown file's header hierarchy. The Outline view is a great way to review your document's header structure and outline. Extending the Markdown preview Extensions can contribute custom styles and scripts to the Markdown preview to change its appearance and add new functionality. Here's a set of example extensions that customize the preview: Using your own CSS You can also use your own CSS in the Markdown preview with the \"markdown.styles\": [] setting . This lists URLs for style sheets to load in the Markdown preview. These stylesheets can either be https URLs, or relative paths to local files in the current workspace. For example, to load a stylesheet called Style.css at the root of your current workspace, use File > Preferences > Settings to bring up the workspace settings.json file and make this update: // Place your settings in this file to overwrite default and user settings. { \"markdown.styles\": [ \"Style.css\" ] } Keep trailing whitespace in order to create line breaks To create hard line breaks , Markdown requires two or more spaces at the end of a line. Depending on your user or workspace settings, VS Code may be configured to remove trailing whitespace. In order to keep trailing whitespace in Markdown files only, you can add these lines to your settings.json : { \"[markdown]\": { \"files.trimTrailingWhitespace\": false } } Markdown preview security For security reasons, VS Code restricts the content displayed in the Markdown preview. This includes disabling script execution and only allowing resources to be loaded over https . When the Markdown preview blocks content on a page, an alert popup is shown in the top right corner of the preview window: You can change what content is allowed in the Markdown preview by clicking on this popup or running the Markdown: Change preview security settings command in any Markdown file: The Markdown preview security settings apply to all files in the workspace. Here are the details about each of these security levels: Strict This is the default setting. Only loads trusted content and disables script execution. Blocks http images. It is strongly recommended that you keep Strict security enabled unless you have a very good reason to change it AND you trust all markdown files in the workspace. Allow insecure content Keeps scripts disabled but allows content to be loaded over http . Disable Disables additional security in the preview window. This allows script execution and also allows content to be loaded over http . Snippets for Markdown There are several built-in Markdown snippets included in VS Code - press kb(editor.action.triggerSuggest) (Trigger Suggest) and you get a context specific list of suggestions. Tip: You can add in your own User Defined Snippets for Markdown. Take a look at User Defined Snippets to find out how. Compiling Markdown into HTML VS Code integrates with Markdown compilers through the integrated task runner . We can use this to compile .md files into .html files. Let's walk through compiling a simple Markdown document. Step 1: Install a Markdown compiler For this walkthrough, we use the popular Node.js module, markdown-it . npm install -g markdown-it Note: There are many Markdown compilers to choose from beyond markdown-it . Pick the one that best suits your needs and environment. Step 2: Create a simple MD file Open VS Code on an empty folder and create a sample.md file. Note: You can open a folder with VS Code by either selecting the folder with File > Open Folder or navigating to the folder and typing 'code .' at the command line. Place the following source code in that file: # Hello Markdown in VS Code! This is a simple introduction to compiling Markdown in VS Code. Things you'll need: * [Node.js](https://nodejs.org) * [markdown-it](https://www.npmjs.com/package/markdown-it) * [tasks.json](../editor/tasks.md) ## Section Title > This block quote is here for your information. Step 3: Create tasks.json The next step is to set up the task configuration file tasks.json . To do this, run Terminal > Configure Tasks and click Create tasks.json file from templates . VS Code then presents a list of possible tasks.json templates to choose from. Select Others since we want to run an external command. This generates a tasks.json file in your workspace .vscode folder with the following content: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"echo\", \"type\": \"shell\", \"command\": \"echo Hello\" } ] } To use markdown-it to compile the Markdown file, change the contents as follows: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Compile Markdown\", \"type\": \"shell\", \"command\": \"markdown-it sample.md -o sample.html\", \"group\": \"build\" } ] } Tip: While the sample is there to help with common configuration settings, IntelliSense is available for the tasks.json file as well to help you along. Use kb(editor.action.triggerSuggest) to see the available settings. Step 4: Run the Build Task Since in more complex environments there can be more than one build task we prompt you to pick the task to execute after pressing kb(workbench.action.tasks.build) ( Run Build Task ). In addition, we allow you to scan the output for compile problems. Since we only want to convert the Markdown file to HTML select Never scan the build output from the presented list. At this point, you should see an additional file show up in the file list sample.html . If you want to make the Compile Markdown task the default build task to run execute Configure Default Build Task from the global Terminal menu and select Compile Markdown from the presented list. The final tasks.json file will then look like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Compile Markdown\", \"type\": \"shell\", \"command\": \"markdown-it sample.md -o sample.html\", \"problemMatcher\": [], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } Automating Markdown compilation Let's take things a little further and automate Markdown compilation with VS Code. We can do so with the same task runner integration as before, but with a few modifications. Step 1: Install Gulp and some plug-ins We use Gulp to create a task that automates Markdown compilation. We also use the gulp-markdown plug-in to make things a little easier. We need to install gulp both globally ( -g switch) and locally: npm install -g gulp npm install gulp gulp-markdown-it Note: gulp-markdown-it is a Gulp plug-in for the markdown-it module we were using before. There are many other Gulp Markdown plug-ins you can use, as well as plug-ins for Grunt. You can test that your gulp installation was successful by typing gulp -v . You should see a version displayed for both the global (CLI) and local installations. Step 2: Create a simple Gulp task Open VS Code on the same folder from before (contains sample.md and tasks.json under the .vscode folder), and create gulpfile.js at the root. Place the following source code in that file: var gulp = require('gulp'); var markdown = require('gulp-markdown-it'); gulp.task('markdown', function() { return gulp.src('**/*.md') .pipe(markdown()) .pipe(gulp.dest(function(f) { return f.base; })); }); gulp.task('default', function() { return gulp.watch('**/*.md', gulp.series(['markdown'])); }); What is happening here? We are watching for changes to any Markdown file in our workspace, i.e. the current folder open in VS Code. We take the set of Markdown files that have changed, and run them through our Markdown compiler, i.e. gulp-markdown-it . We now have a set of HTML files, each named respectively after their original Markdown file. We then put these files in the same directory. Step 3: Run the gulp default Task To complete the tasks integration with VS Code, we will need to modify the task configuration from before to run the default Gulp task we just created. You can either delete the tasks.json file or empty it only keeping the \"version\": \"2.0.0\" property. Now execute Run Task from the global Terminal menu. Observe that you are presented with a picker listing the tasks defined in the gulp file. Select gulp: default to start the task. We allow you to scan the output for compile problems. Since we only want to convert the Markdown file to HTML select Never scan the build output from the presented list. At this point, if you create and/or modify other Markdown files, you see the respective HTML files generated and/or changes reflected on save. You can also enable Auto Save to make things even more streamlined. If you want to make the gulp: default task the default build task executed when pressing kb(workbench.action.tasks.build) run Configure Default Build Task from the global Terminal menu and select gulp: default from the presented list. The final tasks.json file will then look like this: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"gulp\", \"task\": \"default\", \"problemMatcher\": [], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } Step 4: Terminate the gulp default Task The gulp: default task runs in the background and watches for file changes to Markdown files. If you want to stop the task, you can use the Terminate Task from the global Terminal menu. Next steps Read on to find out about: CSS, SCSS, and Less - Want to edit your CSS? VS Code has great support for CSS, SCSS, and Less editing. Common questions Is there spell checking? Not installed with VS Code but there are spell checking extensions. Check the VS Code Marketplace to look for useful extensions to help with your workflow. Does VS Code support GitHub Flavored Markdown? No, VS Code targets the CommonMark Markdown specification using the markdown-it library. GitHub is moving toward the CommonMark specification which you can read about in this update . In the walkthrough above, I didn't find the Configure Task command in the Command Palette? You may have opened a file in VS Code rather than a folder. You can open a folder by either selecting the folder with File > Open Folder or navigating to the folder and typing 'code .' at the command line."
  },
  "guides/vscode/languages/overview.html": {
    "href": "guides/vscode/languages/overview.html",
    "title": "Programming Languages | Fountain of Knowledge",
    "keywords": "Programming Languages Hundreds of programming languages supported In Visual Studio Code, we have support for almost every major programming language. Several ship in the box, for example, JavaScript, TypeScript, CSS, and HTML but more rich language extensions can be found in the VS Code Marketplace . Here are eight of the most popular language extensions: Go to the Marketplace or use the integrated Extensions view and search for your desired programming language to find snippets, code completion/IntelliSense providers, linters, debuggers, and more. Note : If you want to change the display language of VS Code (for example, to Chinese), see the Display Language topic. Language specific documentation Learn about programming languages supported by VS Code. These include: C++ - C# - CSS - Dart - Dockerfile - F# - Go - HTML - Java - JavaScript - JSON - Less - Markdown - PHP - PowerShell - Python - SCSS - T-SQL - TypeScript . Click on any linked item to get an overview of how to use VS Code in the context of that language. Most language extensions also contain a summary of their core features in their README. Language features in VS Code The richness of support varies across the different languages and their extensions: Syntax highlighting and bracket matching Smart completions (IntelliSense) Linting and corrections Code navigation (Go to Definition, Find All References) Debugging Refactoring Changing the language for the selected file In VS Code, we default the language support for a file based on its filename extension. However, at times you may want to change language modes, to do this click on the language indicator - which is located on the right hand of the Status Bar. This will bring up the Select Language Mode dropdown where you can select another language for the current file. Tip : You can get the same dropdown by running the Change Language Mode command ( kb(workbench.action.editor.changeLanguageMode) ). Language Id VS Code associates a language mode with a specific language identifier so that various VS Code features can be enabled based on the current language mode. A language identifier is often (but not always) the lowercased programming language name. Note that casing matters for exact identifier matching ('Markdown' != 'markdown'). Unknown language files have the language identifier plaintext . You can see the list of currently installed languages and their identifiers in the Change Language Mode ( kb(workbench.action.editor.changeLanguageMode) ) dropdown. You can find a list of known identifiers in the language identifier reference . Adding a file extension to a language You can add new file extensions to an existing language with the files.associations setting . For example, the setting below adds the .myphp file extension to the php language identifier: \"files.associations\": { \"*.myphp\": \"php\" } IntelliSense ( kb(editor.action.triggerSuggest) ) will show you the available language identifiers. Next steps Now you know that VS Code has support for the languages you care about. Read on... Code Navigation - Peek and Go to Definition and more Debugging - This is where VS Code really shines Common questions Can I contribute my own language service? Yes you can! Check out the example language server in the VS Code Extension API documentation. What if I don't want to create a full language service, can I reuse existing TextMate bundles? Yes, you can also add support for your favorite language through TextMate colorizers. See the Syntax Highlight Guide in the Extension API section to learn how to integrate TextMate .tmLanguage syntax files into VS Code. Can I map additional file extensions to a language? Yes, with the files.associations setting you can map file extensions to an existing language either globally or per workspace. Here is an example that will associate more file extensions to the PHP language: \"files.associations\": { \"*.php4\": \"php\", \"*.php5\": \"php\" } You can also configure full file paths to languages if needed. The following example associates all files in a folder somefolder to PHP: \"files.associations\": { \"**/somefolder/*.*\": \"php\" } Note that the pattern is a glob pattern that will match on the full path of the file if it contains a / and will match on the file name otherwise. How do I set the default language for new files? Using the files.defaultLanguage setting , you can map all new files to a default language. Whenever a new blank file is opened, the editor will be configured for that language mode. This example will associate new files with the HTML language: // The default language mode that is assigned to new files. \"files.defaultLanguage\": \"html\""
  },
  "guides/vscode/languages/php.html": {
    "href": "guides/vscode/languages/php.html",
    "title": "PHP in Visual Studio Code | Fountain of Knowledge",
    "keywords": "PHP in Visual Studio Code Visual Studio Code is a great editor for PHP development. You get features like syntax highlighting and bracket matching, IntelliSense (code completion), and snippets out of the box and you can add more functionality through community-created VS Code extensions . Linting VS Code uses the official PHP linter ( php -l ) for PHP language diagnostics. This allows VS Code to stay current with PHP linter improvements. Tip: Using XAMPP? Install the full version of PHP in order to obtain the development libraries. There are three settings to control the PHP linter: php.validate.enable : controls whether to enable PHP linting at all. Enabled by default. php.validate.executablePath : points to the PHP executable on disk. Set this if the PHP executable is not on the system path. php.validate.run : controls whether the validation is triggered on save (value: \"onSave\" ) or on type (value: \"onType\" ). Default is on save. To change the PHP settings, open your User or Workspace Settings ( kb(workbench.action.openSettings) ) and type 'php' to filter the list of available settings. To set the PHP executable path, select the Edit in settings.json link under PHP > Validate: Executable Path , which will open your user settings.json file. Add the php.validate.executablePath setting with the path to your PHP installation: Windows: { \"php.validate.executablePath\": \"c:/php/php.exe\" } Linux and macOS: { \"php.validate.executablePath\": \"/usr/bin/php\" } Snippets Visual Studio Code includes a set of common snippets for PHP. To access these, hit kb(editor.action.triggerSuggest) to get a context-specific list. PHP extensions There are many PHP language extensions available on the VS Code Marketplace and more are being created. You can search for PHP extensions from within VS Code in the Extensions view ( kb(workbench.view.extensions) ) then filter the extensions dropdown list by typing 'php'. Disable built-in PHP support To disable the built-in PHP smart completions in favor of suggestions from an installed PHP extension, uncheck PHP > Suggest: Basic , which sets php.suggest.basic to false in your settings.json file. Debugging PHP debugging with XDebug is supported through a PHP Debug extension . Follow the extension's instructions for configuring XDebug to work with VS Code. Next steps Read on to find out about: Extension Marketplace - Browse the extensions others have shared Debugging - Learn more about VS Code debugging"
  },
  "guides/vscode/languages/powershell.html": {
    "href": "guides/vscode/languages/powershell.html",
    "title": "PowerShell in Visual Studio Code | Fountain of Knowledge",
    "keywords": "PowerShell in Visual Studio Code PowerShell is a task-based command-line shell and scripting language built on .NET , which provides a powerful toolset for administrators on any platform. The Microsoft PowerShell extension for Visual Studio Code provides rich language support and capabilities such as completions, definition tracking, and linting analysis for PowerShell versions 3, 4, 5, and 5.1 as well as all versions of PowerShell Core . Install the PowerShell extension The official PowerShell extension can be installed by following the steps described in the Visual Studio Code User Guide or by going directly to the Visual Studio Code Marketplace and clicking the Install Button . You can also install the PowerShell extension from within Visual Studio Code by opening the Extensions view with keyboard shortcut kb(workbench.view.extensions) and typing \"PowerShell\" and select the PowerShell extension: Install from the command line Alternatively, the PowerShell extension can be installed from any command line (including PowerShell, Cmd, bash) on all platforms using the following command code --install-extension ms-vscode.powershell If you are running VS Code Insiders , you will need this command instead: code-insiders --install-extension ms-vscode.powershell Example scripts Example scripts are included with the extension and can be found at the following path. C:\\Users\\<yourusername>\\.vscode\\extensions\\ms-vscode.PowerShell-<version>\\examples To open or view the examples in Visual Studio Code, run the following from your PowerShell command prompt: code (Get-ChildItem $Home\\.vscode\\extensions\\ms-vscode.PowerShell-*\\examples)[-1] If using the Insiders edition: code-insiders (Get-ChildItem $Home\\.vscode-insiders\\extensions\\ms-vscode.PowerShell-*\\examples)[-1] You can also open the examples from the Command Palette ( kb(workbench.action.showCommands) ) with the PowerShell: Open Examples Folder command. Major features Syntax highlighting Code snippets IntelliSense for cmdlets and more Rule-Based analysis provided by PowerShell Script Analyzer \"Go to definition\" of cmdlets and variables Find references of cmdlets and variables Document and Workspace symbol discovery Run selected section of PowerShell code using kbstyle(F8) Launch online help for the symbol under the cursor using kbstyle(Ctrl + F1) Local script debugging and basic interactive console support Enable ISE mode using kbstyle(Ctrl + Shift + P) then search for \"Enable ISE Mode\" Debugging The PowerShell extension uses the built-in debugging interface of VS Code to allow for debugging of PowerShell scripts and modules. You can learn more about VS Code debugging here. Hey, Scripting Guy! blog For more information on debugging, check out the \"Hey, Scripting Guy!\" two-part blog post series written by @keithHill on debugging with the PowerShell extension: Debugging PowerShell script in Visual Studio Code – Part 1 Debugging PowerShell script in Visual Studio Code – Part 2 PowerShell extension settings You can customize VS Code settings from the File > Preferences > Settings menu item ( Code > Preferences > Settings on macOS). You can also click the gear icon located in the lower left corner of the Activity Bar. You can also use the keyboard shortcut kb(workbench.action.openSettings) to open your settings. The VS Code team has introduced a settings GUI in version 1.27.1 as the new default interface for customizing settings. In VS Code versions prior to 1.27.1, this will open your settings.json file. You can still open the settings.json file by using Preferences: Open Settings (JSON) command from the Command Palette ( kb(workbench.action.showCommands) ) or by changing the default settings editor with the \"workbench.settings.editor\" setting. Go to User and Workspace settings for more information on configuring VS Code settings. Multi-version support You can configure the PowerShell extension to use any version of PowerShell installed on your machine by following these instructions . You can also change the version by clicking on the version number in the lower right corner: Or run the PowerShell: Show Session Menu command from the Command Palette ( kb(workbench.action.showCommands) ). Pester Pester is a Behavior-driven Development (BDD) based unit test runner for PowerShell. Pester provides a framework for running unit tests to execute and validate PowerShell commands. Pester follows a file naming convention for naming tests to be discovered by Pester at test time and a simple set of functions that expose a testing domain-specific language (DSL) for isolating, running, evaluating and reporting the results of PowerShell commands. Windows 10 and Server 2016 comes with Pester 3.40 pre-installed. To update Pester or to install the latest version on other platforms follow the Pester installation instructions . Plaster Plaster is a template-based file and project generator written in PowerShell. Its purpose is to streamline the creation of PowerShell module projects, Pester tests, DSC configurations and more. See the GitHub Plaster repository for more information, for documentation on Plaster's cmdlets see Cmdlet Documentation . The PowerShell extension allows the creation of new Plaster projects by running the PowerShell: Create New Project from Plaster Template command from the Command Palette ( kb(workbench.action.showCommands) ). PSScriptAnalyzer PSScriptAnalyzer is a static source code checker for PowerShell modules and scripts. PSScriptAnalyzer checks the quality of PowerShell code by running a set of rules. The rules are based on PowerShell best practices identified by the PowerShell Team and the community. PSScriptAnalyzer generates diagnostic records (errors and warnings) to inform users about potential code defects and suggests possible solutions for improvements. The PowerShell extension includes PSScriptAnalyzer by default, and automatically performs analysis on PowerShell script files being edited in VS Code. PSScriptAnalyzer Settings PSScriptAnalyzer is shipped with a collection of built-in rules that checks various aspects of PowerShell source code such as presence of uninitialized variables, usage of PSCredential Type, usage of Invoke-Expression, etc. Additional functionality such as exclude/include specific rules is also supported. To disable PSScriptAnalyzer, open your settings, browse Extensions, select the PowerShell extension and deselect the checkbox for PSScriptAnalyzer. Format document command is provided by the PSScriptAnalyzer module. Document Formatting Automatic document formatting can be invoked using the Format Document command or the ( kb(editor.action.formatDocument) ) keyboard shortcut. CodeLens CodeLenses are a VS Code feature to provide actionable, contextual information that is displayed within the source code. CodeLens support was added in version 1.3.0 of the PowerShell extension, read the PowerShell extension changelog for more information. Pester CodeLens support Pester supports CodeLens integration for Run tests and Debug tests . CodeLens Pester debug support CodeLens Pester symbol support Function reference CodeLens support CodeLens function reference support shows the number of times a function is referenced within your code and allows you to jump to specific references. Extension FAQ page Check out the FAQ page on the PowerShell extensions Wiki Types.ps1xml and Format.ps1xml files ps1xml files are PowerShell's way to extend the type system and define output formatting. For more information on these files, please refer to the official PowerShell documentation on Types.ps1xml and Format.ps1xml . You can get IntelliSense features when authoring ps1xml files by installing the XML extension by Red Hat . After installing, add this configuration to your user settings: \"xml.fileAssociations\": [ { \"systemId\": \"https://raw.githubusercontent.com/PowerShell/PowerShell/master/src/Schemas/Format.xsd\", \"pattern\": \"**/*.Format.ps1xml\" }, { \"systemId\": \"https://raw.githubusercontent.com/PowerShell/PowerShell/master/src/Schemas/Types.xsd\", \"pattern\": \"**/*.Types.ps1xml\" } ] This tells the XML extension to use the official XML schemas from the PowerShell repository for all .ps1xml files. This enables the following features in ps1xml files: Syntax error reporting Schema validation Tag and attribute completion Auto-close tags Symbol highlighting Document folding Document symbols and outline Renaming support Document Formatting"
  },
  "guides/vscode/languages/python.html": {
    "href": "guides/vscode/languages/python.html",
    "title": "Python in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Python in Visual Studio Code Working with Python in Visual Studio Code, using the Microsoft Python extension , is simple, fun, and productive. The extension makes VS Code an excellent Python editor, and works on any operating system with a variety of Python interpreters. It leverages all of VS Code's power to provide auto complete and IntelliSense, linting, debugging, and unit testing, along with the ability to easily switch between Python environments, including virtual and conda environments. This article provides only an overview of the different capabilities of the Python extension for VS Code. For a walkthrough of editing, running, and debugging code, use the button below. Python Hello World Tutorial Install Python and the Python extension The tutorial guides you through installing Python and using the extension. You must install a Python interpreter yourself separately from the extension. For a quick install, use Python 3.7 from python.org and install the extension from the VS Code Marketplace . Once you have a version of Python installed, activate it using the Python: Select Interpreter command. If VS Code doesn't automatically locate the interpreter you're looking for, refer to Environments - Manually specify an interpreter . You can configure the Python extension through settings. Learn more in the Python Settings reference . Windows Subsystem for Linux : If you are on Windows, WSL is a great way to do Python development. You can run Linux distributions on Windows and Python is often already installed. When coupled with the Remote - WSL extension, you get full VS Code editing and debugging support while running in the context of WSL. To learn more, go to Developing in WSL or try the Working in WSL tutorial. Insiders program The Insiders program allows you to try out and automatically install new versions of the Python extension prior to release, including new features and fixes. If you'd like to opt into the program, you can either open the Command Palette ( kb(workbench.action.showCommands) ) and select Python: Switch to Insiders Daily/Weekly Channel or else you can open settings ( kb(workbench.action.openSettings) ) and look for Python: Insiders Channel to set the channel to \"daily\" or \"weekly\". Run Python code To experience Python, create a file (using the File Explorer ) named hello.py and paste in the following code (assuming Python 3): print(\"Hello World\") The Python extension then provides shortcuts to run Python code in the currently selected interpreter ( Python: Select Interpreter in the Command Palette): In the text editor: right-click anywhere in the editor and select Run Python File in Terminal . If invoked on a selection, only that selection is run. In Explorer: right-click a Python file and select Run Python File in Terminal . You can also use the Terminal: Create New Integrated Terminal command to create a terminal in which VS Code automatically activates the currently selected interpreter. See Environments below. The Python: Start REPL activates a terminal with the currently selected interpreter and then runs the Python REPL. For a more specific walkthrough on running code, see the tutorial . Autocomplete and IntelliSense The Python extension supports code completion and IntelliSense using the currently selected interpreter. IntelliSense is a general term for a number of features, including intelligent code completion (in-context method and variable suggestions) across all your files and for built-in and third-party modules. IntelliSense quickly shows methods, class members, and documentation as you type, and you can trigger completions at any time with kb(editor.action.triggerSuggest) . You can also hover over identifiers for more information about them. Tip : Check out the IntelliCode extension for VS Code (preview) . IntelliCode provides a set of AI-assisted capabilities for IntelliSense in Python, such as inferring the most relevant auto-completions based on the current code context. Linting Linting analyzes your Python code for potential errors, making it easy to navigate to and correct different problems. The Python extension can apply a number of different linters including Pylint, pycodestyle, Flake8, mypy, pydocstyle, prospector, and pylama. See Linting . Debugging No more print statement debugging! Set breakpoints, inspect data, and use the debug console as you run your program step by step. Debug a number of different types of Python applications, including multi-threaded, web, and remote applications. For Python-specific details, including setting up your launch.json configuration and remote debugging, see Debugging . General VS Code debugging information is found in the debugging document . The Django and Flask tutorials also demonstrate debugging in the context of those web apps, including debugging Django page templates. Environments The Python extension automatically detects Python interpreters that are installed in standard locations. It also detects conda environments as well as virtual environments in the workspace folder. See Configuring Python environments . You can also use the python.pythonPath setting to point to an interpreter anywhere on your computer. The current environment is shown on the left side of the VS Code Status Bar: The Status Bar also indicates if no interpreter is selected: The selected environment is used for IntelliSense, auto-completions, linting, formatting, and any other language-related feature other than debugging. It is also activated when you use run Python in a terminal . To change the current interpreter, which includes switching to conda or virtual environments, select the interpreter name on the Status Bar or use the Python: Select Interpreter command. VS Code prompts you with a list of detected environments as well as any you've added manually to your user settings (see Configuring Python environments ). Installing packages Packages are installed using the Terminal panel and commands like pip install <package_name> (Windows) and pip3 install <package_name> (macOS/Linux). VS Code installs that package into your project along with its dependencies. Examples are given in the Python tutorial as well as the Django and Flask tutorials. Jupyter notebooks If you open a Jupyter notebook file ( .ipynb ) in VS Code, you can use the Jupyter Notebook Editor to directly view, modify, and run code cells. You can also convert and open the notebook as a Python code file. The notebook's cells are delimited in the Python file with #%% comments, and the Python extension shows Run Cell or Run All Cells CodeLens. Selecting either CodeLens starts the Jupyter server and runs the cell(s) in the Python interactive window: Opening a notebook as a Python file allows you to use all of VS Code's debugging capabilities. You can then save the notebook file and open it again as a notebook in the Notebook Editor, Jupyter, or even upload it to a service like Azure Notebooks . Using either method, Notebook Editor or a Python file, you can also connect to a remote Jupyter server for running the code. For more information, see Jupyter support . Testing The Python extension supports testing with the unittest, pytest, and nose test frameworks. To run tests, you enable one of the frameworks in settings. Each framework also has specific settings, such as arguments that identify paths and patterns for test discovery. Once discovered, VS Code provides a variety of commands (on the Status Bar, the Command Palette, and elsewhere) to run and debug tests, including the ability to run individual test files and individual methods. Configuration The Python extension provides a wide variety of settings for its various features. These are described on their relevant topics, such as Editing code , Linting , Debugging , and Testing . The complete list is found in the Settings reference . Other popular Python extensions The Microsoft Python extension provides all of the features described previously in this article. Additional Python language support can be added to VS Code by installing other popular Python extensions. Open the Extensions view ( kb(workbench.view.extensions) ). Filter the extension list by typing 'python'. The extensions shown above are dynamically queried. Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Next steps Python Hello World tutorial - Get started with Python in VS Code. Editing Python - Learn about auto-completion, formatting, and refactoring for Python. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Django tutorial Flask tutorial"
  },
  "guides/vscode/languages/tsql.html": {
    "href": "guides/vscode/languages/tsql.html",
    "title": "Transact-SQL in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Transact-SQL in Visual Studio Code Turn Visual Studio Code into a powerful editor for Transact-SQL (T-SQL) development, with the mssql extension available in the VS Code Marketplace. The mssql extension is optimized to work with SQL Server running on-premises, in any cloud, Azure SQL Database, and Azure SQL Data Warehouse. Connect to SQL databases, type T-SQL code, execute T-SQL code, view results, and save results as JSON or CSV files. While typing T-SQL code, you get rich T-SQL language features like T-SQL IntelliSense (code completion), syntax highlighting, linting, code navigation and code snippets. Download VS Code - If you haven't downloaded VS Code yet, quickly install for your platform (Linux, macOS or Windows). Install T-SQL support Add T-SQL language support to VS Code by installing the mssql extension from the VS Code marketplace as follows: Open the Extensions view from VS Code Side Bar ( kb(workbench.view.extensions) ). Type \"mssql\" in the search bar, click Install , and reload VS Code when prompted. Connect and Execute T-SQL Easily connect to SQL Server running on-premises, in any cloud, Azure SQL Database, and Azure SQL Data Warehouse. Then, execute your T-SQL statements and batches to view results and messages - all within VS Code. Your recent connections are saved across sessions, so you can quickly connect to your databases again. View and Save Results View results and messages when you execute your T-SQL code. Save results as a JSON or CSV file to use the data in your applications with just a few clicks. T-SQL IntelliSense As you type T-SQL code in the editor, VS Code provides intelligent code completion for T-SQL keywords, suggestions for schema object names (tables, columns, views), and parameter help for functions and procedures when connected to a database. Linting Linting is the analysis of your T-SQL code for potential syntax errors. Use Visual Studio Code to quickly navigate to the errors and warnings in your T-SQL code as you type. Peek Definition/Go to Definition Use Peek Definition or Go to Definition to quickly browse the definition of schema objects in your database such as tables, functions, and procedures while typing T-SQL code. Snippets T-SQL snippets provide code templates for commonly used T-SQL statements. Type \"sql\" to get the list of T-SQL snippets. Next steps Download the free SQL Server 2017 Developer Edition . Install the mssql extension from the Visual Studio Code Marketplace. Build an app using SQL Server - Get started with SQL Server on macOS, Linux, and Windows using your favorite programming language. Contribute to the mssql extension on GitHub . Submit a bug report or a feature suggestion on our GitHub Issue Tracker . Further Reading SQL Server documentation SQL Server on Linux documentation SQL Server Blog SQL Server Videos on Channel9"
  },
  "guides/vscode/languages/typescript.html": {
    "href": "guides/vscode/languages/typescript.html",
    "title": "TypeScript in Visual Studio Code | Fountain of Knowledge",
    "keywords": "TypeScript in Visual Studio Code TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It offers classes, modules, and interfaces to help you build robust components. The TypeScript language specification has full details about the language. Installing the TypeScript compiler Visual Studio Code includes TypeScript language support but does not include the TypeScript compiler, tsc . You will need to install the TypeScript compiler either globally or in your workspace to transpile TypeScript source code to JavaScript ( tsc HelloWorld.ts ). The easiest way to install TypeScript is through npm, the Node.js Package Manager . If you have npm installed, you can install TypeScript globally ( -g ) on your computer by: npm install -g typescript You can test your install by checking the version. tsc --version Another option is to install the TypeScript compiler locally in your project ( npm install --save-dev typescript ) and has the benefit of avoiding possible interactions with other TypeScript projects you may have. Syntax highlighting and semantic highlighting In addition to syntax highlighting, TypeScript and JavaScript also provide semantic highlighting. Syntax highlighting colors the text based on lexical rules. Semantic highlighting enriches the syntax coloring based on resolved symbol information from the language service. Whether semantic highlighting is visible depends on the current color theme. Each theme can configure whether to display semantic highlighting and how it styles the semantic tokens. If semantic highlighting is enabled and the color theme has a corresponding styling rule defined, different colors and styles can be seen. Semantic highlighting can change colors based on: The resolved type of a symbol: namespace, variable, property, variable, property, class, interface, typeParameter. Whether the variable/property is read-only (const) or modifiable. Whether the variable/property type is callable (a function type) or not. IntelliSense IntelliSense shows you intelligent code completion, hover info, and signature information so that you can write code more quickly and correctly. Sorry, your browser doesn't support HTML 5 video. VS Code provides IntelliSense for individual TypeScript files as well as TypeScript tsconfig.json projects. Snippets VS Code includes basic TypeScript snippets that are suggested as you type; Sorry, your browser doesn't support HTML 5 video. You can install extensions to get additional snippets or define your own snippets for TypeScript. See User Defined Snippets for more information. Tip : You can disable snippets by setting editor.snippetSuggestions to \"none\" in your settings file. If you'd like to see snippets, you can specify the order relative to suggestions; at the top ( \"top\" ), at the bottom ( \"bottom\" ), or inlined ordered alphabetically ( \"inline\" ). The default is \"inline\" . JSDoc support VS Code's TypeScript IntelliSense understands many standard JSDoc annotations, and uses them to show typing information and documentation in suggestions , hover info , and signature help . Keep in mind that when using JSDoc for TypeScript code, you should not include type annotations. The TypeScript compiler only uses TypeScript type annotations and ignores those from JSDoc. Sorry, your browser doesn't support HTML 5 video. To disable JSDoc comment suggestions in TypeScript, set \"typescript.suggest.completeJSDocs\": false . Hover information Hover over a TypeScript symbol to quickly see its type information and relevant documentation: You can also show the hover info at the current cursor position with the kb(editor.action.showHover) keyboard shortcut. Signature help As you write a TypeScript function call, VS Code shows information about the function signature and highlights the parameter that you are currently completing: Signature help is shown automatically when you type a ( or , within a function call. Use kb(editor.action.triggerParameterHints) to manually trigger signature help. Auto imports Automatic imports speed up coding by helping you find available symbols and automatically adding imports for them. Just start typing to see suggestions for all available TypeScript symbols in your current project. If you choose one of the suggestions from another file or module, VS Code will automatically add an import for it. In this example, VS Code adds an import for Hercules to the top of the file: You can disable auto imports by setting \"typescript.autoImportSuggestions.enabled\": false . Formatting VS Code includes a TypeScript formatter that providers basic code formatting with reasonable defaults. Use the typescript.format.* settings to configure the built-in formatter, such as making braces appear on their own line. Or, if the built-in formatter is getting in the way, set \"typescript.format.enable\" to false to disable it. For more specialized code formatting styles, try installing one of the formatting extensions from the VS Code marketplace. JSX and auto closing tags VS Code's TypeScript features also work with JSX . To use JSX in your TypeScript, use the *.tsx file extension instead of the normal *.ts : VS Code also includes JSX-specific features such as autoclosing of JSX tags in TypeScript: Sorry, your browser doesn't support HTML 5 video. Set \"typescript.autoClosingTags\" to false to disable JSX tag closing. Code navigation Code navigation lets you quickly navigate TypeScript projects. Go to Definition kb(editor.action.revealDefinition) - Go to the source code of a symbol definition. Peek Definition kb(editor.action.peekDefinition) - Bring up a Peek window that shows the definition of a symbol. Go to References kb(editor.action.goToReferences) - Show all references to a symbol. Go to Type Definition kb(editor.action.goToTypeDefinition) - Go to the type that defines a symbol. For an instance of a class, this will reveal the class itself instead of where the instance is defined. Go to Implementation kb(editor.action.goToImplementation) - Go to the implementations of an interface or abstract method. You can navigate via symbol search using the Go to Symbol commands from the Command Palette ( kb(workbench.action.showCommands) ). Go to Symbol in File kb(workbench.action.gotoSymbol) Go to Symbol in Workspace kb(workbench.action.showAllSymbols) Rename Press kb(editor.action.rename) to rename the symbol under the cursor across your TypeScript project: Refactoring VS Code includes some handy refactorings for TypeScript such as Extract function and Extract constant . Just select the source code you'd like to extract and then click on the lightbulb in the gutter or press ( kb(editor.action.quickFix) ) to see available refactorings. See Refactorings for more information about refactorings and how you can configure keyboard shortcuts for individual refactorings. Available TypeScript refactorings include: Extract to method or function - Extract the selected statements or expressions to either a new method or a new function in the file. After selecting the Extract to method or Extract to function refactoring, enter the name of the extracted method/function. Extract to constant - Extract the selected expression to a new constant in the file. Extract type to interface or type alias - Extract the selected complex type to either an interface or a type alias. Move to new file - Move one or more classes, functions, constants, or interfaces in the top-level scope of the file to a new file. The new file's name is inferred from the selected symbol's name. Convert between named imports and namespace imports - Convert between named imports ( import { Name } from './foo' ) and namespace imports ( import * as foo from './foo' ). Convert between default export and named export - Convert from using a export default and having a named export ( export const Foo = ... ). Generate get and set accessors - Encapsulate a selected class property by generating a getter and setter for it. Convert parameters to destructured object - Rewrite a function that takes a long list of arguments to take a single arguments object. Quick Fixes Quick Fixes are suggested edits that address simple coding errors. Example Quick Fixes include: Adding a missing this to a member access. Fixing a misspelled property name. Removing unreachable code or unused imports Declaring When you move your cursor on to a TypeScript error, VS Code shows a lightbulb that indicates that Quick Fixes are available. Click the lightbulb or press kb(editor.action.quickFix) to show a list of available Quick Fixes and refactorings . Unused variables and unreachable code Unused TypeScript code, such as the else block of an if statement that is always true or an unreferenced import, is faded out in the editor: You can quickly remove this unused code by placing the cursor on it and triggering the Quick Fix command ( kb(editor.action.quickFix) ) or clicking on the lightbulb. To disable fading out of unused code, set \"editor.showUnused\" to false . You can also disable fading of unused code only in TypeScriptScript by setting: \"[typescript]\": { \"editor.showUnused\": false }, \"[typescriptreact]\": { \"editor.showUnused\": false }, Organize Imports The Organize Imports source code action sorts the imports in a TypeScript file and removes unused imports: Sorry, your browser doesn't support HTML 5 video. You can run Organize Imports from the Source Action context menu or with the kb(editor.action.organizeImports) keyboard shortcut. Organize imports can also be done automatically when you save a TypeScript file by setting: \"editor.codeActionsOnSave\": { \"source.organizeImports\": true } Code Actions on Save The editor.codeActionsOnSave setting lets you configure a set of Code Actions that are run when a file is saved. For example, you can enable organize imports on save by setting: // On save, run both fixAll and organizeImports source actions \"editor.codeActionsOnSave\": { \"source.fixAll\": true, \"source.organizeImports\": true, } You can also set editor.codeActionsOnSave to an array of Code Actions to execute in order. Here are some source actions: \"organizeImports\" - Enables organize imports on save. \"fixAll\" - Auto Fix on Save computes all possible fixes in one round (for all providers including ESLint). \"fixAll.eslint\" - Auto Fix only for ESLint. \"addMissingImports\" - Adds all missing imports on save. See TypeScript for more information. Code suggestions VS Code automatically suggests some common code simplifications such as converting a chain of .then calls on a promise to use async and await Sorry, your browser doesn't support HTML 5 video. Set \"typescript.suggestionActions.enabled\" to false to disable suggestions. References CodeLens The TypeScript references CodeLens displays an inline count of reference for classes, interfaces, methods, properties, and exported objects: You can enable this by setting \"typescript.referencesCodeLens.enabled\": true in the User Settings file. Click on the reference count to quickly browse a list of references: Implementations CodeLens The TypeScript implementations CodeLens displays the number of implementors of an interface: You can enable this by setting \"typescript.implementationsCodeLens.enabled\": true . As with the references CodeLens, you can click on the implementation count to quickly browse a list of all implementations. Update imports on file move When you move or rename a file that is imported by other files in your TypeScript project, VS Code can automatically update all import paths that reference the moved file. The typescript.updateImportsOnFileMove.enabled setting controls this behavior. Valid settings values are: \"prompt\" - The default. Asks if paths should be updated for each file move. \"always\" - Always automatically update paths. \"never\" - Do not update paths automatically and do not prompt. Debugging VS Code comes with great debugging support for TypeScript, including support for sourcemaps. Set breakpoints, inspect objects, navigate the call stack, and execute code in the Debug Console. See the Debugging topic to learn more. Debug client side You can debug your client-side code using a browser debugger such as the built-in Edge and Chrome debugger , or the Debugger for Firefox . Debug server side Debug Node.js in VS Code using the built-in debugger. Setup is easy and there is a Node.js debugging tutorial to help you. Linters Linters provides warnings for suspicious looking code. While VS Code does not include a built-in TypeScript linter, TypeScript linter extensions available in the marketplace. ESLint is a popular linter, which also supports TypeScript. The ESLint extension integrates ESLint into VS Code so you can see linting errors right in the editor and even quickly many of fix them with Quick Fixes . The ESLint plugin guide details how to configure ESLint for your TypeScript projects. TypeScript extensions VS Code provides many features for TypeScript out of the box. In addition to what comes built-in, you can install an extension for greater functionality. Tip: Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Next steps To learn more, see: TypeScript tutorial - Create a simple Hello World TypeScript in VS Code. Compiling TypeScript - Compile TypeScript to a JavaScript target version. Debugging TypeScript - Learn about debugging TypeScript both server and client-side with VS Code. Common questions Can I use the version of TypeScript that ships with VS 2015? No, the TypeScript language service that ships with Visual Studio 2015 and 2017 isn't compatible with VS Code. You will need to install a separate version of TypeScript from npm . How can I use the latest TypeScript beta with VS Code? The simplest way to try out the latest TypeScript features in VS Code is to install the JavaScript and TypeScript Nightly extension . You can also configure VS Code to use a specific TypeScript version ."
  },
  "guides/vscode/nodejs/angular-tutorial.html": {
    "href": "guides/vscode/nodejs/angular-tutorial.html",
    "title": "Using Angular in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Using Angular in Visual Studio Code Angular is a popular JavaScript library developed by Google for building web application user interfaces. The Visual Studio Code editor supports Angular IntelliSense and code navigation out of the box. Welcome to Angular We'll be using the Angular CLI for this tutorial. To install and use the command line interface as well as run the Angular application server, you'll need the Node.js JavaScript runtime and npm (the Node.js package manager) installed. npm is included with Node.js which you can install from Node.js downloads . Tip : To test that you have Node.js and npm correctly installed on your machine, you can type node --version and npm --version . To install the Angular CLI, in a terminal or command prompt type: npm install -g @angular/cli This may take a few minutes to install. You can now create a new Angular application by typing: ng new my-app my-app is the name of the folder for your application. This may take a few minutes to create the Angular application in TypeScript and install its dependencies. Let's quickly run our Angular application by navigating to the new folder and typing ng serve to start the web server and open the application in a browser: cd my-app ng serve You should see \"Welcome to app!!\" on http://localhost:4200 in your browser. We'll leave the web server running while we look at the application with VS Code. To open your Angular application in VS Code, open another terminal (or command prompt) and navigate to the my-app folder and type code . : cd my-app code . Syntax highlighting and bracket matching Now expand the src\\app folder and select the app.component.ts file. You'll notice that VS Code has syntax highlighting for the various source code elements and, if you put the cursor on a parenthesis, the matching bracket is also selected. IntelliSense As you hover your mouse over text in the file, you'll see that VS Code gives you information about key items in your source code. Items such as variables, classes and Angular decorators are a few examples where you'll be presented with this information. As you start typing in app.component.ts , you'll see smart suggestions and code snippets. You can click the information button ( i ) to see a flyout with more documentation. VS Code uses the TypeScript language service for code intelligence ( IntelliSense ) and it has a feature called Automatic Type Acquisition (ATA). ATA pulls down the npm Type Declaration files ( *.d.ts ) for the npm modules referenced in the package.json . Go to Definition, Peek definition Through the TypeScript language service, VS Code can also provide type definition information in the editor through Go to Definition ( kb(editor.action.revealDefinition) ) or Peek Definition ( kb(editor.action.peekDefinition) ). Open the app.module.ts file and put the cursor over AppComponent in the bootstrap property declaration, right click and select Peek Definition . A Peek window will open showing the AppComponent definition from app.component.ts . Press kbstyle(Escape) to close the Peek window. Hello World! Let's update the sample application to \"Hello World\". Go back to the app.component.ts file and change the title string in AppComponent to \"Hello World\". import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { title = 'Hello World'; } Once you save the app.component.ts file, the running instance of the server will update the web page and you'll see \"Welcome to Hello World!!\". Tip : VS Code supports Auto Save, which by default saves your files after a delay. Check the Auto Save option in the File menu to turn on Auto Save or directly configure the files.autoSave user setting . Debugging Angular To debug the client side Angular code, we'll use the built-in JavaScript debugger. Note: This tutorial assumes you have the Edge browser installed. If you want to debug using Chrome, replace the launch type with pwa-chrome . There is also a debugger for the Firefox browser. Set a breakpoint To set a breakpoint in app.component.ts , click on the gutter to the left of the line numbers. This will set a breakpoint which will be visible as a red circle. Configure the debugger We need to initially configure the debugger . To do so, go to the Run view ( kb(workbench.view.debug) ) and click on the gear button or Create a launch.json link to create a launch.json debugger configuration file. Choose Edge: launch from the Select Environment dropdown list. This will create a launch.json file in a new .vscode folder in your project which includes a configuration to launch the website. We need to make one change for our example: change the port of the url from 8080 to 4200 . Your launch.json should look like this: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"pwa-msedge\", \"request\": \"launch\", \"name\": \"Launch Edge against localhost\", \"url\": \"http://localhost:4200\", \"webRoot\": \"${workspaceFolder}\" } ] } Press kb(workbench.action.debug.start) or the green arrow to launch the debugger and open a new browser instance. The source code where the breakpoint is set runs on startup before the debugger was attached so we won't hit the breakpoint until we refresh the web page. Refresh the page and you should hit your breakpoint. You can step through your source code ( kb(workbench.action.debug.stepOver) ), inspect variables such as AppComponent , and see the call stack of the client side Angular application. For more information about the debugger and its available options, check out our documentation on browser debugging . Popular Starter Kits In this tutorial, we used the Angular CLI to create a simple Angular application. There are lots of great samples and starter kits available to help build your first Angular application. Recipes The VS Code team has created recipes for more complex debugging scenarios. There you'll find the Debugging with Angular CLI recipe which also uses the Angular CLI and goes into detail on debugging the generated project's unit tests. MEAN Starter If you'd like to see a full MEAN (MongoDB, Express, Angular, Node.js) stack example, look at MEAN.JS . They have documentation and an application generator for a sample MEAN project. You'll need to install and start MongoDB , but you'll quickly have a MEAN application running. VS Code also has great MongoDB support through the Azure Databases extension. React React is another popular web framework. If you'd like to see an example of React working with VS Code, check out the Using React in VS Code tutorial. It will walk you through creating an React application and configuring the launch.json file for the JavaScript debugger. Angular Extensions In addition to the functionality, VS Code provides out of the box, you can install VS Code extensions for greater functionality. Click on an extension tile above to read the description and reviews on the Marketplace . To find other Angular extensions, open the Extensions view ( kb(workbench.view.extensions) ) and type 'angular' to see a filtered list of Angular extensions. The community has also created \"Extension Packs\" which bundle useful extensions together (for example, a linter, debugger, and snippets) into a single download. To see available Angular extension packs, add the \"extension packs\" category to your filter (angular @category:\"extension packs\")."
  },
  "guides/vscode/nodejs/browser-debugging.html": {
    "href": "guides/vscode/nodejs/browser-debugging.html",
    "title": "Browser debugging in VS Code | Fountain of Knowledge",
    "keywords": "Browser debugging in VS Code Visual Studio Code includes a built-in debugger for Edge and Chrome. There are a couple ways to get started with it. Use the Open Link command to debug a URL. Clicking a link in the JavaScript debug terminal . Use a launch config to launch a browser with your app. We also have more detailed walkthroughs to get started with React , Angular , Vue , and Ember , as well as other debugging recipes . Open Link command The simplest way to debug a webpage is through the Debug: Open Link command found in the Command Palette ( kb(workbench.action.showCommands) ). When you run this command, you'll be prompted for a URL to open, and the debugger will be attached. If your default browser is Edge, VS Code will use it to open the page. Otherwise, it will try to find an installation of Chrome on your system instead. Launch configuration Launch configs are the traditional way to set up debugging in VS Code, and provide you the most flexibility for running complex applications. In this section, we'll go into more detail about configurations and features for more advanced debugging scenarios. Instructions for Node.js debugging with source maps and stepping over external code also apply to browser-based debugging. Note : If you are just getting started with VS Code, you can learn about general debugging features and creating launch.json configuration files in the Debugging topic. Launching browsers In most cases, you'll want to start a new instance of the browser to debug your webpage or file. To do this, you can create a file named .vscode/launch.json that looks like this: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"pwa-msedge\", \"request\": \"launch\", \"name\": \"Launch my cool app\", \"url\": \"http://localhost:8000\" } ] } When you hit kb(workbench.action.debug.start) or the Start button in the Debug view, http://localhost:8000 will be opened in debug mode. If you'd like to use Chrome instead of Edge, replace pwa-msedge with pwa-chrome . You can also debug a single file without running a server, for example: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"pwa-msedge\", \"request\": \"launch\", \"name\": \"Launch hello.html\", \"file\": \"${workspaceFolder}/hello.html\" } ] } Attaching to browsers To attach to a running browser, it needs to be launched in a special debug mode. You can do this using the following command, replacing edge.exe with the path to your Edge or Chrome binary: edge.exe --remote-debugging-port=9222 --user-data-dir=remote-debug-profile Setting the --remote-debugging-port tells the browser to listen on that port for a debug connection. Setting a separate --user-data-dir forces a new instance of the browser to be opened; if this flag isn't given, then the command will open a new window of any running browser and not enter debug mode. Next, add a new section to the vscode/launch.json file as below: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"pwa-msedge\", \"request\": \"attach\", \"name\": \"Attach to browser\", \"port\": 9222 } ] } Now, you can press kb(workbench.action.debug.start) or the Start button in the Debug view to attach to the running browser. You can even add a host property to debug a browser running on a different machine. Launch configuration attributes Debugging configurations are stored in a launch.json file located in your workspace's .vscode folder. An introduction into the creation and use of debugging configuration files is in the general Debugging article. You can either \"launch\" a browser with your application, or \"attach\" to an existing browser that you started in debug mode . Below is a reference of common launch.json attributes specific to browser debugging. You can view the complete set of options in the vscode-js-debug options documentation. webRoot - The root directory for your source code. Most often, and by default, the webRoot is your workspace folder. This option is used for sourcemap resolution. outFiles - An array of glob patterns for locating generated JavaScript files. See the section on Source maps . smartStep - Try to automatically step over source code that doesn't map to source files. See the section on Smart stepping . skipFiles - Automatically skip files covered by these glob patterns. See the section on Skipping uninteresting code . trace - Enable diagnostic output. These attributes are only available for launch configurations of request type launch : url - The URL to automatically open when the browser is launched. runtimeExecutable - Either an absolute path to the browser executable to use, or the version of the browser to use. Valid versions include stable (default), canary , beta , and dev . runtimeArgs - Optional arguments passed when launching the browser. These attributes are only available for launch configurations of request type attach : url - If given, VS Code will attach to a tab with this URL. If not provided, it will attach to all browser tabs. port - Debug port to use. See the section on Attaching to Node.js . address - TCP/IP address of the debug port. See the section on Attaching to Browsers . Next steps Debugging - Read about general VS Code debugging features. Debugging Recipes - Set up debugging for your favorite platform."
  },
  "guides/vscode/nodejs/debugging-recipes.html": {
    "href": "guides/vscode/nodejs/debugging-recipes.html",
    "title": "JavaScript Debugging Recipes | Fountain of Knowledge",
    "keywords": "JavaScript Debugging Recipes Visual Studio Code supports debugging of many languages and platforms via debuggers that are either built-in or contributed by extensions. To make it easier to get started with debugging, we have made a collection of debugging \"recipes\" which contain the steps and configuration you need to set up debugging for your favorite platform. The recipes are in GitHub at https://github.com/microsoft/vscode-recipes . Debug server-side JavaScript in Node.js The Visual Studio Code editor supports debugging Node.js applications via the built-in Node.js debugger. Recipes: Debugging Node.js with Nodemon Debugging Node.js AWS Lambda functions Debug client-side JavaScript in Browsers The Visual Studio Code editor supports debugging of JavaScript running in Microsoft Edge and Google Chrome . You can read more about debugging browsers works in the Browser Debugging documentation . Recipes: Debugging Angular apps with Angular CLI Debugging Next.js apps Debugging Meteor apps Debugging Vue.js apps Debugging Mocha tests Debugging Jest tests Blog posts : Live edit and debug your React apps directly from VS Code Super-charged live editing and JavaScript debugging for Angular using VS Code Electron - Debug Electron applications The Visual Studio Code editor supports debugging Electron applications via the built-in JavaScript debugger. Recipes: Debugging Electron Main and Renderer processes Next steps Debugging - Read about general VS Code debugging features. Node.js Debugging - Learn about the built-in Node.js debugger. Video: Getting started with Node.js debugging - Attach to a running Node.js process."
  },
  "guides/vscode/nodejs/emberjs-tutorial.html": {
    "href": "guides/vscode/nodejs/emberjs-tutorial.html",
    "title": "Using Ember in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Using Ember in Visual Studio Code Ember is a popular JavaScript framework for building web application user interfaces. The Visual Studio Code editor supports Ember.js IntelliSense and code navigation out of the box. Welcome to Ember We'll be using the Ember CLI for this tutorial. To install and use the command line interface as well as run the Ember.js application server, you'll need the Node.js JavaScript runtime and npm (the Node.js package manager) installed. npm is included with Node.js which you can install from Node.js downloads . Tip : To test that you have Node.js and npm correctly installed on your machine, you can type node --version and npm --version . To install Ember CLI, in a terminal or command prompt type: npm install -g ember-cli This may take a few minutes to install. You can now create a new Ember.js application by typing: ember new my-app my-app is the name of the folder for your application. This may take a few minutes to create the Ember application in JavaScript and install its dependencies. Let's quickly run our Ember application by navigating to the new folder and typing ember serve to start the web server and open the application in a browser: cd my-app ember serve Once you see the Build successful message, you can open your browser to http://localhost:4200 and you should see \"Congratulations, you made it!\". You can press kbstyle(Ctrl+C) to stop the Ember server. To open your Ember application in VS Code, open another terminal (or command prompt) and navigate to the my-app folder and type code . : cd my-app code . Syntax highlighting and bracket matching Now expand the app folder and select the app.js file. You'll notice that VS Code has syntax highlighting for the various source code elements and, if you put the cursor on a parentheses, the matching bracket is also selected. IntelliSense As you start typing in app.js , you'll see smart suggestions or completions. After you select a suggestion and type . , you see the types and methods on the object through IntelliSense . VS Code uses the TypeScript language service for its JavaScript code intelligence and it has a feature called Automatic Type Acquisition (ATA). ATA pulls down the npm Type Declaration files ( *.d.ts ) for the npm modules referenced in the package.json . If you select a method, you'll also get parameter help: Go to Definition, Peek definition Through the TypeScript language service, VS Code can also provide type definition information in the editor through Go to Definition ( kb(editor.action.revealDefinition) ) or Peek Definition ( kb(editor.action.peekDefinition) ). Put the cursor over Application , right click and select Peek Definition . A Peek window will open showing the Application definition from ember_application Type Declaration file. Press kbstyle(Escape) to close the Peek window. Extensions The VS Code Marketplace has many community created extensions for Ember.js development which add features like code snippets and advanced code suggestions. You can search in the Extensions view ( kb(workbench.view.extensions) ) by typing 'ember'. Common questions Can I debug Ember client side code with VS Code? You can use the built-in browser debugger for client side debugging. Unfortunately it is difficult to get the configuration correct due to the sourcemaps created by the Ember CLI default transpiler. See issue #193 for an explanation and partial workaround."
  },
  "guides/vscode/nodejs/extensions.html": {
    "href": "guides/vscode/nodejs/extensions.html",
    "title": "JavaScript extensions for VS Code | Fountain of Knowledge",
    "keywords": "JavaScript extensions for VS Code Visual Studio Code supports many features for JavaScript and Node.js development. The features that ship with the downloaded product are the core features: debugging, IntelliSense, code navigation, etc. In addition, to these core features, you can install a large number of quality extensions to add features to VS Code for JavaScript development. Tip: To see how to install and manage your extensions, please refer to the extension documentation . Finding extensions You can find JavaScript extensions by typing JavaScript in the Extension view search bar. Alternatively, you can find JavaScript extensions using tags: \"tag:javascript\". Search for more extensions in VS Code or in the Marketplace . In addition you can search for Node.js extensions. Tip: The extensions shown above are dynamically queried. Click on an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Recommended extensions If you are just getting started, here are the extensions we recommend trying out. ESLint Marketplace - ESLint Publisher - Dirk Baeumer Easily integrate ESLint into your project. If ESLint isn't your favorite linter, choose among a variety of other linter extensions, including JSHint , JSCS , and JS Standard . Read more about setting up JavaScript linters in the VS Code documentation . JavaScript (ES6) code snippets Marketplace - JavaScript (ES6) code snippets Publisher - charalampos karypidis VS Code comes with many built-in code snippets. The JavaScript (ES6) code snippets extension adds snippets for ES6 (ECMAScript 6) syntax. Here is a small sampling of the snippets provided by this extension. See the extension's README to see the dozens of snippets this pack gives you. You can read more about JavaScript snippets in the VS Code documentation . For additional snippet packs, including Angular 1 , Angular 2 , Bootstrap 3 , ReactJs , and jQuery , check out the Marketplace's Snippets category . npm IntelliSense Marketplace - npm IntelliSense Publisher - Christian Kohler This extension provides IntelliSense for npm modules when using import or require ."
  },
  "guides/vscode/nodejs/nodejs-debugging.html": {
    "href": "guides/vscode/nodejs/nodejs-debugging.html",
    "title": "Node.js debugging in VS Code | Fountain of Knowledge",
    "keywords": "Node.js debugging in VS Code The Visual Studio Code editor has built-in debugging support for the Node.js runtime and can debug JavaScript, TypeScript, and many other languages that are transpiled into JavaScript. Setting up a project for Node.js debugging is straightforward with VS Code providing appropriate launch configuration defaults and snippets. There are a few ways you can debug your Node.js programs in VS Code: Use auto attach to debug processes you run in VS Code's integrated terminal, Use the JavaScript debug terminal , in a similar way, or Use a launch config to start your program, or attach to a process launched outside of VS Code Auto Attach If the Auto Attach feature is enabled, the Node debugger automatically attaches to certain Node.js processes that have been launched from VS Code's Integrated Terminal. To enable the feature, either use the Toggle Auto Attach command from the Command Palette ( kb(workbench.action.showCommands) ) or, if it's already activated, use the Auto Attach Status bar item. There are three modes for auto attach, which you can select in the resulting Quick Pick and via the debug.javascript.autoAttachFilter setting: smart (default) - If you execute a script outside of your node_modules folder or use a common 'runner' script like mocha or ts-node, the process will be debugged. You can configure the 'runner' script allow list using the Auto Attach Smart Pattern setting ( debug.javascript.autoAttachSmartPattern ). always - All Node.js processes launched in the Integrated Terminal will be debugged. onlyWithFlag - Only processes launched with the --inspect or --inspect-brk flag will be debugged. After enabling Auto Attach , you'll need to restart your terminal. This can be done by clicking the ⚠ icon in the top right of the terminal, or just creating a new one. Then, the debugger should attach to your program within a second: When auto attach is on, the Auto Attach item will appear in the status bar across the bottom of the VS Code window. Clicking it allows you to change the auto attach mode, or temporarily turn it off. Temporarily turning off auto attach is useful if you're running some one-off programs where you don't need debugging, but you don't want to disable the feature entirely. Additional Configuration Other Launch Configuration Properties You can apply other properties normally found in launch.json to auto attach in the debug.javascript.terminalOptions setting. For example, to add node internals to your skipFiles, you could add the following to your user or workspace settings: \"debug.javascript.terminalOptions\": { \"skipFiles\": [ \"<node_internals>/**\" ] }, Auto Attach Smart Patterns In smart Auto Attach mode, VS Code will try to attach to your code, and not attach to build tools you aren't interested in debugging. It does this by matching the main script against a list of glob patterns . The glob patterns are configurable in the debug.javascript.autoAttachSmartPattern setting, which defaults to: [ \"!**/node_modules/**\", // exclude scripts in node_modules folders \"**/$KNOWN_TOOLS$/**\" // but include some common tools ] $KNOWN_TOOLS$ is replaced list a list of common 'code runners' such as ts-node , mocha , ava , and so on. You can modify this list if these settings don't work. For example, to exclude mocha and include my-cool-test-runner , you could add two lines: [ \"!**/node_modules/**\", \"**/$KNOWN_TOOLS$/**\", \"!**/node_modules/mocha/**\", // use \"!\" to exclude all scripts in \"mocha\" node modules \"**/node_modules/my-cool-test-runner/**\" // include scripts in the custom test runner ] JavaScript Debug Terminal In a similar way to auto attach , the JavaScript Debug Terminal will automatically debug any Node.js process you run in it. You can create a Debug Terminal by running the use the Debug: Create JavaScript Debug Terminal command from the Command Palette ( kbs(workbench.action.showCommands) ), or by selecting the Create JavaScript Debug Terminal from the terminal switcher dropdown. Additional Configuration Other Launch Configuration Properties You can apply other properties normally found in launch.json to the debug terminal in the debug.javascript.terminalOptions setting. For example, to add node internals to your skipFiles, you could add the following to your user or workspace settings: \"debug.javascript.terminalOptions\": { \"skipFiles\": [ \"<node_internals>/**\" ] }, Launch Configuration Launch configs are the traditional way to set up debugging in VS Code, and provide you the most configuration options for running complex applications. In this section we'll go into more detail about configurations and features for more advanced debugging scenarios. You'll find instruction for debugging with source maps , stepping over external code , doing remote debugging , and much more. If you'd like to watch an introductory video, see Getting started with Node.js debugging . Note : If you are just getting started with VS Code, you can learn about general debugging features and creating launch.json configuration files in the Debugging topic. Launch configuration attributes Debugging configurations are stored in a launch.json file located in your workspace's .vscode folder. An introduction into the creation and use of debugging configuration files is in the general Debugging article. Below is a reference of common launch.json attributes specific to the Node.js debugger. You can view the complete set of options in the vscode-js-debug options documentation. The following attributes are supported in launch configurations of type launch and attach : outFiles - array of glob patterns for locating generated JavaScript files. See section Source maps . resolveSourceMapLocations - an array of glob patterns for locations where source maps should be parsed. See section Source maps . timeout - when restarting a session, give up after this number of milliseconds. See section Attaching to Node.js . stopOnEntry - break immediately when the program launches. localRoot - VS Code's root directory. See section Remote debugging below. remoteRoot - Node's root directory. See section Remote debugging below. smartStep - try to automatically step over code that doesn't map to source files. See section Smart stepping . skipFiles - automatically skip files covered by these glob patterns. See section Skipping uninteresting code . trace - enable diagnostic output. These attributes are only available for launch configurations of request type launch : program - an absolute path to the Node.js program to debug. args - arguments passed to the program to debug. This attribute is of type array and expects individual arguments as array elements. cwd - launch the program to debug in this directory. runtimeExecutable - absolute path to the runtime executable to be used. Default is node . See section Launch configuration support for 'npm' and other tools . runtimeArgs - optional arguments passed to the runtime executable. runtimeVersion - if \" nvm \" (or \" nvm-windows \") or \" nvs \" is used for managing Node.js versions, this attribute can be used to select a specific version of Node.js. See section Multi version support below. env - optional environment variables. This attribute expects environment variables as a list of string typed key/value pairs. envFile - optional path to a file containing environment variable definitions. See section Load environment variables from external file below. console - the console to launch the program ( internalConsole , integratedTerminal , externalTerminal ). See section Node Console below. outputCapture - if set to std , output from the process stdout/stderr will be shown in the Debug Console, instead of listening to output over the debug port. This is useful for programs or log libraries that write directly to the stdout/stderr streams instead of using console.* APIs. This attribute is only available for launch configurations of request type attach : restart - restart the connection on termination. See section Restarting debug session automatically . protocol - debug protocol to use. See section Supported Node-like runtimes above. port - debug port to use. See sections Attaching to Node.js and Remote debugging . address - TCP/IP address of the debug port. See sections Attaching to Node.js and Remote debugging . processId - the debugger tries to attach to this process after having sent a USR1 signal. With this setting, the debugger can attach to an already running process that was not started in debug mode. When using the processId attribute, the debug port is determined automatically based on the Node.js version (and the used protocol) and cannot be configured explicitly. So don't specify a port attribute. continueOnAttach - whether to continue the process if it's paused when we attach to it. This option is useful if you launch your program with --inspect-brk . Launch configurations for common scenarios You can trigger IntelliSense ( kb(editor.action.triggerSuggest) ) in your launch.json file to see launch configuration snippets for commonly used Node.js debugging scenarios. You can also bring up the snippets with the Add Configuration... button in the lower right of the launch.json editor window. These are the available snippets: Launch Program : Launch a Node.js program in debug mode. Launch via npm : Launch a Node.js program through an npm 'debug' script. If you have defined an npm debug script in your package.json, you can use it directly from your launch configuration. Make sure that the debug port used in the npm script, corresponds to the port specified in the snippet. Attach : Attach to the debug port of a locally running Node.js program. Make sure that the Node.js program to debug has been started in debug mode, and the debug port used is the same as the one specified in the snippet. Attach to Remote Program : Attach to the debug port of a Node.js program running on the host specified by the address attribute. Make sure that the Node.js program to debug has been started in debug mode, and the debug port used is the same as the one specified in the snippet. To help VS Code map source files between your workspace and the filesystem of the remote host, make sure to specify correct paths for the localRoot and remoteRoot attributes. Attach by Process ID : Open the process picker to select a node or gulp process for debugging. With this launch configuration, you can even attach to a node or gulp process that was not started in debug mode. Nodemon Setup : Use nodemon to relaunch a debug session automatically whenever the JavaScript source has changed. Make sure that you have nodemon installed globally. Note that terminating the debug session only terminates the program to debug, not nodemon itself. To terminate nodemon, press kbstyle(Ctrl+C) in the Integrated Terminal. Mocha Tests : Debug mocha tests in a test folder of your project. Make sure that your project has 'mocha' installed in its node_modules folder. Yeoman generator : Debug a yeoman generator. The snippet asks you to specify the name of the generator. Make sure that your project has 'yo' installed in its node_modules folder and that your generated project has been installed for debugging by running npm link in the project folder. Gulp task : Debug a gulp task. Make sure that your project has 'gulp' installed in its node_modules folder. Electron Main : Debug the main Node.js process of an Electron application. The snippet assumes that the Electron executable has been installed inside the node_modules/.bin directory of the workspace. Node console By default, Node.js debug sessions launch the target in the internal VS Code Debug Console. Since the Debug Console does not support programs that need to read input from the console, you can enable either an external terminal or use the VS Code Integrated Terminal by setting the console attribute in your launch configuration to externalTerminal or integratedTerminal respectively. The default is internalConsole . If an external terminal is used, you can configure which terminal program to use via the terminal.external.windowsExec , terminal.external.osxExec , and terminal.external.linuxExec settings. Launch configuration support for 'npm' and other tools Instead of launching the Node.js program directly with node, you can use 'npm' scripts or other task runner tools directly from a launch configuration: Any program available on the PATH (for example 'npm', 'mocha', 'gulp', etc.) can be used for the runtimeExecutable attribute and arguments can be passed via runtimeArgs . You do not have to set the program attribute if your npm script or other tool implicitly specifies the program to launch. Let's look at an 'npm' example. If your package.json has a 'debug' script, for example: \"scripts\": { \"debug\": \"node myProgram.js\" }, the corresponding launch configuration would look like this: { \"name\": \"Launch via npm\", \"type\": \"node\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"runtimeExecutable\": \"npm\", \"runtimeArgs\": [ \"run-script\", \"debug\" ], } Multi version support If you are using ' nvm ' (or ' nvm-windows ') to manage your Node.js versions, it is possible to specify a runtimeVersion attribute in a launch configuration for selecting a specific version of Node.js: { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch test\", \"runtimeVersion\": \"14\", \"program\": \"${workspaceFolder}/test.js\" } If you are using ' nvs ' to manage your Node.js versions, it is possible to use runtimeVersion attribute to select a specific version, architecture, and flavor Node.js, for example: { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch test\", \"runtimeVersion\": \"chackracore/8.9.4/x64\", \"program\": \"${workspaceFolder}/test.js\" } Make sure to have those Node.js versions installed that you want to use with the runtimeVersion attribute, as the feature will not download and install the version automatically. For example, you'll have to run something like nvm install 7.10.1 or nvs add 7.10.1 from the integrated terminal if you plan to add \"runtimeVersion\": \"7.10.1\" to your launch configuration. If you omit the minor and patch version and have, for example, \"runtimeVersion\": \"14\" , then the most recent 14.x.y version installed on your system will be used. Load environment variables from external file The VS Code Node debugger supports loading environment variables from a file and passing them to the Node.js runtime. To use this feature, add an attribute envFile to your launch configuration and specify the absolute path to the file containing the environment variables: //... \"envFile\": \"${workspaceFolder}/.env\", \"env\": { \"USER\": \"john doe\" } //... Any environment variable specified in the env dictionary will override variables loaded from the file. Here's an example of an .env file: USER=doe PASSWORD=abc123 # a comment # an empty value: empty= # new lines expanded in quoted strings: lines=\"foo\\nbar\" Attaching to Node.js If you want to attach the VS Code debugger to an external Node.js program, launch Node.js as follows: node --inspect program.js or if the program shouldn't start running, but must wait for the debugger to attach: node --inspect-brk program.js Now you have a couple options for attaching the debugger to your program: Open a \"process picker\" that lists all potential candidate processes and let you pick one, or Create an \"attach\" configuration that explicitly specifies all configuration options and then press F5 . Let's go through these options in detail: Attach to Node Process action The Attach to Node Process command from the Command Palette ( kb(workbench.action.showCommands) ) opens a Quick Pick menu that lists all potential processes that are available to the Node.js debugger: The individual processes listed in the picker show the debug port and process ID. Once you select your Node.js process in that list, the Node.js debugger will try to attach to it. In addition to Node.js processes, the picker also shows other programs that were launched with one of the various forms --inspect arguments. This makes it possible to attach to Electron's or VS Code's helper processes. Setting up an \"Attach\" configuration This option requires more work but in contrast to the previous two options it allows you to configure various debug configuration options explicitly. The simplest \"attach\" configuration looks like this: { \"name\": \"Attach to Process\", \"type\": \"node\", \"request\": \"attach\", \"port\": 9229 } The port 9229 is the default debug port of the --inspect and --inspect-brk options. To use a different port (for example 12345 ), add it to the options like this: --inspect=12345 and --inspect-brk=12345 and change the port attribute in the launch configuration to match. If you want to attach to a Node.js process that hasn't been started in debug mode, you can do this by specifying the process ID of the Node.js process as a string: { \"name\": \"Attach to Process\", \"type\": \"node\", \"request\": \"attach\", \"processId\": \"53426\" } Since it is a bit laborious to repeatedly find the process ID and enter it in the launch configuration, Node debug supports a command variable PickProcess that will open the process picker (from above). Using the PickProcess variable the launch configuration looks like this: { \"name\": \"Attach to Process\", \"type\": \"node\", \"request\": \"attach\", \"processId\": \"${command:PickProcess}\" } Stop debugging Using the Debug: Stop action (available in the Debug toolbar or via the Command Palette ) stops the debug session. If the debug session was started in \"attach\" mode (and the red terminate button in the Debug toolbar shows a superimposed \"plug\"), pressing Stop disconnects the Node.js debugger from the debuggee that then continues execution. If the debug session is in \"launch\" mode, pressing Stop does the following: When pressing Stop for the first time, the debuggee is requested to shut down gracefully by sending a SIGINT signal. The debuggee is free to intercept this signal and clean up anything as necessary and then shut down. If there are no breakpoints (or problems) in that shutdown code, the debuggee and the debug session will terminate. However if the debugger hits a breakpoint in the shutdown code or if the debuggee does not terminate properly by itself, then the debug session will not end. In this case, pressing Stop again will force terminate the debuggee and its child processes ( SIGKILL ). So if you see that a debug session doesn't end when you press the red Stop button, then press the button again to force a shutdown of the debuggee. Note that on the Windows operating system, pressing Stop always forcibly kills the debuggee and its child processes. Source maps The JavaScript debugger of VS Code supports source maps that help debugging of transpiled languages, for example, TypeScript or minified/uglified JavaScript. With source maps, it's possible to single step through or set breakpoints in the original source. If no source map exists for the original source, or if the source map is broken and cannot successfully map between the source and the generated JavaScript, then breakpoints show up as unverified (gray hollow circles). The source map feature is controlled by the sourceMaps attribute that defaults to true . This means that the debugger always tries to use source maps (if it can find any) and as a consequence, you can even specify a source file (for example, app.ts) with the program attribute. If you need to disable source maps for some reason, you can set the sourceMaps attribute to false . Tool Configuration Since source maps are not always automatically created, you should make sure to configure your transpiler to create them. For example: TypeScript For TypeScript, you can enable sourcemaps by passing --sourceMap to tsc , or by adding \"sourceMap\": true in your tsconfig.json file. tsc --sourceMap --outDir bin app.ts Babel For Babel, you'll want to set the sourceMaps option to true , or pass the --source-maps option when compiling your code. npx babel script.js --out-file script-compiled.js --source-maps Webpack Webpack has numerous source map options. We recommend setting the property devtool: \"source-map\" in your webpack.config.js for the best fidelity of results, although you can experiment with other settings causes slowdowns in your build. Also, if you have additional compilation steps in webpack, such as using a TypeScript loader, you'll also want to make sure that those steps are set up to generate sourcemaps. Otherwise, the sourcemaps that webpack generates will map back to the compiled code from the loader, instead of the real sources. Source Map Discovery By default, VS Code will search your entire workspace, excluding node_modules , for sourcemaps. In large workspaces, this search might be slow. You can configure the locations where VS Code will search for source maps by setting the outFiles attribute in your launch.json . For example, this configuration will only discover sourcemaps for .js files in the bin folder: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Launch TypeScript\", \"type\": \"node\", \"request\": \"launch\", \"program\": \"app.ts\", \"outFiles\": [ \"${workspaceFolder}/bin/**/*.js\" ] } ] } Note that the outFiles should match your JavaScript files, not the source map files (which may end in .map instead of .js ). Source Map Resolution By default, only source maps in your outFiles will be resolved. This behavior is used to prevent dependencies from interfering with breakpoints you set. For example, if you had a file src/index.ts and a dependency had a source map that referenced webpack:///./src/index.ts , that would incorrectly resolve to your source file and could lead to surprising results. You can configure this behavior by setting the resolveSourceMapLocations option. If set to null , every source map will be resolved. For example, this configuration will additionally allow source maps in node_modules/some-dependency to be resolved: \"resolveSourceMapLocations\": [ \"out/**/*.js\", \"node_modules/some-dependency/**/*.js\", ] Smart stepping With the smartStep attribute set to true in a launch configuration, VS Code will automatically skip 'uninteresting code' when stepping through code in the debugger. 'Uninteresting code' is code that is generated by a transpiling process but is not covered by a source map so it does not map back to the original source. This code gets in your way when stepping through source code in the debugger because it makes the debugger switch between the original source code and generated code that you are not interested in. smartStep will automatically step through code not covered by a source map until it reaches a location that is covered by a source map again. Smart stepping is especially useful for cases like async/await downcompilation in TypeScript, where the compiler injects helper code that is not covered by a source map. The smartStep feature only applies to JavaScript code that was generated from source and therefore has a source map. For JavaScript without sources, the smart stepping option has no effect. JavaScript source map tips A common issue when debugging with source maps is that you'll set a breakpoint, and it will turn gray. If you hover the cursor over it, you'll see the message, \"Breakpoint ignored because generated code not found (source map problem?)\" . What now? There are a range of issues that can lead to this. First, a quick explanation of how the Node debug adapter handles source maps. When you set a breakpoint in app.ts , the debug adapter has to figure out the path to app.js , the transpiled version of your TypeScript file, which is what is actually running in Node. But, there is not a straightforward way to figure this out starting from the .ts file. Instead, the debug adapter uses the outFiles attribute in the launch.json to find all the transpiled .js files, and parses them for a source map, which contains the locations of its associated .ts files. When you build your app.ts file in TypeScript with source maps enabled, it either produces an app.js.map file, or a source map inlined as a base64-encoded string in a comment at the bottom of the app.js file. To find the .ts files associated with this map, the debug adapter looks at two properties in the source map, sources , and sourceRoot . sourceRoot is optional - if present, it is prepended to each path in sources , which is an array of paths. The result is an array of absolute or relative paths to .ts files. Relative paths are resolved relative to the source map. Finally, the debug adapter searches for the full path of app.ts in this resulting list of .ts files. If there's a match, it has found the source map file to use when mapping app.ts to app.js . If there is no match, then it can't bind the breakpoint, and it will turn gray. Here are some things to try when your breakpoints turn gray: While debugging, run the Debug: Create Diagnostic Information for Current Session command. This command will bring up a tool that can provide hints to help you resolve any issues from the Command Palette ( kb(workbench.action.showCommands) ). Did you build with source maps enabled? Make sure there are .js.map files, or inlined source maps in your .js files. Are the sourceRoot and sources properties in your source map correct? Can they be combined to get the correct path to the .ts file? Have you opened the folder in VS Code with the incorrect case? It's possible to open folder foo/ from the command line like code FOO in which case source maps may not be resolved correctly. Try searching for help with your particular setup on Stack Overflow or by filing an issue on GitHub. Try adding a debugger statement. If it breaks into the .ts file there, but breakpoints at that spot don't bind, that is useful information to include with a GitHub issue. Remote debugging Note: VS Code now has universal remote development capabilities . Using the Remote Development extensions, Node.js development in remote scenarios and containers is no different than Node.js development in a local setup. This is the recommended way to remote debug Node.js programs . Check out the Getting started section and Remote tutorials to learn more. If you are unable to use any of the Remote Development extensions to debug your Node.js program, below is a guide on how to debug a remote Node.js program from your local instance of VS Code. The Node.js debugger supports remote debugging where you attach to a process running on a different machine, or in a container. Specify a remote host via the address attribute. For example: { \"type\": \"node\", \"request\": \"attach\", \"name\": \"Attach to remote\", \"address\": \"192.168.148.2\", // <- remote address here \"port\": 9229 } By default, VS Code will stream the debugged source from the remote Node.js folder to the local VS Code and show it in a read-only editor. You can step through this code, but cannot modify it. If you want VS Code to open the editable source from your workspace instead, you can set up a mapping between the remote and local locations. A localRoot and a remoteRoot attribute can be used to map paths between a local VS Code project and a (remote) Node.js folder. This works even locally on the same system or across different operating systems. Whenever a code path needs to be converted from the remote Node.js folder to a local VS Code path, the remoteRoot path is stripped off the path and replaced by localRoot . For the reverse conversion, the localRoot path is replaced by the remoteRoot . { \"type\": \"node\", \"request\": \"attach\", \"name\": \"Attach to remote\", \"address\": \"TCP/IP address of process to be debugged\", \"port\": 9229, \"localRoot\": \"${workspaceFolder}\", \"remoteRoot\": \"C:\\\\Users\\\\username\\\\project\\\\server\" } Access Loaded Scripts If you need to set a breakpoint in a script that is not part of your workspace and therefore cannot be easily located and opened through normal VS Code file browsing, you can access the loaded scripts via the LOADED SCRIPTS view in the Run view: The LOADED SCRIPTS view lets you quickly select the script by typing its name or filter the list when Enable Filter on Type is on. Scripts are loaded into a read-only editor where you can set breakpoints. These breakpoints are remembered across debug sessions but you only have access to the script content while a debug session is running. Restarting debug sessions automatically when source is edited The restart attribute of a launch configuration controls whether the Node.js debugger automatically restarts after the debug session has ended. This feature is useful if you use nodemon to restart Node.js on file changes. Setting the launch configuration attribute restart to true makes the node debugger automatically try to reattach to Node.js after Node.js has terminated. If you have started your program server.js via nodemon on the command line like this: nodemon --inspect server.js you can attach the VS Code debugger to it with the following launch configuration: { \"name\": \"Attach to node\", \"type\": \"node\", \"request\": \"attach\", \"restart\": true, \"port\": 9229 } Alternatively you can start your program server.js via nodemon directly with a launch config and attach the VS Code debugger: { \"name\": \"Launch server.js via nodemon\", \"type\": \"node\", \"request\": \"launch\", \"runtimeExecutable\": \"nodemon\", \"program\": \"${workspaceFolder}/server.js\", \"console\": \"integratedTerminal\", \"internalConsoleOptions\": \"neverOpen\" } Tip: Pressing the Stop button stops the debug session and disconnects from Node.js, but nodemon (and Node.js) will continue to run. To stop nodemon , you will have to kill it from the command line (which is easily possible if you use the integratedTerminal as shown above). Tip: In case of syntax errors, nodemon will not be able to start Node.js successfully until the error has been fixed. In this case, VS Code will continue trying to attach to Node.js but eventually give up (after 10 seconds). To avoid this, you can increase the timeout by adding a timeout attribute with a larger value (in milliseconds). Restart frame The Node debugger supports restarting execution at a stack frame. This can be useful in situations where you have found a problem in your source code and you want to rerun a small portion of the code with modified input values. Stopping and then restarting the full debug session can be time-consuming. The Restart Frame action allows you to reenter the current function after you have changed variables with the Set Value action: Restart Frame won't roll back mutation to state outside of the function, so it may not always work as expected. Breakpoints Conditional Breakpoints Conditional breakpoints are breakpoints that only pause when an expression returns a truthy value. You can create one by right-clicking in the gutter beside a line number and selecting \"Conditional Breakpoint\": Logpoints Something you want to just log a message or value when code hits a certain location, rather than pausing. You can do this with logpoints. Logpoints don't pause, but rather log a message to the Debug Console when hit. In the JavaScript debugger, you can use curly braces to interpolate expressions into the message, like current value is: {myVariable.property} . You can create one by right-clicking in the gutter beside a line number and selecting \"Logpoint\". For example, this might log something like location is /usr/local : Hit count breakpoints The 'hit count condition' controls how many times a breakpoint needs to be hit before it will 'break' execution. You can place a hit count breakpoint by right-clicking in the gutter beside a line number, selecting \"Conditional Breakpoint\", and then switching to \"Hit Count\". The hit count syntax supported by the Node.js debugger is either an integer or one of the operators < , <= , == , > , >= , % followed by an integer. Some examples: >10 break always after 10 hits <3 break on the first two hits only 10 same as >=10 %2 break on every other hit Breakpoint validation For performance reasons, Node.js parses the functions inside JavaScript files lazily on first access. As a consequence, breakpoints don't work in source code areas that haven't been seen (parsed) by Node.js. Since this behavior is not ideal for debugging, VS Code passes the --nolazy option to Node.js automatically. This prevents the delayed parsing and ensures that breakpoints can be validated before running the code (so they no longer \"jump\"). Since the --nolazy option might increase the start-up time of the debug target significantly, you can easily opt out by passing a --lazy as a runtimeArgs attribute. When doing so, you will find that some of your breakpoints don't \"stick\" to the line requested but instead \"jump\" for the next possible line in already-parsed code. To avoid confusion, VS Code always shows breakpoints at the location where Node.js thinks the breakpoint is. In the BREAKPOINTS section, these breakpoints are shown with an arrow between requested and actual line number: This breakpoint validation occurs when a session starts and the breakpoints are registered with Node.js, or when a session is already running and a new breakpoint is set. In this case, the breakpoint may \"jump\" to a different location. After Node.js has parsed all the code (for example, by running through it), breakpoints can be easily reapplied to the requested locations with the Reapply button in the BREAKPOINTS section header. This should make the breakpoints \"jump back\" to the requested location. Skipping uninteresting code VS Code Node.js debugging has a feature to avoid source code that you don't want to step through (also known as 'Just My Code'). This feature can be enabled with the skipFiles attribute in your launch configuration. skipFiles is an array of glob patterns for script paths to skip. For example, using: \"skipFiles\": [ \"${workspaceFolder}/node_modules/**/*.js\", \"${workspaceFolder}/lib/**/*.js\" ] all code in the node_modules and lib folders in your project will be skipped. Built-in core modules of Node.js can be referred to by the 'magic name' <node_internals> in a glob pattern. The following example skips all internal modules: \"skipFiles\": [ \"<node_internals>/**/*.js\" ] The exact 'skipping' rules are as follows: If you step into a skipped file, you won't stop there - you will stop on the next executed line that is not in a skipped file. If you have set the option to break on thrown exceptions, then you won't break on exceptions thrown from skipped files unless they bubble up into a non-skipped file. If you set a breakpoint in a skipped file, you will stop at that breakpoint, and you will be able to step through it until you step out of it, at which point normal skipping behavior will resume. The location of console messages from inside skip files will be shown as the first non-skipped location in the call stack. Skipped source is shown in a 'dimmed' style in the CALL STACK view: Hovering over the dimmed entries explains why the stack frame is dimmed. A context menu item on the call stack, Toggle skipping this file enables you to easily skip a file at runtime without adding it to your launch config. This option only persists for the current debugging session. You can also use it to stop skipping a file that is skipped by the skipFiles option in your launch config. Note: The legacy protocol debugger supports negative glob patterns, but they must follow a positive pattern: positive patterns add to the set of skipped files, while negative patterns subtract from that set. In the following ( legacy protocol-only) example all but a 'math' module is skipped: \"skipFiles\": [ \"${workspaceFolder}/node_modules/**/*.js\", \"!${workspaceFolder}/node_modules/math/**/*.js\" ] Note: The legacy protocol debugger has to emulate the skipFiles feature because the V8 Debugger Protocol does not support it natively. This might result in slow stepping performance. Supported Node-like runtimes The current VS Code JavaScript debugger supports Node version at or above 8.x, recent Chrome versions, and recent Edge versions (via the pwa-msedge launch type). Next steps In case you didn't already read the Node.js section, take a look at: Node.js - End to end Node scenario with a sample application To see tutorials on the basics of Node.js debugging, check out these videos: Intro Video - Debugging - Introductory video showcasing the basics of debugging. Getting started with Node.js debugging - Learn how to attach to a running Node.js process. To learn about VS Code's task running support, go to: Tasks - Running tasks with Gulp, Grunt, and Jake. Showing Errors and Warnings To write your own debugger extension, visit: Debugger Extension - Steps to create a VS Code debug extension starting from a mock sample Common questions Can I debug if I'm using symlinks? Yes, if you've created symlinks for folders inside your project, such as with npm link , you can debug the symlinked sources by telling the Node.js runtime to preserve symlinked paths. Use the node.exe --preserve-symlinks switch in your launch configuration runtimeArgs attribute. runtimeArgs , an array of strings, are passed to the debugging session runtime executable, which defaults to node.exe. { \"runtimeArgs\": [ \"--preserve-symlinks\" ] } If your main script is inside a symlinked path, then you will also need to add the \"--preserve-symlinks-main\" option. This option is only available in Node 10+. How do I debug ECMAScript modules? If you use esm or pass --experimental-modules to Node.js in order to use ECMAScript modules, you can pass these options through the runtimeArgs attribute of launch.json : \"runtimeArgs\": [\"--experimental-modules\"] - Use the experimental ECMAScript modules support in Node v8.5.0+ \"runtimeArgs\": [\"-r\", \"esm\"] - Use the esm ES module loader ( [\"-r esm\"] without a comma won't work)"
  },
  "guides/vscode/nodejs/nodejs-deployment.html": {
    "href": "guides/vscode/nodejs/nodejs-deployment.html",
    "title": "Deploy a Node.js Application to Azure | Fountain of Knowledge",
    "keywords": "Deploy a Node.js Application to Azure This page is redirected to ../azure/deployment and only exists to create the \"Node.js Deployment\" TOC item."
  },
  "guides/vscode/nodejs/nodejs-tutorial.html": {
    "href": "guides/vscode/nodejs/nodejs-tutorial.html",
    "title": "Node.js tutorial in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Node.js tutorial in Visual Studio Code Node.js is a platform for building fast and scalable server applications using JavaScript. Node.js is the runtime and npm is the Package Manager for Node.js modules. Visual Studio Code has support for the JavaScript and TypeScript languages out-of-the-box as well as Node.js debugging. However, to run a Node.js application, you will need to install the Node.js runtime on your machine. To get started in this walkthrough, install Node.js for your platform . The Node Package Manager is included in the Node.js distribution. You'll need to open a new terminal (command prompt) for the node and npm command-line tools to be on your PATH. To test that you have Node.js installed correctly on your computer, open a new terminal and type node --version and you should see the current Node.js version installed. Linux : There are specific Node.js packages available for the various flavors of Linux. See Installing Node.js via package manager to find the Node.js package and installation instructions tailored to your version of Linux. Windows Subsystem for Linux : If you are on Windows, WSL is a great way to do Node.js development. You can run Linux distributions on Windows and install Node.js into the Linux environment. When coupled with the Remote - WSL extension, you get full VS Code editing and debugging support while running in the context of WSL. To learn more, go to Developing in WSL or try the Working in WSL tutorial. Hello World Let's get started by creating the simplest Node.js application, \"Hello World\". Create an empty folder called \"hello\", navigate into and open VS Code: mkdir hello cd hello code . Tip: You can open files or folders directly from the command line. The period '.' refers to the current folder, therefore VS Code will start and open the Hello folder. From the File Explorer toolbar, press the New File button: and name the file app.js : By using the .js file extension, VS Code interprets this file as JavaScript and will evaluate the contents with the JavaScript language service. Refer to the VS Code JavaScript language topic to learn more about JavaScript support. Create a simple string variable in app.js and send the contents of the string to the console: var msg = 'Hello World'; console.log(msg); Note that when you typed console. IntelliSense on the console object was automatically presented to you. Also notice that VS Code knows that msg is a string based on the initialization to 'Hello World' . If you type msg. you'll see IntelliSense showing all of the string functions available on msg . After experimenting with IntelliSense, revert any extra changes from the source code example above and save the file ( kb(workbench.action.files.save) ). Running Hello World It's simple to run app.js with Node.js. From a terminal, just type: node app.js You should see \"Hello World\" output to the terminal and then Node.js returns. Integrated Terminal VS Code has an integrated terminal which you can use to run shell commands. You can run Node.js directly from there and avoid switching out of VS Code while running command-line tools. View > Terminal ( kb(workbench.action.terminal.toggleTerminal) with the backtick character) will open the integrated terminal and you can run node app.js there: For this walkthrough, you can use either an external terminal or the VS Code integrated terminal for running the command-line tools. Debugging Hello World As mentioned in the introduction, VS Code ships with a debugger for Node.js applications. Let's try debugging our simple Hello World application. To set a breakpoint in app.js , put the editor cursor on the first line and press kb(editor.debug.action.toggleBreakpoint) or click in the editor left gutter next to the line numbers. A red circle will appear in the gutter. To start debugging, select the Run View in the Activity Bar: You can now click Debug toolbar green arrow or press kb(workbench.action.debug.start) to launch and debug \"Hello World\". Your breakpoint will be hit and you can view and step through the simple application. Notice that VS Code displays a different colored Status Bar to indicate it is in Debug mode and the DEBUG CONSOLE is displayed. Now that you've seen VS Code in action with \"Hello World\", the next section shows using VS Code with a full-stack Node.js web app. Note: We're done with the \"Hello World\" example so navigate out of that folder before you create an Express app. You can delete the \"Hello\" folder if you want as it is not required for the rest of the walkthrough. An Express application Express is a very popular application framework for building and running Node.js applications. You can scaffold (create) a new Express application using the Express Generator tool. The Express Generator is shipped as an npm module and installed by using the npm command-line tool npm . Tip: To test that you've got npm correctly installed on your computer, type npm --help from a terminal and you should see the usage documentation. Install the Express Generator by running the following from a terminal: npm install -g express-generator The -g switch installs the Express Generator globally on your machine so you can run it from anywhere. We can now scaffold a new Express application called myExpressApp by running: express myExpressApp --view pug This creates a new folder called myExpressApp with the contents of your application. The --view pug parameters tell the generator to use the pug template engine. To install all of the application's dependencies (again shipped as npm modules), go to the new folder and execute npm install : cd myExpressApp npm install At this point, we should test that our application runs. The generated Express application has a package.json file which includes a start script to run node ./bin/www . This will start the Node.js application running. From a terminal in the Express application folder, run: npm start The Node.js web server will start and you can browse to http://localhost:3000 to see the running application. Great code editing Close the browser and from a terminal in the myExpressApp folder, stop the Node.js server by pressing kbstyle(CTRL+C) . Now launch VS Code: code . Note: If you've been using the VS Code integrated terminal to install the Express generator and scaffold the app, you can open the myExpressApp folder from your running VS Code instance with the File > Open Folder command. The Node.js and Express documentation does a great job explaining how to build rich applications using the platform and framework. Visual Studio Code will make you more productive in developing these types of applications by providing great code editing and navigation experiences. Open the file app.js and hover over the Node.js global object __dirname . Notice how VS Code understands that __dirname is a string. Even more interesting, you can get full IntelliSense against the Node.js framework. For example, you can require http and get full IntelliSense against the http class as you type in Visual Studio Code. VS Code uses TypeScript type declaration (typings) files (for example node.d.ts ) to provide metadata to VS Code about the JavaScript based frameworks you are consuming in your application. Type declaration files are written in TypeScript so they can express the data types of parameters and functions, allowing VS Code to provide a rich IntelliSense experience. Thanks to a feature called Automatic Type Acquisition , you do not have to worry about downloading these type declaration files, VS Code will install them automatically for you. You can also write code that references modules in other files. For example, in app.js we require the ./routes/index module, which exports an Express.Router class. If you bring up IntelliSense on index , you can see the shape of the Router class. Debug your Express app You will need to create a debugger configuration file launch.json for your Express application. Click on the Run icon in the Activity Bar and then the Configure gear icon at the top of the Run view to create a default launch.json file. Select the Node.js environment by ensuring that the type property in configurations is set to \"node\" . When the file is first created, VS Code will look in package.json for a start script and will use that value as the program (which in this case is \"${workspaceFolder}\\\\bin\\\\www ) for the Launch Program configuration. { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}\\\\bin\\\\www\" } ] } Save the new file and make sure Launch Program is selected in the configuration dropdown at the top of the Run view. Open app.js and set a breakpoint near the top of the file where the Express app object is created by clicking in the gutter to the left of the line number. Press kb(workbench.action.debug.start) to start debugging the application. VS Code will start the server in a new terminal and hit the breakpoint we set. From there you can inspect variables, create watches, and step through your code. Deploy your application If you'd like to learn how to deploy your web application, check out the Deploying Applications to Azure tutorials where we show how to run your website in Azure. Next steps There is much more to explore with Visual Studio Code, please try the following topics: Settings - Learn how to customize VS Code for how you like to work. Debugging - This is where VS Code really shines. Video: Getting started with Node.js debugging - Learn how to attach to a running Node.js process. Node.js debugging - Learn more about VS Code's built-in Node.js debugging. Debugging recipes - Examples for scenarios like client-side and container debugging. Tasks - Running tasks with Gulp, Grunt and Jake. Showing Errors and Warnings."
  },
  "guides/vscode/nodejs/reactjs-tutorial.html": {
    "href": "guides/vscode/nodejs/reactjs-tutorial.html",
    "title": "Using React in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Using React in Visual Studio Code React is a popular JavaScript library developed by Facebook for building web application user interfaces. The Visual Studio Code editor supports React.js IntelliSense and code navigation out of the box. Welcome to React We'll be using the create-react-app generator for this tutorial. To use the generator as well as run the React application server, you'll need Node.js JavaScript runtime and npm (Node.js package manager) installed. npm is included with Node.js which you can download and install from Node.js downloads . Tip : To test that you have Node.js and npm correctly installed on your machine, you can type node --version and npm --version in a terminal or command prompt. You can now create a new React application by typing: npx create-react-app my-app where my-app is the name of the folder for your application. This may take a few minutes to create the React application and install its dependencies. Note : If you've previously installed create-react-app globally via npm install -g create-react-app , we recommend you uninstall the package using npm uninstall -g create-react-app to ensure that npx always uses the latest version. Let's quickly run our React application by navigating to the new folder and typing npm start to start the web server and open the application in a browser: cd my-app npm start <!-- TBD mention yarn and link --> You should see the React logo and a link to \"Learn React\" on http://localhost:3000 in your browser. We'll leave the web server running while we look at the application with VS Code. To open your React application in VS Code, open another terminal or command prompt window, navigate to the my-app folder and type code . : cd my-app code . Markdown preview In the File Explorer, one file you'll see is the application README.md Markdown file. This has lots of great information about the application and React in general. A nice way to review the README is by using the VS Code Markdown Preview . You can open the preview in either the current editor group ( Markdown: Open Preview kb(markdown.showPreview) ) or in a new editor group to the side ( Markdown: Open Preview to the Side kb(markdown.showPreviewToSide) ). You'll get nice formatting, hyperlink navigation to headers, and syntax highlighting in code blocks. Syntax highlighting and bracket matching Now expand the src folder and select the index.js file. You'll notice that VS Code has syntax highlighting for the various source code elements and, if you put the cursor on a parenthesis, the matching bracket is also selected. IntelliSense As you start typing in index.js , you'll see smart suggestions or completions. After you select a suggestion and type . , you see the types and methods on the object through IntelliSense . VS Code uses the TypeScript language service for its JavaScript code intelligence and it has a feature called Automatic Type Acquisition (ATA). ATA pulls down the npm Type Declaration files ( *.d.ts ) for the npm modules referenced in the package.json . If you select a method, you'll also get parameter help: Go to Definition, Peek definition Through the TypeScript language service, VS Code can also provide type definition information in the editor through Go to Definition ( kb(editor.action.revealDefinition) ) or Peek Definition ( kb(editor.action.peekDefinition) ). Put the cursor over the App , right click and select Peek Definition . A Peek window will open showing the App definition from App.js . Press kbstyle(Escape) to close the Peek window. Hello World! Let's update the sample application to \"Hello World!\". Create a new H1 header with \"Hello, world!\" and replace the <App /> tag in ReactDOM.render with element . import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import reportWebVitals from './reportWebVitals'; var element = React.createElement('h1', { className: 'greeting' }, 'Hello, world!'); ReactDOM.render(element, document.getElementById('root')); reportWebVitals(); Once you save the index.js file, the running instance of the server will update the web page and you'll see \"Hello World!\" when you refresh your browser. Tip : VS Code supports Auto Save, which by default saves your files after a delay. Check the Auto Save option in the File menu to turn on Auto Save or directly configure the files.autoSave user setting . Debugging React To debug the client side React code, we'll use the built-in JavaScript debugger. Note: This tutorial assumes you have the Edge browser installed. If you want to debug using Chrome, replace the launch type with pwa-chrome . There is also a debugger for the Firefox browser. Set a breakpoint To set a breakpoint in index.js , click on the gutter to the left of the line numbers. This will set a breakpoint which will be visible as a red circle. Configure the debugger We need to initially configure the debugger . To do so, go to the Run view ( kb(workbench.view.debug) ) and click on the gear button or Create a launch.json link to create a launch.json debugger configuration file. Choose Edge: launch from the Select Environment dropdown list. This will create a launch.json file in a new .vscode folder in your project which includes a configuration to launch the website. We need to make one change for our example: change the port of the url from 8080 to 3000 . Your launch.json should look like this: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"pwa-msedge\", \"request\": \"launch\", \"name\": \"Launch Edge against localhost\", \"url\": \"http://localhost:3000\", \"webRoot\": \"${workspaceFolder}\" } ] } Ensure that your development server is running ( npm start ). Then press kb(workbench.action.debug.start) or the green arrow to launch the debugger and open a new browser instance. The source code where the breakpoint is set runs on startup before the debugger was attached, so we won't hit the breakpoint until we refresh the web page. Refresh the page and you should hit your breakpoint. You can step through your source code ( kb(workbench.action.debug.stepOver) ), inspect variables such as element , and see the call stack of the client side React application. For more information about the debugger and its available options, check out our documentation on browser debugging . Live editing and debugging If you are using webpack together with your React app, you can have a more efficient workflow by taking advantage of webpack's HMR mechanism which enables you to have live editing and debugging directly from VS Code. You can learn more in this Live edit and debug your React apps directly from VS Code blog post and the webpack Hot Module Replacement documentation . Linting Linters analyze your source code and can warn you about potential problems before you run your application. The JavaScript language services included with VS Code has syntax error checking support by default, which you can see in action in the Problems panel ( View > Problems kb(workbench.actions.view.problems) ). Try making a small error in your React source code and you'll see a red squiggle and an error in the Problems panel. Linters can provide more sophisticated analysis, enforcing coding conventions and detecting anti-patterns. A popular JavaScript linter is ESLint . ESLint, when combined with the ESLint VS Code extension , provides a great in-product linting experience. First, install the ESLint command-line tool: npm install -g eslint Then install the ESLint extension by going to the Extensions view and typing 'eslint'. Once the ESLint extension is installed and VS Code reloaded, you'll want to create an ESLint configuration file, .eslintrc.js . You can create one using the extension's ESLint: Create ESLint configuration command from the Command Palette ( kb(workbench.action.showCommands) ). The command will prompt you to answer a series of questions in the Terminal panel. Take the defaults, and it will create a .eslintrc.js file in your project root that looks something like this: module.exports = { \"env\": { \"browser\": true, \"es2020\": true }, \"extends\": [ \"eslint:recommended\", \"plugin:react/recommended\" ], \"parserOptions\": { \"ecmaFeatures\": { \"jsx\": true }, \"ecmaVersion\": 11, \"sourceType\": \"module\" }, \"plugins\": [ \"react\" ], \"rules\": { } }; ESLint will now analyze open files and shows a warning in index.js about 'App' being defined but never used. You can modify the ESLint rules in the .eslintrc.js file. Let's add an error rule for extra semi-colons: \"rules\": { \"no-extra-semi\":\"error\" } Now when you mistakenly have multiple semicolons on a line, you'll see an error (red squiggle) in the editor and error entry in the Problems panel. Popular Starter Kits In this tutorial, we used the create-react-app generator to create a simple React application. There are lots of great samples and starter kits available to help build your first React application. VS Code React Sample This is a sample React application used for a demo at the 2016 //Build conference. The sample creates a simple TODO application and includes the source code for a Node.js Express server. It also shows how to use the Babel ES6 transpiler and then use webpack to bundle the site assets. TypeScript React If you're curious about TypeScript and React, you can also create a TypeScript version of the create-react-app application by specifying that you want to use the TypeScript template: npx create-react-app my-app --template typescript See the details at Adding TypeScript on the Create React App site . Angular Angular is another popular web framework. If you'd like to see an example of Angular working with VS Code, check out the Debugging with Angular CLI recipe. It will walk you through creating an Angular application and configuring the launch.json file for the JavaScript debugger. Common questions Can I get IntelliSense within declarative JSX? Yes. For example, if you open the create-react-app project's App.js file, you can see IntelliSense within the React JSX in the render() method."
  },
  "guides/vscode/nodejs/vuejs-tutorial.html": {
    "href": "guides/vscode/nodejs/vuejs-tutorial.html",
    "title": "Using Vue in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Using Vue in Visual Studio Code Vue.js is a popular JavaScript library for building web application user interfaces and Visual Studio Code has built-in support for the Vue.js building blocks of HTML , CSS , and JavaScript . For a richer Vue.js development environment, you can install the Vetur extension which supports Vue.js IntelliSense, code snippets, formatting, and more. Welcome to Vue We'll be using the Vue CLI for this tutorial. If you are new to the Vue.js framework, you can find great documentation and tutorials on the vuejs.org website. To install and use the Vue CLI as well as run the Vue application server, you'll need the Node.js JavaScript runtime and npm (the Node.js package manager) installed. npm is included with Node.js which you can install from Node.js downloads . Tip : To test that you have Node.js and npm correctly installed on your machine, you can type node --version and npm --version . To install the vue/cli , in a terminal or command prompt type: npm install -g @vue/cli This may take a few minutes to install. You can now create a new Vue.js application by typing: vue create my-app where my-app is the name of the folder for your application. You will be prompted to select a preset and you can keep the default (babel, eslint) , which will use Babel to transpile the JavaScript to browser compatible ES5 and install the ESLint linter to detect coding errors. It may take a few minutes to create the Vue application and install its dependencies. Let's quickly run our Vue application by navigating to the new folder and typing npm run serve to start the web server and open the application in a browser: cd my-app npm run serve You should see \"Welcome to your Vue.js App\" on http://localhost:8080 in your browser. You can press kbstyle(Ctrl+C) to stop the vue-cli-service server. To open your Vue application in VS Code, from a terminal (or command prompt), navigate to the my-app folder and type code . : cd my-app code . VS Code will launch and display your Vue application in the File Explorer. Vetur extension Now expand the src folder and select the App.vue file. You'll notice that VS Code doesn't show any syntax highlighting and it treats the file as Plain Text as you can see in the lower right Status Bar. You'll also see a notification recommending the Vetur extension for the .vue file type. The Vetur extension supplies Vue.js language features (syntax highlighting, IntelliSense, snippets, formatting) to VS Code. From the notification, press Install to download and install the Vetur extension. You should see the Vetur extension Installing in the Extensions view. Once the installation is complete (may take several minutes), the Install button will change to the Manage gear button. Now you should see that .vue is a recognized file type for the Vue language and you have language features such as syntax highlighting, bracket matching, and hover descriptions. IntelliSense As you start typing in App.vue , you'll see smart suggestions or completions both for HTML and CSS but also for Vue.js specific items like declarations ( v-bind , v-for ) in the Vue template section: and Vue properties ( methods , computed ) in the scripts section: Go to Definition, Peek definition VS Code through the Vue extension language service can also provide type definition information in the editor through Go to Definition ( kb(editor.action.revealDefinition) ) or Peek Definition ( kb(editor.action.peekDefinition) ). Put the cursor over the App , right click and select Peek Definition . A Peek window will open showing the App definition from App.js . Press kbstyle(Escape) to close the Peek window. Hello World! Let's update the sample application to \"Hello World!\". In App.vue replace the HelloWorld component msg custom attribute text with \"Hello World!\". <template> <div id=\"app\"> <img src=\"./assets/logo.png\"> <HelloWorld msg=\"Hello World!\"/> </div> </template> Once you save the App.vue file ( kb(workbench.action.files.save) ), restart the server with npm run serve and you'll see \"Hello World!\". Leave the server running while we go on to learn about Vue.js client side debugging. Tip : VS Code supports Auto Save, which by default saves your files after a delay. Check the Auto Save option in the File menu to turn on Auto Save or directly configure the files.autoSave user setting . Linting Linters analyze your source code and can warn you about potential problems before you run your application. The Vue ESLint plugin ( eslint-plugin-vue ) checks for Vue.js specific syntax errors which are shown in the editor as red squigglies and are also displayed in the Problems panel ( View > Problems kb(workbench.actions.view.problems) ). Below you can see an error when the Vue linter detects more than one root element in a template: Debugging You can debug client side Vue.js code with the built-in JavaSCript debugger. You can learn more from the Vue.js debugging in VS Code recipe on the VS Code debugging recipes site. Note: There are currently issues with the sourcemaps generated by vue-cli, which cause issues with the debugging experience in VS Code. See https://github.com/vuejs/vue-loader/issues/1163 . Another popular tool for debugging Vue.js is the vue-devtools plug-in. Other extensions Vetur is only one of many Vue.js extensions available for VS Code. You can search in the Extensions view ( kb(workbench.view.extensions) ) by typing 'vue'. There are also Extension Packs which bundle extensions that other people have found useful for Vue.js development."
  },
  "guides/vscode/nodejs/working-with-javascript.html": {
    "href": "guides/vscode/nodejs/working-with-javascript.html",
    "title": "Working with JavaScript | Fountain of Knowledge",
    "keywords": "Working with JavaScript This topic describes some of the advanced JavaScript features supported by Visual Studio Code. Using the TypeScript language service, VS Code can provide smart completions (IntelliSense) as well as type checking for JavaScript. IntelliSense Visual Studio Code's JavaScript IntelliSense provides intelligent code completion, parameter info, references search, and many other advanced language features. Our JavaScript IntelliSense is powered by the JavaScript language service developed by the TypeScript team. While IntelliSense should just work for most JavaScript projects without any configuration, you can make IntelliSense even more useful with JSDoc or by configuring a jsconfig.json project. For the details of how JavaScript IntelliSense works, including being based on type inference, JSDoc annotations, TypeScript declarations, and mixing JavaScript and TypeScript projects, see the JavaScript language service documentation . When type inference does not provide the desired information, type information may be provided explicitly with JSDoc annotations. This document describes the JSDoc annotations currently supported. In addition to objects, methods, and properties, the JavaScript IntelliSense window also provides basic word completion for the symbols in your file. Typings and Automatic Type Acquisition IntelliSense for JavaScript libraries and frameworks is powered by TypeScript type declaration (typings) files. Type declaration files are written in TypeScript so they can express the data types of parameters and functions, allowing VS Code to provide a rich IntelliSense experience in a performant manner. Many popular libraries ship with typings files so you get IntelliSense for them automatically. For libraries that do not include typings, VS Code's Automatic Type Acquisition will automatically install community maintained typings file for you. Automatic type acquisition requires npmjs , the Node.js package manager, which is included with the Node.js runtime. In this image you can see IntelliSense, including the method signature, parameter info, and the method's documentation for the popular lodash library. Type declaration files are automatically downloaded and managed by Visual Studio Code for packages listed in your project's package.json or that you import into a JavaScript file. { \"dependencies\": { \"lodash\": \"^4.17.0\" } } You can alternately explicitly list packages to acquire type declaration files for in a jsconfig.json . { \"typeAcquisition\": { \"include\": [ \"jquery\" ] } } Most common JavaScript libraries ship with declaration files or have type declaration files available. You can search for a library's type declaration file package using the TypeSearch site. Fixing npm not installed warning for Automatic Type Acquisition Automatic Type Acquisition uses npm , the Node.js package manager, to install and manage Type Declaration (typings) files. To ensure that Automatic Type Acquisition works properly, first ensure that you have npm installed on your machine. Run npm --version from a terminal or command prompt to quickly check that npm is installed and available. npm is installed with the Node.js runtime, which is available for download from Nodejs.org . Install the current LTS (Long Term Support) version and the npm executable will be added by default to your system path. If you have npm installed but still see a warning message, you can explicitly tell VS Code where npm is installed with the typescript.npm setting . This should be set to the full path of the npm executable on your machine, and this does not have to match the version of npm you are using to manage packages in your workspace. typescript.npm requires TypeScript 2.3.4+. For example, on Windows, you would add a path like this to your settings.json file: { \"typescript.npm\": \"C:\\\\Program Files\\\\nodejs\\\\npm.cmd\" } JavaScript projects (jsconfig.json) The presence of a jsconfig.json file in a directory indicates that the directory is the root of a JavaScript project. jsconfig.json specifies the root files and the options for the language features provided by the JavaScript language service . For common setups, a jsconfig.json file is not required, however, there are situations when you will want to add a jsconfig.json . Not all files should be in your JavaScript project (for example, you want to exclude some files from showing IntelliSense). This situation is common with front-end and back-end code. Your workspace contains more than one project context. In this situation, you should add a jsconfig.json file at the root folder for each project. You are using the TypeScript compiler to down-level compile JavaScript source code. Location of jsconfig.json To define our code as a JavaScript project, create jsconfig.json at the root of your JavaScript code as shown below. A JavaScript project is the source files of the project and should not include the derived or packaged files (such as a dist directory). In more complex projects, you may have more than one jsconfig.json file defined inside a workspace. You will want to do this so that the source code in one project does not appear in the IntelliSense of another project. Illustrated below is a project with a client and server folder, showing two separate JavaScript projects: Writing jsconfig.json Below is a simple template for jsconfig.json file, which defines the JavaScript target to be ES6 and the exclude attribute excludes the node_modules folder. You can copy and paste this code into your jsconfig.json file. { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\" }, \"exclude\": [ \"node_modules\", \"**/node_modules/*\" ] } The exclude attribute tells the language service which files are not part of your source code. If IntelliSense is slow, add folders to your exclude list (VS Code will prompt you to do this if it detects slow completions). You will want to exclude files generated by a build process (such as a dist directory). These files will cause suggestions to show up twice and will slow down IntelliSense. You can explicitly set the files in your project using the include attribute. If no include attribute is present, then this defaults to including all files in the containing directory and subdirectories. When a include attribute is specified, only those files are included. Here is an example with an explicit include attribute: { \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es6\" }, \"include\": [ \"src/**/*\" ] } The best practice, and least error prone route, is to use the include attribute with a single src folder. Note that file paths in exclude and include are relative to the location of jsconfig.json . For more information, see the full jsconfig.json documentation . Migrating to TypeScript It is possible to have mixed TypeScript and JavaScript projects. To start migrating to TypeScript, rename your jsconfig.json file to tsconfig.json and set the allowJs property to true . For more information, see Migrating from JavaScript . Note: jsconfig.json is the same as a tsconfig.json file, only with allowJs set to true. See the documentation for tsconfig.json here to see other available options. Type checking JavaScript VS Code allows you to leverage some of TypeScript's advanced type checking and error reporting functionality in regular JavaScript files. This is a great way to catch common programming mistakes. These type checks also enable some exciting Quick Fixes for JavaScript, including Add missing import and Add missing property . TypeScript can infer types in .js files same as in .ts files. When types cannot be inferred, they can be specified using JSDoc comments. You can read more about how TypeScript uses JSDoc for JavaScript type checking in Type Checking JavaScript Files . Type checking of JavaScript is optional and opt-in. Existing JavaScript validation tools such as ESLint can be used alongside the new built-in type checking functionality. You can get started with type checking a few different ways depending on your needs. Per file The easiest way to enable type checking in a JavaScript file is by adding // @ts-check to the top of a file. // @ts-check let itsAsEasyAs = 'abc' itsAsEasyAs = 123 // Error: Type '123' is not assignable to type 'string' Using // @ts-check is a good approach if you just want to try type checking in a few files but not yet enable it for an entire codebase. Using a setting To enable type checking for all JavaScript files without changing any code, just add \"js/ts.implicitProjectConfig.checkJs\": true to your workspace or user settings. This enables type checking for any JavaScript file that is not part of a jsconfig.json or tsconfig.json project. You can opt individual files out of type checking with a // @ts-nocheck comment at the top of the file: // @ts-nocheck let easy = 'abc' easy = 123 // no error You can also disable individual errors in a JavaScript file using a // @ts-ignore comment on the line before the error: let easy = 'abc' // @ts-ignore easy = 123 // no error Using jsconfig or tsconfig To enable type checking for JavaScript files that are part of a jsconfig.json or tsconfig.json , add \"checkJs\": true to the project's compiler options: jsconfig.json : { \"compilerOptions\": { \"checkJs\": true }, \"exclude\": [ \"node_modules\", \"**/node_modules/*\" ] } tsconfig.json : { \"compilerOptions\": { \"allowJs\": true, \"checkJs\": true }, \"exclude\": [ \"node_modules\", \"**/node_modules/*\" ] } This enables type checking for all JavaScript files in the project. You can use // @ts-nocheck to disable type checking per file. JavaScript type checking requires TypeScript 2.3. If you are unsure what version of TypeScript is currently active in your workspace, run the TypeScript: Select TypeScript Version command to check. You must have a .js/.ts file open in the editor to run this command. If you open a TypeScript file, the version appears in the lower right corner. Global variables and type checking Let's say that you are working in legacy JavaScript code that uses global variables or non-standard DOM APIs: window.onload = function() { if (window.webkitNotifications.requestPermission() === CAN_NOTIFY) { window.webkitNotifications.createNotification(null, 'Woof!', '🐶').show() } else { alert('Could not notify') } } If you try to use // @ts-check with the above code, you'll see a number of errors about the use of global variables: Line 2 - Property 'webkitNotifications' does not exist on type 'Window'. Line 2 - Cannot find name 'CAN_NOTIFY'. Line 3 - Property 'webkitNotifications' does not exist on type 'Window'. If you want to continue using // @ts-check but are confident that these are not actual issues with your application, you have to let TypeScript know about these global variables. To start, create a jsconfig.json at the root of your project: { \"compilerOptions\": { }, \"exclude\": [ \"node_modules\", \"**/node_modules/*\" ] } Then reload VS Code to make sure the change is applied. The presence of a jsconfig.json lets TypeScript know that your Javascript files are part of a larger project. Now create a globals.d.ts file somewhere your workspace: interface Window { webkitNotifications: any; } declare var CAN_NOTIFY: number; d.ts files are type declarations. In this case, globals.d.ts lets TypeScript know that a global CAN_NOTIFY exists and that a webkitNotifications property exists on window . You can read more about writing d.ts in the TypeScript documentation . d.ts files do not change how JavaScript is evaluated, they are used only for providing better JavaScript language support. Using tasks Using the TypeScript compiler One of the key features of TypeScript is the ability to use the latest JavaScript language features, and emit code that can execute in JavaScript runtimes that don't yet understand those newer features. With JavaScript using the same language service, it too can now take advantage of this same feature. The TypeScript compiler tsc can down-level compile JavaScript files from ES6 to another language level. Configure the jsconfig.json with the desired options and then use the –p argument to make tsc use your jsconfig.json file, for example tsc -p jsconfig.json to down-level compile. Read more about the compiler options for down level compilation in the jsconfig documentation . Running Babel The Babel transpiler turns ES6 files into readable ES5 JavaScript with Source Maps. You can easily integrate Babel into your workflow by adding the configuration below to your tasks.json file (located under the workspace's .vscode folder). The group setting makes this task the default Task: Run Build Task gesture. isBackground tells VS Code to keep running this task in the background. To learn more, go to Tasks . { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"watch\", \"command\": \"${workspaceFolder}/node_modules/.bin/babel\", \"args\": [\"src\", \"--out-dir\", \"lib\", \"-w\", \"--source-maps\"], \"type\": \"shell\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"isBackground\": true } ] } Once you have added this, you can start Babel with the kb(workbench.action.tasks.build) ( Run Build Task ) command and it will compile all files from the src directory into the lib directory. Tip: For help with Babel CLI, see the instructions in Using Babel . The example above uses the CLI option. Disable JavaScript support If you prefer to use JavaScript language features supported by other JavaScript language tools such as Flow , you can disable VS Code's built-in JavaScript support. You do this by disabling the built-in TypeScript language extension TypeScript and JavaScript Language Features (vscode.typescript-language-features) which also provides the JavaScript language support. To disable JavaScript/TypeScript support, go to the Extensions view ( kb(workbench.view.extensions) ) and filter on built-in extensions ( Show Built-in Extensions in the ... More Actions dropdown), then type 'typescript'. Select the TypeScript and JavaScript Language Features extension and press the Disable button. VS Code built-in extensions cannot be uninstalled, only disabled, and can be re-enabled at any time."
  },
  "guides/vscode/other/office.html": {
    "href": "guides/vscode/other/office.html",
    "title": "Office Add-ins with Visual Studio Code | Fountain of Knowledge",
    "keywords": "Office Add-ins with Visual Studio Code Office Add-ins run inside an Office application and can interact with contents of the Office document using the rich JavaScript API. Under the hood, an Office Add-in is just a web app that you can host anywhere. Using a manifest.xml file, you tell the Office application where your web app is located and how you want it to appear. The Office application takes care of hosting it within Office. Create a new Office Add-in project First follow the instructions to Create an Office Add-in using any editor to install the necessary prerequisites, and use the Yeoman generator yo office to create a new add-in project. The following table lists the project attributes to select in the Yeoman generator. Option Value New subfolder (Accept the default) Add-in name Outlook Add-in Supported Office application (Select Outlook) Create new add-in Yes, I want a new add-in Add TypeScript No Choose framework Jquery Use Visual Studio Code to develop your Office Add-in Visual Studio Code is a great tool to help you develop your custom Office Add-ins for Outlook, Word, Excel, PowerPoint, regardless of whether the Add-ins run in web clients, Windows clients, iOS clients or on macOS! Getting started Open the project in Visual Studio Code by entering the following text on the command line from within the same folder where you ran the generator: code . Open the manifest.xml file that was created by Yo Office and locate the SourceLocation node. Update the URL of the DefaultValue to the URL where you will host the Add-in. Tip: If you are using an Azure Web App as the host, the URL will look like https://[name-of-your-web-app].azurewebsites.net/[path-to-add-in] . If you are using the self-hosted option listed above, it will be http://localhost:3000/[path-to-add-in] . Debugging your Office Add-in VS Code does not currently support client-side debugging. To debug your client-side Add-in, you can use the Office web clients and open the browser's developer tools and debug the Add-in just like any other client-side JavaScript application. If you are using Node.js or ASP.NET Core for server-side logic that supports your Office Add-in, refer to the Debugging page to configure VS Code for debugging either of these runtimes. Install the Add-in Office Add-ins must be installed, or registered, with the Office application in order to load. This is done using the manifest.xml file you modified earlier. Side loading Mail Add-ins Mail Add-ins can be installed within the Outlook Web App. Browse to your Outlook Web App and login. Once logged in, select the gear icon in the top-right section and select Manage add-ins : On the Manage add-ins page, select the + icon, and then select Add from a file . Locate the manifest.xml file for your custom Add-in and install it, accepting all prompts when installing it. Once that's done, select an existing email and you will see a horizontal bar below the email header that includes the Add-in: Next try creating an email, select the Add-ins or Apps menu item to get the Task Pane to appear: Select the Add-in and see it appear in the Task Pane: Deploying Add-ins to the Office 365 Tenancy's App Catalog All Office Add-ins (including Mail Add-ins) can be installed from your Office 365 tenancy's App Catalog site. Log in to your Office 365 portal . In the left-hand navigation, towards the bottom, select the Admin / SharePoint option: From the SharePoint Admin Center , select the Apps option in the left-hand menu and then select the App Catalog . On the App Catalog page, select the Apps for Office option and upload the manifest.xml file. Install Content & Task Pane Add-ins in Word / Excel / PowerPoint Depending on the type of Add-in you created, you can add it to one of the Office applications. Task Pane and Content Add-ins can be installed in Word, Excel & PowerPoint. Mail Add-ins can be installed in Outlook. To install an Add-in within an Office application, select the Insert tab and click the Office Add-ins button, as shown here using the Excel Web App: You can select Add-ins you've uploaded to your Office 365 tenancy's App Catalog using the Office Add-ins dialog (listed under My Organization ) or acquire Add-ins from the Office Store. Next steps Check out the other pages on the VS Code site to find out how you can use more capabilities of the editor when creating custom Office Add-ins: Language Overview - You can write Office Add-ins in many languages. Find out what VS Code has to offer. User Interface - Just starting out with VS Code? This is worth reviewing. Basic Editing - Learn about the powerful VS Code editor. Common questions Can I create an Office Add-in with the generator and use VS Code regardless of the language or client-side framework? Yes, you can. You can use pure HTML, Angular, Ember, React, Aurelia... anything you like! Can I use TypeScript to create my Office Add-in? Absolutely, VS Code has great support for TypeScript !"
  },
  "guides/vscode/other/unity.html": {
    "href": "guides/vscode/other/unity.html",
    "title": "Unity Development with VS Code | Fountain of Knowledge",
    "keywords": "Unity Development with VS Code Visual Studio Code can be a great companion to Unity for editing and debugging C# files. All of the C# features are supported and more. In the screen below, you can see code colorization, bracket matching, IntelliSense, CodeLens and that's just the start. Read on to find out how to configure Unity and your project to get the best possible experience. Prerequisites From Using .NET Core in Visual Studio Code : Install the .NET Core SDK , which includes the Runtime and the dotnet command. [Windows only] Logout or restart Windows to allow changes to %PATH% to take effect. [macOS only] To avoid seeing \"Some projects have trouble loading. Please review the output for more details\", make sure to install the latest stable Mono release. Note : This version of Mono, which is installed into your system, will not interfere with the version of MonoDevelop that is installed by Unity. Install the C# extension from the VS Code Marketplace. Setup VS Code as Unity Script Editor Open up Unity Preferences , External Tools , then browse for the Visual Studio Code executable as External Script Editor . The Visual Studio Code executable can be found at /Applications/Visual Studio Code.app on macOS, %localappdata%\\Programs\\Microsoft VS Code\\Code.exe on Windows by default. Unity has built-in support for opening scripts in Visual Studio Code as an external script editor on Windows and macOS. Unity will detect when Visual Studio Code is selected as an external script editor and pass the correct arguments to it when opening scripts from Unity. Unity will also set up a default .vscode/settings.json with file excludes, if it does not already exist (from Unity 5.5 Release notes ). Unity version 2019.2 or above Since 2019.2 , it is required to use the Visual Studio Code editor package. The built-in support for opening scripts from Unity and getting csproj and sln files generated has been removed. Editing Evolved With the solution file selected, you are now ready to start editing with VS Code. Here is a list of some of the things you can expect: Syntax Highlighting Bracket matching IntelliSense Snippets CodeLens Peek Go-to Definition Code Actions/Lightbulbs Go to symbol Hover Two topics that will help you are Basic Editing and C# . In the image below, you can see VS Code showing hover context, peeking references and more. Unity Extensions The community is continually developing more and more valuable extensions for Unity. Here are some popular extensions that you might find useful. You can search for more extensions in the VS Code Extension Marketplace . The extensions shown above are dynamically queried. Select an extension tile above to read the description and reviews to decide which extension is best for you. See more in the Marketplace . Enabling code completion (For recent versions of Unity) If you are installing VS Code for the first time, you might be missing targeting packs required for Unity's code-completion (IntelliSense) in VS Code. Targeting pack download links: Windows: .NET Framework 4.6 Targeting Pack macOS: Download .NET SDK Steps: Stop VS Code or Unity running. Download and install the targeting pack for your targeted framework version / preferred version from one of the above links. Start Unity. Create and/or open an existing script in VS Code, through Unity, and you should now see code completions. Enabling Unity warnings Unity has a set of custom C# warnings , called analyzers, that check for common issues with your source code. These analyzers ship out of the box with Visual Studio but need to be set up manually in Visual Studio Code. Due to how Unity handles its .csproj files, it does not seem possible to install packages automatically. You will need to download the analyzers from the NuGet website manually. When you're done, open the package file using a tool such as 7zip and extract Microsoft.Unity.Analyzers.dll onto your project's root folder. You can place it inside a folder named NuGet , for example. Do not place it inside Assets or Packages , as that will cause Unity to try to process the .dll , which will make it output an error in the console. Next, create an omnisharp.json file at the root folder of your project, as explained here . Analyzer support in OmniSharp is experimental at the moment, so we need to enable it explicitly. We also need to point it to the .dll file we just extracted. Your omnisharp.json file should end up looking like this: { \"RoslynExtensionsOptions\": { \"EnableAnalyzersSupport\": true, \"LocationPaths\": [ \"./NuGet/microsoft.unity.analyzers.1.9.0\" ] } } where \"./NuGet/microsoft.unity.analyzers.1.9.0\" is a relative path pointing to the folder containing the .dll file. Depending on where you placed it, your path may look different. The Unity analyzers should now be working in your project. You can test them by creating an empty FixedUpdate() method inside one of your MonoBehavior classes, which should trigger a The Unity message 'FixedUpdate' is empty warning ( UNT0001 ). Note that while it is possible to activate these analyzers, the suppressors they ship with the package (that turn off other C# warnings that may conflict with these custom ones) may not be picked up by OmniSharp at the moment, according to this thread . You can still turn off specific rules manually by following these steps: Create a .editorconfig file in your project's root folder (next to Unity's .csproj files). Add the following contents to the file: root=true [*.cs] dotnet_diagnostic.IDE0051.severity = none root=true tells OmniSharp that this is your project root and it should stop looking for parent .editorconfig files outside of this folder. dotnet_diagnostic.IDE0051.severity = none is an example of turning off the analyzer with ID IDE0051 by setting its severity level to none . You can read more about these settings in the Analyzer overview . You can add as many of these rules as you want to this file. [*.cs] indicates that our custom rules should apply to all C# scripts (files with the .cs extension). You are now ready to code in Visual Studio Code, while getting the same warnings as you would when using Visual Studio! Next steps Read on to learn more about: Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Debugging - how to use the debugger with your project C# - learn about the C# support in VS Code Common questions I don't have IntelliSense You need to ensure that your solution is open in VS Code (not just a single file). Open the folder with your solution and you usually will not need to do anything else. If for some reason VS Code has not selected the right solution context, you can change the selected project by clicking on the OmniSharp flame icon on the status bar. Choose the -CSharp version of the solution file and VS Code will light up. How can I change the file exclusions? Unity creates a number of additional files that can clutter your workspace in VS Code. You can easily hide these so that you can focus on the files you actually want to edit. To do this, add the following JSON to your workspace settings . // Configure glob patterns for excluding files and folders. \"files.exclude\": { \"**/.git\": true, \"**/.DS_Store\": true, \"**/*.meta\": true, \"**/*.*.meta\": true, \"**/*.unity\": true, \"**/*.unityproj\": true, \"**/*.mat\": true, \"**/*.fbx\": true, \"**/*.FBX\": true, \"**/*.tga\": true, \"**/*.cubemap\": true, \"**/*.prefab\": true, \"**/Library\": true, \"**/ProjectSettings\": true, \"**/Temp\": true } As you can see below this will clean things up a lot... Before After How can I debug Unity? Install the Debugger for Unity extension. And check out Debugging with VS Code to learn more about VS Code debugging support."
  },
  "guides/vscode/preferred/additional.html": {
    "href": "guides/vscode/preferred/additional.html",
    "title": "Additionas | Fountain of Knowledge",
    "keywords": "Additionas adelonzeta.vscode-inky-snippets akamud.vscode-theme-onedark anseki.vscode-color cillroy.docs-toc CoenraadS.bracket-pair-colorizer-2 cweijan.epub-reader dbaeumer.vscode-eslint docsmsft.docs-article-templates docsmsft.docs-build docsmsft.docs-images docsmsft.docs-linting docsmsft.docs-markdown docsmsft.docs-metadata docsmsft.docs-preview docsmsft.docs-scaffolding docsmsft.docs-yaml eamodio.gitlens emmanuelbeziat.vscode-great-icons esbenp.prettier-vscode fabianlauer.vs-code-xml-format GitHub.github-vscode-theme GitHub.remotehub GitHub.vscode-pull-request-github Gruntfuggly.todo-tree hbenl.vscode-test-explorer humao.rest-client janisdd.vscode-edit-csv johnpapa.vscode-peacock justin-grote.powershell-extension-pack leveluptutorials.theme-levelup Liveecommerce.vscode-remote-workspace lonefy.vscode-JS-CSS-HTML-formatter LouisWT.regexp-preview mhutchie.git-graph miguelsolorio.fluent-icons monokai.theme-monokai-pro-vscode ms-vscode-remote.remote-containers ms-vscode-remote.remote-ssh ms-vscode-remote.remote-ssh-edit ms-vscode-remote.remote-wsl ms-vscode-remote.vscode-remote-extensionpack ms-vscode.powershell ms-vscode.powershell-preview ms-vscode.test-adapter-converter ms-vsliveshare.vsliveshare ms-vsliveshare.vsliveshare-audio ms-vsliveshare.vsliveshare-pack oderwat.indent-rainbow PKief.material-icon-theme PKief.material-product-icons Pod212.vscode-github-projects PsykoSoldi3r.vscode-git-flow rangav.vscode-thunder-client redhat.vscode-commons redhat.vscode-yaml richie5um2.vscode-sort-json ritwickdey.LiveServer rvest.vs-code-prettier-eslint slevesque.vscode-zipexplorer tobysmith568.run-in-powershell TylerLeonhardt.vscode-inline-values-powershell TylerLeonhardt.vscode-pester-test-adapter usernamehw.errorlens vscode-icons-team.vscode-icons vsls-contrib.codetour vsls-contrib.gistfs vsls-contrib.gitdoc wwm.better-align yzhang.markdown-all-in-one zhuangtongfa.material-theme"
  },
  "guides/vscode/preferred/extensions.html": {
    "href": "guides/vscode/preferred/extensions.html",
    "title": "Extensions | Fountain of Knowledge",
    "keywords": "Extensions Too many to list but see below Note See Additions for more information"
  },
  "guides/vscode/preferred/overview.html": {
    "href": "guides/vscode/preferred/overview.html",
    "title": "Overview | Fountain of Knowledge",
    "keywords": "Overview All the extensions, themes and additional settings I use"
  },
  "guides/vscode/preferred/theme.html": {
    "href": "guides/vscode/preferred/theme.html",
    "title": "Themes | Fountain of Knowledge",
    "keywords": "Themes Colour Theme GitHub Dark File Icon Theme VScode Icons Product Icon Theme Material Product Icons Note See Additions for more information"
  },
  "guides/vscode/python/coding-pack-python.html": {
    "href": "guides/vscode/python/coding-pack-python.html",
    "title": "Coding Pack for Python | Fountain of Knowledge",
    "keywords": "Coding Pack for Python The Coding Pack for Python helps you quickly set up a Python coding environment with Visual Studio Code. The standalone installer helps you install a Python interpreter, Visual Studio Code, extensions that provide support for Python in Visual Studio Code, and a number of common and useful Python packages. Getting started With the Coding Pack for Python, it's easy to get started developing with Python and VS Code. Download and run the Coding Pack for Python installer. Note : The installer only supports Windows 10 64-bit. This download is 200MB, and up to 100MB will be downloaded while you are installing. Once the installer launches, review and accept the License Agreement. Then select Install . After installation completes, select Next . Note : If you select Cancel before the installation completes, you will need to manually remove and uninstall any components that have already been installed. Launch Visual Studio Code and start coding! Note : If there are any issues installing components, you can use the steps discussed in Manual installation What's installed by the Coding Pack for Python The Coding Pack for Python installs the key components you need to use Visual Studio Code for Python development. Specifically, it installs: Visual Studio Code Visual Studio Code extensions: Python Pylance Live Share Gather The Python runtime (CPython 3.8.5) Useful Python packages jupyter numpy sklearn pandas Matplotlib Along with the tools and packages necessary for Python development, the Coding Pack also configures common user settings and PowerShell. This includes Python extension settings, such as the default interpreter and language server, as well as execution policies to allow for virtual environment activation in the terminal. Note : If there was an existing version of Visual Studio Code installed on your machine, your settings.json will not be overwritten and you'll need to configure Python settings yourself. Manual installation If you have any problems during installation, the following manual steps can be used to complete your installation. Visual Studio Code and the Python extension If there was an issue installing VS Code, you can install it from here . Once VS Code is installed, you can install the Python extension for VS Code from the Visual Studio Marketplace. For additional details about installing extensions, see Extension Marketplace . The Python extension is named Python and is published by Microsoft. Python interpreter If there was an issue installing the Python interpreter, you can install Python 3.8 from the Microsoft Store . Along with the Python extension, you need to install a Python interpreter for development with Python. There are other options for installing the Python interpreter, such as directly from Python.org , and which interpreter you use is dependent on your specific needs. If you use the Python.org version, just make sure to uncheck the \"Install launcher for all users\" box if you don't have admin access. Note : If you use the Microsoft Store installation option, be aware that some packages might not work well with this package; however, the packages listed below have been tested and work fine. For additional information about using Python on Windows, see the VS Code Python documentation and Using Python on Windows at Python.org. Verify your Python installation by opening a cmd prompt and running the following code python --version . If the installation was successful, the output window shows the version of Python that you just installed. Additional VS Code extensions Pylance language server extension Pylance is an extension that works alongside Python in Visual Studio Code to provide performant language support. Under the hood, Pylance is powered by Pyright, Microsoft's static type checking tool. Using Pyright, Pylance can supercharge your Python IntelliSense experience with rich type information, helping you write better code faster. Install the Pylance extension from the Visual Studio marketplace . Open a Python (.py) file and the Pylance extension will activate. Select Yes when prompted to make Pylance the default language server. This will update your preferences, which you can also do manually by adding \"python.languageServer\": \"Pylance\" to your settings.json file using the text editor. Gather extension The Gather extension adds the experimental Gather feature to the Python extension. With one button, you'll be able to select any notebook or Interactive Window cell and have Gather find and then copy all of the dependent code that was used to generate that cell's result into a new notebook or script. Install the Gather extension from Visual Studio marketplace . Live Share extension Visual Studio Live Share enables you to collaboratively edit and debug with others in real time, regardless of what programming languages you're using or app types you're building. It allows you to instantly share your current project, and then as needed, share debugging sessions, terminal instances, localhost web apps, voice calls, and more! For additional details, see the documentation . Download and install the Visual Studio Live Share extension from the Visual Studio marketplace. Follow the guidance in the documentation about How-to: Collaborate using Visual Studio Code Common Python packages If you need to manually install the Python packages that the Coding Pack would otherwise have installed, you can do so using the following Python commands. python -m pip install matplotlib python -m pip install pandas python -m pip install scikit-learn python -m pip install matplotlib python -m pip install jupyter Be aware that these commands will install the packages into the global environment for your interpreter, because that's where the Coding Pack would have installed them. That said, a good option to consider is adding the packages to a virtual environment. For information about virtual environments, see the topic Using Python environments in VS Code . Note : If you have problems running the Python commands above, you might need to make sure that the Python interpreter is on your PATH environment variable. Settings and configuration To help you get started quickly, the Coding Pack for Python sets a few key settings. If you need to configure them manually, you can use the following guidance. Set default interpreter Open VS Code Within VS Code, open the Command Palette (ctrl+shift+p) Select Python: Select Interpreter Select the interpreter that you installed or that was installed by the Coding Pack Set language server to pylance Install the Pylance extension and set it as the default language server as described in the section above . Enable running scripts in PowerShell Open VS Code If a terminal is not already opened, select Terminal > New Terminal from the main toolbar Once the terminal has opened, enter the following command: Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned Uninstalling the Coding Pack for Python If you need to uninstall (or repair) your Coding Pack for Python installation, you can use the following steps. Rerun the standalone installer. At the UI prompt, select Uninstall . Once you select uninstall, the following tasks will be performed: The folder with the Python interpreter and associated Python packages will be removed, including any user installed packages. The folder will be removed from the PATH environment variable. Any settings modified by the installation process will be reset. Note : The uninstall process will not remove Visual Studio Code. At the end of the uninstall process, you can click the provided link to open \"Apps & features\" to uninstall Visual Studio Code. If you decide to repair your installation, be aware that any other Python packages you might have installed will be removed as part of the repair process."
  },
  "guides/vscode/python/data-science.html": {
    "href": "guides/vscode/python/data-science.html",
    "title": "Working with Jupyter Notebooks | Fountain of Knowledge",
    "keywords": "Working with Jupyter Notebooks This page is redirected to /docs/datascience/overview.md and only exists to keep the \"Data Science\" TOC item."
  },
  "guides/vscode/python/debugging.html": {
    "href": "guides/vscode/python/debugging.html",
    "title": "Python debugging in VS Code | Fountain of Knowledge",
    "keywords": "Python debugging in VS Code The Python extension supports debugging of several types of Python applications. For a short walkthrough of basic debugging, see Tutorial - Configure and run the debugger . Also see the Flask tutorial . Both tutorials demonstrate core skills like setting breakpoints and stepping through code. For general debugging features such as inspecting variables, setting breakpoints, and other activities that aren't language-dependent, review VS Code debugging . This article addresses only those considerations that are specific to Python, mainly Python-specific debugging configurations , including the necessary steps for specific app types and remote debugging. Initialize configurations A configuration drives VS Code's behavior during a debugging session. Configurations are defined in a launch.json file that's stored in a .vscode folder in your workspace. Note To change debugging configuration, your code must be stored in a folder. To initialize debug configurations, first select the Run view in the sidebar: If you don't yet have any configurations defined, you'll see a button to Run and Debug, as well as a link to create a configuration (launch.json) file: To generate a launch.json file with Python configurations, do the following steps: Click the create a launch.json file link (circled in the image above) or use the Run > Open configurations menu command. A configuration menu will open from the Command Palette allowing you to choose the type of debug configuration you want for the opened file. For now, in the Select a debug configuration menu that appears, select Python File . Note Starting a debugging session through the Debug Panel, F5 or Run > Start Debugging , when no configuration exists will also bring up the debug configuration menu, but will not create a launch.json file. The Python extension then creates and opens a launch.json file that contains a pre-defined configuration based on what you previously selected, in this case, Python File . You can modify configurations (to add arguments, for example), and also add custom configurations. The details of configuration properties are covered later in this article under Standard configuration and options . Additional configurations are also described in this article under Debugging specific app types . Additional configurations By default, VS Code shows only the most common configurations provided by the Python extension. You can select other configurations to include in launch.json by using the Add Configuration command shown in the list and the launch.json editor. When you use the command, VS Code prompts you with a list of all available configurations (be sure to scroll down to see all the Python options): Selecting the Node.js: Gulp task yields the following result: See Debugging specific app types for details on all of these configurations. During debugging, the Status Bar shows the current configuration and the current debugging interpreter. Selecting the configuration brings up a list from which you can choose a different configuration: By default, the debugger uses the same interpreter selected for your workspace, just like other features of Python extension for VS Code. To use a different interpreter for debugging specifically, set the value for python in launch.json for the applicable debugger configuration. Alternately, select the named interpreter on the Status Bar to select a different one. Basic debugging The simplest way to begin debugging a Python file is to use the Run view and click the Run and Debug button. When no configuration has been previously set, you will be presented with a list of debugging options. Select the appropriate option to quickly begin debugging your code. Two common options are to use the Python File configuration to run the currently open Python file or to use the Attach using Process ID configuration to attach the debugger to a process that is already running. For information about creating and using debugging configurations see the Initialize configurations and Additional configurations sections. Once a configuration is added, it can be selected from the dropdown list and started using the Start Debugging button. Command line debugging The debugger can also be run from the command line. The debugger command line syntax is as follows: python -m debugpy --listen | --connect [<host>:]<port> [--wait-for-client] [--configure-<name> <value>]... [--log-to <path>] [--log-to-stderr] <filename> | -m <module> | -c <code> | --pid <pid> [<arg>]... As an example, from the command line, you could start the debugger using a specified port (5678) and script using the following syntax. This example assumes the script is long-running and omits the --wait-for-client flag, meaning that the script will not wait for the client to attach. python -m debugpy --listen 5678 ./myscript.py You would then use the following configuration to attach from the VS Code Python extension. { \"name\": \"Python: Attach\", \"type\": \"python\", \"request\": \"attach\", \"connect\": { \"host\": \"localhost\", \"port\": 5678 } } Note : Specifying host is optional for listen , by default 127.0.0.1 is used. If you wanted to debug remote code or code running in a docker container, on the remote machine or container, you would need to modify the previous CLI command to specify a host. python -m debugpy --listen 0.0.0.0:5678 ./myscript.py The associated configuration file would then look as follows. { \"name\": \"Attach\", \"type\": \"python\", \"request\": \"attach\", \"connect\": { \"host\": \"remote-machine-name\", // replace this with remote machine name \"port\": 5678 } } Note : Be aware that when you specify a host value other than 127.0.0.1 or localhost you are opening a port to allow access from any machine, which carries security risks. You should make sure that you're taking appropriate security precautions, such as using SSH tunnels, when doing remote debugging. Flag Options Description --listen or --connect [<host>:]<port> Required . Specifies the host address and port for the debug adapter server to wait for incoming connections (--listen) or to connect with a client that is waiting for an incoming connection (--connect). This is the same address that is used in the VS Code debug configuration. By default, the host address is localhost (127.0.0.1) . --wait-for-client none Optional . Specifies that the code should not run until there's a connection from the debug server. This setting allows you to debug from the first line of your code. --log-to <path> Optional . Specifies a path to an existing directory for saving logs. --log-to-stderr none Optional . Enables debugpy to write logs directly to stderr. --pid <pid> Optional . Specifies a process that is already running to inject the debug server into. --configure-<name> <value> Optional . Sets a debug property that must be known to the debug server before the client connects. Such properties can be used directly in launch configuration, but must be set in this manner for attach configurations. For example, if you don't want the debug server to automatically inject itself into subprocesses created by the process you're attaching to, use --configure-subProcess false . Note : [<arg>] can be used to pass command-line arguments along to the app being launched. Debugging by attaching over a network connection Local script debugging In some scenarios, you need to debug a Python script that's invoked locally by another process. For example, you may be debugging a web server that runs different Python scripts for specific processing jobs. In such cases, you need to attach the VS Code debugger to the script once it's been launched: Run VS Code, open the folder or workspace containing the script, and create a launch.json for that workspace if one doesn't exist already. In the script code, add the following and save the file: import debugpy # 5678 is the default attach port in the VS Code debug configurations. Unless a host and port are specified, host defaults to 127.0.0.1 debugpy.listen(5678) print(\"Waiting for debugger attach\") debugpy.wait_for_client() debugpy.breakpoint() print('break on this line') Open a terminal using Terminal: Create New Integrated Terminal , which activates the script's selected environment. In the terminal, install the debugpy package with python -m pip install --upgrade debugpy . In the terminal, start Python with the script, for example, python3 myscript.py . You should see the \"Waiting for debugger attach\" message that's included in the code, and the script halts at the debugpy.wait_for_client() call. Switch to the Run view, select the appropriate configuration from the debugger dropdown list, and start the debugger. The debugger should stop on the debugpy.breakpoint() call, from which point you can use the debugger normally. You can, of course, set other breakpoints in the script code using the UI instead of using debugpy.breakpoint() . Remote script debugging with SSH Remote debugging allows you to step through a program locally within VS Code while it runs on a remote computer. It is not necessary to install VS Code on the remote computer. For added security, you may want or need to use a secure connection, such as SSH, to the remote computer when debugging. Note : On Windows computers, you may need to install Windows 10 OpenSSH to have the ssh command. The following steps outline the general process to set up an SSH tunnel. An SSH tunnel allows you to work on your local machine as if you were working directly on the remote in a more secure manner than if a port was opened for public access. On the remote computer: Enable port forwarding by opening the sshd_config config file (found under /etc/ssh/ on Linux and under %programfiles(x86)%/openssh/etc on Windows) and adding or modifying the following setting: AllowTcpForwarding yes Note : The default for AllowTcpForwarding is yes, so you might not need to make a change. If you had to add or modify AllowTcpForwarding , restart the SSH server. On Linux/macOS, run sudo service ssh restart ; on Windows, run services.msc , locate and select OpenSSH or sshd in the list of services, and select Restart . On the local computer: Create an SSH tunnel by running ssh -2 -L sourceport:localhost:destinationport -i identityfile user@remoteaddress , using a selected port for destinationport and the appropriate username and the remote computer's IP address in user@remoteaddress . For example, to use port 5678 on IP address 1.2.3.4, the command would be ssh -2 -L 5678:localhost:5678 -i identityfile user@1.2.3.4 . You can specify the path to an identity file, using the -i flag. Verify that you can see a prompt in the SSH session. In your VS Code workspace, create a configuration for remote debugging in your launch.json file, setting the port to match the port used in the ssh command and the host to localhost . You use localhost here because you've set up the SSH tunnel. { \"name\": \"Python: Attach\", \"type\": \"python\", \"request\": \"attach\", \"port\": 5678, \"host\": \"localhost\", \"pathMappings\": [ { \"localRoot\": \"${workspaceFolder}\", // Maps C:\\Users\\user1\\project1 \"remoteRoot\": \".\" // To current working directory ~/project1 } ] } Starting debugging Now that an SSH tunnel has been set up to the remote computer, you can begin your debugging. Both computers: make sure that identical source code is available. Both computers: install debugpy using python -m pip install --upgrade debugpy into your environment (while using a form of virtual environment is not required, it is a recommended best practice). Remote computer: there are two ways to specify how to attach to the remote process. In the source code, add the following lines, replacing address with the remote computer's IP address and port number (IP address 1.2.3.4 is shown here for illustration only). import debugpy # Allow other computers to attach to debugpy at this IP address and port. debugpy.listen(('1.2.3.4', 5678)) # Pause the program until a remote debugger is attached debugpy.wait_for_client() The IP address used in listen should be the remote computer's private IP address. You can then launch the program normally, causing it to pause until the debugger attaches. Launch the remote process through debugpy, for example: python3 -m debugpy --listen 1.2.3.4:5678 --wait-for-client -m myproject This starts the package myproject using python3 , with the remote computer's private IP address of 1.2.3.4 and listening on port 5678 (you can also start the remote Python process by specifying a file path instead of using -m , such as ./hello.py ). Local computer: Only if you modified the source code on the remote computer as outlined above , then in the source code, add a commented-out copy of the same code added on the remote computer. Adding these lines makes sure that the source code on both computers matches line by line. #import debugpy # Allow other computers to attach to debugpy at this IP address and port. #debugpy.listen(('1.2.3.4', 5678)) # Pause the program until a remote debugger is attached #debugpy.wait_for_client() Local computer: switch to the Run view in VS Code, select the Python: Attach configuration Local computer: set a breakpoint in the code where you want to start debugging. Local computer: start the VS Code debugger using the modified Python: Attach configuration and the Start Debugging button. VS Code should stop on your locally set breakpoints, allowing you to step through the code, examine variables, and perform all other debugging actions. Expressions that you enter in the Debug Console are run on the remote computer as well. Text output to stdout, as from print statements, appears on both computers. Other outputs, such as graphical plots from a package like matplotlib, however, appear only on the remote computer. During remote debugging, the debugging toolbar appears as below: On this toolbar, the disconnect button ( kb(workbench.action.debug.stop) ) stops the debugger and allows the remote program to run to completion. The restart button ( kb(workbench.action.debug.restart) ) restarts the debugger on the local computer but does not restart the remote program. Use the restart button only when you've already restarted the remote program and need to reattach the debugger. Set configuration options When you first create launch.json , there are two standard configurations that run the active file in the editor in either the integrated terminal (inside VS Code) or the external terminal (outside of VS Code): { \"configurations\": [ { \"name\": \"Python: Current File (Integrated Terminal)\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${file}\", \"console\": \"integratedTerminal\" }, { \"name\": \"Python: Current File (External Terminal)\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${file}\", \"console\": \"externalTerminal\" } ] } The specific settings are described in the following sections. You can also add other settings, such as args , that aren't included in the standard configurations. Tip : It's often helpful in a project to create a configuration that runs a specific startup file. For example, if you want to always launch startup.py with the arguments --port 1593 when you start the debugger, create a configuration entry as follows: { \"name\": \"Python: startup.py\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/startup.py\", \"args\" : [\"--port\", \"1593\"] }, name Provides the name for the debug configuration that appears in the VS Code dropdown list. type Identifies the type of debugger to use; leave this set to python for Python code. request Specifies the mode in which to start debugging: launch : start the debugger on the file specified in program attach : attach the debugger to an already running process. See Remote debugging for an example. program Provides the fully qualified path to the python program's entry module (startup file). The value ${file} , often used in default configurations, uses the currently active file in the editor. By specifying a specific startup file, you can always be sure of launching your program with the same entry point regardless of which files are open. For example: \"program\": \"/Users/Me/Projects/PokemonGo-Bot/pokemongo_bot/event_handlers/__init__.py\", You can also rely on a relative path from the workspace root. For example, if the root is /Users/Me/Projects/PokemonGo-Bot then you can use the following: \"program\": \"${workspaceFolder}/pokemongo_bot/event_handlers/__init__.py\", module Provides the ability to specify the name of a module to be debugged, similarly to the -m argument when run at the command line. For more information, see Python.org python The full path that points to the Python interpreter to be used for debugging. If not specified, this setting defaults to the interpreter selected for your workspace, which is equivalent to using the value ${command:python.interpreterPath} . To use a different interpreter, specify its path instead in the python property of a debug configuration. Alternately, you can use a custom environment variable that's defined on each platform to contain the full path to the Python interpreter to use, so that no additional folder paths are needed. If you need to pass arguments to the Python interpreter, you can use the pythonArgs property. pythonArgs Specifies arguments to pass to the Python interpreter using the syntax \"pythonArgs\": [\"<arg 1>\", \"<arg 2>\",...] . args Specifies arguments to pass to the Python program. Each element of the argument string that's separated by a space should be contained within quotes, for example: \"args\": [\"--quiet\", \"--norepeat\", \"--port\", \"1593\"], stopOnEntry When set to true , breaks the debugger at the first line of the program being debugged. If omitted (the default) or set to false , the debugger runs the program to the first breakpoint. console Specifies how program output is displayed as long as the defaults for redirectOutput aren't modified. Value Where output is displayed \"internalConsole\" VS Code debug console. If redirectOutput is set to False, no output is displayed. \"integratedTerminal\" (default) VS Code Integrated Terminal . If redirectOutput is set to True, output is also displayed in the debug console. \"externalTerminal\" Separate console window . If redirectOutput is set to True, output is also displayed in the debug console. autoReload Allows for the automatic reload of the debugger when changes are made to code after the debugger execution has hit a breakpoint. To enable this feature set {\"enable\": true} as shown in the following code. { \"name\": \"Python: Current File\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${file}\", \"console\": \"integratedTerminal\", \"autoReload\": { \"enable\": true } } * Note: When the debugger performs a reload, code that runs on import might be executed again. To avoid this situation, try to only use imports, constants, and definitions in your module, placing all code into functions. Alternatively, you can also use if __name__==\"__main__\" checks. subProcess Specifies whether to enable subprocess debugging. Defaults to false , set to true to enable. For more information, see multi-target debugging . cwd Specifies the current working directory for the debugger, which is the base folder for any relative paths used in code. If omitted, defaults to ${workspaceFolder} (the folder open in VS Code). As an example, say ${workspaceFolder} contains a py_code folder containing app.py , and a data folder containing salaries.csv . If you start the debugger on py_code/app.py , then the relative paths to the data file vary depending on the value of cwd : cwd Relative path to data file Omitted or ${workspaceFolder} data/salaries.csv ${workspaceFolder}/py_code ../data/salaries.csv ${workspaceFolder}/data salaries.csv redirectOutput When set to true (the default for internalConsole), causes the debugger to print all output from the program into the VS Code debug output window. If set to false (the default for integratedTerminal and externalTerminal), program output is not displayed in the debugger output window. This option is typically disabled when using \"console\": \"integratedTerminal\" or \"console\": \"externalTerminal\" because there's no need to duplicate the output in the debug console. justMyCode When omitted or set to true (the default), restricts debugging to user-written code only. Set to false to also enable debugging of standard library functions. django When set to true , activates debugging features specific to the Django web framework. sudo When set to true and used with \"console\": \"externalTerminal\" , allows for debugging apps that require elevation. Using an external console is necessary to capture the password. pyramid When set to true , ensures that a Pyramid app is launched with the necessary pserve command . env Sets optional environment variables for the debugger process beyond system environment variables, which the debugger always inherits. The values for these variables must be entered as strings. envFile Optional path to a file that contains environment variable definitions. See Configuring Python environments - environment variable definitions file . gevent If set to true , enables debugging of gevent monkey-patched code . Breakpoints and logpoints The Python extension supports breakpoints and logpoints for debugging code. For a short walkthrough of basic debugging and using breakpoints, see Tutorial - Configure and run the debugger . Conditional breakpoints Breakpoints can also be set to trigger based on expressions, hit counts, or a combination of both. The Python extension support hit counts that are integers, as well as integers preceded by the ==, >, >=, <, <=, and % operators. For example, you could set a breakpoint to trigger after 5 occurrences by setting a hitcount of >5 For more information, see conditional breakpoints in the main VS Code debugging article. Invoking a breakpoint in code In your Python code, you can call debugpy.breakpoint() at any point where you want to pause the debugger during a debugging session. Breakpoint validation The Python extension automatically detects breakpoints that are set on non-executable lines, such as pass statements or the middle of a multiline statement. In such cases, running the debugger moves the breakpoint to the nearest valid line to ensure that code execution stops at that point. Debugging specific app types The configuration dropdown provides a variety of different options for general app types: Configuration Description Attach See Remote debugging in the previous section. Django Specifies \"program\": \"${workspaceFolder}/manage.py\" , \"args\": [\"runserver\"] . Also adds \"django\": true to enable debugging of Django HTML templates. Flask See Flask debugging below. Gevent Adds \"gevent\": true to the standard integrated terminal configuration. Pyramid Removes program , adds \"args\": [\"${workspaceFolder}/development.ini\"] , adds \"jinja\": true for enabling template debugging, and adds \"pyramid\": true to ensure that the program is launched with the necessary pserve command . Scrapy Specifies \"module\": \"scrapy\" and adds \"args\": [\"crawl\", \"specs\", \"-o\", \"bikes.json\"] . Watson Specifies \"program\": \"${workspaceFolder}/console.py\" and \"args\": [\"dev\", \"runserver\", \"--noreload=True\"] . Specific steps are also needed for remote debugging and Google App Engine. For details on debugging tests (including nosetest), see Testing . To debug an app that requires administrator privileges, use \"console\": \"externalTerminal\" and \"sudo\": \"True\" . Flask debugging { \"name\": \"Python: Flask\", \"type\": \"python\", \"request\": \"launch\", \"module\": \"flask\", \"env\": { \"FLASK_APP\": \"app.py\" }, \"args\": [ \"run\", \"--no-debugger\" ], \"jinja\": true }, As you can see, this configuration specifies \"env\": {\"FLASK_APP\": \"app.py\"} and \"args\": [\"run\", \"--no-debugger\"] . The \"module\": \"flask\" property is used instead of program . (You may see \"FLASK_APP\": \"${workspaceFolder}/app.py\" in the env property, in which case modify the configuration to refer to only the filename. Otherwise, you may see \"Cannot import module C\" errors where C is a drive letter.) The \"jinja\": true setting also enables debugging for Flask's default Jinja templating engine. If you want to run Flask's development server in development mode, use the following configuration: { \"name\": \"Python: Flask (development mode)\", \"type\": \"python\", \"request\": \"launch\", \"module\": \"flask\", \"env\": { \"FLASK_APP\": \"app.py\", \"FLASK_ENV\": \"development\" }, \"args\": [ \"run\" ], \"jinja\": true }, Troubleshooting There are many reasons why the debugger may not work. Oftentimes the debug console reveals specific causes, but two specific reasons are as follows: The path to the python executable is incorrect: check the path of your selected interpreter by running the Python: Select Interpreter command and looking at the current value: There are invalid expressions in the watch window: clear all expressions from the Watch window and restart the debugger. If you're working with a multi-threaded app that uses native thread APIs (such as the Win32 CreateThread function rather than the Python threading APIs), it's presently necessary to include the following source code at the top of whichever file you want to debug: import debugpy debugpy.debug_this_thread() Next steps Python environments - Control which Python interpreter is used for editing and debugging. Testing - Configure test environments and discover, run, and debug tests. Settings reference - Explore the full range of Python-related settings in VS Code. General debugging - Learn about the debugging features of VS Code."
  },
  "guides/vscode/python/editing.html": {
    "href": "guides/vscode/python/editing.html",
    "title": "Editing Python in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Editing Python in Visual Studio Code The Python extension provides many features for editing Python source code in Visual Studio Code: Autocomplete and IntelliSense Quick Fixes Run Selection/Line in Terminal (REPL) Formatting Refactoring Also see Linting and Jupyter Support . Autocomplete and IntelliSense Autocomplete and IntelliSense are provided for all files within the current working folder and for Python packages that are installed in standard locations. While editing, you can right-click different identifiers to take advantage of several convenient commands Go to Definition ( kb(editor.action.revealDefinition) ) jumps from your code into the code that defines an object. This command is helpful when you're working with libraries. Peek Definition ( kb(editor.action.peekDefinition) ), is similar, but displays the definition directly in the editor (making space in the editor window to avoid obscuring any code). Press kbstyle(Escape) to close the Peek window or use the x in the upper right corner. Go to Declaration jumps to the point at which the variable or other object is declared in your code. Peek Declaration is similar, but displays the declaration directly in the editor. Again, use kbstyle(Escape) or the x in the upper right corner to close the Peek window. Customize IntelliSense behavior To customize the behavior of the analysis engine, see the code analysis settings and autocomplete settings . You can also customize the general behavior of autocomplete and IntelliSense, even to disable these features entirely. See Customizing IntelliSense . Tip : Check out the IntelliCode extension for VS Code (preview) . IntelliCode provides a set of AI-assisted capabilities for IntelliSense in Python, such as inferring the most relevant auto-completions based on the current code context. For more information, see the IntelliCode for VS Code FAQ . Enable IntelliSense for custom package locations To enable IntelliSense for packages that are installed in other, non-standard locations, add those locations to the python.autoComplete.extraPaths collection in the settings file (the default collection is empty). For example, you might have installed Google App Engine installed in custom locations, specified in app.yaml if you use Flask. In this case, you'd specify those locations as follows: Windows: \"python.autoComplete.extraPaths\": [ \"C:/Program Files (x86)/Google/google_appengine\", \"C:/Program Files (x86)/Google/google_appengine/lib/flask-0.12\"] macOS/Linux: \"python.autoComplete.extraPaths\": [ \"~/.local/lib/Google/google_appengine\", \"~/.local/lib/Google/google_appengine/lib/flask-0.12\" ] The python.autoComplete.addBrackets setting (default false ) also determines whether VS Code automatically adds parentheses ( () ) when autocompleting a function name. For example, if you set addBrackets to true : \"python.autoComplete.addBrackets\": true, and then write import os followed by os.getc , you'll see autocomplete for os.getcwd . Selecting that auto-complete adds os.getcwd() to your source code and place the cursor inside the parentheses. When the setting is false, only os.getcwd is added to the file. For more on IntelliSense generally, see IntelliSense . Troubleshooting If autocomplete and IntelliSense are not working for a custom module, check the following causes: Cause Solution The path to the python interpreter is incorrect Check the pythonPath setting. Restart VS Code if you make a correction. The custom module is located in a non-standard location (not installed using pip). Add the location to the python.autoComplete.extraPaths setting and restart VS Code. Quick Fixes The add imports Quick Fix allows you to quickly complete import statements. Begin by typing a package name within the editor and you will notice a Code Action is available to automatically complete the line of source code (as long as you have the module installed within the environment). Hover over the text (marked with a squiggle) and then select the Code Action light bulb when it appears. You can then select from a list of potential imports. Note that the functionality in the below examples is provided by the Pylance language server. The add imports Code Action also recognizes some of the popular abbreviations for the following common Python packages: numpy as np, tensorflow as tf, pandas as pd, matplotlib.pyplot as plt, matplotlib , as mpl, math as m, scipi.io as spio, and scipy as sp, panel as pn, and holoviews as hv. The import suggestions list is ordered with import statements for packages (or modules) at the top, followed by statements for additional modules and/or members (classes, objects, etc.) from specified packages. Run Selection/Line in Terminal (REPL) The Python: Run Selection/Line in Python Terminal command ( kbstyle(Shift+Enter) ) is a simple way to take whatever code is selected, or the code on the current line if there is no selection, and run it in the Python Terminal. An identical Run Selection/Line in Python Terminal command is also available on the context menu for a selection in the editor. VS Code automatically removes indents based on the first non-empty line of the selection, shifting all other lines left accordingly. Source code that runs in the terminal/REPL is cumulative until the current instance of the terminal is closed. The command opens the Python Terminal if necessary; you can also open the interactive REPL environment directly using the Python: Start REPL command. (Initial startup might take a few moments especially if the first statement you run is an import .) On first use of the Python: Run Selection/Line in Python Terminal command, VS Code may send the text to the REPL before that environment is ready, in which case the selection or line is not run. If you encounter this behavior, try the command again when the REPL has finished loading. Formatting Formatting makes code easier to read by human beings by applying specific rules and conventions for line spacing, indents, spacing around operators, and so on (see an example on the autopep8 page). Formatting doesn't affect the functionality of the code itself. ( Linting , on the other hand, analyzes code for common syntactical, stylistic, and functional errors as well as unconventional programming practices that can lead to errors. Although there is a little overlap between formatting and linting, the two capabilities are complementary.) The Python extension supports source code formatting using either autopep8 (the default), black , or yapf . General formatting settings Setting (python.formatting.) Default value Description provider \"autopep8\" Specifies the formatter to use, either \"autopep8\", \"yapf\", or \"black\". Formatter-specific settings The following settings apply to the individual formatters. The Python extension looks in the current pythonPath for the formatter. To use a formatter in another location, specify that location in the appropriate custom path setting. The pip install commands may require elevation. Formatter Install steps Arguments setting (python.formatting.) Custom path setting (python.formatting.) autopep8 pip install pep8 pip install --upgrade autopep8 autopep8Args autopep8Path black (see note) pip install black blackArgs blackPath yapf pip install yapf yapfArgs yapfPath Note : By default, the Black formatter can't be installed when a Python 2 environment is active. Attempting to do so may display the message \"Formatter black is not installed. Install?\". If you try to install Black in response, another message appears saying \"Could not find a version that satisfies the requirement black' No matching distribution found for black.\" To work around this issue and use the Black formatter with Python 2, first install Black in a Python 3 environment. Then set the python.formatting.blackPath setting to that install location. When using custom arguments, each top-level element of an argument string that's separated by space on the command line must be a separate item in the args list. For example: \"python.formatting.autopep8Args\": [\"--max-line-length\", \"120\", \"--experimental\"], \"python.formatting.yapfArgs\": [\"--style\", \"{based_on_style: chromium, indent_width: 20}\"], \"python.formatting.blackArgs\": [\"--line-length\", \"100\"] In the second example, the top-level element {based_on_style: chromium, indent_width: 20} is a single value contained in braces, so the spaces within that value don't delineate a separate element. Troubleshooting If formatting fails, check the following possible causes: Cause Solution The path to the python interpreter is incorrect. Check the pythonPath setting. The formatter is not installed in the current environment. Open a command prompt, navigate to the location specified in the pythonPath setting, and run pip install for the formatter. The path to the formatter is incorrect. Check the value of the appropriate python.formatting.<formatter>Path setting. Custom arguments for the formatter are incorrect. Check that the appropriate python.formatting.<formatter>Path setting does not contain arguments, and that python.formatting.<formatter>Args contains a list of individual top-level argument elements such as \"python.formatting.yapfArgs\": [\"--style\", \"{based_on_style: chromium, indent_width: 20}\"] . Pop up with warning message Black does not support the \"Format Select\" command. black does not support formatting sections of code, it can be prevented with the following settings \"[python]\": {\"editor.formatOnPaste\": false, \"editor.formatOnSaveMode\": \"file\"} . Refactoring The Python extension adds the following refactoring commands: Extract Variable , Extract Method , and Sort Imports . Extract Variable Extracts all similar occurrences of the selected text within the current scope, and replaces it with a variable. The new method is given the name newvariableNNN where NNN is a random number. Invoked by: Context Menu: right-click a selection and select Extract Variable . Command Palette ( kb(workbench.action.showCommands) ), then Python Refactor: Extract Variable . Assign a keyboard shortcut to the python.refactorExtractVariable command. Extract Method Extracts all similar occurrences of the selected expression or block within the current scope, and replaces it with a method call. The new method is given the name newmethodNNN where NNN is a random number. Invoked by: Context Menu: right-click a selection and select Extract Method . Command Palette ( kb(workbench.action.showCommands) ), then Python Refactor: Extract Method . Assign a keyboard shortcut to the python.refactorExtractMethod command. Sort Imports Sort Imports uses the isort package to consolidate specific imports from the same module into a single import statement and to organize import statements in alphabetical order. Invoked by: Right-click in editor and select Sort Imports (no selection is required) Command Palette ( kb(workbench.action.showCommands) ), then Python Refactor: Sort Imports Assign a keyboard shortcut to the python.sortImports command Custom arguments to isort are specified in the python.sortImports.args setting, where each top-level element, as separated by spaces on the command line, is a separate item in the array: \"python.sortImports.args\": [\"-rc\", \"--atomic\"], To use a custom isort script, use the python.sortImports.path setting to specify the path. Further configurations can be stored in an .isort.cfg file as documented on isort configuration . Note : For those migrating from isort4 to isort5, some CLI flags and config options have changed, refer to the project's isort5 upgrade guide . Next steps Linting - Enable, configure, and apply a variety of Python linters. Debugging - Learn to debug Python both locally and remotely. Testing - Configure test environments and discover, run, and debug tests. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. IntelliSense - Learn about IntelliSense features."
  },
  "guides/vscode/python/environments.html": {
    "href": "guides/vscode/python/environments.html",
    "title": "Using Python environments in VS Code | Fountain of Knowledge",
    "keywords": "Using Python environments in VS Code This article discusses the helpful features provided by the VS Code Python extension for working with Python environments. An \"environment\" in Python is the context in which a Python program runs and consists of an interpreter and any number of installed packages. After you finish this article, you'll have a good understanding of: General environment concepts How to select an environment How to create a virtual or conda environment How to select and activate a virtual environment How to work with Environments and Terminal windows Where the Python extension looks for environments Environment variables and environment variable definitions files (.env) While this article provides some information about Python environments and their concepts, it is primarily for understanding how to work with them within VS Code. If you're new to working with Python environments, you can learn more at Virtual Environments and Packages (Python.org) and Installing Python Modules (Python.org) . Note : If you're looking to get started with Python in Visual Studio Code, refer to the tutorial Getting Started with Python in VS Code . The Python tutorial (Python.org) might also be helpful if you're new to the Python language. Global and virtual environments By default, any Python interpreter that you've installed runs in its own global environment , which is not specific to any one project. For example, if you just run python (Windows) or python3 (macOS/Linux) at a new command prompt, you're running in that interpreter's global environment. Accordingly, any packages that you install or uninstall affect the global environment and all programs that you run within that context. Although working in the global environment is an easy way to get started, that environment will, over time, become cluttered with many different packages that you've installed for different projects. Such clutter makes it difficult to thoroughly test an application against a specific set of packages with known versions, which is exactly the kind of environment you'd set up on a build server or web server. For this reason, developers often create a virtual environment for a project. A virtual environment is a subfolder in a project that contains a copy of a specific interpreter. When you activate the virtual environment, any packages you install are installed only in that environment's subfolder. When you then run a Python program within that environment, you know that it's running against only those specific packages. Be aware that if you're not using a virtual environment , and you have multiple versions of Python installed and set in the path environment variable, you might need to specify the Python interpreter to use in the terminal for installing packages to the global environment. Note : While it's possible to open a virtual environment folder as a workspace, doing so is not recommended and might cause issues with using the Python extension. Conda environments A conda environment is a Python environment that's managed using the conda package manager (see Getting started with conda (conda.io)). Conda works well to create environments with interrelated dependencies as well as binary packages. Unlike virtual environments, which are scoped to a project, conda environments are available globally on any given computer. This availability makes it easy to configure several distinct conda environments and then choose the appropriate one for any given project. Where the extension looks for environments The extension automatically looks for interpreters in the following locations: Standard install paths such as /usr/local/bin , /usr/sbin , /sbin , c:\\\\python27 , c:\\\\python36 , etc. Virtual environments located directly under the workspace (project) folder. Virtual environments located in the folder identified by the python.venvPath setting (see General settings ), which can contain multiple virtual environments. The extension looks for virtual environments in the first-level subfolders of venvPath . Virtual environments located in a ~/.virtualenvs folder for virtualenvwrapper . Interpreters installed by pyenv , Pipenv , and Poetry . Virtual environments located in the path identified by WORKON_HOME (as used by virtualenvwrapper ). Conda environments that contain a Python interpreter. VS Code does not show conda environments that don't contain an interpreter. Interpreters installed in a .direnv folder for direnv under the workspace (project) folder. You can also manually specify an interpreter if Visual Studio Code does not locate it automatically. Note : Once the \"select interpreter\" flow is triggered, pipenv environments for the workspace folder will be searched for. If one is found, then no other interpreters are searched for or listed as pipenv expects to manage all aspects. The extension also loads an environment variable definitions file identified by the python.envFile setting. The default value of this setting is ${workspaceFolder}/.env . Work with environments Create a virtual environment To create a virtual environment, use the following command, where \".venv\" is the name of the environment folder: # macOS/Linux # You may need to run sudo apt-get install python3-venv first python3 -m venv .venv # Windows # You can also use py -3 -m venv .venv python -m venv .venv Note : To learn more about the venv module, see Creation of virtual environments on Python.org. When you create a new virtual environment, a prompt will be displayed to allow you to select it for the workspace. This will add the path to the Python interpreter from the new virtual environment to your workspace settings. That environment will then be used when installing packages and running code through the Python extension. For examples of using virtual environment in projects, see the Python , Django , and Flask tutorials. Tip : When you're ready to deploy the application to other computers, you can create a requirements.txt file with the command pip freeze > requirements.txt ( pip3 on macOS/Linux). The requirements file describes the packages you've installed in your virtual environment. With only this file, you or other developers can restore those packages using pip install -r requirements.txt (or, again, pip3 on macOS/Linux). By using a requirements file, you need not commit the virtual environment itself to source control. Create a conda environment The Python extension automatically detects existing conda environments provided that the environment contains a Python interpreter. For example, the following command creates a conda environment with the Python 3.4 interpreter and several libraries, which VS Code then shows in the list of available interpreters: conda create -n env-01 python=3.4 scipy=0.15.0 astroid babel In contrast, if you fail to specify an interpreter, as with conda create --name env-00 , the environment won't appear in the list. For more information on the conda command line, see Conda environments (conda.io). Additional notes: If you create a new conda environment while VS Code is running, use the Reload Window command to refresh the environment list shown with Python: Select Interpreter ; otherwise you may not see the environment there. It might take a short time to appear; if you don't see it at first, wait 15 seconds then try using the command again. To ensure the environment is set up well from a shell perspective, one option is to use an Anaconda prompt with the activated environment to launch VS Code using the code . command. At that point you just need to select the interpreter using the Command Palette or by clicking on the status bar. Although the Python extension for VS Code doesn't currently have direct integration with conda environment.yml files, VS Code itself is a great YAML editor. Conda environments can't be automatically activated in the VS Code Integrated Terminal if the default shell is set to PowerShell. To change the shell, see Integrated terminal - Configuration . You can manually specify the path to the conda executable to use for activation (version 4.4+). To do so, open the Command Palette ( kb(workbench.action.showCommands) ) and enter Preferences: Open User Settings . Then set python.condaPath , which is in the Python extension section of User Settings, with the appropriate path. Select and activate an environment By default, the Python extension looks for and uses the first Python interpreter it finds in the system path. To select a specific environment, use the Python: Select Interpreter command from the Command Palette ( kb(workbench.action.showCommands) ). Note : If the Python extension doesn't find an interpreter, it issues a warning. On macOS, the extension also issues a warning if you're using the OS-installed Python interpreter, because you typically want to use an interpreter you install directly. In either case, you can disable these warnings by setting python.disableInstallationCheck to true in your user settings . You can switch environments at any time; switching environments helps you test different parts of your project with different interpreters or library versions as needed. The Python: Select Interpreter command displays a list of available global environments, conda environments, and virtual environments. (See the Where the extension looks for environments section for details, including the distinctions between these types of environments.) The following image, for example, shows several Anaconda and CPython installations along with a conda environment and a virtual environment ( env ) that's located within the workspace folder: Note: On Windows, it can take a little time for VS Code to detect available conda environments. During that process, you may see \"(cached)\" before the path to an environment. The label indicates that VS Code is presently working with cached information for that environment. If you have a folder or a workspace open in VS Code and you select an interpreter from the list, the Python extension will store that information internally so that the same interpreter will be used once you reopen the workspace. The Python extension uses the selected environment for running Python code (using the Python: Run Python File in Terminal command), providing language services (auto-complete, syntax checking, linting, formatting, etc.) when you have a .py file open in the editor, and opening a terminal with the Terminal: Create New Integrated Terminal command. In the latter case, VS Code automatically activated the selected environment. Tip : To prevent automatic activation of a selected environment, add \"python.terminal.activateEnvironment\": false to your settings.json file (it can be placed anywhere as a sibling to the existing settings). Tip : If the activate command generates the message \"Activate.ps1 is not digitally signed. You cannot run this script on the current system.\", then you need to temporarily change the PowerShell execution policy to allow scripts to run (see About Execution Policies in the PowerShell documentation): Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process Note : By default, VS Code uses the interpreter selected for your workspace when debugging code. You can override this behavior by specifying a different path in the python property of a debug configuration. See Choose a debugging environment . The Status Bar always shows the current interpreter. The Status Bar also reflects when no interpreter is selected. In either case, clicking this area of the Status Bar is a convenient shortcut for the Python: Select Interpreter command. Tip : If you have any problems with VS Code recognizing a virtual environment, please file an issue in the extension repository so we can help determine the cause. Manually specify an interpreter If VS Code does not automatically locate an interpreter you want to use, you can browse for the interpreter on your file system or provide the path to it manually. You can do so by running the Python: Select Interpreter command and clicking on the Enter interpreter path... option that shows on the top of the interpreters list: You can then either enter the full path of the Python interpreter directly in the text box (for example, \".venv/Scripts/python.exe\"), or you can click on the Find... button and browse your file system to find the python executable you wish to select. If you want to manually specify a default interpreter that will be used once you first open your workspace, you can create or modify an entry for python.defaultInterpreterPath setting in your workspace settings.json with the full path to the Python executable. For example: Windows: { \"python.defaultInterpreterPath\": \"c:/python39/python.exe\", } macOS/Linux: { \"python.defaultInterpreterPath\": \"/home/python39/python\", } You can also use python.defaultInterpreterPath to point to a virtual environment, for example: Windows: { \"python.defaultInterpreterPath\": \"c:/dev/ala/venv/Scripts/python.exe\", } macOS/Linux: { \"python.defaultInterpreterPath\": \"/home/abc/dev/ala/venv/bin/python\", } Note : Changes to the python.defaultInterpreterPath setting are not picked up after an interpreter has already been selected for a workspace; any changes to the setting will be ignored once an initial interpreter is selected for the workspace. Additionally, if you'd like to set up a default interpreter to all of your Python applications, you can add an entry for python.defaultInterpreterPath manually inside your User Settings. To do so, open the Command Palette ( kb(workbench.action.showCommands) ) and enter Preferences: Open User Settings . Then set python.defaultInterpreterPath , which is in the Python extension section of User Settings, with the appropriate interpreter. You can also use an environment variable in the path setting using the syntax ${env:VARIABLE} . For example, if you've created a variable named PYTHON_INSTALL_LOC with a path to an interpreter, you can then use the following setting value: \"python.defaultInterpreterPath\": \"${env:PYTHON_INSTALL_LOC}\", Note : Variable substitution is only supported in VS Code settings files, it will not work in .env environment files. By using an environment variable, you can easily transfer a project between operating systems where the paths are different, just be sure to set the environment variable on the operating system first. Environments and Terminal windows After using Python: Select Interpreter , that interpreter is applied when right-clicking a file and selecting Python: Run Python File in Terminal . The environment is also activated automatically when you use the Terminal: Create New Integrated Terminal command unless you change the python.terminal.activateEnvironment setting to false . However, launching VS Code from a shell in which a certain Python environment is activated does not automatically activate that environment in the default Integrated Terminal. Use the Terminal: Create New Integrated Terminal command after VS Code is running. Note: conda environments cannot be automatically activated in the integrated terminal if PowerShell is set as the integrated shell. See Integrated terminal - Configuration for how to change the shell. Any changes you make to an activated environment within the terminal are persistent. For example, using conda install <package> from the terminal with a conda environment activated installs the package into that environment permanently. Similarly, using pip install in a terminal with a virtual environment activated adds the package to that environment. Changing interpreters with the Python: Select Interpreter command doesn't affect terminal panels that are already open. You can thus activate separate environments in a split terminal: select the first interpreter, create a terminal for it, select a different interpreter, then use the split button ( kb(workbench.action.terminal.split) ) in the terminal title bar. Choose a debugging environment By default, the debugger will use the Python interpreter you have selected with the Python extension. However, if you have a python property in the debug configuration of launch.json , that interpreter is used instead. To be more specific, VS Code will give precedence to the python property of the selected debug configuration in launch.json . If it's not defined, then it will use the path to the Python interpreter you have selected for your workspace. For more details on debug configuration, see Debugging configurations . Environment variables Environment variable definitions file An environment variable definitions file is a simple text file containing key-value pairs in the form of environment_variable=value , with # used for comments. Multiline values are not supported, but values can refer to any other environment variable that's already defined in the system or earlier in the file. For more information, see Variable substitution . Environment variable definitions files can be used for scenarios such as debugging and tool execution (including linters, formatters, IntelliSense, and testing tools), but are not applied to the terminal. By default, the Python extension looks for and loads a file named .env in the current workspace folder, then applies those definitions. The file is identified by the default entry \"python.envFile\": \"${workspaceFolder}/.env\" in your user settings (see General settings ). You can change the python.envFile setting at any time to use a different definitions file. A debug configuration also contains an envFile property that also defaults to the .env file in the current workspace (see Debugging - Set configuration options ). This property allows you to easily set variables for debugging purposes that replace variables specified in the default .env file. For example, when developing a web application, you might want to easily switch between development and production servers. Instead of coding the different URLs and other settings into your application directly, you could use separate definitions files for each. For example: dev.env file # dev.env - development configuration # API endpoint MYPROJECT_APIENDPOINT=https://my.domain.com/api/dev/ # Variables for the database MYPROJECT_DBURL=https://my.domain.com/db/dev MYPROJECT_DBUSER=devadmin MYPROJECT_DBPASSWORD=!dfka**213= prod.env file # prod.env - production configuration # API endpoint MYPROJECT_APIENDPOINT=https://my.domain.com/api/ # Variables for the database MYPROJECT_DBURL=https://my.domain.com/db/ MYPROJECT_DBUSER=coreuser MYPROJECT_DBPASSWORD=kKKfa98*11@ You can then set the python.envFile setting to ${workspaceFolder}/prod.env , then set the envFile property in the debug configuration to ${workspaceFolder}/dev.env . Note : When environment variables are specified using multiple methods, be aware that there is an order of precedence. Environment variables contained in the .env file specified by the python.envFile setting (user or workspace) will override variables defined in the envFile specified in launch.json , as well as any env variables defined in the launch.json file itself. Similarly, environment variables defined in the envFile specified in launch.json will override env variables defined in the launch.json file. Variable substitution When defining an environment variable in a definitions file, you can use the value of any existing environment variable with the following general syntax: <VARIABLE>=...${env:EXISTING_VARIABLE}... where ... means any other text as used in the value. The curly braces are required. Within this syntax, the following rules apply: Variables are processed in the order they appear in the .env file, so you can use any variable that's defined earlier in the file. Single or double quotes don't affect substituted value and are included in the defined value. For example, if the value of VAR1 is abcedfg , then VAR2='${env:VAR1}' assigns the value 'abcedfg' to VAR2 . The $ character can be escaped with a backslash, as in \\$ . You can use recursive substitution, such as PYTHONPATH=${env:PROJ_DIR}:${env:PYTHONPATH} (where PROJ_DIR is any other environment variable). You can use only simple substitution; nesting such as ${_${env:VAR1}_EX} is not supported. Entries with unsupported syntax are left as-is. Use of the PYTHONPATH variable The PYTHONPATH environment variable specifies additional locations where the Python interpreter should look for modules. In VS Code, PYTHONPATH can be set through the terminal settings (terminal.integrated.env.*) and/or within an .env file. When the terminal settings are used, PYTHONPATH affects any tools that are run within the terminal by a user, as well as any action the extension performs for a user that is routed through the terminal such as debugging. However, in this case when the extension is performing an action that isn't routed through the terminal, such as the use of a linter or formatter, then this setting will not have an effect on module look-up. When PYTHONPATH is set using an .env file, it will affect anything the extension does on your behalf and actions performed by the debugger, but it will not affect tools run in the terminal. If needed, you can set PYTHONPATH using both methods. An example of when to use PYTHONPATH would be if you have source code in a src folder and tests in a tests folder. When running tests, however, those tests can't normally access modules in src unless you hard-code relative paths. To solve this problem, you could add the path to src to PYTHONPATH by creating an .env file within your VS Code workspace. PYTHONPATH=src Then set python.envFile in your settings.json file to point to the .env file you just created. For example, if the .env file was in your workspace root, your settings.json would be set as shown: \"python.envFile\": \"${workspaceFolder}/.env\" The value of PYTHONPATH can contain multiple locations separated by os.pathsep : a semicolon ( ; ) on Windows and a colon ( : ) on Linux/macOS. Invalid paths are ignored. If you find that your value for PYTHONPATH isn't working as expected, make sure that you're using the correct separator between locations for the operating system. For example, using a colon to separate locations on Windows, or using a semicolon to separate locations on Linux/macOS results in an invalid value for PYTHONPATH, which is ignored. Note : PYTHONPATH does not specify a path to a Python interpreter itself. For additional information about PYTHONPATH, read the PYTHONPATH documentation . Next steps Editing code - Learn about autocomplete, IntelliSense, formatting, and refactoring for Python. Debugging - Learn to debug Python both locally and remotely. Testing - Configure test environments and discover, run, and debug tests. Settings reference - Explore the full range of Python-related settings in VS Code."
  },
  "guides/vscode/python/jupyter-support-py.html": {
    "href": "guides/vscode/python/jupyter-support-py.html",
    "title": "Python Interactive window | Fountain of Knowledge",
    "keywords": "Python Interactive window Jupyter (formerly IPython Notebook) is an open-source project that lets you easily combine Markdown text and executable Python source code on one canvas called a notebook . Visual Studio Code supports working with Jupyter Notebooks natively , as well as through Python code files. This topic covers the support offered through Python code files and demonstrates how to: Work with Jupyter-like code cells Run code in the Python Interactive Window View, inspect, and filter variables using the Variables Explorer and Data Viewer Connect to a remote Jupyter server Debug a Jupyter notebook Export a Jupyter notebook To work with Jupyter notebooks, you must activate an Anaconda environment in VS Code, or another Python environment in which you've installed the Jupyter package . To select an environment, use the Python: Select Interpreter command from the Command Palette ( kb(workbench.action.showCommands) ). Once the appropriate environment is activated, you can create and run Jupyter-like code cells, connect to a remote Jupyter server for running code cells, and export Python files as Jupyter notebooks. Jupyter code cells You define Jupyter-like code cells within Python code using a # %% comment: # %% msg = \"Hello World\" print(msg) # %% msg = \"Hello again\" print(msg) Note : Make sure to save the code shown above in a file with a .py extension. When the Python extension detects a code cell, it adds Run Cell and Debug Cell CodeLens adornments. The first cell also includes Run Below and all subsequent cells include Run Above : Note: By default, Debug Cell just steps into user code. If you want to step into non-user code, you need to uncheck Data Science: Debug Just My Code in the Python extension settings ( kb(workbench.action.openSettings) ). Run Cell applies to only the one code cell. Run Below , which appears on the first cell, runs all the code in the file. Run Above applies to all the code cells up to, but not including, the cell with the adornment. You would use Run Above , for example, to initialize the state of the runtime environment before running that specific cell. Selecting a command starts Jupyter (if necessary, which might take a minute), then runs the appropriate cell(s) in the Python Interactive window: You can also run code cells using ( kbstyle(Ctrl+Enter) ) or the Python: Run Selection/Line in Python Terminal command ( kbstyle(Shift+Enter) ). After using this command, the Python extension automatically moves the cursor to the next cell. If you're in the last cell in the file, the extension automatically inserts another # %% delimiter for a new cell, mimicking the behavior of a Jupyter notebook. You can also click in the margin to the left of line numbers to set breakpoints. Then you can use Debug Cell to start a debugging session for that code cell. The debugger stops execution at breakpoints and allows you to step through code one line at a time and inspect variables (see Debugging for details). Additional commands and keyboard shortcuts The following table lists additional commands and keyboard shortcuts supported when working with code cells. Command Keyboard shortcut Python: Go to Next Cell kbstyle(Ctrl+Alt+]) Python: Go to Previous Cell kbstyle(Ctrl+Alt+[) Python: Extend Selection by Cell Above kbstyle(Ctrl+Shift+Alt+[) Python: Extend Selection by Cell Below kbstyle(Ctrl+Shift+Alt+]) Python: Move Selected Cells Up kbstyle(Ctrl+; U) Python: Move Selected Cells Down kbstyle(Ctrl+; D) Python: Insert Cell Above kbstyle(Ctrl+; A) Python: Insert Cell Below kbstyle(Ctrl+; B) Python: Insert Cell Below Position kbstyle(Ctrl+; S) Python: Delete Selected Cells kbstyle(Ctrl+; X) Python: Change Cell to Code kbstyle(Ctrl+; C) Python: Change Cell to Markdown kbstyle(Ctrl+; M) Python Interactive window The Python Interactive window, mentioned in the previous section, can be used as a standalone console with arbitrary code (with or without code cells). To use the window as a console, open it with the Jupyter: Create Interactive Window command from the Command Palette. You can then type in code, using kbstyle(Enter) to go to a new line and kbstyle(Shift+Enter) to run the code. To use the window with a file, use the Jupyter: Run Current File in Python Interactive Window command from the Command Palette. IntelliSense The Python Interactive window has full IntelliSense – code completions, member lists, quick info for methods, and parameter hints. You can be just as productive typing in the Python Interactive window as you are in the code editor. Plot Viewer The Plot Viewer gives you the ability to work more deeply with your plots. In the viewer you can pan, zoom, and navigate plots in the current session. You can also export plots to PDF, SVG, and PNG formats. Within the Python Interactive window, double-click any plot to open it in the viewer, or select the expand button on the upper left corner of the plot. <!-- ``` #%% import matplotlib.pyplot as plt #%% cat = [\"bored\", \"happy\", \"bored\"] dog = [\"happy\", \"bored\", \"happy\"] activity = [\"combing\", \"drinking\", \"feeding\"] fig = ax = plt.subplot() ax.plot(activity, dog, label=\"dog\") ax.plot(activity, cat, label=\"cat\") ax.legend() plt.show() ``` --> Note: The Python Interactive window supports rendering plots created with matplotlib and Altair . <!-- ### Live Share for Python Interactive The Python Interactive window also supports [Visual Studio Live Share](https://visualstudio.microsoft.com/services/live-share/) for real-time collaboration. Live Share lets you co-edit and co-debug while sharing audio, servers, terminals, diffs, comments, and more. ![Live Share for the Python Interactive window](images/jupyter/live-share-and-interactive.gif) This feature requires the [Live Share extensions](https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare-pack) to be installed on both host and guest machines. --> Variables Explorer and Data Viewer Within the Python Interactive window, it's possible to view, inspect, and filter the variables within your current Jupyter session. Select the Variables button in the interactive window toolbar to open the Variables explorer after running code and cells, you'll see a list of the current variables, which will automatically update as variables are used in code. For additional information about your variables, you can also double-click on a row or use the Show variable in data viewer button to see a more detailed view of a variable in the Data Viewer. Once open, you can filter the values by searching over the rows. Connect to a remote Jupyter server You can offload intensive computation in a Jupyter notebook to other computers by connecting to a remote Jupyter server. Once connected, code cells run on the remote server rather than the local computer. To connect to a remote Jupyter server: Run the Jupyter: Specify local or remote Jupyter server for connections command from the Command Palette ( kb(workbench.action.showCommands) ). Select how you would like to connect to a Jupyter server. If working remotely, provide the server's URI (hostname) with the authentication token included with a ?token= URL parameter when prompted. (If you start the server in the VS Code terminal with an authentication token enabled, the URL with the token typically appears in the terminal output from where you can copy it.) Alternatively, you can specify a username and password after providing the URI. The Python Interactive window indicates where code is run by displaying the URI (which is blurred out in the image below): Note: For added security, Microsoft recommends configuring your Jupyter server with security precautions such as SSL and token support. This helps ensure that requests sent to the Jupyter server are authenticated and connections to the remote server are encrypted. For guidance about securing a notebook server, see the Jupyter docs . Convert Jupyter notebooks to Python code file When you've activated an environment with Jupyter installed, you can open a Jupyter notebook file ( .ipynb ) in VS Code and then convert it to Python code. Once you've converted the file, you can run the code as you would with any other Python file and also use the VS Code debugger. Opening and debugging notebooks in VS Code is a convenient way to find and resolve code bugs, which is difficult to do directly in a Jupyter notebook. When you open a notebook file, Visual Studio Code will open it in the Notebook Editor automatically. Use the convert icon on the toolbar to convert the Notebook (.ipynb) file to a Python file (.py). Select the convert icon followed by \"Python Script\", wait a few seconds, and then VS Code opens the converted notebook in an untitled file. The notebook's cells are delimited in the Python file with # %% comments; Markdown cells are converted wholly to comments preceded with # %% [markdown] , and render as HTML in the interactive window alongside code and output such as graphs: Note: The first time you run code cells in a Python file, the Python extension starts a Jupyter server. It may take some time for the server to start up and for the Python Interactive window to appear with the results of the code. Debug a Jupyter notebook The Visual Studio Code debugger lets you step through your code, set breakpoints, examine state, and analyze problems. Using the debugger is a helpful way to find and correct issues in notebook code. In VS Code, activate a Python environment in which Jupyter is installed, as described at the beginning of this article. Import the notebook's .ipynb file into VS Code as described in the previous section. (Download the file first if you're using a cloud-based Jupyter environment such as Azure Notebooks .) To start the debugger, use one of the following options: For the whole notebook, open the Command Palette ( kb(workbench.action.showCommands) ) and run the Jupyter: Debug Current File in Python Interactive Window command. For an individual cell, use the Debug Cell adornment that appears above the cell. The debugger specifically starts on the code in that cell. By default, Debug Cell just steps into user code. If you want to step into non-user code, you need to uncheck Data Science: Debug Just My Code in the Python extension settings ( kb(workbench.action.openSettings) ). To familiarize yourself with the general debugging features of VS Code, such as inspecting variables, setting breakpoints, and other activities, review VS Code debugging . As you find issues, stop the debugger, correct your code, save the file, and start the debugger again. When you're satisfied that all your code is correct. Save the file, then export the notebook as described in the following section. You can then upload the notebook to your normal Jupyter environment. Export a Jupyter notebook In addition to opening a Jupyter notebook, you can also use one of the following commands from the Command Palette ( kb(workbench.action.showCommands) ) to export content from a Python file in VS Code to a Jupyter notebook (with the .ipynb extension). Jupyter: Export Current Python File as Jupyter Notebook : creates a Jupyter notebook from the contents of the current file, using the # %% and # %% [markdown] delimiters to specify their respective cell types. Jupyter: Export Current Python File and Output as Jupyter Notebook : creates a Jupyter notebook from the contents of the current file and includes output from code cells. Jupyter: Export Interactive Window as Jupyter Notebook : creates a Jupyter notebook from the contents of the Python Interactive window. After exporting the contents, VS Code displays a prompt through which you can open the notebook in a browser."
  },
  "guides/vscode/python/linting.html": {
    "href": "guides/vscode/python/linting.html",
    "title": "Linting Python in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Linting Python in Visual Studio Code Linting highlights syntactical and stylistic problems in your Python source code, which oftentimes helps you identify and correct subtle programming errors or unconventional coding practices that can lead to errors. For example, linting detects use of an uninitialized or undefined variable, calls to undefined functions, missing parentheses, and even more subtle issues such as attempting to redefine built-in types or functions. Linting is thus distinct from Formatting because linting analyzes how the code runs and detects errors whereas formatting only restructures how code appears . By default, stylistic and syntactical code detection is enabled by the Language Server. If you require third-party linters for additional problem detection, however, you can enable them by using the Python: Select Linter command and selecting the appropriate linter. You can easily enable and disable all linting by using the Python: Enable Linting command. Enable linters To enable linters other than the default PyLint, open the Command Palette ( kb(workbench.action.showCommands) ) and select the Python: Select Linter command. This command adds \"python.linting.<linter>Enabled\": true to your settings, where <linter> is the name of the chosen linter. See Specific linters for details. Enabling a linter prompts you to install the required packages in your selected environment for the chosen linter. Note : If you're using a global environment and VS Code is not running elevated, linter installation may fail. In that case, either run VS Code elevated, or manually run the Python package manager to install the linter at an elevated command prompt for the same environment: for example sudo pip3 install pylint (macOS/Linux) or pip install pylint (Windows, at an elevated prompt) Disable linting You can disable all Python linting with the Python: Enable Linting command, which shows a dropdown with the current linting state and options to turn Python linting on or off . Run linting To perform linting: Linting runs automatically when you save a file. Open the Command Palette ( kb(workbench.action.showCommands) ), then enter and select Python: Run Linting . Issues are shown in the Problems panel and as underlines in the code editor. Hovering over an underlined issue displays the details: General linting settings The remainder of this article describes settings for linting in general as well as specific linters. You can add any of the settings to your user settings.json file (opened with the File > Preferences > Settings command kb(workbench.action.openSettings) ). Refer to User and Workspace settings to find out more about working with settings in VS Code generally. To change the linting behavior across all enabled linters, modify the following settings: Feature Setting (python.linting.) Default value Linting in general enabled true Linting on file save lintOnSave true Maximum number of linting messages maxNumberOfProblems 100 Exclude file and folder patterns ignorePatterns [\".vscode/*.py\", \"**/site-packages/**/*.py\"] You can easily change python.linting.enabled by using the Python: Enable Linting command. When enabling lintOnSave , you might also want to enable the generic files.autoSave option (see Save / Auto Save ). The combination provides frequent linting feedback in your code as you type. Specific linters The following table provides a summary of available Python linters and their basic settings. Only Pylint is enabled by default. For descriptions of individual settings, see the Linter settings reference . Linter Package name for pip install command Default state True/false enable setting (python.linting.) Arguments setting (python.linting.) Custom path setting (python.linting.) Pylint (default) pylint Enabled pylintEnabled pylintArgs pylintPath Flake8 flake8 Disabled flake8Enabled flake8Args flake8Path mypy mypy Disabled mypyEnabled mypyArgs mypyPath pydocstyle pydocstyle Disabled pydocstyleEnabled pydocstyleArgs pydocstylePath pycodestyle (pep8) pycodestyle Disabled pycodestyleEnabled pycodestyleArgs pycodestylePath prospector prospector Disabled prospectorEnabled prospectorArgs prospectorPath pylama pylama Disabled pylamaEnabled pylamaArgs pylamaPath bandit bandit Disabled banditEnabled banditArgs banditPath To select a different linter, use the Python: Select Linter command. You can also edit your settings manually to enable multiple linters. Note, however, that using the Select Linter command overwrites those edits. Custom arguments are specified in the appropriate arguments setting for each linter. Each top-level element of an argument string that's separated by a space on the command line must be a separate item in the args list. For example: \"python.linting.pylintArgs\": [\"--reports\", \"12\", \"--disable\", \"I0011\"], \"python.linting.flake8Args\": [\"--ignore=E24,W504\", \"--verbose\"] \"python.linting.pydocstyleArgs\": [\"--ignore=D400\", \"--ignore=D4\"] Note that if a top-level element is a single value, as delineated by quotation marks or braces, it still appears as a single item in the list even if the value itself contains spaces. A custom path is generally unnecessary as the Python extension resolves the path to the linter based on the Python interpreter being used (see Environments ). To use a different version of a linter, specify its path in the appropriate custom path setting. For example, if your selected interpreter is a virtual environment but you want to use a linter that's installed in a global environment, then set the appropriate path setting to point to the global environment's linter. The sections that follow provide additional details for those individual linters linked in the table. In general, custom rules must be specified in a separate file as required by the linter you're using. Pylint Pylint messages fall into the categories in the following table with the indicated mapping to VS Code categories. You can change the setting to change the mapping. Pylint category Description VS Code category mapping Applicable setting (python.linting.) Convention (C) Programming standard violation Information (green underline) pylintCategorySeverity.convention Refactor (R) Bad code smell Hint (light bulbs) pylintCategorySeverity.refactor Warning (W) Python-specific problems Warning pylintCategorySeverity.warning Error (E) Likely code bugs Error (red underline) pylintCategorySeverity.error Fatal (F) An error prevented further Pylint processing Error pylintCategorySeverity.fatal Default Pylint rules Python in Visual Studio code is configured by default to use a set of linting rules that are friendly to the largest number of Python developers: Enable all Error (E) and Fatal (F) messages. Disable all Convention (C) and Refactor (R) messages. Disable all Warning (W) messages except the following: unreachable (W0101): Unreachable code duplicate-key (W0109): Duplicate key %r in dictionary unnecessary-semicolon (W0301): Unnecessary semicolon global-variable-not-assigned (W0602): Using global for %r but no assignment is done unused-variable (W0612): Unused variable %r binary-op-exception (W0711): Exception to catch is the result of a binary \"%s\" operation bad-format-string (W1302): Invalid format string anomalous-backslash-in-string (W1401): Anomalous backslash in string bad-open-mode (W1501): \"%s\" is not a valid mode for open These rules are applied through the following default arguments passed to Pylint: --disable=all --enable=F,E,unreachable,duplicate-key,unnecessary-semicolon,global-variable-not-assigned,unused-variable,binary-op-exception,bad-format-string,anomalous-backslash-in-string,bad-open-mode These arguments are passed whenever the python.linting.pylintUseMinimalCheckers is set to true (the default). If you specify a value in pylintArgs or use a Pylint configuration file (see the next section), then pylintUseMinimalCheckers is implicitly set to false . For the complete list of Pylint messages, see readable-pylint-messages (GitHub). Command-line arguments and configuration files See Pylint command-line arguments for general switches. Command-line arguments can be used to load Pylint plugins, such as the plugin for Django: \"python.linting.pylintArgs\": [\"--load-plugins\", \"pylint_django\"] Options can also be specified in a pylintrc or .pylintrc options file in the workspace folder, as described on Pylint command line arguments . To control which Pylint messages are shown, add the following contents to an options file: [MESSAGES CONTROL] # Enable the message, report, category or checker with the given id(s). You can # either give multiple identifier separated by comma (,) or put this option # multiple time. #enable= # Disable the message, report, category or checker with the given id(s). You # can either give multiple identifier separated by comma (,) or put this option # multiple time (only on the command line, not in the configuration file where # it should appear only once). #disable= You can easily generate an options file using Pylint itself: # Using an *nix shell or cmd on Windows pylint --generate-rcfile > .pylintrc For PowerShell you have to explicitly specify a UTF-8 output encoding: pylint --generate-rcfile | Out-File -Encoding utf8 .pylintrc The generated file contains sections for all the Pylint options, along with documentation in the comments. pydocstyle Command-line arguments and configuration files See pydocstyle Command Line Interface for general options. For example, to ignore error D400 (first line should end with a period), add the following line to your settings.json file: \"python.linting.pydocstyleArgs\": [\"--ignore=D400\"] A code prefix also instructs pydocstyle to ignore specific categories of errors. For example, to ignore all Docstring Content issues (D4XXX errors), add the following line to settings.json : \"python.linting.pydocstyleArgs\": [\"--ignore=D4\"] More details can be found in the pydocstyle documentation . Options can also be read from a [pydocstyle] section of any of the following configuration files: setup.cfg tox.ini .pydocstyle .pydocstyle.ini .pydocstylerc .pydocstylerc.ini For more information, see Configuration Files . Message category mapping The Python extension maps all pydocstyle errors to the Convention (C) category. pycodestyle (pep8) Command-line arguments and configuration files See pycodestyle example usage and output for general switches. For example, to ignore error E303 (too many blank lines), add the following line to your settings.json file: \"python.linting.pycodestyleArgs\": [\"--ignore=E303\"] pycodestyle options are read from the [pycodestyle] section of a tox.ini or setup.cfg file located in any parent folder of the path(s) being processed. For details, see pycodestyle configuration . Message category mapping The Python extension maps pycodestyle message categories to VS Code categories through the following settings. If desired, change the setting to change the mapping. pycodestyle category Applicable setting (python.linting.) VS Code category mapping W pycodestyleCategorySeverity.W Warning E pycodestyleCategorySeverity.E Error Prospector Command-line arguments and configuration files See Prospector Command Line Usage for general options. For example, to set a strictness level of \"very high,\" add the following line to your settings.json file: \"python.linting.prospectorArgs\": [\"-s\", \"veryhigh\"] It's common with Prospector to use profiles to configure how Prospector runs. By default, Prospector loads the profile from a .prospector.yaml file in the current folder. Because Prospector calls other tools, such as Pylint, any configuration files for those tools override tool-specific settings in .prospector.yaml . For example, suppose you specify the following in .prospector.yaml : pylint: disable: - too-many-arguments If you also have a .pylintrc file that enables the too-many-arguments warning, you continue to see the warning from Pylint within VS Code. Message category mapping The Python extension maps all Prospector errors and warnings to the Error (E) category. Flake8 Command-line arguments and configuration files See Invoking Flake8 for general switches. For example, to ignore error E303 (too many blank lines), use the following setting: \"python.linting.flake8Args\": [\"--ignore=E303\"] By default, Flake8 ignores E121, E123, E126, E226, E24, and E704. Flake8 user options are read from the C:\\Users\\<username>\\.flake8 (Windows) or ~/.config/flake8 (macOS/Linux) file. At the project level, options are read from the [flake8] section of a tox.ini , setup.cfg , or .flake8 file. For details, see Flake8 configuration . Message category mapping The Python extension maps flake8 message categories to VS Code categories through the following settings. If desired, change the setting to change the mapping. Flake8 category Applicable setting (python.linting.) VS Code category mapping F flake8CategorySeverity.F Error E flake8CategorySeverity.E Error W flake8CategorySeverity.W Warning mypy Message category mapping The Python extension maps mypy message categories to VS Code categories through the following settings. If desired, change the setting to change the mapping. mypy category Applicable setting (python.linting.) VS Code category mapping error mypyCategorySeverity.error Error note mypyCategorySeverity.note Information Troubleshooting linting Error message Cause Solution ... unable to import <module_name> The Python extension is using the wrong version of Pylint. Ensure that the pythonPath setting points to a valid Python installation where Pylint is installed. Alternately, set the python.linting.pylintPath to an appropriate version of Pylint for the Python interpreter being used. Linting with <linter> failed ... The path to the Python interpreter is incorrect. Check the pythonPath setting (see Environments ). The linter has not been installed in the current Python environment. Open a command window, navigate to the location of the Python interpreter in the pythonPath setting, and run pip install for the linter. The path to the linter is incorrect. Ensure that the appropriate python.linting.<linter>Path setting for the linter is correct. Custom arguments are defined incorrectly. Check the appropriate python.linting.<linter>Args settings, and that the value of the setting is a list of the argument elements that are separated by spaces. For example, \"python.linting.pylintPath\": \"pylint --load-plugins pylint_django\" is incorrect. The correct syntax is \"python.linting.pylintArgs\": [\"--load-plugins\", \"pylint_django\"] . Next steps Debugging - Learn to debug Python both locally and remotely. Testing - Configure test environments and discover, run, and debug tests. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code."
  },
  "guides/vscode/python/python-on-azure.html": {
    "href": "guides/vscode/python/python-on-azure.html",
    "title": "Deploy Python to Azure | Fountain of Knowledge",
    "keywords": "Deploy Python to Azure The Azure Tools extensions for Visual Studio Code make it easy to deploy Python applications (including containers) to Azure App Service and to deploy serverless code to Azure Functions . Deployment tutorials The following tutorials on the Python Azure Developer's Center walk you though the details. Tutorial Description Deploy Python web apps to Azure App Service Deploy a web app using the Azure App Service extension. Deploy Python containers to Azure App Service Deploy a Docker container using the Docker extension. Deploy Python to Azure Functions Deploy serverless code using the Azure Functions extension."
  },
  "guides/vscode/python/python-tutorial.html": {
    "href": "guides/vscode/python/python-tutorial.html",
    "title": "Getting Started with Python in VS Code | Fountain of Knowledge",
    "keywords": "Getting Started with Python in VS Code In this tutorial, you use Python 3 to create the simplest Python \"Hello World\" application in Visual Studio Code. By using the Python extension, you make VS Code into a great lightweight Python IDE (which you may find a productive alternative to PyCharm). This tutorial introduces you to VS Code as a Python environment, primarily how to edit, run, and debug code through the following tasks: Write, run, and debug a Python \"Hello World\" Application Learn how to install packages by creating Python virtual environments Write a simple Python script to plot figures within VS Code This tutorial is not intended to teach you Python itself. Once you are familiar with the basics of VS Code, you can then follow any of the programming tutorials on python.org within the context of VS Code for an introduction to the language. If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this tutorial, you need to first setup your Python development environment. Specifically, this tutorial requires: VS Code VS Code Python extension Python 3 Install Visual Studio Code and the Python Extension If you have not already done so, install VS Code . Next, install the Python extension for VS Code from the Visual Studio Marketplace. For additional details on installing extensions, see Extension Marketplace . The Python extension is named Python and it's published by Microsoft. Install a Python interpreter Along with the Python extension, you need to install a Python interpreter. Which interpreter you use is dependent on your specific needs, but some guidance is provided below. Windows Install Python from python.org . You can typically use the Download Python button that appears first on the page to download the latest version. Note : If you don't have admin access, an additional option for installing Python on Windows is to use the Microsoft Store. The Microsoft Store provides installs of Python 3.7 , Python 3.8 , and Python 3.9 . Be aware that you might have compatibility issues with some packages using this method. For additional information about using Python on Windows, see Using Python on Windows at Python.org macOS The system install of Python on macOS is not supported. Instead, an installation through Homebrew is recommended. To install Python using Homebrew on macOS use brew install python3 at the Terminal prompt. Note On macOS, make sure the location of your VS Code installation is included in your PATH environment variable. See these setup instructions for more information. Linux The built-in Python 3 installation on Linux works well, but to install other Python packages you must install pip with get-pip.py . Other options Data Science : If your primary purpose for using Python is Data Science, then you might consider a download from Anaconda . Anaconda provides not just a Python interpreter, but many useful libraries and tools for data science. Windows Subsystem for Linux : If you are working on Windows and want a Linux environment for working with Python, the Windows Subsystem for Linux (WSL) is an option for you. If you choose this option, you'll also want to install the Remote - WSL extension . For more information about using WSL with VS Code, see VS Code Remote Development or try the Working in WSL tutorial , which will walk you through setting up WSL, installing Python, and creating a Hello World application running in WSL. Verify the Python installation To verify that you've installed Python successfully on your machine, run one of the following commands (depending on your operating system): Linux/macOS: open a Terminal Window and type the following command: python3 --version Windows: open a command prompt and run the following command: py -3 --version If the installation was successful, the output window should show the version of Python that you installed. Note You can use the py -0 command in the VS Code integrated terminal to view the versions of python installed on your machine. The default interpreter is identified by an asterisk (*). Start VS Code in a project (workspace) folder Using a command prompt or terminal, create an empty folder called \"hello\", navigate into it, and open VS Code ( code ) in that folder ( . ) by entering the following commands: mkdir hello cd hello code . Note : If you're using an Anaconda distribution, be sure to use an Anaconda command prompt. By starting VS Code in a folder, that folder becomes your \"workspace\". VS Code stores settings that are specific to that workspace in .vscode/settings.json , which are separate from user settings that are stored globally. Alternately, you can run VS Code through the operating system UI, then use File > Open Folder to open the project folder. Select a Python interpreter Python is an interpreted language, and in order to run Python code and get Python IntelliSense, you must tell VS Code which interpreter to use. From within VS Code, select a Python 3 interpreter by opening the Command Palette ( kb(workbench.action.showCommands) ), start typing the Python: Select Interpreter command to search, then select the command. You can also use the Select Python Environment option on the Status Bar if available (it may already show a selected interpreter, too): The command presents a list of available interpreters that VS Code can find automatically, including virtual environments. If you don't see the desired interpreter, see Configuring Python environments . Note : When using an Anaconda distribution, the correct interpreter should have the suffix ('base':conda) , for example Python 3.7.3 64-bit ('base':conda) . Selecting an interpreter sets which interpreter will be used by the Python extension for that workspace. Note : If you select an interpreter without a workspace folder open, VS Code sets python.defaultInterpreterPath in User scope instead, which sets the default interpreter for VS Code in general. The user setting makes sure you always have a default interpreter for Python projects. The workspace settings lets you override the user setting. Create a Python Hello World source code file From the File Explorer toolbar, select the New File button on the hello folder: Name the file hello.py , and it automatically opens in the editor: By using the .py file extension, you tell VS Code to interpret this file as a Python program, so that it evaluates the contents with the Python extension and the selected interpreter. Note : The File Explorer toolbar also allows you to create folders within your workspace to better organize your code. You can use the New folder button to quickly create a folder. Now that you have a code file in your Workspace, enter the following source code in hello.py : msg = \"Hello World\" print(msg) When you start typing print , notice how IntelliSense presents auto-completion options. IntelliSense and auto-completions work for standard Python modules as well as other packages you've installed into the environment of the selected Python interpreter. It also provides completions for methods available on object types. For example, because the msg variable contains a string, IntelliSense provides string methods when you type msg. : Feel free to experiment with IntelliSense some more, but then revert your changes so you have only the msg variable and the print call, and save the file ( kb(workbench.action.files.save) ). For full details on editing, formatting, and refactoring, see Editing code . The Python extension also has full support for Linting . Run Hello World It's simple to run hello.py with Python. Just click the Run Python File in Terminal play button in the top-right side of the editor. The button opens a terminal panel in which your Python interpreter is automatically activated, then runs python3 hello.py (macOS/Linux) or python hello.py (Windows): There are three other ways you can run Python code within VS Code: Right-click anywhere in the editor window and select Run Python File in Terminal (which saves the file automatically): Select one or more lines, then press kbstyle(Shift+Enter) or right-click and select Run Selection/Line in Python Terminal . This command is convenient for testing just a part of a file. From the Command Palette ( kb(workbench.action.showCommands) ), select the Python: Start REPL command to open a REPL terminal for the currently selected Python interpreter. In the REPL, you can then enter and run lines of code one at a time. Configure and run the debugger Let's now try debugging our simple Hello World program. First, set a breakpoint on line 2 of hello.py by placing the cursor on the print call and pressing kb(editor.debug.action.toggleBreakpoint) . Alternately, just click in the editor's left gutter, next to the line numbers. When you set a breakpoint, a red circle appears in the gutter. Next, to initialize the debugger, press kb(workbench.action.debug.start) . Since this is your first time debugging this file, a configuration menu will open from the Command Palette allowing you to select the type of debug configuration you would like for the opened file. Note : VS Code uses JSON files for all of its various configurations; launch.json is the standard name for a file containing debugging configurations. These different configurations are fully explained in Debugging configurations ; for now, just select Python File , which is the configuration that runs the current file shown in the editor using the currently selected Python interpreter. The debugger will stop at the first line of the file breakpoint. The current line is indicated with a yellow arrow in the left margin. If you examine the Local variables window at this point, you will see now defined msg variable appears in the Local pane. A debug toolbar appears along the top with the following commands from left to right: continue ( kb(workbench.action.debug.start) ), step over ( kb(workbench.action.debug.stepOver) ), step into ( kb(workbench.action.debug.stepInto) ), step out ( kb(workbench.action.debug.stepOut) ), restart ( kb(workbench.action.debug.restart) ), and stop ( kb(workbench.action.debug.stop) ). The Status Bar also changes color (orange in many themes) to indicate that you're in debug mode. The Python Debug Console also appears automatically in the lower right panel to show the commands being run, along with the program output. To continue running the program, select the continue command on the debug toolbar ( kb(workbench.action.debug.start) ). The debugger runs the program to the end. Tip Debugging information can also be seen by hovering over code, such as variables. In the case of msg , hovering over the variable will display the string Hello world in a box above the variable. You can also work with variables in the Debug Console (If you don't see it, select Debug Console in the lower right area of VS Code, or select it from the ... menu.) Then try entering the following lines, one by one, at the > prompt at the bottom of the console: msg msg.capitalize() msg.split() Select the blue Continue button on the toolbar again (or press F5) to run the program to completion. \"Hello World\" appears in the Python Debug Console if you switch back to it, and VS Code exits debugging mode once the program is complete. If you restart the debugger, the debugger again stops on the first breakpoint. To stop running a program before it's complete, use the red square stop button on the debug toolbar ( kb(workbench.action.debug.stop) ), or use the Run > Stop debugging menu command. For full details, see Debugging configurations , which includes notes on how to use a specific Python interpreter for debugging. Tip: Use Logpoints instead of print statements : Developers often litter source code with print statements to quickly inspect variables without necessarily stepping through each line of code in a debugger. In VS Code, you can instead use Logpoints . A Logpoint is like a breakpoint except that it logs a message to the console and doesn't stop the program. For more information, see Logpoints in the main VS Code debugging article. Install and use packages Let's now run an example that's a little more interesting. In Python, packages are how you obtain any number of useful code libraries, typically from PyPI . For this example, you use the matplotlib and numpy packages to create a graphical plot as is commonly done with data science. (Note that matplotlib cannot show graphs when running in the Windows Subsystem for Linux as it lacks the necessary UI support.) Return to the Explorer view (the top-most icon on the left side, which shows files), create a new file called standardplot.py , and paste in the following source code: import matplotlib.pyplot as plt import numpy as np x = np.linspace(0, 20, 100) # Create a list of evenly-spaced numbers over the range plt.plot(x, np.sin(x)) # Plot the sine of each x point plt.show() # Display the plot Tip : If you enter the above code by hand, you may find that auto-completions change the names after the as keywords when you press kbstyle(Enter) at the end of a line. To avoid this, type a space, then kbstyle(Enter) . Next, try running the file in the debugger using the \"Python: Current file\" configuration as described in the last section. Unless you're using an Anaconda distribution or have previously installed the matplotlib package, you should see the message, \"ModuleNotFoundError: No module named 'matplotlib'\" . Such a message indicates that the required package isn't available in your system. To install the matplotlib package (which also installs numpy as a dependency), stop the debugger and use the Command Palette to run Terminal: Create New Integrated Terminal ( kb(workbench.action.terminal.new) ). This command opens a command prompt for your selected interpreter. A best practice among Python developers is to avoid installing packages into a global interpreter environment. You instead use a project-specific virtual environment that contains a copy of a global interpreter. Once you activate that environment, any packages you then install are isolated from other environments. Such isolation reduces many complications that can arise from conflicting package versions. To create a virtual environment and install the required packages, enter the following commands as appropriate for your operating system: Note : For additional information about virtual environments, see Environments . Create and activate the virtual environment Note : When you create a new virtual environment, you should be prompted by VS Code to set it as the default for your workspace folder. If selected, the environment will automatically be activated when you open a new terminal. For Windows py -3 -m venv .venv .venv\\scripts\\activate If the activate command generates the message \"Activate.ps1 is not digitally signed. You cannot run this script on the current system.\", then you need to temporarily change the PowerShell execution policy to allow scripts to run (see About Execution Policies in the PowerShell documentation): Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process For macOS/Linux python3 -m venv .venv source .venv/bin/activate Select your new environment by using the Python: Select Interpreter command from the Command Palette . Install the packages # Don't use with Anaconda distributions because they include matplotlib already. # macOS python3 -m pip install matplotlib # Windows (may require elevation) python -m pip install matplotlib # Linux (Debian) apt-get install python3-tk python3 -m pip install matplotlib Rerun the program now (with or without the debugger) and after a few moments a plot window appears with the output: Once you are finished, type deactivate in the terminal window to deactivate the virtual environment. For additional examples of creating and activating a virtual environment and installing packages, see the Django tutorial and the Flask tutorial . Next steps You can configure VS Code to use any Python environment you have installed, including virtual and conda environments. You can also use a separate environment for debugging. For full details, see Environments . To learn more about the Python language, follow any of the programming tutorials listed on python.org within the context of VS Code. To learn to build web apps with the Django and Flask frameworks, see the following tutorials: Use Django in Visual Studio Code Use Flask in Visual Studio Code There is then much more to explore with Python in Visual Studio Code: Editing code - Learn about autocomplete, IntelliSense, formatting, and refactoring for Python. Linting - Enable, configure, and apply a variety of Python linters. Debugging - Learn to debug Python both locally and remotely. Testing - Configure test environments and discover, run, and debug tests. Settings reference - Explore the full range of Python-related settings in VS Code. Deploy Python to Azure App Service using containers Deploy Python to Azure App Service on Linux"
  },
  "guides/vscode/python/settings-reference.html": {
    "href": "guides/vscode/python/settings-reference.html",
    "title": "Python settings reference | Fountain of Knowledge",
    "keywords": "Python settings reference The Python Extension for Visual Studio Code is highly configurable. This page describes the key settings you can work with. For general information about working with settings in VS Code, refer to User and workspace settings , as well as the Variables reference for information about predefined variable support. General settings Setting (python.) Default Description condaPath \"conda\" Path to the conda executable. defaultInterpreterPath \"python\" Path to the default Python interpreter to be used by the Python extension on the first time it loads for a workspace, or the path to a folder containing the Python interpreter. Can use variables like ${workspaceFolder} and ${workspaceFolder}/.venv . Using a path to a folder allows anyone working with a project to create an environment in the .venv folder as appropriate to their operating system, rather than having to specify an exact platform-dependent path. settings.json file can then be included in a source code repository. Note : Changes to this setting made after an interpreter has been selected for a workspace will not be applied or considered by the Python extension. As well, the Python extension doesn't automatically add or change this setting. pipenvPath \"pipenv\" Path to the pipenv executable to use for activation. disableInstallationCheck false If set to true , disables a warning from the extension if no Python interpreter is installed. On macOS, also disables a warning that appears if you're using the OS-installed Python interpreter. It's generally recommended to install a separate interpreter on macOS. venvFolders [] Paths to folders where virtual environments are created. Depending on the virtualization tool used, it can be the project itself: ${workspaceFolder} , or separate folders for all virtual environments located side by side: .\\envs , ~/.virtualenvs , and so on. envFile \"${workspaceFolder}/ .env\" Absolute path to a file containing environment variable definitions. See Configuring Python environments - environment variable definitions file . globalModuleInstallation false Specifies whether to install packages for the current user only using the --user command-line argument (the default), or to install for all users in the global environment (when set to true ). Ignored when using a virtual environment. For more information on the --user argument, see pip - User Installs . poetryPath \"poetry\" Specifies the location of the Poetry dependency manager executable, if installed. The default value \"poetry\" assumes the executable is in the current path. The Python extension uses this setting to install packages when Poetry is available and there's a poetry.lock file in the workspace folder. terminal.launchArgs [] Launch arguments that are given to the Python interpreter when you run a file using commands such as Python: Run Python File in Terminal . In the launchArgs list, each item is a top-level command-line element that's separated by a space (quoted values that contain spaces are a single top-level element and are thus one item in the list). For example, for the arguments --a --b --c {\"value1\" : 1, \"value2\" : 2} , the list items should be [\"--a\", \"--b\", \"--c\", \"{\\\"value1\\\" : 1, \\\"value2\\\" : 2}\\\"\"] . Note that Visual Studio code ignores this setting when debugging because it instead uses arguments from your selected debugging configuration in launch.json . terminal.executeInFileDir false Indicates whether to run a file in the file's directory instead of the current folder. terminal.activateEnvironment true Indicates whether to automatically activate the environment you select using the Python: Select Interpreter command when a new terminal is created. For example, when this setting is true and you select a virtual environment, the extension automatically runs the environment's activate command when creating a new terminal ( source env/bin/activate on macOS/Linux; env\\scripts\\activate on Windows). terminal.activateEnvInCurrentTerminal false Specifies whether to activate the currently open terminal when the Python extension is activated, using the virtual environment selected. logging.level error Specifies the level of logging to be performed by the extension. The possible levels of logging, in increasing level of information provided, are off , error , warn , info , and debug . When set to off , which is not recommended, basic information will still be shown such as startup information and commands run by the Python extension. At the error level, basic information and errors will be shown. At the warn level, basic, error, and warning information will be shown. At the info level, basic, error, warning, and additional information like method execution times and return values will be shown. At this time, the debug level doesn't display additional information. insidersChannel off Specifies whether to participate in the Insiders program and the channel to use. Set to weekly or daily to automatically download and install the latest Insiders builds of the Python extension, which include upcoming features and bug fixes. Workspace symbol (tags) settings Workspace symbols are symbols in C source code generated by the ctags tool (described on Wikipedia and on ctags.sourceforge.net ). To quote Wikipedia, ctags \"generates an index (or tag) file of names found in source and header files of various programming languages.\" Where Python is concerned, ctags makes it easier to jump to defined functions and other symbols in C/C++ extension modules. Setting (python.workspaceSymbols.) Default Description tagFilePath \"${workspaceFolder}/ .vscode/tags\" Fully qualified path to tag file (an exuberant ctag file), used to provide workspace symbols. enabled true Specifies whether to enable the Workspace Symbol provider. rebuildOnStart true Specifies whether to rebuild the tags file on start. rebuildOnFileSave true Specifies whether to rebuild the tags file on when saving a Python file. ctagsPath \"ctags\" Fully qualified path to the ctags executable; default value assumes it's in the current environment. exclusionPatterns [\"**/site-packages/**\"] Pattern used to exclude files and folders from ctags. Code analysis settings IntelliSense engine settings Note: If you have never changed your language server setting, your language server is set to Pylance via the “Default” setting value. Setting (python.) Default Description languageServer Default Defines type of the language server (Default, Pylance , Microsoft, Jedi, None). Python Language Server settings Pylance Language Server The language server settings apply when python.languageServer is Pylance or Default . If you have difficulties with the language server, see Troubleshooting in the language server repository. Setting (python.analysis.) Default Description typeCheckingMode off Specifies the level of type checking analysis to perform. Available values are off , basic , and strict . When set to off no type checking analysis is conducted; unresolved imports/variables diagnostics are produced. When set to basic non-type checking-related rules (all rules in off ), as well as basic type checking rules are used. When set to strict all type checking rules at the highest severity of error (including all rules in off and basic categories) are used. diagnosticMode openFilesOnly Specifies what code files the language server analyzes for problems. Available values are workspace and openFilesOnly . stubPath ./typings Specifies a path to a directory that contains custom type stubs. Each package's type stub file(s) are expected to be in its own subdirectory. autoSearchPaths true Indicates whether to automatically add search paths based on some predefined names (like src ). Available values are true and false . extraPaths [] Specifies extra search paths for import resolution. Paths should be specified as strings and must be separated by commas when there are multiple paths. [\"path 1\",\"path 2\"] completeFunctionParens false Adds parentheses to function completions. Accepted values are true and false . useLibraryCodeForTypes true Parses the source code for a package when a typestub is not found. Available values are true and false . autoImportCompletion true Controls the offering of auto-imports in completions. Available values are true and false . diagnosticSeverityOverrides {} Allows a user to override the severity levels for individual diagnostics. For each rule, the available severity levels are error (red squiggle), warning (yellow squiggle), information (blue squiggle), and none (rule disabled). For information about the keys to use for the diagnostic severity rules, see the Diagnostic severity rules section below. Note: Similar to the core Python extension, Pylance has an Insiders program that offers early access to new features and improvements. To enable the Insiders program, set pylance.insidersChannel to daily . This setting enables a daily check for new builds. At startup or when the Insiders setting is changed, Pylance will automatically update and prompt you to reload. To leave the Insiders program, just remove the setting, or explicitly set it to off instead. You might be prompted to downgrade your extension to the latest stable version. Diagnostic severity rules This section details all the available rules that can be customized using the python.analysis.diagnosticSeverityOverrides setting as shown in the following example. { \"python.analysis.diagnosticSeverityOverrides\": { \"reportUnboundVariable\": \"information\", \"reportImplicitStringConcatenation\": \"warning\" } } Value Description reportGeneralTypeIssues Diagnostics for general type inconsistencies, unsupported operations, argument/parameter mismatches, etc. This covers all of the basic type-checking rules not covered by other rules. It does not include syntax errors. reportPropertyTypeMismatch Diagnostics for properties where the type of the value passed to the setter is not assignable to the value returned by the getter. Such mismatches violate the intended use of properties, which are meant to act like variables. reportPropertyTypeMismatch Diagnostics for member accesses on functions. reportMissingImports Diagnostics for imports that have no corresponding imported python file or type stub file. reportMissingModuleSource Diagnostics for imports that have no corresponding source file. This happens when a type stub is found, but the module source file was not found, indicating that the code may fail at runtime when using this execution environment. Type checking will be done using the type stub. reportMissingTypeStubs Diagnostics for imports that have no corresponding type stub file (either a typeshed file or a custom type stub). The type checker requires type stubs to do its best job at analysis. reportImportCycles Diagnostics for cyclical import chains. These are not errors in Python, but they do slow down type analysis and often hint at architectural layering issues. Generally, they should be avoided. reportUnusedImport Diagnostics for an imported symbol that is not referenced within that file. reportUnusedClass Diagnostics for a class with a private name (starting with an underscore) that is not accessed. reportUnusedFunction Diagnostics for a function or method with a private name (starting with an underscore) that is not accessed. reportUnusedVariable Diagnostics for a variable that is not accessed. reportDuplicateImport Diagnostics for an imported symbol or module that is imported more than once. reportWildcardImportFromLibrary Diagnostics for a wildcard import from an external library. reportOptionalSubscript Diagnostics for an attempt to subscript (index) a variable with an Optional type. reportOptionalMemberAccess Diagnostics for an attempt to access a member of a variable with an Optional type. reportOptionalCall Diagnostics for an attempt to call a variable with an Optional type. reportOptionalIterable Diagnostics for an attempt to use an Optional type as an iterable value (e.g. within a for statement). reportOptionalContextManager Diagnostics for an attempt to use an Optional type as a context manager (as a parameter to a with statement). reportOptionalOperand Diagnostics for an attempt to use an Optional type as an operand to a binary or unary operator (like '+', '==', 'or', 'not'). reportUntypedFunctionDecorator Diagnostics for function decorators that have no type annotations. These obscure the function type, defeating many type analysis features. reportUntypedClassDecorator Diagnostics for class decorators that have no type annotations. These obscure the class type, defeating many type analysis features. reportUntypedBaseClass Diagnostics for base classes whose type cannot be determined statically. These obscure the class type, defeating many type analysis features. reportUntypedNamedTuple Diagnostics when “namedtuple” is used rather than “NamedTuple”. The former contains no type information, whereas the latter does. reportPrivateUsage Diagnostics for incorrect usage of private or protected variables or functions. Protected class members begin with a single underscore _ and can be accessed only by subclasses. Private class members begin with a double underscore but do not end in a double underscore and can be accessed only within the declaring class. Variables and functions declared outside of a class are considered private if their names start with either a single or double underscore, and they cannot be accessed outside of the declaring module. reportConstantRedefinition Diagnostics for attempts to redefine variables whose names are all-caps with underscores and numerals. reportIncompatibleMethodOverride Diagnostics for methods that override a method of the same name in a base class in an incompatible manner (wrong number of parameters, incompatible parameter types, or incompatible return type). reportIncompatibleVariableOverride Diagnostics for class variable declarations that override a symbol of the same name in a base class with a type that is incompatible with the base class symbol type. reportInvalidStringEscapeSequence Diagnostics for invalid escape sequences used within string literals. The Python specification indicates that such sequences will generate a syntax error in future versions. reportUnknownParameterType Diagnostics for input or return parameters for functions or methods that have an unknown type. reportUnknownArgumentType Diagnostics for call arguments for functions or methods that have an unknown type. reportUnknownLambdaType Diagnostics for input or return parameters for lambdas that have an unknown type. reportUnknownVariableType Diagnostics for variables that have an unknown type. reportUnknownMemberType Diagnostics for class or instance variables that have an unknown type. reportMissingTypeArgument Diagnostics for when a generic class is used without providing explicit or implicit type arguments. reportInvalidTypeVarUse Diagnostics for improper use of type variables in a function signature. reportCallInDefaultInitializer Diagnostics for function calls within a default value initialization expression. Such calls can mask expensive operations that are performed at module initialization time. reportUnnecessaryIsInstance Diagnostics for 'isinstance' or 'issubclass' calls where the result is statically determined to be always true or always false. Such calls are often indicative of a programming error. reportUnnecessaryCast Diagnostics for 'cast' calls that are statically determined to be unnecessary. Such calls are sometimes indicative of a programming error. reportAssertAlwaysTrue Diagnostics for 'assert' statement that will probably always assert. This can be indicative of a programming error. reportSelfClsParameterName Diagnostics for a missing or misnamed “self” parameter in instance methods and “cls” parameter in class methods. Instance methods in metaclasses (classes that derive from “type”) are allowed to use “cls” for instance methods. reportImplicitStringConcatenation Diagnostics for two or more string literals that follow each other, indicating an implicit concatenation. This is considered a bad practice and often masks bugs such as missing commas. reportUndefinedVariable Diagnostics for undefined variables. reportUnboundVariable Diagnostics for unbound and possibly unbound variables. reportInvalidStubStatement Diagnostics for statements that should not appear within a stub file. reportUnusedCallResult Diagnostics for call expressions whose results are not consumed and are not None. reportUnsupportedDunderAll Diagnostics for unsupported operations performed on __all__ . reportUnusedCoroutine Diagnostics for call expressions that return a Coroutine and whose results are not consumed. Jedi Language Server The language server settings apply when python.languageServer is Jedi . | Setting | Default | Description | | --- | --- | --- | | jediPath | \"\" | Path to folder containing the Jedi library (folder should contain a jedi subfolder). | | jediMemoryLimit | 0 | Memory limit for the Jedi completion engine in megabytes. Zero (the default) means 1024 MB. -1 disables the memory limit check. | Microsoft Python Language Server The language server settings apply when python.languageServer is Microsoft . If you have any difficulties with the language server, see Troubleshooting in the language server repository. Setting (python.analysis.) Default Description diagnosticPublishDelay 1000 The number of milliseconds to wait before transferring diagnostic messages to the problems list. disabled errors warnings information [] List of diagnostics messages to suppress or show as errors, warnings, or information. See below for applicable values. The classification of messages affects both what's shown in the Problems window and in the editor (such as the color of the underlining). logLevel \"Error\" Defines the types of log messages that language server writes into the Problems window, one of \"Error\", \"Warning\", \"Information\", and \"Trace\". The \"Warning\" level implicitly includes \"Error\"; \"Information\" implicitly includes \"Warning\" and \"Error\"; \"Trace\" includes all messages. openFilesOnly true When true, shows only errors and warnings for open files rather than for the entire workspace. symbolsHierarchyDepthLimit 10 Limits the depth of the symbol tree in the document outline. typeshedPaths [] Paths to look for typeshed modules on GitHub. The disabled , errors , warnings , and information settings can contain the following values: Value Default type Description or message text inherit-non-class Warning Attempted to inherit something that is not a class. too-many-function-arguments Warning Too many arguments have been provided to a function call. too-many-positional-arguments-before-star Warning Too many arguments have been provided before a starred argument. no-cls-argument Warning First parameter in a class method must be cls. no-method-argument Warning Method has no arguments. no-self-argument Warning First parameter in a method must be self. parameter-already-specified Warning An argument with this name has already been specified. parameter-missing Warning A required positional argument is missing. positional-argument-after-keyword Warning A positional argument has been provided after a keyword argument. positional-only-named Warning A positional-only argument (3.8+) has been named in a function call. return-in-init Warning Encountered an explicit return in __init__ function. typing-generic-arguments Warning An error occurred while constructing Generic . typing-typevar-arguments Warning An error occurred while constructing TypeVar . typing-newtype-arguments Warning An error occurred while constructing NewType . unknown-parameter-name Warning The keyword argument name provided is unknown. unresolved-import Warning An import cannot be resolved, and may be missing. undefined-variable Warning A variable has been used that has not yet been defined. variable-not-defined-globally Warning A variable is not defined in the global scope. variable-not-defined-nonlocal Warning A variable is not defined in non-local scopes. To suppress the \"undefined-variable\" messages, for example, use the setting \"python.analysis.disabled\": [\"undefined-variable\"] . To suppress those messages and \"too-many-function-arguments\" messages as well, use the setting \"python.analysis.disabled\": [\"undefined-variable\", \"too-many-function-arguments\"] . You can similarly set \"python.analysis.errors\" , \"python.analysis.warnings\" , and \"python.analysis.information\" to control the visibility and severity of the diagnostics. AutoComplete settings Setting (python.autoComplete.) Default Description See also addBrackets false Specifies whether VS Code automatically adds parentheses ( () ) when autocompleting a function name. Editing extraPaths [] Specifies locations of additional packages for which to load autocomplete data. Editing Formatting settings Setting (python.formatting.) Default Description See also provider \"autopep8\" Specifies the formatter to use, either \"autopep8\", \"black\", or \"yapf\". Editing - Formatting autopep8Path \"autopep8\" Path to autopep8 Editing - Formatting autopep8Args [] Arguments for autopep8, where each top-level element that's separated by a space is a separate item in the list. Editing - Formatting blackPath \"black\" Path to black Editing - Formatting blackArgs [] Arguments for black, where each top-level element that's separated by a space is a separate item in the list. Editing - Formatting yapfPath \"yapf\" Path to yapf Editing - Formatting yapfArgs [] Arguments for yapf, where each top-level element that's separated by a space is a separate item in the list. Editing - Formatting Refactoring - Sort Imports settings Setting (python.sortImports.) Default Description See also path \"\" Path to isort script Editing - Refactoring - Sort Imports args [] Arguments for isort, each argument as a separate item in the array. Editing - Refactoring - Sort Imports Linting settings General Setting (python.linting.) Default Description See also enabled true Specifies whether to enable linting in general. Linting lintOnSave true Specifies whether to line when saving a file. Linting maxNumberOfProblems 100 Limits the number of linting messages shown. Linting ignorePatterns [\".vscode/*.py\", \"**/site-packages/**/*.py\"] Exclude file and folder patterns. Linting Pylint Setting (python.linting.) Default Description See also pylintEnabled true Specifies whether to enable Pylint. Linting pylintArgs [] Additional arguments for Pylint, where each top-level element that's separated by a space is a separate item in the list. Linting pylintUseMinimalCheckers true Specifies whether to use the default value for pylintArgs. Linting pylintPath \"pylint\" The path to Pylint. Linting pylintCategorySeverity.convention \"Information\" Mapping for Pylint convention message to VS Code type. Linting pylintCategorySeverity.refactor \"Hint\" Mapping for Pylint refactor message to VS Code type. Linting pylintCategorySeverity.warning \"Warning\" Mapping for Pylint warning message to VS Code type. Linting pylintCategorySeverity.error \"Error\" Mapping for Pylint error message to VS Code type. Linting pylintCategorySeverity.fatal \"Error\" Mapping for Pylint fatal message to VS Code type. Linting pycodestyle (pep8) Setting (python.linting.) Default Description See also pycodestyleEnabled false Specifies whether to enable pycodestyle. Linting pycodestyleArgs [] Additional arguments for pycodestyle, where each top-level element that's separated by a space is a separate item in the list. Linting pycodestylePath \"pycodestyle\" The path to pycodestyle. Linting pycodestyleCategorySeverity.W \"Warning\" Mapping for pycodestyle W message to VS Code type. Linting pycodestyleCategorySeverity.E \"Error\" Mapping for pycodestyle E message to VS Code type. Linting Flake8 Setting (python.linting.) Default Description See also flake8Enabled false Specifies whether to enable flake8. Linting flake8Args [] Additional arguments for flake8, where each top-level element that's separated by a space is a separate item in the list. Linting flake8Path \"flake8\" The path to flake8. Linting flake8CategorySeverity.F \"Error\" Mapping for flake8 F message to VS Code type. Linting flake8CategorySeverity.E \"Error\" Mapping for flake8 E message to VS Code type. Linting flake8CategorySeverity.W \"Warning\" Mapping for flake8 W message to VS Code type. Linting mypy Setting (python.linting.) Default Description See also mypyEnabled false Specifies whether to enable mypy. Linting mypyArgs [\"--ignore-missing-imports\", \"--follow-imports=silent\"] Additional arguments for mypy, where each top-level element that's separated by a space is a separate item in the list. Linting mypyPath \"mypy\" The path to mypy. Linting mypyCategorySeverity.error \"Error\" Mapping for mypy error message to VS Code type. Linting mypyCategorySeverity.note \"Information\" Mapping for mypy note message to VS Code type. Linting pydocstyle Setting (python.linting.) Default Description See also pydocstyleEnabled false Specifies whether to enable pydocstyle. Linting pydocstyleArgs [] Additional arguments for pydocstyle, where each top-level element that's separated by a space is a separate item in the list. Linting pydocstylePath \"pydocstyle\" The path to pydocstyle. Linting prospector Setting (python.linting.) Default Description See also prospectorEnabled false Specifies whether to enable prospector. Linting prospectorArgs [] Additional arguments for prospector, where each top-level element that's separated by a space is a separate item in the list. Linting prospectorPath \"prospector\" The path to prospector. Linting pylama Setting (python.linting.) Default Description See also pylamaEnabled false Specifies whether to enable pylama. Linting pylamaArgs [] Additional arguments for pylama, where each top-level element that's separated by a space is a separate item in the list. Linting pylamaPath \"pylama\" The path to pylama. Linting Testing settings General settings Setting (python.testing.) Default Description See also cwd null Specifies an optional working directory for tests. Testing promptToConfigure true Specifies whether VS Code prompts to configure a test framework if potential tests are discovered. Testing debugPort 3000 Port number used for debugging of unittest tests. Testing autoTestDiscoverOnSaveEnabled true Specifies whether to enable or disable auto run test discovery when saving a test file. Testing unittest framework Setting (python.testing.) Default Description See also unittestEnabled false Specifies whether unittest is enabled for testing. Testing unittestArgs [\"-v\", \"-s\", \".\", \"-p\", \"*test*.py\"] Arguments to pass to unittest, where each top-level element that's separated by a space is a separate item in the list. Testing pytest framework Setting (python.testing.) Default Description See also pytestEnabled false Specifies whether pytest is enabled for testing. Testing pytestPath \"pytest\" Path to pytest. Use a full path if pytest is located outside the current environment. Testing pytestArgs [] Arguments to pass to pytest, where each top-level element that's separated by a space is a separate item in the list. When debugging tests with pytest-cov installed, include --no-cov in these arguments. Testing Nose framework Setting (python.testing.) Default Description See also nosetestsEnabled false Specifies whether Nose is enabled for testing. Testing nosetestPath \"nosetests\" Path to Nose. Use a full path if pytest is located outside the current environment. Testing nosetestArgs [] Arguments to pass to Nose, where each top-level element that's separated by a space is a separate item in the list. Testing Predefined variables The Python extension settings support predefined variables. Similar to the general VS Code settings, variables use the ${variableName} syntax. Specifically, the extension supports the following variables: ${cwd} - the task runner's current working directory on startup ${workspaceFolder} - the path of the folder opened in VS Code ${workspaceRootFolderName} - the name of the folder opened in VS Code without any slashes (/) ${workspaceFolderBasename} - the name of the folder opened in VS Code without any slashes (/) ${file} - the current opened file ${relativeFile} - the current opened file relative to workspaceFolder ${relativeFileDirname} - the current opened file's dirname relative to workspaceFolder ${fileBasename} - the current opened file's basename ${fileBasenameNoExtension} - the current opened file's basename with no file extension ${fileDirname} - the current opened file's dirname ${fileExtname} - the current opened file's extension ${lineNumber} - the current selected line number in the active file ${selectedText} - the current selected text in the active file ${execPath} - the path to the running VS Code executable For additional information about predefined variables and example usages, see the Variables reference in the general VS Code docs. Next steps Python environments - Control which Python interpreter is used for editing and debugging. Editing code - Learn about autocomplete, IntelliSense, formatting, and refactoring for Python. Linting - Enable, configure, and apply a variety of Python linters. Debugging - Learn to debug Python both locally and remotely. Testing - Configure test environments and discover, run, and debug tests."
  },
  "guides/vscode/python/testing.html": {
    "href": "guides/vscode/python/testing.html",
    "title": "Python testing in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Python testing in Visual Studio Code The Python extension supports testing with Python's built-in unittest framework as well as pytest . Nose is also supported, although the framework itself is in maintenance mode. After enabling a test framework , use the Python: Discover Tests command to scan the project for tests according to the discovery patterns of the currently selected test framework. Once discovered, Visual Studio Code provides a variety of means to run tests and debug tests . VS Code displays test output in the Python Test Log panel, including errors caused when a test framework is not installed. With pytest, failed tests also appear in the Problems panel. A little background on unit testing (If you're already familiar with unit testing, you can skip to the walkthroughs .) A unit is a specific piece of code to be tested, such as a function or a class. Unit tests are then other pieces of code that specifically exercise the code unit with a full range of different inputs, including boundary and edge cases. For example, say you have a function to validate the format of an account number that a user enters in a web form: def validate_account_number_format(account_string): # Return false if invalid, true if valid # ... Unit tests are concerned only with the unit's interface —its arguments and return values—not with its implementation (which is why no code is shown here in the function body; often you'd be using other well-tested libraries to help implement the function). In this example, the function accepts any string and returns true if that string contains a properly formatted account number, false otherwise. To thoroughly test this function, you want to throw at it every conceivable input: valid strings, mistyped strings (off by one or two characters, or containing invalid characters), strings that are too short or too long, blank strings, null arguments, strings containing control characters (non-text codes), string containing HTML, strings containing injection attacks (such as SQL commands or JavaScript code), and so on. It's especially important to test security cases like injection attacks if the validated string is later used in database queries or displayed in the app's UI. For each input, you then define the function's expected return value (or values). In this example, again, the function should return true for only properly formatted strings. (Whether the number itself is a real account is a different matter that would be handled elsewhere through a database query.) With all the arguments and expected return values in hand, you now write the tests themselves, which are pieces of code that call the function with a particular input, then compare the actual return value with the expected return value (this comparison is called an assertion ): # Import the code to be tested import validator # Import the test framework (this is a hypothetical module) import test_framework # This is a generalized example, not specific to a test framework class Test_TestAccountValidator(test_framework.TestBaseClass): def test_validator_valid_string(): # The exact assertion call depends on the framework as well assert(validate_account_number_format(\"1234567890\"), true) # ... def test_validator_blank_string(): # The exact assertion call depends on the framework as well assert(validate_account_number_format(\"\"), false) # ... def test_validator_sql_injection(): # The exact assertion call depends on the framework as well assert(validate_account_number_format(\"drop database master\"), false) # ... tests for all other cases The exact structure of the code depends on the test framework you're using, and specific examples are provided later in this article. In any case, as you can see, each test is very simple: invoke the function with an argument and assert the expected return value. The combined results of all the tests is your test report, which tells you whether the function (the unit), is behaving as expected across all test cases. That is, when a unit passes all of its tests, you can be confident that it's functioning properly. (The practice of test-driven development is where you actually write the tests first, then write the code to pass more and more tests until all of them pass.) Because unit tests are small, isolated piece of code (in unit testing you avoid external dependencies and use mock data or otherwise simulated inputs), they're quick and inexpensive to run. This characteristic means that you can run unit tests early and often. Developers typically run unit tests even before committing code to a repository; gated check-in systems can also run unit tests before merging a commit. Many continuous integration systems also run unit tests after every build. Running the unit test early and often means that you quickly catch regressions, which are unexpected changes in the behavior of code that previously passed all its unit tests. Because the test failure can easily be traced to a particular code change, it's easy to find and remedy the cause of the failure, which is undoubtedly better than discovering a problem much later in the process! For a general background on unit testing, see Unit Testing on Wikipedia. For a variety of useful unit test examples, see https://github.com/gwtw/py-sorting , a repository with tests for different sorting algorithms. Example test walkthroughs Python tests are Python classes that reside in separate files from the code being tested. Each test framework specifies the structure and naming of tests and test files. Once you write tests and enable a test framework, VS Code locates those tests and provides you with various commands to run and debug them. For this section, create a folder and open it in VS Code. Then create a file named inc_dec.py with the following code to be tested: def increment(x): return x + 1 def decrement(x): return x - 1 With this code, you can experience working with tests in VS Code as described in the sections that follow. Enable a test framework Testing in Python is disabled by default. To enable testing, use the Python: Configure Tests command on the Command Palette. This command prompts you to select a test framework, the folder containing tests, and the pattern used to identify test files. You can also configure testing manually by setting one and only one of the following settings to true: python.testing.unittestEnabled , python.testing.pytestEnabled , and python.testing.nosetestsEnabled . Each framework also has specific configuration settings as described under Test configuration settings for their folders and patterns. It's important that you enable only a single test framework at a time. For this reason, when you enable one framework also be sure to disable the others. The Python: Configure Tests command does this automatically. When you enable a test framework, VS Code prompts you to install the framework package if it's not already present in the currently activated environment: Create tests Each test framework has its own conventions for naming test files and structuring the tests within, as described in the following sections. Each case includes two test methods, one of which is intentionally set to fail for the purposes of demonstration. Because Nose is in maintenance mode and not recommended for new projects, only unittest and pytest examples are shown in the sections that follow. (Nose2, the successor to Nose, is just unittest with plugins, and so it follows the unittest patterns shown here.) Tests in unittest Create a file named test_unittest.py that contains a test class with two test methods: import inc_dec # The code to test import unittest # The test framework class Test_TestIncrementDecrement(unittest.TestCase): def test_increment(self): self.assertEqual(inc_dec.increment(3), 4) def test_decrement(self): self.assertEqual(inc_dec.decrement(3), 4) if __name__ == '__main__': unittest.main() Tests in pytest Create a file named test_pytest.py that contains two test methods: import inc_dec # The code to test def test_increment(): assert inc_dec.increment(3) == 4 def test_decrement(): assert inc_dec.decrement(3) == 4 Test discovery VS Code uses the currently enabled testing framework to discover tests. You can trigger test discovery at any time using the Python: Discover Tests command. python.testing.autoTestDiscoverOnSaveEnabled is set to true by default, meaning test discovery is performed automatically whenever you save a test file. To disable this feature, set the value to false . Test discovery applies the discovery patterns for the current framework (which can be customized using the Test configuration settings ). The default behavior is as follows: python.testing.unittestArgs : Looks for any Python ( .py ) file with \"test\" in the name in the top-level project folder. All test files must be importable modules or packages. You can customize the file matching pattern with the -p configuration setting, and customize the folder with the -t setting. python.testing.pytestArgs : Looks for any Python ( .py ) file whose name begins with \"test_\" or ends with \"_test\", located anywhere within the current folder and all subfolders. Tip : Sometimes tests placed in subfolders aren't discovered because such test files cannot be imported. To make them importable, create an empty file named __init__.py in that folder. If discovery succeeds, the status bar shows Run Tests instead: If discovery fails (for example, the test framework isn't installed), you see a notification on the status bar. Selecting the notification provides more information: Once VS Code recognizes tests, it provides several ways to run those tests as described in Run tests . The most obvious means are CodeLens adornments that appear directly in the editor and allow you to easily run a single test method or, with unittest, a test class: Note : At present, the Python extension doesn't provide a setting to turn the adornments on or off. To suggest a different behavior, file an issue on the vscode-python repository . For Python, test discovery also activates the Test Explorer with an icon on the VS Code activity bar. The Test Explorer helps you visualize, navigate, and run tests: Run tests You run tests using any of the following actions: With a test file open, select the Run Test CodeLens adornment that appears above a test method or a class, as shown in the previous section. This command runs only that one method or only those tests in the class. Select Run Tests on the Status Bar (which can change appearance based on results), then select one of the commands like Run All Tests or Discover Tests : In Test Explorer : To run all discovered tests, select the play button at the top of Test Explorer : To run a specific group of tests, or a single test, select the file, class, or test, then select the play button to the right of that item: Right-click a file in Explorer and select Run All Tests , which runs the tests in that one file. From the Command Palette , select any of the run test commands: Command Description Debug All Tests See Debug tests . Debug Test Method See Debug tests . Run All Tests Searches for and runs all tests in the workspace and its subfolders. Run Current Test File Runs the test in the file that's currently viewed in the editor. Run Failed Tests Re-runs any tests that failed in a previous test run. Runs all test if no tests have been run yet. Run Test File Prompts for a specific test filename, then runs the test in that file. Run Test Method Prompts for the name of a test to run, providing auto-completion for test names. Show Test Output Opens the Python Test Log panel with information about passing and failing tests, as well as errors and skipped tests. After a test run, VS Code displays results directly with the CodeLens adornments in the editor and in Test Explorer . Results are shown both for individual tests as well as any classes and files containing those tests. Failed tests are also adorned in the editor with a red underline. VS Code also shows test results in the Python Test Log output panel (use the View > Output menu command to show the Output panel, then select Python Test Log from the dropdown on the right side): With pytest, failed tests also appear in the Problems panel, where you can double-click on an issue to navigate directly to the test: Run tests in parallel Support for running tests in parallel with pytest is available through the pytest-xdist package. To enable parallel testing: Open the integrated terminal and install the pytest-xdist package. For more details refer to the project's documentation page . For Windows py -3 -m pip install pytest-xdist For macOS/Linux python3 -m pip install pytest-xdist Next, create a file named pytest.ini in your project directory and add the content below, specifying the number of CPUs to be used. For example, to set it up for 4 CPUs: [pytest] addopts=-n4 Run your tests, which will now be run in parallel. Debug tests You might occasionally need to step through and analyze tests in the debugger, either because the tests themselves have a code defect you need to track down or in order to better understand why an area of code being tested is failing. For example, the test_decrement functions given earlier are failing because the assertion itself is faulty. The following steps demonstrate how to analyze the test: Set a breakpoint on first the line in the test_decrement function. Select the Debug Test adornment above that function or the \"bug\" icon for that test in Test Explorer . VS Code starts the debugger and pauses at the breakpoint. In the Debug Console panel, enter inc_dec.decrement(3) to see that the actual result is 2, whereas the expected result specified in the test is the incorrect value of 4. Stop the debugger and correct the faulty code: # unittest self.assertEqual(inc_dec.decrement(3), 2) # pytest assert inc_dec.decrement(3) == 2 Save the file and run the tests again to confirm that they pass, and see that the CodeLens adornments also indicate passing status. Note : running or debugging a test does not automatically save the test file. Always be sure to save changes to a test before running it, otherwise you'll likely be confused by the results because they still reflect the previous version of the file! The Python: Debug All Tests and Python: Debug Test Method commands (on both the Command Palette and Status Bar menu) launch the debugger for all tests and a single test method, respectively. You can also use the \"bug\" icons in Test Explorer to launch the debugger for all tests in a selected scope as well as all discovered tests. The debugger works the same for tests as for other Python code, including breakpoints, variable inspection, and so on. To customize settings for debugging tests, you can specify \"request\":\"test\" in the launch.json file in the .vscode folder from your workspace. This configuration will be used when you run Python: Debug All Tests and Python: Debug Test Method commands. For example, the configuration below in the launch.json file disables the justMyCode setting for debugging tests: { \"name\": \"Debug Tests\", \"type\": \"python\", \"request\": \"test\", \"console\": \"integratedTerminal\", \"justMyCode\": false } If you have more than one configuration entry with \"request\":\"test\" , the first definition will be used since we currently don't support multiple definitions for this request type. For more information on debugging, see Python debugging configurations and the general VS Code Debugging article. Test configuration settings The behavior of testing with Python is driven by both general settings and settings that are specific to whichever framework you've enabled. General settings Setting (python.testing.) Default Description autoTestDiscoverOnSaveEnabled true Specifies whether to enable or disable auto run test discovery when saving a test file. cwd null Specifies an optional working directory for tests. debugPort 3000 Port number used for debugging of unittest tests. promptToConfigure true Specifies whether VS Code prompts to configure a test framework if potential tests are discovered. unittest configuration settings Setting (python.testing.) Default Description unittestEnabled false Specifies whether unittest is enabled as the test framework. All other frameworks should be disabled. unittestArgs [\"-v\", \"-s\", \".\", \"-p\", \"*test*.py\"] Arguments to pass to unittest, where each element that's separated by a space is a separate item in the list. See below for a description of the defaults. The default arguments for unittest are as follows: -v sets default verbosity. Remove this argument for simpler output. -s . specifies the starting directory for discovering tests. If you have tests in a \"test\" folder, change the argument to -s test (meaning \"-s\", \"test\" in the arguments array). -p *test*.py is the discovery pattern used to look for tests. In this case, it's any .py file that includes the word \"test\". If you name test files differently, such as appending \"_test\" to every filename, then use a pattern like *_test.py in the appropriate argument of the array. To stop a test run on the first failure, add the fail fast option \"-f\" to the arguments array. See unittest command-line interface for the full set of available options. pytest configuration settings Setting (python.testing.) Default Description pytestEnabled false Specifies whether pytest is enabled as the test framework. All other frameworks should be disabled. pytestPath \"pytest\" Path to pytest. Use a full path if pytest is located outside the current environment. pytestArgs [] Arguments to pass to pytest, where each element that's separated by a space is a separate item in the list. See pytest command-line options . You can also configure pytest using a pytest.ini file as described on pytest Configuration . Note If you have the pytest-cov coverage module installed, VS Code doesn't stop at breakpoints while debugging because pytest-cov is using the same technique to access the source code being run. To prevent this behavior, include --no-cov in pytestArgs when debugging tests, for example by adding \"env\": {\"PYTEST_ADDOPTS\": \"--no-cov\"} to your debug configuration. (See Debug Tests above about how to set up that launch configuration.) (For more information, see Debuggers and PyCharm in the pytest-cov documentation.) Nose configuration settings Setting (python.testing.) Default Description nosetestsEnabled false Specifies whether Nose is enabled as the test framework. All other frameworks should be disabled. nosetestPath \"nosetests\" Path to Nose. Use a full path if Nose is located outside the current environment. nosetestArgs [] Arguments to pass to Nose, where each element that's separated by a space is a separate item in the list. See Nose usage options . You can also configure nose with a .noserc or nose.cfg file as described on Nose configuration . See also Python environments - Control which Python interpreter is used for editing and debugging. Settings reference - Explore the full range of Python-related settings in VS Code."
  },
  "guides/vscode/python/tutorial-create-containers.html": {
    "href": "guides/vscode/python/tutorial-create-containers.html",
    "title": "Create Docker containers for Python | Fountain of Knowledge",
    "keywords": "Create Docker containers for Python This tutorial walks you through the full process of containerizing an existing Python application using Docker and pushing the app image to a Docker registry, all within Visual Studio Code. The tutorial also demonstrates how to use base container images that include production-ready web servers (uwsgi and nginx), and how to configure those servers for both Django and Flask web apps, which is helpful to know no matter what your deployment target. If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . An introduction to containers Docker is a system that allows you to deploy and run apps using containers rather than setting up dedicated environments like virtual machines. A container is a lightweight runtime environment that shares the resources of the host operating system with other containers. Docker is the layer that sits above the operating system to manage resources on behalf of containers. A container is specifically an instance of a Docker image , an executable package that contains everything needed to run your app: app code, configuration files, runtimes, and all of app's dependencies. An image can be used to instantiate any number of identical containers, which is especially useful when scaling out a cloud-based web app. Because container images are much smaller than virtual machine images, instances can be started and stopped much more quickly than virtual machines, enabling your app to be highly responsive to varying loads at a minimal cost. (When used to scale web apps, containers are often managed in clusters , which are then managed by an orchestration agent such as Kubernetes .) Images, for their part, are built in multiple layers . The lowest or base layers of an image are typically common elements like the Python runtime; the higher layers contain more specialized elements like your application code. Because of layering, it takes very little time to rebuild an image when changing only the top layer with your app code. Similarly, when you push an image to a container registry , an online repository for images from which you can deploy to cloud services like Azure, only the modified layers need be uploaded and redeployed. As a result, using containers has only a small impact on your develop-test-deploy loop. You experience the basics of containers and images in the course of this tutorial. For additional background, including helpful diagrams, refer to the Docker documentation . Prerequisites Visual Studio Code Python and the Python extension as described on Python Tutorial - Prerequisites . Docker Community Edition . To verify your installation, run the command docker --version , which should show output like Docker version 18.06.1-ce, build e68fc7a . The Docker extension for VS Code , which helps you manage local Docker images, provides Docker commands, and simplifies deployment of app images to Azure. You can find an overview of the extension on the vscode-docker GitHub repository Suitable app code Install the Docker extension App code If you don't already have an app you'd like to work with, use one of the following samples, which already include the Docker-related files described in this tutorial: python-sample-vscode-django-tutorial , which is the result of following the Django Tutorial . python-sample-vscode-flask-tutorial , which is the result of following the Flask Tutorial . After verifying that your app runs properly, generate a requirements.txt file (using pip freeze > requirements.txt , for example) so that those dependencies can be automatically installed in the Docker image. The samples each include a requirements.txt file. Create a container registry As mentioned earlier, a container registry is an online repository for container images that allows a cloud service, like Azure App Service, to acquire the image whenever it needs to start a container instance. Because the registry manages images separate from container instances, the same image in a registry can be used to start any number of concurrent instances, as happens when scaling out a web app to handle increased loads. Because setting up a registry is a one-time affair, you do that step now before creating images that you then push to that registry. Registry options include the following: The Azure Container Registry (ACR) , a private, secure, hosted registry for your images. Docker Hub , Docker's own hosted registry that provides a free way to share images. A private registry running on your own server, as described on Docker registry in the Docker documentation. To create an Azure Container Registry, as shown later in this tutorial, do the following: Follow the first part of Quickstart: Create a container registry using the Azure portal through the \"Log in to ACR\" section. You don't need to complete the sections \"Push image to ACR\" and later because you do those steps within VS Code as part of this tutorial. Make sure that the registry endpoint you created is visible under Registries in the Docker explorer of VS Code: Create a container image A container image is a bundle of your app code and its dependencies. To create an image, Docker needs a Dockerfile that describes how to structure the app code in the container and how to get that code running. The Dockerfile , in other words, is the template for your image. The Docker extension helps you create these files with customization for production servers. Note : The Python samples linked earlier in this article already contain the necessary Docker files. The instructions here help you create files for an app of your own. Create the Docker files In VS Code, open the Command Palette ( kb(workbench.action.showCommands) ) and select the Docker: Add Docker files to workspace command. When the prompt appears after a few moments, select Python as the app type. Specify the port on which your app listens, such as 8000 (as in the Django sample) or 5000 (as in the Flask sample). The port value ends up only in the Docker compose files (see below) and have no impact on your container image. With all this information, the Docker extension creates the following files: The Dockerfile file describes the contents of your app's layer in the image. Your app layer is added on top of the base image indicated in the Dockerfile .. By default, the name of the image is the name of the workspace folder in VS Code. A .dockerignore file that reduces image size by excluding files and folders that aren't needed in the image, such as .git and .vscode . For Python, add another line to the file for __pycache__ . docker-compose.yml and docker-compose.debug.yml files that are used with Docker compose . For the purposes of this tutorial, you can ignore or delete these files. Tip: VS Code provides great support for Docker files. See the Working with Docker article to learn about rich language features like smart suggestions, completions, and error detection. Using production servers For Python, the Docker extension by default specifies the base image python:alpine in the Dockerfile and includes commands to run only the Flask development server. These defaults obviously don't accommodate Django, for one, and when deploying to the cloud, as with Azure App Service, you should also use production-ready web servers instead of a development server. (If you've used Flask, you're probably accustomed to seeing the development server's warning in this regard!) For this reason, you need to modify the Dockerfile to use a base image with production servers, then provide the necessary configuration for your app. The following sections provide details for both Flask and Django. Changes for Flask apps A good base image for Flask is tiangolo/uwsgi-nginx-flask:python3.6-alpine3.7 , which is also available for other versions of Python (see the tiangolo/uwsgi-nginx-flask repository on GitHub). This image already contains Flask and the production-ready uwsgi and nginx servers. By default, the image assumes that (a) your app code is located in an app folder, (b) the Flask app object is named app , and (c) the app object is located in main.py . Because your app may have a different structure, you can indicate the correct folders in the Dockerfile and provide the necessary parameters the uwsgi server in a uwsgi.ini file. The following steps summarize the configuration used in the python-sample-vscode-flask-tutorial app, which you can adapt for your own code. The Dockerfile indicates the location and name of the Flask app object, the location of static files for nginx, and the location of the uwsgi.ini file. (The Dockerfile in the sample contains further explanatory comments that are omitted here.) FROM tiangolo/uwsgi-nginx-flask:python3.6-alpine3.7 ENV LISTEN_PORT=5000 EXPOSE 5000 # Indicate where uwsgi.ini lives ENV UWSGI_INI=uwsgi.ini # Tell nginx where static files live. ENV STATIC_URL=/hello_app/static # Set the folder where uwsgi looks for the app WORKDIR /hello_app # Copy the app contents to the image COPY . /hello_app # If you have additional requirements beyond Flask (which is included in the # base image), generate a requirements.txt file with pip freeze and uncomment # the next three lines. #COPY requirements.txt / #RUN pip install --no-cache-dir -U pip #RUN pip install --no-cache-dir -r /requirements.txt The uwsgi.ini file, which is in the root of the sample project folder, provides configuration arguments for the uwsgi server. For the sample, the configuration below says that the Flask app object is found in the hello_app/webapp.py module, and that it's named (that is, \"callable\" as) app . The other values are additional common uwsgi settings: [uwsgi] module = hello_app.webapp callable = app uid = 1000 master = true threads = 2 processes = 4 Changes for Django apps A good base image for Django is tiangolo/uwsgi-nginx:python3.6-alpine3.7 , which is also available for other versions of Python (see the tiangolo/uwsgi-nginx repository on GitHub). This base image already contains the production-ready uwsgi and nginx servers, but does not include Django. It's also necessary to provide settings to uwsgi so it can find the app's startup code. The following steps summarize the configuration used in the python-sample-vscode-django-tutorial app that you can adapt for your own code. Make sure you have a requirements.txt file in your project that contains Django and its dependencies. You can generate requirements.txt using the command pip freeze > requirements.txt . In your Django project's settings.py file, modify the ALLOWED_HOSTS list to include the root URL to which you intend to deploy the app. For example, the following code assumes deployment to an Azure App Service (azurewebsites.net) named \"vsdocs-django-sample-container\": ALLOWED_HOSTS = [ # Example host name only; customize to your specific host \"vsdocs-django-sample-container.azurewebsites.net\" ] Without this entry, you'll eventually get all the way through the deployment only to see a \"DisallowedHost\" message that instructs to you add the domain to ALLOWED_HOSTS , which requires that you rebuild, push, and redeploy the image all over again! Create a uwsgi.ini file in the Django project folder (alongside manage.py ) that contains startup arguments for the uwsgi server. In the sample, the Django project is in a folder called web_project , which is where the wsgi.py and setting.py files live. [uwsgi] chdir = . module = web_project.wsgi:application env = DJANGO_SETTINGS_MODULE=web_project.settings uid = 1000 master = true threads = 2 processes = 4 To serve static files, copy the nginx.conf file from the django-react-devcontainer repo into your Django project folder. Modify the Dockerfile to indicate the location of uwsgi.ini , set the location of static files for nginx, and make sure the SQLite database file is writable. (The Dockerfile in the sample contains further explanatory comments that are omitted here.) FROM tiangolo/uwsgi-nginx:python3.6-alpine3.7 ENV LISTEN_PORT=8000 EXPOSE 8000 # Indicate where uwsgi.ini lives ENV UWSGI_INI=uwsgi.ini # Tell nginx where static files live (as typically collected using Django's # collectstatic command. ENV STATIC_URL=/app/static_collected # Copy the app files to a folder and run it from there WORKDIR /app ADD . /app # Make app folder writable for the sake of db.sqlite3, and make that file also writable. RUN chmod g+w /app RUN chmod g+w /app/db.sqlite3 # Make sure dependencies are installed RUN python3 -m pip install -r requirements.txt Note : When building a Docker image on Windows, you typically see the message below, which is why the Dockerfile shown here includes the two chmod commands. If need to make other files writable, add the appropriate chmod commands to your Dockerfile. SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories. Build and test the image With the necessary Dockerfile in place, you're ready to build the Docker image and run it locally: Make sure that Docker is running on your computer. On the VS Code Command Palette ( kb(workbench.action.showCommands) ), select Docker: Build Image . When prompted for the Docker file, choose the Dockerfile that you created in the previous section. (VS Code remembers your selection so you won't need to enter it again to rebuild.) When prompted for a name to give the image, use a name that follows the conventional form of <registry or username>/<image name>:<tag> , where <tag> is typically latest . Here are some examples (when using the Azure Container Registry): # Examples for Azure Container Registry, prefixed with the registry name vsdocsregistry.azurecr.io/python-sample-vscode-django-tutorial:latest vsdocsregistry.azurecr.io/python-sample-vscode-flask-tutorial:latest vsdocsregistry.azurecr.io/myexpressapp:latest # Examples for Docker hub, prefixed with your username vsdocs-team/python-sample-vscode-django-tutorial:latest vsdocs-team/python-sample-vscode-flask-tutorial:latest vsdocs-team/myexpressapp:latest Each step of Docker's build process appears in the VS Code Terminal panel, including any errors that occur running the steps in the Dockerfile . Tip : every time you run the Docker: Build image command, the Docker extension opens another Terminal in VS Code in which to run the command. You can close each terminal once the build is complete. Alternately, you can reuse the same terminal to build the image by scrolling up in the command history using the up arrow. When the build is complete, the image appears in the Docker explorer under Images : Run and test your container locally by using the following command, replacing <image_name> with your specific image, and changing the port numbers as needed. For web apps, you can then open browser to localhost:<port> to see the running app. # For Flask sample docker run --rm -it -p 5000:5000 <image_name> # For Django sample docker run --rm -it -p 8000:8000 <image_name> Two useful features of the Docker extension The Docker extension provides a simple UI to manage and even run your images rather than using the Docker CLI. Just expand the Image node in the Docker explorer, right-click any image, and select any of the menu items: In addition, on the top of the Docker explorer, next to the refresh button, is a button for System Prune . This command cleans up any dangling and otherwise unused images on your local computer. It's a good idea to periodically use the command to reclaim space on your file system. Push the image to a registry Once you're confident that your image works, the next step is to push it to your container registry: On the Command Palette ( kb(workbench.action.showCommands) ), select Docker: Push . Choose the image you just built to push the image to the registry; upload progress appears in the Terminal. Once completed, expand the Registries > Azure (or DockerHub ) node in the Docker explorer, then expand the registry and image name to see the exact image. (You may need to refresh the Docker explorer.) Tip: The first time you push an image, you see that VS Code uploads all of the different layers that make up the image. Subsequent push operations, however, upload only those layers that have changed. Because it's typically only your app code that's changes, those uploads happen much more quickly, making for a tight edit-build-deploy-test loop. To see this, make a small change to your code, rebuild the image, and then push again to the registry. The whole process typically completes in a matter of seconds. Next steps Now that you've created a container with your app, you're ready to deploy it to any container-ready cloud service. For details on deploying to Azure App Service, see Deploy a container . You can also learn more about the Docker extension for VS Code by visiting the vscode-docker repository on GitHub. Issues and contributions are welcome. And again, if you encountered any problems in the course of this tutorial, feel free to file an issue for this tutorial in the VS Code documentation repository ."
  },
  "guides/vscode/python/tutorial-django.html": {
    "href": "guides/vscode/python/tutorial-django.html",
    "title": "Django Tutorial in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Django Tutorial in Visual Studio Code Django is a high-level Python framework designed for rapid, secure, and scalable web development. Django includes rich support for URL routing, page templates, and working with data. In this Django tutorial, you create a simple Django app with three pages that use a common base template. You create this app in the context of Visual Studio Code in order to understand how to work with Django in the VS Code terminal, editor, and debugger. This tutorial does not explore various details about Django itself, such as working with data models and creating an administrative interface. For guidance on those aspects, refer to the Django documentation links at the end of this tutorial. The completed code project from this Django tutorial can be found on GitHub: python-sample-vscode-django-tutorial . If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this Django tutorial, you must do the following (which are the same steps as in the general Python tutorial ): Install the Python extension . Install a version of Python 3 (for which this tutorial is written). Options include: (All operating systems) A download from python.org ; typically use the Download Python 3.9.1 button that appears first on the page (or whatever is the latest version). (Linux) The built-in Python 3 installation works well, but to install other Python packages you must run sudo apt install python3-pip in the terminal. (macOS) An installation through Homebrew on macOS using brew install python3 (the system install of Python on macOS is not supported). (All operating systems) A download from Anaconda (for data science purposes). On Windows, make sure the location of your Python interpreter is included in your PATH environment variable. You can check the location by running path at the command prompt. If the Python interpreter's folder isn't included, open Windows Settings, search for \"environment\", select Edit environment variables for your account , then edit the Path variable to include that folder. Create a project environment for the Django tutorial In this section, you create a virtual environment in which Django is installed. Using a virtual environment avoids installing Django into a global Python environment and gives you exact control over the libraries used in an application. A virtual environment also makes it easy to Create a requirements.txt file for the environment . On your file system, create a project folder for this tutorial, such as hello_django . In that folder, use the following command (as appropriate to your computer) to create a virtual environment named env based on your current interpreter: # Linux sudo apt-get install python3-venv # If needed python3 -m venv env # macOS python3 -m venv env # Windows python -m venv env Note : Use a stock Python installation when running the above commands. If you use python.exe from an Anaconda installation, you see an error because the ensurepip module isn't available, and the environment is left in an unfinished state. Open the project folder in VS Code by running code . , or by running VS Code and using the File > Open Folder command. In VS Code, open the Command Palette ( View > Command Palette or ( kb(workbench.action.showCommands) )). Then select the Python: Select Interpreter command: The command presents a list of available interpreters that VS Code can locate automatically (your list will vary; if you don't see the desired interpreter, see Configuring Python environments ). From the list, select the virtual environment in your project folder that starts with ./env or .\\env : Run Terminal: Create New Integrated Terminal ( kb(workbench.action.terminal.new) ) from the Command Palette, which creates a terminal and automatically activates the virtual environment by running its activation script. Note : On Windows, if your default terminal type is PowerShell, you may see an error that it cannot run activate.ps1 because running scripts is disabled on the system. The error provides a link for information on how to allow scripts. Otherwise, use Terminal: Select Default Shell to set \"Command Prompt\" or \"Git Bash\" as your default instead. The selected environment appears on the left side of the VS Code status bar, and notice the \"(venv)\" indicator that tells you that you're using a virtual environment: Update pip in the virtual environment by running the following command in the VS Code Terminal: python -m pip install --upgrade pip Install Django in the virtual environment by running the following command in the VS Code Terminal: python -m pip install django You now have a self-contained environment ready for writing Django code. VS Code activates the environment automatically when you use Terminal: Create New Integrated Terminal ( kb(workbench.action.terminal.new) ). If you open a separate command prompt or terminal, activate the environment by running source env/bin/activate (Linux/macOS) or env\\Scripts\\Activate.ps1 (Windows). You know the environment is activated when the command prompt shows (env) at the beginning. Create and run a minimal Django app In Django terminology, a \"Django project\" is composed of several site-level configuration files along with one or more \"apps\" that you deploy to a web host to create a full web application. A Django project can contain multiple apps, each of which typically has an independent function in the project, and the same app can be in multiple Django projects. An app, for its part, is just a Python package that follows certain conventions that Django expects. To create a minimal Django app, then, it's necessary to first create the Django project to serve as the container for the app, then create the app itself. For both purposes, you use the Django administrative utility, django-admin , which is installed when you install the Django package. Create the Django project In the VS Code Terminal where your virtual environment is activated, run the following command: django-admin startproject web_project . This startproject command assumes (by use of . at the end) that the current folder is your project folder, and creates the following within it: manage.py : The Django command-line administrative utility for the project. You run administrative commands for the project using python manage.py <command> [options] . A subfolder named web_project , which contains the following files: __init__.py : an empty file that tells Python that this folder is a Python package. asgi.py : an entry point for ASGI-compatible web servers to serve your project. You typically leave this file as-is as it provides the hooks for production web servers. settings.py : contains settings for Django project, which you modify in the course of developing a web app. urls.py : contains a table of contents for the Django project, which you also modify in the course of development. wsgi.py : an entry point for WSGI-compatible web servers to serve your project. You typically leave this file as-is as it provides the hooks for production web servers. Create an empty development database by running the following command: python manage.py migrate When you run the server the first time, it creates a default SQLite database in the file db.sqlite3 that is intended for development purposes, but can be used in production for low-volume web apps. For additional information about databases, see the Types of databases section. To verify the Django project, make sure your virtual environment is activated, then start Django's development server using the command python manage.py runserver . The server runs on the default port 8000, and you see output like the following output in the terminal window: Performing system checks... System check identified no issues (0 silenced). January 15, 2021 - 14:33:31 Django version 3.1.5, using settings 'web_project.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CTRL-BREAK. Django's built-in web server is intended only for local development purposes. When you deploy to a web host, however, Django uses the host's web server instead. The wsgi.py and asgi.py modules in the Django project take care of hooking into the production servers. If you want to use a different port than the default 8000, specify the port number on the command line, such as python manage.py runserver 5000 . kbstyle(Ctrl+click) the http://127.0.0.1:8000/ URL in the terminal output window to open your default browser to that address. If Django is installed correctly and the project is valid, you see the default page shown below. The VS Code terminal output window also shows the server log. When you're done, close the browser window and stop the server in VS Code using kbstyle(Ctrl+C) as indicated in the terminal output window. Create a Django app In the VS Code Terminal with your virtual environment activated, run the administrative utility's startapp command in your project folder (where manage.py resides): python manage.py startapp hello The command creates a folder called hello that contains a number of code files and one subfolder. Of these, you frequently work with views.py (that contains the functions that define pages in your web app) and models.py (that contains classes defining your data objects). The migrations folder is used by Django's administrative utility to manage database versions as discussed later in this tutorial. There are also the files apps.py (app configuration), admin.py (for creating an administrative interface ), and tests.py (for creating tests ), which are not covered here. Modify hello/views.py to match the following code, which creates a single view for the app's home page: from django.http import HttpResponse def home(request): return HttpResponse(\"Hello, Django!\") Create a file, hello/urls.py , with the contents below. The urls.py file is where you specify patterns to route different URLs to their appropriate views. The code below contains one route to map root URL of the app ( \"\" ) to the views.home function that you just added to hello/views.py : from django.urls import path from hello import views urlpatterns = [ path(\"\", views.home, name=\"home\"), ] The web_project folder also contains a urls.py file, which is where URL routing is actually handled. Open web_project/urls.py and modify it to match the following code (you can retain the instructive comments if you like). This code pulls in the app's hello/urls.py using django.urls.include , which keeps the app's routes contained within the app. This separation is helpful when a project contains multiple apps. from django.contrib import admin from django.urls import include, path urlpatterns = [ path(\"\", include(\"hello.urls\")), path('admin/', admin.site.urls) ] Save all modified files. In the VS Code Terminal, again with the virtual environment activated, run the development server with python manage.py runserver and open a browser to http://127.0.0.1:8000/ to see a page that renders \"Hello, Django\". Create a debugger launch profile You're probably already wondering if there's an easier way to run the server and test the app without typing python manage.py runserver each time. Fortunately, there is! You can create a customized launch profile in VS Code, which is also used for the inevitable exercise of debugging. Switch to Run view in VS Code (using the left-side activity bar or kb(workbench.action.debug.start) ). You may see the message \"To customize Run and Debug create a launch.json file\". This means that you don't yet have a launch.json file containing debug configurations. VS Code can create that for you if you click on the create a launch.json file link: Select the link and VS Code will prompt for a debug configuration. Select Django from the dropdown and VS Code will populate a new launch.json file with a Django run configuration. The launch.json file contains a number of debugging configurations, each of which is a separate JSON object within the configuration array. Scroll down to and examine the configuration with the name \"Python: Django\": { \"name\": \"Python: Django\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/manage.py\", \"args\": [ \"runserver\", ], \"django\": true }, This configuration tells VS Code to run \"${workspaceFolder}/manage.py\" using the selected Python interpreter and the arguments in the args list. Launching the VS Code debugger with this configuration, then, is the same as running python manage.py runserver in the VS Code Terminal with your activated virtual environment. (You can add a port number like \"5000\" to args if desired.) The \"django\": true entry also tells VS Code to enable debugging of Django page templates, which you see later in this tutorial. Test the configuration by selecting the Run > Start Debugging menu command, or selecting the green Start Debugging arrow next to the list ( kb(workbench.action.debug.continue) ): kbstyle(Ctrl+click) the http://127.0.0.1:8000/ URL in the terminal output window to open the browser and see that the app is running properly. Close the browser and stop the debugger when you're finished. To stop the debugger, use the Stop toolbar button (the red square) or the Run > Stop Debugging command ( kb(workbench.action.debug.stop) ). You can now use the Run > Start Debugging at any time to test the app, which also has the benefit of automatically saving all modified files. Explore the debugger Debugging gives you the opportunity to pause a running program on a particular line of code. When a program is paused, you can examine variables, run code in the Debug Console panel, and otherwise take advantage of the features described on Debugging . Running the debugger also automatically saves any modified files before the debugging session begins. Before you begin : Make sure you've stopped the running app at the end of the last section by using kbstyle(Ctrl+C) in the terminal. If you leave the app running in one terminal, it continues to own the port. As a result, when you run the app in the debugger using the same port, the original running app handles all the requests and you won't see any activity in the app being debugged and the program won't stop at breakpoints. In other words, if the debugger doesn't seem to be working, make sure that no other instance of the app is still running. In hello/urls.py , add a route to the urlpatterns list: path(\"hello/<name>\", views.hello_there, name=\"hello_there\"), The first argument to path defines a route \"hello/\" that accepts a variable string called name . The string is passed to the views.hello_there function specified in the second argument to path . URL routes are case-sensitive. For example, the route /hello/<name> is distinct from /Hello/<name> . If you want the same view function to handle both, define paths for each variant. Replace the contents of views.py with the following code to define the hello_there function that you can step through in the debugger: import re from django.utils.timezone import datetime from django.http import HttpResponse def home(request): return HttpResponse(\"Hello, Django!\") def hello_there(request, name): now = datetime.now() formatted_now = now.strftime(\"%A, %d %B, %Y at %X\") # Filter the name argument to letters only using regular expressions. URL arguments # can contain arbitrary text, so we restrict to safe characters only. match_object = re.match(\"[a-zA-Z]+\", name) if match_object: clean_name = match_object.group(0) else: clean_name = \"Friend\" content = \"Hello there, \" + clean_name + \"! It's \" + formatted_now return HttpResponse(content) The name variable defined in the URL route is given as an argument to the hello_there function. As described in the code comments, always filter arbitrary user-provided information to avoid various attacks on your app. In this case, the code filters the name argument to contain only letters, which avoids injection of control characters, HTML, and so forth. (When you use templates in the next section, Django does automatic filtering and you don't need this code.) Set a breakpoint at the first line of code in the hello_there function ( now = datetime.now() ) by doing any one of the following: With the cursor on that line, press kb(editor.debug.action.toggleBreakpoint) , or, With the cursor on that line, select the Run > Toggle Breakpoint menu command, or, Click directly in the margin to the left of the line number (a faded red dot appears when hovering there). The breakpoint appears as a red dot in the left margin: Start the debugger by selecting the Run > Start Debugging menu command, or selecting the green Start Debugging arrow next to the list ( kb(workbench.action.debug.continue) ): Observe that the status bar changes color to indicate debugging: A debugging toolbar (shown below) also appears in VS Code containing commands in the following order: Pause (or Continue, kb(workbench.action.debug.continue) ), Step Over ( kb(workbench.action.debug.stepOver) ), Step Into ( kb(workbench.action.debug.stepInto) ), Step Out ( kb(workbench.action.debug.stepOut) ), Restart ( kb(workbench.action.debug.restart) ), and Stop ( kb(workbench.action.debug.stop) ). See VS Code debugging for a description of each command. Output appears in a \"Python Debug Console\" terminal. Open a browser and navigate to http://127.0.0.1:8000/hello/VSCode . Before the page renders, VS Code pauses the program at the breakpoint you set. The small yellow arrow on the breakpoint indicates that it's the next line of code to run. Use Step Over to run the now = datetime.now() statement. On the left side of the VS Code window, you see a Variables pane that shows local variables, such as now , as well as arguments, such as name . Below that are panes for Watch , Call Stack , and Breakpoints (see VS Code debugging for details). In the Locals section, try expanding different values. You can also double-click values (or use kb(debug.setVariable) ) to modify them. Changing variables such as now , however, can break the program. Developers typically make changes only to correct values when the code didn't produce the right value to begin with. When a program is paused, the Debug Console panel (which is different from the \"Python Debug Console\" in the Terminal panel) lets you experiment with expressions and try out bits of code using the current state of the program. For example, once you've stepped over the line now = datetime.now() , you might experiment with different date/time formats. In the editor, select the code that reads now.strftime(\"%A, %d %B, %Y at %X\") , then right-click and select Debug: Evaluate to send that code to the debug console, where it runs: now.strftime(\"%A, %d %B, %Y at %X\") 'Friday, 07 September, 2018 at 07:46:32' Tip : The Debug Console also shows exceptions from within the app that may not appear in the terminal. For example, if you see a \"Paused on exception\" message in the Call Stack area of Run view, switch to the Debug Console to see the exception message. Copy that line into the > prompt at the bottom of the debug console, and try changing the formatting: now.strftime(\"%a, %d %B, %Y at %X\") 'Fri, 07 September, 2018 at 07:46:32' now.strftime(\"%a, %d %b, %Y at %X\") 'Fri, 07 Sep, 2018 at 07:46:32' now.strftime(\"%a, %d %b, %y at %X\") 'Fri, 07 Sep, 18 at 07:46:32' Note : If you see a change you like, you can copy and paste it into the editor during a debugging session. However, those changes aren't applied until you restart the debugger. Step through a few more lines of code, if you'd like, then select Continue ( kb(workbench.action.debug.continue) ) to let the program run. The browser window shows the result: Close the browser and stop the debugger when you're finished. To stop the debugger, use the Stop toolbar button (the red square) or the Run > Stop Debugging command ( kb(workbench.action.debug.stop) ). Tip : To make it easier to repeatedly navigate to a specific URL like http://127.0.0.1:8000/hello/VSCode , output that URL using a print statement somewhere in a file like views.py . The URL appears in the VS Code Terminal where you can use kbstyle(Ctrl+click) to open it in a browser. Go to Definition and Peek Definition commands During your work with Django or any other library, you may want to examine the code in those libraries themselves. VS Code provides two convenient commands that navigate directly to the definitions of classes and other objects in any code: Go to Definition jumps from your code into the code that defines an object. For example, in views.py , right-click on HttpResponse in the home function and select Go to Definition (or use kb(editor.action.revealDefinition) ), which navigates to the class definition in the Django library. Peek Definition ( kb(editor.action.peekDefinition) , also on the right-click context menu), is similar, but displays the class definition directly in the editor (making space in the editor window to avoid obscuring any code). Press kbstyle(Escape) to close the Peek window or use the x in the upper right corner. Use a template to render a page The app you've created so far in this tutorial generates only plain text web pages from Python code. Although it's possible to generate HTML directly in code, developers avoid such a practice because it opens the app to cross-site scripting (XSS) attacks . In the hello_there function of this tutorial, for example, one might think to format the output in code with something like content = \"<h1>Hello there, \" + clean_name + \"!</h1> , where the result in content is given directly to a browser. This opening allows an attacker to place malicious HTML, including JavaScript code, in the URL that ends up in clean_name and thus ends up being run in the browser. A much better practice is to keep HTML out of your code entirely by using templates , so that your code is concerned only with data values and not with rendering. In Django, a template is an HTML file that contains placeholders for values that the code provides at run time. The Django templating engine then takes care of making the substitutions when rendering the page, and provides automatic escaping to prevent XSS attacks (that is, if you tried using HTML in a data value, you would see the HTML rendered only as plain text). The code, therefore, concerns itself only with data values and the template concerns itself only with markup. Django templates provide flexible options such as template inheritance, which allows you to define a base page with common markup and then build upon that base with page-specific additions. In this section, you start by creating a single page using a template. In subsequent sections, you configure the app to serve static files and then create multiple pages to the app that each contains a nav bar from a base template. Django templates also support control flow and iteration, as you see later in this tutorial in the context of template debugging. In the web_project/settings.py file, locate the INSTALLED_APPS list and add the following entry, which makes sure the project knows about the app so it can handle templating: 'hello', Inside the hello folder, create a folder named templates , and then another subfolder named hello to match the app name (this two-tiered folder structure is typical Django convention). In the templates/hello folder, create a file named hello_there.html with the contents below. This template contains two placeholders for data values named \"name\", and \"date\", which are delineated by pairs of curly braces, \\{{ and }} . All other invariant text is part of the template, along with formatting markup (such as <strong> ). As you can see, template placeholders can also include formatting, the expressions after the pipe | symbols, in this case using Django's built-in date filter and time filter . The code, then needs only to pass the datetime value rather than a pre-formatted string: <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <title>Hello, Django</title> </head> <body> <strong>Hello there, \\{{ name }}!</strong> It's \\{{ date | date:\"l, d F, Y\" }} at \\{{ date | time:\"H:i:s\" }} </body> </html> At the top of views.py , add the following import statement: from django.shortcuts import render Also in views.py , modify the hello_there function to use django.shortcuts.render method to load a template and to provide the template context . The context is the set of variables for use within the template. The render function takes the request object, followed by the path to to the template relative to the templates folder , then the context object. (Developers typically name the templates the same as the functions that use them, but matching names are not required because you always refer to the exact filename in your code.) def hello_there(request, name): return render( request, 'hello/hello_there.html', { 'name': name, 'date': datetime.now() } ) You can see that the code is now much simpler, and concerned only with data values, because the markup and formatting is all contained in the template. Start the program (inside or outside of the debugger, using kb(workbench.action.debug.run) ), navigate to a /hello/name URL, and observe the results. Also try navigating to a /hello/name URL using a name like <a%20value%20that%20could%20be%20HTML> to see Django's automatic escaping at work. The \"name\" value shows up as plain text in the browser rather than as rendering an actual element. Serve static files Static files are pieces of content that your web app returns as-is for certain requests, such as CSS files. Serving static files requires that the INSTALLED_APPS list in settings.py contains django.contrib.staticfiles , which is included by default. Serving static files in Django is something of an art, especially when deploying to production. What's shown here is a simple approach that works with the Django development server and also a production server like Gunicorn. A full treatment of static files, however, is beyond the scope of this tutorial, so for more information, see Managing static files in the Django documentation. In production, you also need to set DEBUG=False in settings.py , which necessitates some additional work when using containers. For details, see Issue 13 . Ready the app for static files In the project's web_project/urls.py , add the following import statement: from django.contrib.staticfiles.urls import staticfiles_urlpatterns In that same file, add the following line at the end, which includes standard static file URLs to the list that the project recognizes: urlpatterns += staticfiles_urlpatterns() Refer to static files in a template In the hello folder, create a folder named static . Within the static folder, create a subfolder named hello , matching the app name. The reason for this extra subfolder is that when you deploy the Django project to a production server, you collect all the static files into a single folder that's then served by a dedicated static file server. The static/hello subfolder ensures that when the app's static files are collected, they're in an app-specific subfolder and won't collide with file from other apps in the same project. In the static/hello folder, create a file named site.css with the following contents. After entering this code, also observe the syntax highlighting that VS Code provides for CSS files, including a color preview. .message { font-weight: 600; color: blue; } In templates/hello/hello_there.html , add the following lines after the <title> element. The {% load static %} tag is a custom Django template tag set, which allows you to use {% static %} to refer to a file like the stylesheet. {% load static %} <link rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'hello/site.css' %}\" /> Also in templates/hello/hello_there.html , replace the contents <body> element with the following markup that uses the message style instead of a <strong> tag: <span class=\"message\">Hello, there \\{{ name }}!</span> It's \\{{ date | date:'l, d F, Y' }} at \\{{ date | time:'H:i:s' }}. Run the app, navigate to a /hello/name URL, and observe that the message renders in blue. Stop the app when you're done. Use the collectstatic command For production deployments, you typically collect all the static files from your apps into a single folder using the python manage.py collectstatic command. You can then use a dedicated static file server to serve those files, which typically results in better overall performance. The following steps show how this collection is made, although you don't use the collection when running with the Django development server. In web_project/settings.py , add the following line that defines a location where static files are collected when you use the collectstatic command: STATIC_ROOT = BASE_DIR / 'static_collected' In the Terminal, run the command python manage.py collectstatic and observe that hello/site.css is copied into the top level static_collected folder alongside manage.py . In practice, run collectstatic any time you change static files and before deploying into production. Create multiple templates that extend a base template Because most web apps have more than one page, and because those pages typically share many common elements, developers separate those common elements into a base page template that other page templates then extend. (This is also called template inheritance, meaning the extended pages inherit elements from the base page.) Also, because you'll likely create many pages that extend the same template, it's helpful to create a code snippet in VS Code with which you can quickly initialize new page templates. A snippet helps you avoid tedious and error-prone copy-paste operations. The following sections walk through different parts of this process. Create a base page template and styles A base page template in Django contains all the shared parts of a set of pages, including references to CSS files, script files, and so forth. Base templates also define one or more block tags with content that extended templates are expected to override. A block tag is delineated by {% block <name> %} and {% endblock %} in both the base template and extended templates. The following steps demonstrate creating a base template. In the templates/hello folder, create a file named layout.html with the contents below, which contains blocks named \"title\" and \"content\". As you can see, the markup defines a simple nav bar structure with links to Home, About, and Contact pages, which you create in a later section. Notice the use of Django's {% url %} tag to refer to other pages through the names of the corresponding URL patterns rather than by relative path. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"/> <title>{% block title %}{% endblock %}</title> {% load static %} <link rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'hello/site.css' %}\"/> </head> <body> <div class=\"navbar\"> <a href=\"{% url 'home' %}\" class=\"navbar-brand\">Home</a> <a href=\"{% url 'about' %}\" class=\"navbar-item\">About</a> <a href=\"{% url 'contact' %}\" class=\"navbar-item\">Contact</a> </div> <div class=\"body-content\"> {% block content %} {% endblock %} <hr/> <footer> <p>&copy; 2018</p> </footer> </div> </body> </html> Add the following styles to static/hello/site.css below the existing \"message\" style, and save the file. (This walkthrough doesn't attempt to demonstrate responsive design; these styles simply generate a reasonably interesting result.) .navbar { background-color: lightslategray; font-size: 1em; font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif; color: white; padding: 8px 5px 8px 5px; } .navbar a { text-decoration: none; color: inherit; } .navbar-brand { font-size: 1.2em; font-weight: 600; } .navbar-item { font-variant: small-caps; margin-left: 30px; } .body-content { padding: 5px; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } You can run the app at this point, but because you haven't made use of the base template anywhere and haven't changed any code files, the result is the same as the previous step. Complete the remaining sections to see the final effect. Create a code snippet Because the three pages you create in the next section extend layout.html , it saves time to create a code snippet to initialize a new template file with the appropriate reference to the base template. A code snippet provides a consistent piece of code from a single source, which avoids errors that can creep in when using copy-paste from existing code. In VS Code, select the File (Windows/Linux) or Code (macOS), menu, then select Preferences > User snippets . In the list that appears, select html . (The option may appear as \"html.json\" in the Existing Snippets section of the list if you've created snippets previously.) After VS code opens html.json , add the code below within the existing curly braces. (The explanatory comments, not shown here, describe details such as how the $0 line indicates where VS Code places the cursor after inserting a snippet): \"Django Tutorial: template extending layout.html\": { \"prefix\": \"djextlayout\", \"body\": [ \"{% extends \\\"hello/layout.html\\\" %}\", \"{% block title %}\", \"$0\", \"{% endblock %}\", \"{% block content %}\", \"{% endblock %}\" ], \"description\": \"Boilerplate template that extends layout.html\" }, Save the html.json file ( kb(workbench.action.files.save) ). Now, whenever you start typing the snippet's prefix, such as djext , VS Code provides the snippet as an autocomplete option, as shown in the next section. You can also use the Insert Snippet command to choose a snippet from a menu. For more information on code snippets in general, refer to Creating snippets . Use the code snippet to add pages With the code snippet in place, you can quickly create templates for the Home, About, and Contact pages. In the templates/hello folder, create a new file named home.html , Then start typing djext to see the snippet appear as a completion: When you select the completion, the snippet's code appears with the cursor on the snippet's insertion point: At the insertion point in the \"title\" block, write Home , and in the \"content\" block, write <p>Home page for the Visual Studio Code Django tutorial.</p> , then save the file. These lines are the only unique parts of the extended page template: In the templates/hello folder, create about.html , use the snippet to insert the boilerplate markup, insert About us and <p>About page for the Visual Studio Code Django tutorial.</p> in the \"title\" and \"content\" blocks, respectively, then save the file. Repeat the previous step to create templates/hello/contact.html using Contact us and <p>Contact page for the Visual Studio Code Django tutorial.</p> . In the app's urls.py , add routes for the /about and /contact pages. Be mindful that the name argument to the path function defines the name with which you refer to the page in the {% url %} tags in the templates. path(\"about/\", views.about, name=\"about\"), path(\"contact/\", views.contact, name=\"contact\"), In views.py , add functions for the /about and /contact routes that refer to their respective page templates. Also modify the home function to use the home.html template. # Replace the existing home function with the one below def home(request): return render(request, \"hello/home.html\") def about(request): return render(request, \"hello/about.html\") def contact(request): return render(request, \"hello/contact.html\") Run the app With all the page templates in place, save views.py , run the app, and open a browser to the home page to see the results. Navigate between the pages to verify that the page templates are properly extending the base template. Work with data, data models, and migrations Many web apps work with information stored in a database, and Django makes it easy to represent the objects in that database using models . In Django, a model is a Python class, derived from django.db.models.Model , that represents a specific database object, typically a table. You place these classes in an app's models.py file. With Django, your work with your database almost exclusively through the models you define in code. Django's \"migrations\" then handle all the details of the underlying database automatically as you evolve the models over time. The general workflow is as follows: Make changes to the models in your models.py file. Run python manage.py makemigrations to generate scripts in the migrations folder that migrate the database from its current state to the new state. Run python manage.py migrate to apply the scripts to the actual database. The migration scripts effectively record all the incremental changes you make to your data models over time. By applying the migrations, Django updates the database to match your models. Because each incremental change has its own script, Django can automatically migrate any previous version of a database (including a new database) to the current version. As a result, you need concern yourself only with your models in models.py , never with the underlying database schema or the migration scripts. You let Django do that part! In code, too, you work exclusively with your model classes to store and retrieve data; Django handles the underlying details. The one exception is that you can write data into your database using the Django administrative utility loaddata command . This utility is often used to initialize a data set after the migrate command has initialized the schema. When using the db.sqlite3 file, you can also work directly with the database using a tool like the SQLite browser . It's fine to add or delete records in tables using such a tool, but avoid making changes to the database schema because the database will then be out of sync with your app's models. Instead, change the models, run makemigrations , then run migrate . Types of databases By default, Django includes a db.sqlite3 file for an app's database that's suitable for development work. As described on When to use SQLite (sqlite.org), SQLite works fine for low to medium traffic sites with fewer than 100 K hits/day, but is not recommended for higher volumes. It's also limited to a single computer, so it cannot be used in any multi-server scenario such as load-balancing and geo-replication. For these reasons, consider using a production-level data store such as PostgreSQL , MySQL , and SQL Server . For information on Django's support for other databases, see Database setup . You can also use the Azure SDK for Python to work with Azure storage services like tables and blobs. Define models A Django model is again a Python class derived from django.db.model.Models , which you place in the app's models.py file. In the database, each model is automatically given a unique ID field named id . All other fields are defined as properties of the class using types from django.db.models such as CharField (limited text), TextField (unlimited text), EmailField , URLField , IntegerField , DecimalField , BooleanField . DateTimeField , ForeignKey , and ManyToMany , among others. (See the Model field reference in the Django documentation for details.) Each field takes some attributes, like max_length . The blank=True attribute means the field is optional; null=true means that a value is optional. There is also a choices attribute that limits values to values in an array of data value/display value tuples. For example, add the following class in models.py to define a data model that represents dated entries in a simple message log: from django.db import models from django.utils import timezone class LogMessage(models.Model): message = models.CharField(max_length=300) log_date = models.DateTimeField(\"date logged\") def __str__(self): \"\"\"Returns a string representation of a message.\"\"\" date = timezone.localtime(self.log_date) return f\"'{self.message}' logged on {date.strftime('%A, %d %B, %Y at %X')}\" A model class can include methods that return values computed from other class properties. Models typically include a __str__ method that returns a string representation of the instance. Migrate the database Because you changed your data models by editing models.py , you need to update the database itself. In VS Code, open a Terminal with your virtual environment activated (use the Terminal: Create New Integrated Terminal command, kb(workbench.action.terminal.new) )), navigate to the project folder, and run the following commands: python manage.py makemigrations python manage.py migrate Take a look in the migrations folder to see the scripts that makemigrations generates. You can also look at the database itself to see that the schema is updated. If you see errors when running the commands, make sure you're not using a debugging terminal that's left over from previous steps, as they may not have the virtual environment activated. Use the database through the models With your models in place and the database migrated, you can store and retrieve data using only your models. In this section, you add a form page to the app through which you can log a message. You then modify the home page to display those messages. Because you modify many code files here, be mindful of the details. In the hello folder (where you have views.py ), create a new file named forms.py with the following code, which defines a Django form that contains a field drawn from the data model, LogMessage : from django import forms from hello.models import LogMessage class LogMessageForm(forms.ModelForm): class Meta: model = LogMessage fields = (\"message\",) # NOTE: the trailing comma is required In the templates/hello folder, create a new template named log_message.html with the following contents, which assumes that the template is given a variable named form to define the body of the form. It then adds a submit button with the label \"Log\". {% extends \"hello/layout.html\" %} {% block title %} Log a message {% endblock %} {% block content %} <form method=\"POST\" class=\"log-form\"> {% csrf_token %} \\{{ form.as_p }} <button type=\"submit\" class=\"save btn btn-default\">Log</button> </form> {% endblock %} Note : Django's {% csrf_token %} tag provides protection from cross-site request forgeries. See Cross Site Request Forgery protection in the Django documentation for details. In the app's static/hello/site.css file, add a rule to make the input form wider: input[name=message] { width: 80%; } In the app's urls.py file, add a route for the new page: path(\"log/\", views.log_message, name=\"log\"), In views.py , define the view named log_message (as referred to by the URL route). This view handles both HTTP GET and POST cases. In the GET case (the else: section), it just displays the form that you defined in the previous steps. In the POST case, it retrieves the data from the form into a data object ( message ), sets the timestamp, then saves that object at which point it's written to the database: # Add these to existing imports at the top of the file: from django.shortcuts import redirect from hello.forms import LogMessageForm from hello.models import LogMessage # Add this code elsewhere in the file: def log_message(request): form = LogMessageForm(request.POST or None) if request.method == \"POST\": if form.is_valid(): message = form.save(commit=False) message.log_date = datetime.now() message.save() return redirect(\"home\") else: return render(request, \"hello/log_message.html\", {\"form\": form}) One more step before you're ready to try everything out! In templates/hello/layout.html , add a link in the \"navbar\" div for the message logging page: <!-- Insert below the link to Home --> <a href=\"{% url 'log' %}\" class=\"navbar-item\">Log Message</a> Run the app and open a browser to the home page. Select the Log Message link on the nav bar, which should display the message logging page: Enter a message, select Log , and you should be taken back to the home page. The home page doesn't yet show any of the logged messages yet (which you remedy in a moment). Feel free to log a few more messages as well. If you want, peek in the database using a tool like SQLite Browser to see that records have been created. Open the database as read-only, or otherwise remember to close the database before using the app, otherwise the app will fail because the database is locked. Stop the app when you're done. Now modify the home page to display the logged messages. Start by replacing the contents of app's templates/hello/home.html file with the markup below. This template expects a context variable named message_list . If it receives one (checked with the {% if message_list %} tag), it then iterates over that list (the {% for message in message_list %} tag) to generate table rows for each message. Otherwise the page indicates that no messages have yet been logged. {% extends \"hello/layout.html\" %} {% block title %} Home {% endblock %} {% block content %} <h2>Logged messages</h2> {% if message_list %} <table class=\"message_list\"> <thead> <tr> <th>Date</th> <th>Time</th> <th>Message</th> </tr> </thead> <tbody> {% for message in message_list %} <tr> <td>\\{{ message.log_date | date:'d M Y' }}</td> <td>\\{{ message.log_date | time:'H:i:s' }}</td> <td> \\{{ message.message }} </td> </tr> {% endfor %} </tbody> </table> {% else %} <p>No messages have been logged. Use the <a href=\"{% url 'log' %}\">Log Message form</a>.</p> {% endif %} {% endblock %} In static/hello/site.css , add a rule to format the table a little: .message_list th,td { text-align: left; padding-right: 15px; } In views.py , import Django's generic ListView class, which we'll use to implement the home page: from django.views.generic import ListView Also in views.py , replace the home function with a class named HomeListView , derived from ListView , which ties itself to the LogMessage model and implements a function get_context_data to generate the context for the template. # Remove the old home function if you want; it's no longer used class HomeListView(ListView): \"\"\"Renders the home page, with a list of all messages.\"\"\" model = LogMessage def get_context_data(self, **kwargs): context = super(HomeListView, self).get_context_data(**kwargs) return context In the app's urls.py , import the data model: from hello.models import LogMessage Also in urls.py , make a variable for the new view, which retrieves the five most recent LogMessage objects in descending order (meaning that it queries the database), and then provides a name for the data in the template context ( message_list ), and identifies the template to use: home_list_view = views.HomeListView.as_view( queryset=LogMessage.objects.order_by(\"-log_date\")[:5], # :5 limits the results to the five most recent context_object_name=\"message_list\", template_name=\"hello/home.html\", ) In urls.py , modify the path to the home page to use the home_list_view variable: # Replace the existing path for \"\" path(\"\", home_list_view, name=\"home\"), Start the app and open a browser to the home page, which should now display messages: Stop the app when you're done. Use the debugger with page templates As shown in the previous section, page templates can contain procedural directives like {% for message in message_list %} and {% if message_list %} , rather than only passive, declarative elements like {% url %} and {% block %} . As a result, you can have programming errors inside templates as with any other procedural code. Fortunately, the Python Extension for VS Code provides template debugging when you have \"django\": true in the debugging configuration (as you do already). The following steps demonstrate this capability: In templates/hello/home.html , set breakpoints on both the {% if message_list %} and {% for message in message_list %} lines, as indicated by the yellow arrows in the image below: Run the app in the debugger and open a browser to the home page. (If you're already running the debugger, you don't have to restart the app after setting breakpoints; just refresh the page.) Observe that VS Code breaks into the debugger in the template on the {% if %} statement and shows all the context variables in the Variables pane: Use the Step Over ( kb(workbench.action.debug.stepOver) ) command to step through the template code. Observe that the debugger steps over all declarative statements and pauses at any procedural code. For example, stepping through the {% for message in message_list %} loops lets you examine each value in message and lets you step to lines like <td>\\{{ message.log_date | date:'d M Y' }}</td> . You can also work with variables in the Debug Console panel. (Django filters like date , however, are not presently available in the console.) When you're ready, select Continue ( kb(workbench.action.debug.continue) ) to finish running the app and view the rendered page in the browser. Stop the debugger when you're done. Optional activities The following sections describe additional steps that you might find helpful in your work with Python and Visual Studio Code. Create a requirements.txt file for the environment When you share your app code through source control or some other means, it doesn't make sense to copy all the files in a virtual environment because recipients can always recreate that environment themselves. Accordingly, developers typically omit the virtual environment folder from source control and instead describe the app's dependencies using a requirements.txt file. Although you can create the file by hand, you can also use the pip freeze command to generate the file based on the exact libraries installed in the activated environment: With your chosen environment selected using the Python: Select Interpreter command, run the Terminal: Create New Integrated Terminal command ( kb(workbench.action.terminal.new) )) to open a terminal with that environment activated. In the terminal, run pip freeze > requirements.txt to create the requirements.txt file in your project folder. Anyone (or any build server) that receives a copy of the project needs only to run the pip install -r requirements.txt command to reinstall the packages on which the app depends within the active environment. Note : pip freeze lists all the Python packages you have installed in the current environment, including packages you aren't currently using. The command also lists packages with exact version numbers, which you might want to convert to ranges for more flexibility in the future. For more information, see Requirements Files in the pip command documentation. Create a superuser and enable the administrative interface By default, Django provides an administrative interface for a web app that's protected by authentication. The interface is implemented through the built-in django.contrib.admin app, which is included by default in the project's INSTALLED_APPS list ( settings.py ), and authentication is handled with the built-in django.contrib.auth app, which is also in INSTALLED_APPS by default. Perform the following steps to enable the administrative interface: Create a superuser account in the app by opening a Terminal in VS Code for your virtual environment, then running the command python manage.py createsuperuser --username=<username> --email=<email> , replacing <username> and <email> , of course, with your personal information. When you run the command, Django prompts you to enter and confirm your password. Be sure to remember your username and password combination. These are the credentials you use to authenticate with the app. Add the following URL route in the project-level urls.py ( web_project/urls.py in this tutorial) to point to the built-in administrative interface: # This path is included by default when creating the app path(\"admin/\", admin.site.urls), Run the server, then open a browser to the app's /admin page (such as http://127.0.0.1:8000/admin when using the development server). A login page appears, courtesy of django.contrib.auth . Enter your superuser credentials. Once you're authenticated, you see the default administration page, through which you can manage users and groups: You can customize the administrative interface as much as you like. For example, you could provide capabilities to edit and remove entries in the database. For more information on making customizations, refer to the Django admin site documentation . Create a container for a Django app using the Docker extension The Docker extension makes it easy to build, manage, and deploy containerized applications from Visual Studio Code. If you're interested in learning how to create a Python container for the Django app developed in this tutorial, check out the Python in a container tutorial, which will walk you through how to: Create a Dockerfile file describing a simple Python container. Build, run, and verify the functionality of a Django app. Debug the app running in a container. Next steps Congratulations on completing this walkthrough of working with Django in Visual Studio Code! The completed code project from this tutorial can be found on GitHub: python-sample-vscode-django-tutorial . In this tutorial, we've only scratched the surface of everything Django can do. Be sure to visit the Django documentation and the official Django tutorial for many more details on views, templates, data models, URL routing, the administrative interface, using other kinds of databases, deployment to production, and more. To try your app on a production website, check out the tutorial Deploy Python apps to Azure App Service using Docker Containers . Azure also offers a standard container, App Service on Linux , to which you deploy web apps from within VS Code. You may also want to review the following articles in the VS Code docs that are relevant to Python: Editing Python code Linting Managing Python environments Debugging Python Testing If you encountered any problems in the course of this tutorial, feel free to file an issue in the VS Code documentation repository ."
  },
  "guides/vscode/python/tutorial-flask.html": {
    "href": "guides/vscode/python/tutorial-flask.html",
    "title": "Flask Tutorial in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Flask Tutorial in Visual Studio Code Flask is a lightweight Python framework for web applications that provides the basics for URL routing and page rendering. Flask is called a \"micro\" framework because it doesn't directly provide features like form validation, database abstraction, authentication, and so on. Such features are instead provided by special Python packages called Flask extensions. The extensions integrate seamlessly with Flask so that they appear as if they were part of Flask itself. For example, Flask doesn't provide a page template engine, but installing Flask includes the Jinja templating engine by default. For convenience, we typically speak of these defaults as part of Flask. In this Flask tutorial, you create a simple Flask app with three pages that use a common base template. Along the way, you experience a number of features of Visual Studio Code including using the terminal, the editor, the debugger, code snippets, and more. The completed code project for this Flask tutorial can be found on GitHub: python-sample-vscode-flask-tutorial . If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . Prerequisites To successfully complete this Flask tutorial, you must do the following (which are the same steps as in the general Python tutorial ): Install the Python extension . Install a version of Python 3 (for which this tutorial is written). Options include: (All operating systems) A download from python.org ; typically use the Download Python 3.9.1 button that appears first on the page (or whatever is the latest version). (Linux) The built-in Python 3 installation works well, but to install other Python packages you must run sudo apt install python3-pip in the terminal. (macOS) An installation through Homebrew on macOS using brew install python3 (the system install of Python on macOS is not supported). (All operating systems) A download from Anaconda (for data science purposes). On Windows, make sure the location of your Python interpreter is included in your PATH environment variable. You can check the location by running path at the command prompt. If the Python interpreter's folder isn't included, open Windows Settings, search for \"environment\", select Edit environment variables for your account , then edit the Path variable to include that folder. Create a project environment for the Flask tutorial In this section, you create a virtual environment in which Flask is installed. Using a virtual environment avoids installing Flask into a global Python environment and gives you exact control over the libraries used in an application. A virtual environment also makes it easy to Create a requirements.txt file for the environment . On your file system, create a project folder for this tutorial, such as hello_flask . In that folder, use the following command (as appropriate to your computer) to create a virtual environment named env based on your current interpreter: # Linux sudo apt-get install python3-venv # If needed python3 -m venv env # macOS python3 -m venv env # Windows python -m venv env Note : Use a stock Python installation when running the above commands. If you use python.exe from an Anaconda installation, you see an error because the ensurepip module isn't available, and the environment is left in an unfinished state. Open the project folder in VS Code by running code . , or by running VS Code and using the File > Open Folder command. In VS Code, open the Command Palette ( View > Command Palette or ( kb(workbench.action.showCommands) )). Then select the Python: Select Interpreter command: The command presents a list of available interpreters that VS Code can locate automatically (your list will vary; if you don't see the desired interpreter, see Configuring Python environments ). From the list, select the virtual environment in your project folder that starts with ./env or .\\env : Run Terminal: Create New Integrated Terminal ( kb(workbench.action.terminal.new) )) from the Command Palette, which creates a terminal and automatically activates the virtual environment by running its activation script. Note : On Windows, if your default terminal type is PowerShell, you may see an error that it cannot run activate.ps1 because running scripts is disabled on the system. The error provides a link for information on how to allow scripts. Otherwise, use Terminal: Select Default Shell to set \"Command Prompt\" or \"Git Bash\" as your default instead. The selected environment appears on the left side of the VS Code status bar, and notice the \"(venv)\" indicator that tells you that you're using a virtual environment: Update pip in the virtual environment by running the following command in the VS Code Terminal: python -m pip install --upgrade pip Install Flask in the virtual environment by running the following command in the VS Code Terminal: python -m pip install flask You now have a self-contained environment ready for writing Flask code. VS Code activates the environment automatically when you use Terminal: Create New Integrated Terminal . If you open a separate command prompt or terminal, activate the environment by running source env/bin/activate (Linux/macOS) or env\\Scripts\\Activate.ps1 (Windows). You know the environment is activated when the command prompt shows (env) at the beginning. Create and run a minimal Flask app In VS Code, create a new file in your project folder named app.py using either File > New from the menu, pressing kbstyle(Ctrl+N) , or using the new file icon in the Explorer View (shown below). In app.py , add code to import Flask and create an instance of the Flask object. If you type the code below (instead of using copy-paste), you can observe VS Code's IntelliSense and auto-completions : from flask import Flask app = Flask(__name__) Also in app.py , add a function that returns content, in this case a simple string, and use Flask's app.route decorator to map the URL route / to that function: @app.route(\"/\") def home(): return \"Hello, Flask!\" Tip : You can use multiple decorators on the same function, one per line, depending on how many different routes you want to map to the same function. Save the app.py file ( kb(workbench.action.files.save) ). In the Integrated Terminal, run the app by entering python -m flask run , which runs the Flask development server. The development server looks for app.py by default. When you run Flask, you should see output similar to the following: (env) D:\\py\\\\hello_flask>python -m flask run * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) If you see an error that the Flask module cannot be found, make sure you've run python -m pip install flask in your virtual environment as described at the end of the previous section. Also, if you want to run the development server on a different IP address or port, use the host and port command-line arguments, as with --host=0.0.0.0 --port=80 . To open your default browser to the rendered page, kbstyle(Ctrl+click) the http://127.0.0.1:5000/ URL in the terminal. Observe that when you visit a URL like /, a message appears in the debug terminal showing the HTTP request: 127.0.0.1 - - [11/Jul/2018 08:40:15] \"GET / HTTP/1.1\" 200 - Stop the app by using kbstyle(Ctrl+C) in the terminal. Tip : If you want to use a different filename than app.py , such as program.py , define an environment variable named FLASK_APP and set its value to your chosen file. Flask's development server then uses the value of FLASK_APP instead of the default file app.py . For more information, see Flask command line interface . Run the app in the debugger Debugging gives you the opportunity to pause a running program on a particular line of code. When a program is paused, you can examine variables, run code in the Debug Console panel, and otherwise take advantage of the features described on Debugging . Running the debugger also automatically saves any modified files before the debugging session begins. Before you begin : Make sure you've stopped the running app at the end of the last section by using kbstyle(Ctrl+C) in the terminal. If you leave the app running in one terminal, it continues to own the port. As a result, when you run the app in the debugger using the same port, the original running app handles all the requests and you won't see any activity in the app being debugged and the program won't stop at breakpoints. In other words, if the debugger doesn't seem to be working, make sure that no other instance of the app is still running. Replace the contents of app.py with the following code, which adds a second route and function that you can step through in the debugger: from flask import Flask from datetime import datetime import re app = Flask(__name__) @app.route(\"/\") def home(): return \"Hello, Flask!\" @app.route(\"/hello/<name>\") def hello_there(name): now = datetime.now() formatted_now = now.strftime(\"%A, %d %B, %Y at %X\") # Filter the name argument to letters only using regular expressions. URL arguments # can contain arbitrary text, so we restrict to safe characters only. match_object = re.match(\"[a-zA-Z]+\", name) if match_object: clean_name = match_object.group(0) else: clean_name = \"Friend\" content = \"Hello there, \" + clean_name + \"! It's \" + formatted_now return content The decorator used for the new URL route, /hello/<name> , defines an endpoint /hello/ that can accept any additional value. The identifier inside < and > in the route defines a variable that is passed to the function and can be used in your code. URL routes are case-sensitive. For example, the route /hello/<name> is distinct from /Hello/<name> . If you want the same function to handle both, use decorators for each variant. As described in the code comments, always filter arbitrary user-provided information to avoid various attacks on your app. In this case, the code filters the name argument to contain only letters, which avoids injection of control characters, HTML, and so forth. (When you use templates in the next section, Flask does automatic filtering and you won't need this code.) Set a breakpoint at the first line of code in the hello_there function ( now = datetime.now() ) by doing any one of the following: With the cursor on that line, press kb(editor.debug.action.toggleBreakpoint) , or, With the cursor on that line, select the Run > Toggle Breakpoint menu command, or, Click directly in the margin to the left of the line number (a faded red dot appears when hovering there). The breakpoint appears as a red dot in the left margin: Switch to Run view in VS Code (using the left-side activity bar or kb(workbench.action.debug.start) ). You may see the message \"To customize Run and Debug create a launch.json file\". This means that you don't yet have a launch.json file containing debug configurations. VS Code can create that for you if you click on the create a launch.json file link: Select the link and VS Code will prompt for a debug configuration. Select Flask from the dropdown and VS Code will populate a new launch.json file with a Flask run configuration. The launch.json file contains a number of debugging configurations, each of which is a separate JSON object within the configuration array. Scroll down to and examine the configuration, which is named \"Python: Flask\". This configuration contains \"module\": \"flask\", , which tells VS Code to run Python with -m flask when it starts the debugger. It also defines the FLASK_APP environment variable in the env property to identify the startup file, which is app.py by default, but allows you to easily specify a different file. If you want to change the host and/or port, you can use the args array. { \"name\": \"Python: Flask\", \"type\": \"python\", \"request\": \"launch\", \"module\": \"flask\", \"env\": { \"FLASK_APP\": \"app.py\", \"FLASK_ENV\": \"development\", \"FLASK_DEBUG\": \"0\" }, \"args\": [ \"run\", \"--no-debugger\", \"--no-reload\" ], \"jinja\": true }, Note : If the env entry in your configuration contains \"FLASK_APP\": \"${workspaceFolder}/app.py\" , change it to \"FLASK_APP\": \"app.py\" as shown above. Otherwise you may encounter error messages like \"Cannot import module C\" where C is the drive letter where your project folder resides. Note : Once launch.json is created, an Add Configuration button appears in the editor. That button displays a list of additional configurations to add to the beginning of the configuration list. (The Run > Add Configuration menu command does the same action.). Save launch.json ( kb(workbench.action.files.save) ). In the debug configuration dropdown list select the Python: Flask configuration. Start the debugger by selecting the Run > Start Debugging menu command, or selecting the green Start Debugging arrow next to the list ( kb(workbench.action.debug.continue) ): Observe that the status bar changes color to indicate debugging: A debugging toolbar (shown below) also appears in VS Code containing commands in the following order: Pause (or Continue, kb(workbench.action.debug.continue) ), Step Over ( kb(workbench.action.debug.stepOver) ), Step Into ( kb(workbench.action.debug.stepInto) ), Step Out ( kb(workbench.action.debug.stepOut) ), Restart ( kb(workbench.action.debug.restart) ), and Stop ( kb(workbench.action.debug.stop) ). See VS Code debugging for a description of each command. Output appears in a \"Python Debug Console\" terminal. kbstyle(Ctrl+click) the http://127.0.0.1:5000/ link in that terminal to open a browser to that URL. In the browser's address bar, navigate to http://127.0.0.1:5000/hello/VSCode . Before the page renders, VS Code pauses the program at the breakpoint you set. The small yellow arrow on the breakpoint indicates that it's the next line of code to run. Use Step Over to run the now = datetime.now() statement. On the left side of the VS Code window, you see a Variables pane that shows local variables, such as now , as well as arguments, such as name . Below that are panes for Watch , Call Stack , and Breakpoints (see VS Code debugging for details). In the Locals section, try expanding different values. You can also double-click values (or use kb(debug.setVariable) ) to modify them. Changing variables such as now , however, can break the program. Developers typically make changes only to correct values when the code didn't produce the right value to begin with. When a program is paused, the Debug Console panel (which is different from the \"Python Debug Console\" in the Terminal panel) lets you experiment with expressions and try out bits of code using the current state of the program. For example, once you've stepped over the line now = datetime.now() , you might experiment with different date/time formats. In the editor, select the code that reads now.strftime(\"%A, %d %B, %Y at %X\") , then right-click and select Debug: Evaluate to send that code to the debug console, where it runs: now.strftime(\"%A, %d %B, %Y at %X\") 'Wednesday, 31 October, 2018 at 18:13:39' Tip : The Debug Console also shows exceptions from within the app that may not appear in the terminal. For example, if you see a \"Paused on exception\" message in the Call Stack area of Run view, switch to the Debug Console to see the exception message. Copy that line into the > prompt at the bottom of the debug console, and try changing the formatting: now.strftime(\"%a, %d %B, %Y at %X\") 'Wed, 31 October, 2018 at 18:13:39' now.strftime(\"%a, %d %b, %Y at %X\") 'Wed, 31 Oct, 2018 at 18:13:39' now.strftime(\"%a, %d %b, %y at %X\") 'Wed, 31 Oct, 18 at 18:13:39' Note : If you see a change you like, you can copy and paste it into the editor during a debugging session. However, those changes aren't applied until you restart the debugger. Step through a few more lines of code, if you'd like, then select Continue ( kb(workbench.action.debug.continue) ) to let the program run. The browser window shows the result: Close the browser and stop the debugger when you're finished. To stop the debugger, use the Stop toolbar button (the red square) or the Run > Stop Debugging command ( kb(workbench.action.debug.stop) ). Tip : To make it easier to repeatedly navigate to a specific URL like http://127.0.0.1:5000/hello/VSCode , output that URL using a print statement. The URL appears in the terminal where you can use kbstyle(Ctrl+click) to open it in a browser. Go to Definition and Peek Definition commands During your work with Flask or any other library, you may want to examine the code in those libraries themselves. VS Code provides two convenient commands that navigate directly to the definitions of classes and other objects in any code: Go to Definition jumps from your code into the code that defines an object. For example, in app.py , right-click on the Flask class (in the line app = Flask(__name__) ) and select Go to Definition (or use kb(editor.action.revealDefinition) ), which navigates to the class definition in the Flask library. Peek Definition ( kb(editor.action.peekDefinition) , also on the right-click context menu), is similar, but displays the class definition directly in the editor (making space in the editor window to avoid obscuring any code). Press kbstyle(Escape) to close the Peek window or use the x in the upper right corner. Use a template to render a page The app you've created so far in this tutorial generates only plain text web pages from Python code. Although it's possible to generate HTML directly in code, developers avoid such a practice because it opens the app to cross-site scripting (XSS) attacks . In the hello_there function of this tutorial, for example, one might think to format the output in code with something like content = \"<h1>Hello there, \" + clean_name + \"!</h1> , where the result in content is given directly to a browser. This opening allows an attacker to place malicious HTML, including JavaScript code, in the URL that ends up in clean_name and thus ends up being run in the browser. A much better practice is to keep HTML out of your code entirely by using templates , so that your code is concerned only with data values and not with rendering. A template is an HTML file that contains placeholders for values that the code provides at run time. The templating engine takes care of making the substitutions when rendering the page. The code, therefore, concerns itself only with data values and the template concerns itself only with markup. The default templating engine for Flask is Jinja , which is installed automatically when you install Flask. This engine provides flexible options including automatic escaping (to prevent XSS attacks) and template inheritance. With inheritance, you can define a base page with common markup and then build upon that base with page-specific additions. In this section, you create a single page using a template. In the sections that follow, you configure the app to serve static files, and then create multiple pages to the app that each contains a nav bar from a base template. Inside the hello_flask folder, create a folder named templates , which is where Flask looks for templates by default. In the templates folder, create a file named hello_there.html with the contents below. This template contains two placeholders named \"name\" and \"date\", which are delineated by pairs of curly braces, \\{{ and }} . As you can see, you can also include formatting code in the template directly: <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <title>Hello, Flask</title> </head> <body> {%if name %} <strong>Hello there, \\{{ name }}!</strong> It's \\{{ date.strftime(\"%A, %d %B, %Y at %X\") }}. {% else %} What's your name? Provide it after /hello/ in the URL. {% endif %} </body> </html> Tip : Flask developers often use the flask-babel extension for date formatting, rather than strftime , as flask-babel takes locales and timezones into consideration. In app.py , import Flask's render_template function near the top of the file: from flask import render_template Also in app.py , modify the hello_there function to use render_template to load a template and apply the named values (and add a route to recognize the case without a name). render_template assumes that the first argument is relative to the templates folder. Typically, developers name the templates the same as the functions that use them, but matching names are not required because you always refer to the exact filename in your code. @app.route(\"/hello/\") @app.route(\"/hello/<name>\") def hello_there(name = None): return render_template( \"hello_there.html\", name=name, date=datetime.now() ) You can see that the code is now much simpler, and concerned only with data values, because the markup and formatting is all contained in the template. Start the program (inside or outside of the debugger, using kb(workbench.action.debug.run) ), navigate to a /hello/name URL, and observe the results. Also try navigating to a /hello/name URL using a name like <a%20value%20that%20could%20be%20HTML> to see Flask's automatic escaping at work. The \"name\" value shows up as plain text in the browser rather than as rendering an actual element. Serve static files Static files are of two types. First are those files like stylesheets to which a page template can just refer directly. Such files can live in any folder in the app, but are commonly placed within a static folder. The second type are those that you want to address in code, such as when you want to implement an API endpoint that returns a static file. For this purpose, the Flask object contains a built-in method, send_static_file , which generates a response with a static file contained within the app's static folder. The following sections demonstrate both types of static files. Refer to static files in a template In the hello_flask folder, create a folder named static . Within the static folder, create a file named site.css with the following contents. After entering this code, also observe the syntax highlighting that VS Code provides for CSS files, including a color preview: .message { font-weight: 600; color: blue; } In templates/hello_there.html , add the following line before the </head> tag, which creates a reference to the stylesheet. <link rel=\"stylesheet\" type=\"text/css\" href=\"\\{{ url_for('static', filename='site.css')}}\" /> Flask's url_for tag that is used here, creates the appropriate path to the file. Because it can accept variables as arguments, url_for allows you to programmatically control the generated path, if desired. Also in templates/hello_there.html , replace the contents <body> element with the following markup that uses the message style instead of a <strong> tag (and also displays a message if you just use a hello/ URL without a name): {%if name %} <span class=\"message\">Hello there, \\{{ name }}!</span> It's \\{{ date.strftime(\"%A, %d %B, %Y at %X\") }}. {% else %} <span class=\"message\">What's your name? Provide it after /hello/ in the URL.</span> {% endif %} Run the app, navigate to a /hello/name URL, and observe that the message renders in blue. Stop the app when you're done. Serve a static file from code In the static folder, create a JSON data file named data.json with the following contents (which are meaningless sample data): { \"01\": { \"note\" : \"This data is very simple because we're demonstrating only the mechanism.\" } } In app.py , add a function with the route /api/data that returns the static data file using the send_static_file method: @app.route(\"/api/data\") def get_data(): return app.send_static_file(\"data.json\") Run the app and navigate to the /api/data endpoint to see that the static file is returned. Stop the app when you're done. Create multiple templates that extend a base template Because most web apps have more than one page, and because those pages typically share many common elements, developers separate those common elements into a base page template that other page templates can then extend. (This is also called template inheritance.) Also, because you'll likely create many pages that extend the same template, it's helpful to create a code snippet in VS Code with which you can quickly initialize new page templates. A snippet helps you avoid tedious and error-prone copy-paste operations. The following sections walk through different parts of this process. Create a base page template and styles A base page template in Flask contains all the shared parts of a set of pages, including references to CSS files, script files, and so forth. Base templates also define one or more block tags that other templates that extend the base are expected to override. A block tag is delineated by {% block <name> %} and {% endblock %} in both the base template and extended templates. The following steps demonstrate creating a base template. In the templates folder, create a file named layout.html with the contents below, which contains blocks named \"title\" and \"content\". As you can see, the markup defines a simple nav bar structure with links to Home, About, and Contact pages, which you create in a later section. Each link again uses Flask's url_for tag to generate a link at runtime for the matching route. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <title>{% block title %}{% endblock %}</title> <link rel=\"stylesheet\" type=\"text/css\" href=\"\\{{ url_for('static', filename='site.css')}}\" /> </head> <body> <div class=\"navbar\"> <a href=\"\\{{ url_for('home') }}\" class=\"navbar-brand\">Home</a> <a href=\"\\{{ url_for('about') }}\" class=\"navbar-item\">About</a> <a href=\"\\{{ url_for('contact') }}\" class=\"navbar-item\">Contact</a> </div> <div class=\"body-content\"> {% block content %} {% endblock %} <hr/> <footer> <p>&copy; 2018</p> </footer> </div> </body> </html> Add the following styles to static/site.css below the existing \"message\" style, and save the file. (This walkthrough doesn't attempt to demonstrate responsive design; these styles simply generate a reasonably interesting result.) .navbar { background-color: lightslategray; font-size: 1em; font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif; color: white; padding: 8px 5px 8px 5px; } .navbar a { text-decoration: none; color: inherit; } .navbar-brand { font-size: 1.2em; font-weight: 600; } .navbar-item { font-variant: small-caps; margin-left: 30px; } .body-content { padding: 5px; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; } You can run the app at this point, but because you haven't made use of the base template anywhere and haven't changed any code files, the result is the same as the previous step. Complete the remaining sections to see the final effect. Create a code snippet Because the three pages you create in the next section extend layout.html , it saves time to create a code snippet to initialize a new template file with the appropriate reference to the base template. A code snippet provides a consistent piece of code from a single source, which avoids errors that can creep in when using copy-paste from existing code. In VS Code, select the File (Windows/Linux) or Code (macOS), menu, then select Preferences > User snippets . In the list that appears, select html . (The option may appear as \"html.json\" in the Existing Snippets section of the list if you've created snippets previously.) After VS code opens html.json , add the following entry within the existing curly braces (the explanatory comments, not shown here, describe details such as how the $0 line indicates where VS Code places the cursor after inserting a snippet): \"Flask Tutorial: template extending layout.html\": { \"prefix\": \"flextlayout\", \"body\": [ \"{% extends \\\"layout.html\\\" %}\", \"{% block title %}\", \"$0\", \"{% endblock %}\", \"{% block content %}\", \"{% endblock %}\" ], \"description\": \"Boilerplate template that extends layout.html\" }, Save the html.json file ( kb(workbench.action.files.save) ). Now, whenever you start typing the snippet's prefix, such as flext , VS Code provides the snippet as an autocomplete option, as shown in the next section. You can also use the Insert Snippet command to choose a snippet from a menu. For more information on code snippets in general, refer to Creating snippets . Use the code snippet to add pages With the code snippet in place, you can quickly create templates for the Home, About, and Contact pages. In the templates folder, create a new file named home.html , Then start typing flext to see the snippet appear as a completion: When you select the completion, the snippet's code appears with the cursor on the snippet's insertion point: At the insertion point in the \"title\" block, write Home , and in the \"content\" block, write <p>Home page for the Visual Studio Code Flask tutorial.</p> , then save the file. These lines are the only unique parts of the extended page template: In the templates folder, create about.html , use the snippet to insert the boilerplate markup, insert About us and <p>About page for the Visual Studio Code Flask tutorial.</p> in the \"title\" and \"content\" blocks, respectively, then save the file. Repeat the previous step to create templates/contact.html using Contact us and <p>Contact page for the Visual Studio Code Flask tutorial.</p> in the two content blocks. In app.py , add functions for the /about/ and /contact/ routes that refer to their respective page templates. Also modify the home function to use the home.html template. # Replace the existing home function with the one below @app.route(\"/\") def home(): return render_template(\"home.html\") # New functions @app.route(\"/about/\") def about(): return render_template(\"about.html\") @app.route(\"/contact/\") def contact(): return render_template(\"contact.html\") Run the app With all the page templates in place, save app.py , run the app, and open a browser to see the results. Navigate between the pages to verify that the page templates are properly extending the base template. Note : If you're not seeing the latest changes, you might need to do a hard refresh on the page to avoid seeing a cached file. Optional activities The following sections describe additional steps that you might find helpful in your work with Python and Visual Studio Code. Create a requirements.txt file for the environment When you share your app code through source control or some other means, it doesn't make sense to copy all the files in a virtual environment because recipients can always recreate the environment themselves. Accordingly, developers typically omit the virtual environment folder from source control and instead describe the app's dependencies using a requirements.txt file. Although you can create the file by hand, you can also use the pip freeze command to generate the file based on the exact libraries installed in the activated environment: With your chosen environment selected using the Python: Select Interpreter command, run the Terminal: Create New Integrated Terminal command ( kb(workbench.action.terminal.new) )) to open a terminal with that environment activated. In the terminal, run pip freeze > requirements.txt to create the requirements.txt file in your project folder. Anyone (or any build server) that receives a copy of the project needs only to run the pip install -r requirements.txt command to reinstall the packages in the original the environment. (The recipient still needs to create their own virtual environment, however.) Note : pip freeze lists all the Python packages you have installed in the current environment, including packages you aren't currently using. The command also lists packages with exact version numbers, which you might want to convert to ranges for more flexibility in the future. For more information, see Requirements Files in the pip command documentation. Refactor the project to support further development Throughout this Flask tutorial, all the app code is contained in a single app.py file. To allow for further development and to separate concerns, it's helpful to refactor the pieces of app.py into separate files. In your project folder, create a folder for the app, such as hello_app , to separate its files from other project-level files like requirements.txt and the .vscode folder where VS Code stores settings and debug configuration files. Move the static and templates folders into hello_app , because these folders certainly contain app code. In the hello_app folder, create a file named views.py that contains the routings and the view functions: from flask import Flask from flask import render_template from datetime import datetime from . import app @app.route(\"/\") def home(): return render_template(\"home.html\") @app.route(\"/about/\") def about(): return render_template(\"about.html\") @app.route(\"/contact/\") def contact(): return render_template(\"contact.html\") @app.route(\"/hello/\") @app.route(\"/hello/<name>\") def hello_there(name = None): return render_template( \"hello_there.html\", name=name, date=datetime.now() ) @app.route(\"/api/data\") def get_data(): return app.send_static_file(\"data.json\") Optional: Right-click in the editor and select the Sort Imports command, which consolidates imports from identical modules, removes unused imports, and sorts your import statements. Using the command on the code above in views.py changes the imports as follows (you can remove the extra lines, of course): from datetime import datetime from flask import Flask, render_template from . import app In the hello_app folder, create a file __init__.py with the following contents: import flask app = flask.Flask(__name__) In the hello_app folder, create a file webapp.py with the following contents: # Entry point for the application. from . import app # For application discovery by the 'flask' command. from . import views # For import side-effects of setting up routes. Open the debug configuration file launch.json and update the env property as follows to point to the startup object: \"env\": { \"FLASK_APP\": \"hello_app.webapp\" }, Delete the original app.py file in the project root, as its contents have been moved into other app files. Your project's structure should now be similar to the following: Run the app in the debugger again to make sure everything works. To run the app outside of the VS Code debugger, use the following steps from a terminal: Set an environment variable for FLASK_APP . On Linux and macOS, use export set FLASK_APP=webapp ; on Windows use set FLASK_APP=webapp . Navigate into the hello_app folder, then launch the program using python -m flask run . Create a container for a Flask app using the Docker extension The Docker extension makes it easy to build, manage, and deploy containerized applications from Visual Studio Code. If you're interested in learning how to create a Python container for the Flask app developed in this tutorial, check out the Python in a container tutorial, which will walk you through how to: Create a Dockerfile file describing a simple Python container. Build, run, and verify the functionality of a Flask app. Debug the app running in a container. If you have any problems, feel free to file an issue for this tutorial in the VS Code documentation repository . Next steps Congratulations on completing this walkthrough of working with Flask in Visual Studio Code! The completed code project from this tutorial can be found on GitHub: python-sample-vscode-flask-tutorial . Because this tutorial has only scratched the surface of page templates, refer to the Jinja2 documentation for more information about templates. The Template Designer Documentation contains all the details on the template language. You might also want to review the official Flask tutorial as well as the documentation for Flask extensions . To try your app on a production website, check out the tutorial Deploy Python apps to Azure App Service using Docker Containers . Azure also offers a standard container, App Service on Linux , to which you deploy web apps from within VS Code. You may also want to review the following articles in the VS Code docs that are relevant to Python: Editing Python code Linting Managing Python environments Debugging Python Testing If you encountered any problems in the course of this tutorial, feel free to file an issue in the VS Code documentation repository ."
  },
  "guides/vscode/remote/attach-container.html": {
    "href": "guides/vscode/remote/attach-container.html",
    "title": "Attach to a running container | Fountain of Knowledge",
    "keywords": "Attach to a running container Visual Studio Code can create and start containers for you but that may not match your workflow and you may prefer to \"attach\" VS Code to an already running Docker container - regardless of how it was started. Once attached, you can install extensions, edit, and debug like you can when you open a folder in a container using devcontainer.json . Attach to a Docker container To attach to a Docker container, either select Remote-Containers: Attach to Running Container... from the Command Palette ( kbstyle(F1) ) or use the Remote Explorer in the Activity Bar and from the Containers view, select the Attach to Container inline action on the container you want to connect to. Note: When using Alpine Linux containers, some extensions may not work due to glibc dependencies in native code inside the extension. Attached container configuration files VS Code supports image or container name-level configuration files to speed up setup when you repeatedly connect to a given Docker container. Once attached, anytime you open a folder, install an extension , or forward a port , a local image-specific configuration file will automatically be updated to remember your settings so that when you attach again, everything is back to the right place. By default, an image-level configuration is used. To view or update it after attaching, select Remote-Containers: Open Container Configuration from the Command Palette ( kbstyle(F1) ). If you would prefer to tie your configuration to a container name , select Remote-Containers: Open Named Configuration File from the Command Palette ( kbstyle(F1) ) after attaching. Any updates from this point forward will apply to this name-level configuration rather than at the image level. Both of these files support a subset of devcontainer.json properties: { // Default path to open when attaching to a new container. \"workspaceFolder\": \"/path/to/code/in/container/here\", // An array of extension IDs that specify the extensions to // install inside the container when you first attach to it. \"extensions\": [ \"dbaeumer.vscode-eslint\" ], // Any *default* container specific VS Code settings \"settings\": { \"terminal.integrated.shell.linux\": \"/bin/bash\" }, // An array port numbers to forward \"forwardPorts\": [8000], // Container user VS Code should use when connecting \"remoteUser\": \"vscode\", // Set environment variables for VS Code and sub-processes \"remoteEnv\": { \"MY_VARIABLE\": \"some-value\" } } See the attached container config reference for a complete list of properties and their uses. Once saved, whenever you open a container for the first time with the same image / container name, these properties will be used to configure the environment. Tip: If something is wrong with your configuration, you can also edit it when not attached to the container by selecting Remote-Containers: Open Attached Container Configuration File... from the Command Palette ( kbstyle(F1) ) and then picking the image / container name from the presented list. Finally, if you have extensions you want installed regardless of the container you attach to, you can update settings.json to specify a list of extensions that should always be installed . Attach to a container in a Kubernetes cluster To attach to a container in a Kubernetes cluster, first install the Kubernetes extension and kubectl along with the Remote - Containers extension. Then select the Kubernetes explorer from the Activity bar and expand the cluster and Pod where the container you want to attach to resides. Finally, right-click on the container and select Attach Visual Studio Code from context menu. Note: Attached container configuration files are not yet supported for containers in a Kubernetes cluster. Next steps Create a Development Container - Create a custom container for your work environment. Advanced Containers - Find solutions to advanced container scenarios. devcontainer.json reference - Review the devcontainer.json schema."
  },
  "guides/vscode/remote/codespaces.html": {
    "href": "guides/vscode/remote/codespaces.html",
    "title": "GitHub Codespaces | Fountain of Knowledge",
    "keywords": "GitHub Codespaces GitHub Codespaces provides cloud-powered development environments for any activity - whether it's a long-term project, or a short-term task like reviewing a pull request. You can work with these environments from Visual Studio Code or in a browser-based editor. Environments An environment is the \"backend\" half of GitHub Codespaces. It's where all of the compute associated with software development happens: compiling, debugging, restoring, etc. When you need to work on a new project, pick up a new task, or review a PR, you can simply spin up a Cloud-hosted environment, and GitHub Codespaces takes care of configuring it correctly. It automatically configures everything you need to work on your project: the source code, runtime, compiler, debugger, editor, custom dotfile configurations, relevant editor extensions and more. Customization GitHub Codespaces are fully customizable on a per project basis. This is accomplished by including a devcontainer.json file in the project's repository, similar to VS Code Remote Container development. Example customizations include: Setting the Linux-based operating system to use. Automatically installing various tools, runtimes, and frameworks. Forwarding commonly used ports. Setting environment variables. Configuring editor settings and installing preferred extensions. See the Configuring Codespaces documentation for codespace-specific devcontainer.json settings. Dotfile per user configuration Dotfiles are files whose filename begins with a dot (.). They typically contain configuration information for applications and can control how terminals, editors, source control, and various other tools behave. .bashrc , .gitignore , and .editorconfig are examples of dotfiles commonly used by developers. You can specify a GitHub repo containing your dotfiles, a target location for the files, as well as install commands when creating a codespace. See the Personalizing Codespaces documentation to learn how to add your dotfile configurations to a codespace. Getting started There are getting started topics for both GitHub Codespaces clients. These will fast-track you through signing in to GitHub Codespaces, creating your first codespace, and connecting to it with your preferred client: Codespaces in VS Code - Use the GitHub Codespaces extension to connect and work in your environment. Codespaces in the browser - Connect to your codespace through a browser-based editor. Extension authors The VS Code extension API hides most of the implementation details of running remotely so many extensions will just work in GitHub Codespaces environments without any modification. However, we recommend that you test your extension in a codespace to be sure that all of its functionality works as expected. See the article on Supporting Remote Development and GitHub Codespaces for details. Browser-based editor You also have a free, lightweight Visual Studio Code experience entirely in the browser. The web-based editor lets you browse source code repositories from GitHub safely and quickly and make lightweight code changes. You can open any repository, fork, or pull request in the editor, which has many of the features of VS Code, including search and syntax highlighting. If you want to run or debug your code, you can switch to the cloud-hosted environment or the VS Code desktop. To access this browser-based editor, you can go to your repo on github.com and press kbstyle(.) (period key) or change the URL of your repository to github.dev/org/repo , replacing github.com with github.dev . Limitation: You may not be able to use the web-based editor if you are running your browser with Incognito mode or have ad blockers enabled. Note : This editor is currently in Technical Preview. You can try it out today and provide feedback at https://github.co/browser-editor-feedback . Known limitations and adaptations While working with Codespaces and specifically VS Code in the web, there are certain limitations to keep in mind. Some of these limitations have workarounds or adaptations in place to provide a consistent development experience. For several issues (especially keybindings or those listed with a workaround for the desktop), you can install and use a Codespace as a progressive web application (PWA). Issue Reason Workaround kbstyle(Ctrl+Shift+P) won't launch the Command Palette in Firefox. kbstyle(Ctrl+Shift+P) is reserved in Firefox. Use kbstyle(F1) to launch the Command Palette. Certain default keybindings (for debugging) are different in the web. Since the browser may already have an action registered for those keybindings, we adjust the default for VS Code in the web. Use the adjusted defaults. They appear on tooltip hovers over the debug actions. Step over is kbstyle(Alt+F10) (instead of kbstyle(F10) ) on all browsers. Step into in the web is kbstyle(Alt+F11) (instead of kbstyle(F11) ) on Windows browsers. kbstyle(F11) for debugging does not work on macOS in web or desktop. This is a known, non-browser specific limitation. More information can be found in issue #5102 . Disable kbstyle(F11) to show desktop on macOS. Go to: System Preferences > Keyboard > Shortcuts Uncheck the Show Desktop F11 option kbstyle(Ctrl+N) for new file doesn't work in web. kbstyle(Ctrl+N) opens a new window instead. kbstyle(Ctrl+N) for new file works in the desktop. kbstyle(Ctrl+W) for closing an editor doesn't work in web. kbstyle(Ctrl+W) closes the current tab in browsers. kbstyle(Ctrl+W) works in the desktop. kbstyle(Ctrl+Shift+B) will not toggle the favorites bar in the browser. Codespaces overrides this and redirects to the \"Build\" menu in the Command Palette. No current workarounds. Dragging and dropping files from VS Code to a Codespace (and vice versa) does not work. You can see more context in issue #115535 . There are a couple of options: You can right-click the file in your Codespace to download it to your local machine. You can drag files to your Codespace from the File Explorer. Angular app debugging isn't supported in the web. Code running in a browser cannot launch another browser instance in debug mode for security reasons. You have a few options: Debug Node.js/service-side js normally. Open the Codespace in desktop, in which case the companion will be used to launch your local Edge or Chrome install. Downloading a file with no extension from the browser automatically adds \".txt\" This is how Chrome and Edge behave. Context and potential future solutions in issue #118436 . When you download a file from a remote (including Codespaces), attributes such as the executable bit are removed. Context and potential future solutions can be found in issue #112099 . No current workarounds. You may see the prompt, \" Your_codespace_name can't open this folder because it contains system files\" when trying to download certain folders from a Codespace. A user agent is free to impose the level of restrictions on sensitive directories. More information in this spec and Chromium's blocklist . No additional workarounds beyond the spec and blocklist. Manually visiting http://localhost:forwarded_port won't work to access a forwarded port from a Codespace in the web. This is based on how Codespaces handles port forwarding and generates the correct URL for the web. Click the link from the port forwarding notification to open your app, or the globe icon in the Ports view , both of which will provide the properly generated link. More information in the Codespaces docs . Some extensions behave differently in the web Extension Issue / Reason Workaround Extensions with keyboard shortcuts that overlap with browser shortcuts, for example Git Graph , which uses kbstyle(Ctrl+R) to refresh. The keyboard shortcut may overlap with an existing browser shortcut, for example kbstyle(Ctrl+R) refreshes the window in Safari. You can use a desktop-based, rather than web-based, Codespace to fully leverage your keyboard shortcuts. Different browsers may also behave differently (you can refresh Git Graph in Chrome). Language packs, for example the Japanese Language Pack for Visual Studio Code Language pack extensions are currently not supported in web-based Codespaces. You can use a desktop-based Codespace to use language packs and configure the display language. Bracket Pair Colorizer 2 It will not work in the browser as it introduces an install location dependency that is not easily fixable. Use Bracket Pair Colorizer . Browser Debuggers, such as Debugger for Chrome , Debugger for Firefox , Debugger for Edge . Extensions that require a UI/Desktop extension host do not load in the browser. You can use these extensions in local VS Code (not connected to Codespaces). Or, while your app is running from a Codespace, you can use an alternative, like Chrome DevTools to inspect elements and set breakpoints. Extensions to open a browser, for example open in browser . Extensions that require a UI/Desktop extension host do not load in the browser. Use a substitute extension if possible, like Live Server . Project Manager Project Manager relies on syncing a custom projects.json file, which isn't currently supported . You can use the extension in desktop Codespaces or local VS Code to save and manage your projects, as these options won't require syncing a custom file. Extensions that rely on Chrome, such as Protractor Test Runner and Browser Preview . Chrome is not included in a Codespace. Try to find alternative experiences, or you can use these extensions on your project in local VS Code (not connected to Codespaces). Flutter (and Flutter development overall) Several aspects of the Flutter workflow are limited due to the nature of Docker containers and Codespaces. Flutter recommends installation from snap, but snap cannot be installed within the Codespaces container. Android Emulation does not work within a container. Codespaces cannot detect USB devices plugged into your machine, which makes development on a physical device impossible. Codespaces, like other Linux environments, doesn't support iOS development. You can use local VS Code for Flutter development. LaTeX Workshop The extension provides three kinds of features to help with LaTeX authoring: 1) a set of views that surface common commands, 2) a PDF previewer, and 3) language features like snippets and IntelliSense. The extension can be used fairly fully featured, but there are some web or security limitations. The following workarounds address limitations in the view and previewer feature areas: The views themselves work without issue, but a few of the commands try to launch native applications, like revealing the output folder in the OS file explorer. These do nothing in the web, so using the desktop is an alternative. \"latex-workshop.view.pdf.viewer\" - This setting provides a PDF previewer similar to the Markdown preview . You can preview in a browser tab, in a separate PDF viewer, or in a VS Code tab. Only the browser tab is usable in web-based Codespaces. The separate PDF viewer fails silently, and the VS Code tab hits the Content Security Policy issue. The VS Code Tab viewer has other features that aren't available due to this limitation. Git Graph Some Git Graph webview functionality may be limited in Codespaces. For instance, switching between a file from a commit and the Git Graph webview may blank out the webview. You can use Git Graph fully within VS Code desktop. Other Remote Development extensions (Remote - WSL, Remote - Containers, Remote - SSH) cannot be installed in a Codespace. The Codespace is already a remote context. If you'd like to run in another remote context (for example WSL or a remote SSH computer), open VS Code desktop (not connected to a Codespace) and launch one of the other remote extensions. If you'd like to use a custom dev container , you can use the same .devcontainer in both Codespaces and Remote - Containers. My_Favorite_Extension doesn't work and isn't listed above. There are a few other issues that can prevent features from working as expected in remote contexts. In some cases, you can use another command to work around the issue, but in others, the extension may need to be modified. Check out the remote extension tips for common remote issues and tips on resolving them. Common questions Why is an extension not installable in the browser There are a small number of extensions that have built-in assumptions or need to run on the desktop. Examples are when an extension accesses files from the VS Code installation on the desktop or when an extension depends on an executable that must run in a desktop environment. When you try to install such an extension in the browser, you will be informed that the extension is not available. Notice such an extension can still be used when connecting to a Codespace from VS Code running on the desktop. How do I allow VS Code to access my clipboard for reading? In certain cases, VS Code might ask you for permission to access the clipboard when reading from it. You should be able to grant access to the clipboard from your browser either through settings (search for \"site permissions\") or by looking for this option in the address bar on the right: Once you have granted VS Code access to the clipboard, you can retry the operation. How do I allow VS Code to always open new tabs and windows? Sometimes browsers will, as a security precaution, block VS Code from opening new tabs or windows. If this happens, VS Code will detect the blocking action and explicitly prompt the user. However, you can allow VS Code to always open new windows and tabs by opening the site settings via the context menu in the browser navigation bar and by allowing to Pop-up Windows . Questions or feedback If you have questions, you can consult the GitHub Codespaces Troubleshooting guide . If you'd like to provide feedback, you can enter issues in the GitHub Codespaces Discussions ."
  },
  "guides/vscode/remote/containers.html": {
    "href": "guides/vscode/remote/containers.html",
    "title": "Developing inside a Container | Fountain of Knowledge",
    "keywords": "Developing inside a Container The Visual Studio Code Remote - Containers extension lets you use a Docker container as a full-featured development environment. It allows you to open any folder inside (or mounted into) a container and take advantage of Visual Studio Code's full feature set. A devcontainer.json file in your project tells VS Code how to access (or create) a development container with a well-defined tool and runtime stack. This container can be used to run an application or to separate tools, libraries, or runtimes needed for working with a codebase. Workspace files are mounted from the local file system or copied or cloned into the container. Extensions are installed and run inside the container, where they have full access to the tools, platform, and file system. This means that you can seamlessly switch your entire development environment just by connecting to a different container. This lets VS Code provide a local-quality development experience — including full IntelliSense (completions), code navigation, and debugging — regardless of where your tools (or code) are located . Getting started Note : After reviewing this topic, you can get started with the introductory Containers tutorial . System requirements Local: Windows: Docker Desktop 2.0+ on Windows 10 Pro/Enterprise. Windows 10 Home (2004+) requires Docker Desktop 2.3+ and the WSL 2 back-end . (Docker Toolbox is not supported. Windows container images are not supported.) macOS : Docker Desktop 2.0+. Linux : Docker CE/EE 18.06+ and Docker Compose 1.21+. (The Ubuntu snap package is not supported.) Containers : x86_64 / ARMv7l (AArch32) / ARMv8l (AArch64) Debian 9+, Ubuntu 16.04+, CentOS / RHEL 7+ x86_64 Alpine Linux 3.9+ Other glibc based Linux containers may work if they have needed Linux prerequisites . Installation To get started, follow these steps: Install and configure Docker for your operating system. Windows / macOS : Install Docker Desktop for Windows/Mac . If you are using WSL 2 on Windows, to enable the Windows WSL 2 back-end : Right-click on the Docker taskbar item and select Settings . Check Use the WSL 2 based engine and verify your distribution is enabled under Resources > WSL Integration . Right-click on the Docker task bar item, select Settings and update Resources > File Sharing with any locations your source code is kept. See tips and tricks for troubleshooting. This option is not available if you have enabled the WSL 2 back-end in the step above. Linux : Follow the official install instructions for Docker CE/EE for your distribution . If you are using Docker Compose, follow the Docker Compose directions as well. Add your user to the docker group by using a terminal to run: sudo usermod -aG docker $USER Sign out and back in again so your changes take effect. Install Visual Studio Code or Visual Studio Code Insiders . Install the Remote Development extension pack . Working with Git? Here are two tips to consider: If you are working with the same repository both locally in Windows and inside a container, be sure to set up consistent line endings. See tips and tricks for details. If you clone using a Git credential manager, your container should already have access to your credentials! If you use SSH keys, you can also opt in to sharing them. See Sharing Git credentials with your container for details. Working with Containers The Remote - Containers extension supports two primary operating models: You can use a container as your full-time development environment . You can attach to a running container to inspect it. Quick start: Try a development container The easiest way to get started is to try one of the sample development containers. The Containers tutorial will walk you through setting up Docker and the Remote - Containers extension and let you select a sample: Quick start: Open an existing folder in a container This quick start covers how to set up a dev container for an existing project to use as your full-time development environment using existing source code on your filesystem. Follow these steps: Start VS Code, run the Remote-Containers: Open Folder in Container... command from the Command Palette ( kbstyle(F1) ) or quick actions Status bar item, and select the project folder you would like to set up the container for. Tip: If you want to edit the container's contents or settings before opening the folder, you can run Remote-Containers: Add Development Container Configuration Files... instead. Now pick a starting point for your dev container. You can either select a base dev container definition from a filterable list, or use an existing Dockerfile or Docker Compose file if one exists in the folder you selected. Note: When using Alpine Linux containers, some extensions may not work due to glibc dependencies in native code inside the extension. The list will be automatically sorted based on the contents of the folder you open. Note the dev container definitions displayed come from the vscode-dev-containers repository . You can browse the containers folder of that repository to see the contents of each definition. After picking the starting point for your container, VS Code will add the dev container configuration files to your project ( .devcontainer/devcontainer.json ). The VS Code window will reload and start building the dev container. A progress notification provides status updates. You only have to build a dev container the first time you open it; opening the folder after the first successful build will be much quicker. After the build completes, VS Code will automatically connect to the container. You can now interact with your project in VS Code just as you could when opening the project locally. From now on, when you open the project folder, VS Code will automatically pick up and reuse your dev container configuration. Tip: Want to use a remote Docker host? See the Advanced Containers article for details on setup. While using this approach to bind mount the local filesystem into a container is convenient, it does have some performance overhead on Windows and macOS. There are some techniques that you can apply to improve disk performance, or you can open a repository in a container using a isolated container volume instead. Open a WSL 2 folder in a container on Windows If you are using Windows Subsystem for Linux v2 (WSL 2) and have enabled Docker Desktop's WSL 2 back-end , you can work with source code stored inside WSL! Once the WSL 2 engine is enabled, you can either: Use the Remote-Containers: Reopen Folder in Container command from a folder already opened using the Remote - WSL extension. Select Remote-Containers: Open Folder in Container... from the Command Palette ( kbstyle(F1) ) and choose a WSL folder using the local \\\\wsl$ share (from the Windows side). The rest of the quick start applies as-is! You can learn more about the Remote - WSL extension in its documentation . Open an existing workspace in a container You can also follow a similar process to open a VS Code multi-root workspace in a single container if the workspace only references relative paths to sub-folders of the folder the .code-workspace file is in (or the folder itself). You can either: Use the Remote-Containers: Open Workspace in Container... command. Use File > Open Workspace... once you have opened a folder that contains a .code-workspace file in a container. Once connected, you may want to add the .devcontainer folder to the workspace so you can easily edit its contents if it is not already visible. Also note that, while you cannot use multiple containers for the same workspace in the same VS Code window, you can use multiple Docker Compose managed containers at once from separate windows. Quick start: Open a Git repository or GitHub PR in an isolated container volume While you can open a locally cloned repository in a container , you may want to work with an isolated copy of a repository for a PR review or to investigate another branch without impacting your work. Repository Containers use isolated, local Docker volumes instead of binding to the local filesystem. In addition to not polluting your file tree, local volumes have the added benefit of improved performance on Windows and macOS. (See Advanced Configuration for information on how to use these types of volumes in other scenarios.) For example, follow these steps to open one of the \"try\" repositories in a Repository Container: Start VS Code and run Remote-Containers: Clone Repository in Container Volume... from the Command Palette ( kbstyle(F1) ). Enter microsoft/vscode-remote-try-node (or one of the other \"try\" repositories), a Git URI, a GitHub branch URL, or a GitHub PR URL in the input box that appears and press kbstyle(Enter) . Tip: If you choose a private repository, you may want to setup a credential manager or add your SSH keys to your SSH agent. See Sharing Git credentials with your container . If your repository does not have a .devcontainer/devcontainer.json file in it, you'll be asked to pick a starting point from a filterable list or an existing Dockerfile or Docker Compose file (if one exists). Note: When using Alpine Linux containers, some extensions may not work due to glibc dependencies in native code inside the extension. The list will be automatically sorted based on the contents of the folder you open. Note the dev container definitions displayed come from the vscode-dev-containers repository . You can browse the containers folder of that repository to see the contents of each definition. The VS Code window (instance) will reload, clone the source code, and start building the dev container. A progress notification provides status updates. If you pasted in a GitHub pull request URL in step 2, the PR will be automatically checked out and the GitHub Pull Requests extension will be installed in the container. The extension provides additional PR related features like a PR explorer, interacting with PR comments inline, and status bar visibility. After the build completes, VS Code will automatically connect to the container. You can now work with the repository source code in this independent environment as you would if you had cloned the code locally. Note that if the container fails to come up due to something like a Docker build error, you can select Reopen in Recovery Container in the dialog that appears to go into a \"recovery container\" that allows you to edit your Dockerfile or other content. This opens the docker volume with the cloned repository in a minimal container and shows you the creation log. Once you are done fixing, use Reopen in Container to retry. Tip: Want to use a remote Docker host? See the Advanced Containers article for details on setup. Trusting your Workspace Visual Studio Code takes security seriously and wants to help you safely browse and edit code no matter the source or original authors. The Workspace Trust feature lets you decide whether your project folders should allow or restrict automatic code execution. The Remote - Containers extension has adopted Workspace Trust. Depending on how you open and interact with your source code, you'll be prompted to decide if you trust the code you're editing or executing at different points. Reopen folder in container Setting up a dev container for an existing project requires trusting the local (or WSL) folder. You will be asked to trust the local (or WSL) folder before the window reloads. There are a couple of exceptions to this flow: When clicking on a recent entry. Using the Open Folder in Container command will ask for trust after the window reloads, if trust is not already given. Attach to existing container When attaching to an existing container , you will be asked to confirm that attaching means you trust the container. This is only confirmed once. Clone repository in a volume When cloning a repository in a container volume , you are asked to confirm that cloning a repository means you trust the repository. This is only confirmed once. Inspect volume Inspecting a volume starts in Restricted Mode , and you can trust the folder inside the container. Docker daemon running remotely This implies trusting the machine the Docker daemon runs on . There are no additional prompts to confirm (only those listed for the local/WSL case above). Create a devcontainer.json file VS Code's container configuration is stored in a devcontainer.json file. This file is similar to the launch.json file for debugging configurations, but is used for launching (or attaching to) your development container instead. You can also specify any extensions to install once the container is running or post-create commands to prepare the environment. The dev container configuration is either located under .devcontainer/devcontainer.json or stored as a .devcontainer.json file (note the dot-prefix) in the root of your project. You can use any image, Dockerfile, or set of Docker Compose files as a starting point. Here is a simple example that uses one of the pre-built VS Code Development Container images : { \"image\": \"mcr.microsoft.com/vscode/devcontainers/typescript-node:0-12\", \"forwardPorts\": [ 3000 ], \"extensions\": [ \"dbaeumer.vscode-eslint\" ] } Selecting the Remote-Containers: Add Development Container Configuration Files... command from the Command Palette ( kbstyle(F1) ) will add the needed files to your project as a starting point, which you can further customize for your needs. The command lets you pick a pre-defined container configuration from a list based on your folder's contents, reuse an existing Dockerfile, or reuse an existing Docker Compose file. To learn more about creating devcontainer.json files, see Create a Development Container . Inspecting volumes Occasionally you may run into a situation where you are using a Docker named volume that you want to inspect or make changes in. You can use VS Code to work with these contents without creating or modifying devcontainer.json file by selecting the Remote-Containers: Explore a Volume in a Development Container... from the Command Palette ( kbstyle(F1) ). You can also inspect your volumes in the Remote Explorer. Make sure you have Containers selected in the dropdown, then you'll notice a Dev Volumes section. You can right-click on a volume to inspect its creation information, like when the volume was created, what repo was cloned into it, and the mountpoint. You can also explore it in a dev container. If you have the Docker extension installed, you can right-click on a volume in the Volumes section of the Docker Explorer and select Explore in a Development Container . Managing extensions VS Code runs extensions in one of two places: locally on the UI / client side, or in the container. While extensions that affect the VS Code UI, like themes and snippets, are installed locally, most extensions will reside inside a particular container. This allows you to install only the extensions you need for a given task in a container and seamlessly switch your entire tool-chain just by connecting to a new container. If you install an extension from the Extensions view, it will automatically be installed in the correct location. You can tell where an extension is installed based on the category grouping. There will be a Local - Installed category and also one for your container. Note: If you are an extension author and your extension is not working properly or installs in the wrong place, see Supporting Remote Development for details. Local extensions that actually need to run remotely will appear Disabled in the Local - Installed category. Select Install to install an extension on your remote host. You can also install all locally installed extensions inside the Dev Container by going to the Extensions view and selecting Install Local Extensions in Dev Container: [Name] using the cloud button at the right of the Local - Installed title bar. This will display a dropdown where you can select which locally installed extensions to install in your container. However, some extensions may require you to install additional software in the container. Consult extension documentation for details if you encounter issues. Adding an extension to devcontainer.json While you can edit your devcontainer.json file by hand to add a list of extension IDs, you can also right-click on any extension in the Extensions view and select Add to devcontainer.json . \"Always installed\" extensions If there are extensions that you would like always installed in any container, you can update the remote.containers.defaultExtensions User setting . For example, if you wanted to install the GitLens and Resource Monitor extensions, you would specify their extension IDs as follows: \"remote.containers.defaultExtensions\": [ \"eamodio.gitlens\", \"mutantdino.resourcemonitor\" ] Advanced: Forcing an extension to run locally or remotely Extensions are typically designed and tested to either run locally or remotely, not both. However, if an extension supports it, you can force it to run in a particular location in your settings.json file. For example, the setting below will force the Docker extension to run locally and Debugger for Chrome extension to run remotely instead of their defaults: \"remote.extensionKind\": { \"ms-azuretools.vscode-docker\": [ \"ui\" ], \"msjsdiag.debugger-for-chrome\": [ \"workspace\" ] } A value of \"ui\" instead of \"workspace\" will force the extension to run on the local UI/client side instead. Typically, this should only be used for testing unless otherwise noted in the extension's documentation since it can break extensions . See the article on Supporting Remote Development for details. Forwarding or publishing a port Containers are separate environments, so if you want to access a server, service, or other resource inside your container, you will need to either \"forward\" or \" publish \" the port to your host. You can either configure your container to always expose these ports or just forward them temporarily. Always forwarding a port You can specify a list of ports you always want to forward when attaching or opening a folder in container by using the forwardPorts property in devcontainer.json . \"forwardPorts\": [3000, 3001] Simply reload / reopen the window and the setting will be applied when VS Code connects to the container. Temporarily forwarding a port If you need to access a port that you didn't add to devcontainer.json or publish in your Docker Compose file, you can temporarily forward a new port for the duration of the session by running the Forward a Port command from the Command Palette ( kbstyle(F1) ). After selecting a port, a notification will tell you the localhost port you should use to access the port in the container. For example, if you forwarded an HTTP server listening on port 3000, the notification may tell you that it was mapped to port 4123 on localhost. You can then connect to this remote HTTP server using http://localhost:4123 . This same information is available in the Forwarded Ports section of the Remote Explorer if you need to access it later. If you would like VS Code to remember any ports you have forwarded, check Remote: Restore Forwarded Ports in the Settings editor ( kb(workbench.action.openSettings) ) or set \"remote.restoreForwardedPorts\": true in settings.json . Publishing a port Docker has the concept of \"publishing\" ports when the container is created. Published ports behave very much like ports you make available to your local network. If your application only accepts calls from localhost , it will reject connections from published ports just as your local machine would for network calls. Forwarded ports, on the other hand, actually look like localhost to the application. Each can be useful in different situations. To publish a port, you can: Use the appPort property: If you reference an image or Dockerfile in devcontainer.json , you can use the appPort property to publish ports to the host. \"appPort\": [ 3000, \"8921:5000\" ] Use the Docker Compose ports mapping: The ports mapping can easily be added your docker-compose.yml file to publish additional ports. ports: - \"3000\" - \"8921:5000\" In each case, you'll need to rebuild your container for the setting to take effect. You can do this by running the Remote-Containers: Rebuild Container command in the Command Palette ( kbstyle(F1) ) when you are connected to the container. Opening a terminal Opening a terminal in a container from VS Code is simple. Once you've opened a folder in a container, any terminal window you open in VS Code ( Terminal > New Terminal ) will automatically run in the container rather than locally. You can also use the code command line from this same terminal window to perform a number of operations such as opening a new file or folder in the container. Type code --help to learn what options are available from the command line. Debugging in a container Once you've opened a folder in a container, you can use VS Code's debugger in the same way you would when running the application locally. For example, if you select a launch configuration in launch.json and start debugging ( kb(workbench.action.debug.start) ), the application will start on the remote host and attach the debugger to it. See the debugging documentation for details on configuring VS Code's debugging features in .vscode/launch.json . Container specific settings VS Code's local user settings are also reused when you are connected to a dev container. While this keeps your user experience consistent, you may want to vary some of these settings between your local machine and each container. Fortunately, once you have connected to a container, you can also set container-specific settings by running the Preferences: Open Remote Settings command from the Command Palette ( kbstyle(F1) ) or by selecting the Remote tab in the Settings editor. These will override any local settings you have in place whenever you connect to the container. Default container specific settings You can include defaults for container specific settings in devcontainer.json using the settings property. These values will be automatically placed in the container specific settings file inside the container once it is created. For example, adding this to .devcontainer/devcontainer.json will set the Java home path: \"settings\": { \"java.home\": \"/docker-java-home\" } Since this just establishes the default, you are still able to change the settings as needed once the container is created. Sharing Git credentials with your container The Remote - Containers extension provides out of box support for using local Git credentials from inside a container. In this section, we'll walk through the two supported options. If you do not have your user name or email address set up locally, you may be prompted to do so. You can do this on your local machine by running the following commands: git config --global user.name \"Your Name\" git config --global user.email \"your.email@address\" The extension will automatically copy your local .gitconfig file into the container on startup so you should not need to do this in the container itself. Using a credential helper If you use HTTPS to clone your repositories and have a credential helper configured in your local OS, no further setup is required. Credentials you've entered locally will be reused in the container and vice versa. Using SSH keys There are some cases when you may be cloning your repository using SSH keys instead of a credential helper. To enable this scenario, the extension will automatically forward your local SSH agent if one is running . You can add your local SSH keys to the agent if it is running by using the ssh-add command. For example, run this from a terminal or PowerShell: ssh-add $HOME/.ssh/github_rsa On Windows and Linux, you may get an error because the agent is not running (macOS typically has it running by default). Follow these steps to resolve the problem: Windows : Start a local Administrator PowerShell and run the following commands: # Make sure you're running as an Administrator Set-Service ssh-agent -StartupType Automatic Start-Service ssh-agent Get-Service ssh-agent Linux: First, start the SSH Agent in the background by running the following in a terminal: eval \"$(ssh-agent -s)\" Then add these lines to your ~/.bash_profile or ~/.zprofile (for Zsh) so it starts on login: if [ -z \"$SSH_AUTH_SOCK\" ]; then # Check for a currently running instance of the agent RUNNING_AGENT=\"`ps -ax | grep 'ssh-agent -s' | grep -v grep | wc -l | tr -d '[:space:]'`\" if [ \"$RUNNING_AGENT\" = \"0\" ]; then # Launch a new instance of the agent ssh-agent -s &> $HOME/.ssh/ssh-agent fi eval `cat $HOME/.ssh/ssh-agent` fi Sharing GPG Keys If want to GPG sign your commits, you can share your local keys with your container as well. You can find out about signing using a GPG key in GitHub's documentation . If you do not have GPG set up, you can configure it for your platform: On Windows , you can install Gpg4win . On macOS , you can install GPG Tools . On Linux , locally install the gnupg2 package using your system's package manger. On WSL : Install Gpg4win on the Windows side. Install socat in your WSL distro. sudo apt install socat Install gpg in your WSL distro. sudo apt install gpg Register a pinentry GUI in your WSL distro. echo pinentry-program /mnt/c/Program\\ Files\\ \\(x86\\)/Gpg4win/bin/pinentry.exe > ~/.gnupg/gpg-agent.conf Reload the gpg agent in WSL. gpg-connect-agent reloadagent /bye Next, install gnupg2 in your container by updating your Dockerfile. For example: RUN apt-get update && apt-get install gnupg2 -y Or if running as a non-root user : RUN sudo apt-get update && sudo apt-get install gnupg2 -y The next time the container starts, your GPG keys should be accessible inside the container as well. Note: If you used gpg previously in the container, you may need to run Remote-Containers: Rebuild Container for the update to take effect. Managing containers By default, the Remote - Containers extension automatically starts the containers mentioned in the devcontainer.json when you open the folder. When you close VS Code, the extension automatically shuts down the containers you've connected to. You can change this behavior by adding \"shutdownAction\": \"none\" to devcontainer.json . While you can use the command line to manage your containers, you can also use the Remote Explorer . To stop a container, select Containers from the dropdown (if present), right-click on a running container, and select Stop Container . You can also start exited containers, remove containers, and remove recent folders. From the Details view, you can forward ports and open already forwarded ports in the browser. If you want to clean out images or mass-delete containers, see Cleaning out unused containers and images for different options. Personalizing with dotfile repositories Dotfiles are files whose filename begins with a dot ( . ) and typically contain configuration information for various applications. Since development containers can cover a wide range of application types, it can be useful to store these files somewhere so that you can easily copy them into a container once it is up and running. A common way to do this is to store these dotfiles in a GitHub repository and then use a utility to clone and apply them. The Remote - Containers extension has built-in support for using these with your own containers. If you are new to the idea, take a look at the different dotfiles bootstrap repositories that exist. To use it, add your dotfiles GitHub repository to VS Code's User Settings ( kb(workbench.action.openSettings) ) as follows: Or in settings.json : { \"dotfiles.repository\": \"your-github-id/your-dotfiles-repo\", \"dotfiles.targetPath\": \"~/dotfiles\", \"dotfiles.installCommand\": \"~/dotfiles/install.sh\" } From this point forward, the dotfiles repository will be used whenever a container is created. Advanced container configuration See the Advanced Container Configuration article for information on the following topics: Adding environment variables Adding another local file mount Changing or removing the default source code mount Improving container disk performance Adding a non-root user to your dev container Avoiding extension reinstalls on container rebuild Setting the project name for Docker Compose Using Docker or Kubernetes from inside a container Connecting to multiple containers at once Developing inside a container on a remote Docker Machine or SSH host Reducing Dockerfile build warnings devcontainer.json reference There is a full devcontainer.json reference , where you can review the file schema to help you customize your development containers and control how you attach to running containers. Known limitations Remote - Containers limitations Windows container images are not yet supported. Using a remote Docker Host is possible, but requires additional setup steps . All roots/folders in a multi-root workspace will be opened in the same container, regardless of whether there are configuration files at lower levels. The unofficial Ubuntu Docker snap package for Linux is not supported. Follow the official Docker install instructions for your distribution . Docker Toolbox on Windows is not supported. If you clone a Git repository using SSH and your SSH key has a passphrase, VS Code's pull and sync features may hang when running remotely. Either use an SSH key without a passphrase, clone using HTTPS, or run git push from the command line to work around the issue. Local proxy settings are not reused inside the container, which can prevent extensions from working unless the appropriate proxy information is configured (for example global HTTP_PROXY or HTTPS_PROXY environment variables with the appropriate proxy information). See here for a list of active issues related to Containers. Docker limitations First-time installs of Docker Desktop for Windows when not using the WSL 2 engine will require an additional \"sharing\" step to give your container access to local source code. However, this step may not work with certain AAD (email-based) identities. See Docker Desktop for Windows tips and Enabling file sharing in Docker Desktop for details and workarounds. You may see errors if you sign in to Docker with your email address instead of your Docker ID. This is a known issue and can be resolved by signing in with your Docker ID instead. See Docker issue #935 for details. If you see high CPU spikes for com.docker.hyperkit on macOS, this may be due to a known issue with Docker for Mac . See the Docker issue for details. See the Docker troubleshooting guide for Windows or Mac , consult Docker Support Resources for more information. Docker Extension limitations While the Docker extension can run both remotely and locally, if it is already installed locally, you will be unable to install in a container without first uninstalling it locally. We will address this problem in a future VS Code release. Extension limitations Many extensions will work inside dev containers without modification. However, in some cases, certain features may require changes. If you run into an extension issue, see here for a summary of common problems and solutions that you can mention to the extension author when reporting the issue. In addition, while Alpine support is available, some extensions installed in the container may not work due to glibc dependencies in native code inside the extension. See the Remote Development with Linux article for details. Common questions I am seeing errors when trying to mount the local filesystem into a container Right-click on the Docker task bar item. On Windows, select the Settings menu item then Resources > File Sharing and check the drive(s) where your source code is located. On macOS, select the Preferences menu item then Resources > File Sharing and make sure the folder containing your source code is under a file path specified in the list. See Docker Desktop for Windows tips for information on workarounds to common Docker for Windows issues. Can I use Podman instead of Docker? Podman 1.9+ is mostly compatible with Docker's CLI commands and therefore generally does work if you update the setting Remote > Containers: Docker Path to podman on Linux. However, certain tricks like Docker-from-Docker do not work due to limitations in Podman. This affects the Remote-Containers: Try a Sample... and Remote- Containers: Clone Repository in Container Volume... commands. Docker Compose is also not supported by Podman. I'm seeing an error about a missing library or dependency Some extensions rely on libraries not found in specific Docker images. For example, Visual Studio Live Share requires the installation of system-level dependencies, which are listed in their documentation . The need for these dependencies may depend on the operating system (for example, specific Linux distribution) used by your Docker image. You may need to install these dependencies during the Docker build process, by adding required commands to your Dockerfile. Search the specific extension's documentation to check for dependencies and see Installing additional software for help with resolving the problem. Can I connect to multiple containers at once? A VS Code window can only connect to one window currently, but you can open a new window and attach to an already running container or use a common Docker Compose file with multiple devcontainer.json files to automate the process a bit more. Can I work with containers on a remote host? Yes, you can either attach to a container running on a remote host or create a specialized devcontainer.json to tell VS Code how to work with your remote environment. To access the host, you can either connect to a publicly exposed Docker daemon TCP port or use SSH to tunnel into a remote VM running Docker. See Developing inside a container on a remote Docker host for details. How can I build or deploy container images into my local Docker / Kubernetes install when working inside a container? You can build images and deploy containers by forwarding the Docker socket and installing the Docker CLI (and kubectl for Kubernetes) in the container. See the Docker-from-Docker , Docker-from-Docker Compose , and Kubernetes-Helm dev container definitions for details. What are the connectivity requirements for the VS Code Server when it is running in a container? Installation of VS Code Server requires that your local machine have outbound HTTPS (port 443) connectivity to: update.code.visualstudio.com vscode.blob.core.windows.net *.vo.msecnd.net (Azure CDN) The Remote - Containers extensions will download VS Code Server locally and copy it to the container once connected. You can install extensions manually without an internet connection using the Extensions: Install from VSIX... command, but if you use the extension panel or devcontainer.json to install extensions, your local machine and VS Code Server will need outbound HTTPS (port 443) access to: marketplace.visualstudio.com *.vo.msecnd.net (Azure CDN) *.gallerycdn.vsassets.io (Azure CDN) Finally, some extensions (like C#) download secondary dependencies from download.microsoft.com or download.visualstudio.microsoft.com . Others (like Visual Studio Live Share ) may have additional connectivity requirements. Consult the extension's documentation for details if you run into trouble. VS Code Server runs on a random port inside the container and VS Code itself uses docker exec to communicate with it over Docker's configured communication channel. As an extension author, what do I need to do to make sure my extension works? The VS Code extension API hides most of the implementation details of running remotely so many extensions will just work inside dev containers without any modification. However, we recommend that you test your extension in a dev container to be sure that all of its functionality works as expected. See the article on Supporting Remote Development for details. What other resources are there that may be able to answer my question? The following articles may help answer your question: Advanced Container Configuration or Tips and Tricks Dockerfile reference Docker Compose file reference Docker Desktop for Windows troubleshooting guide and FAQ Docker Desktop for Mac troubleshooting guide and FAQ Docker Support Resources Questions or feedback See Tips and Tricks or the FAQ . Search on Stack Overflow . Add a feature request or report a problem . Create a development container definition for others to use. Contribute to our documentation or VS Code itself . See our CONTRIBUTING guide for details. Next steps Attach to a Running Container - Attach to an already running Docker container. Create a Development Container - Create a custom container for your work environment. Advanced Containers - Find solutions to advanced container scenarios. devcontainer.json reference - Review the devcontainer.json schema."
  },
  "guides/vscode/remote/containers-advanced.html": {
    "href": "guides/vscode/remote/containers-advanced.html",
    "title": "Advanced Container Configuration | Fountain of Knowledge",
    "keywords": "Advanced Container Configuration This article includes advanced setup scenarios for the Visual Studio Code Remote - Containers extension. See the Developing inside a Container article for additional information. Adding environment variables You can set environment variables in your container without altering the container image by using one of the options below. However, you should verify Terminal > Integrated: Inherit Env is checked in settings or the variables you set may not appear in the Integrated Terminal. Option 1: Add individual variables Depending on what you reference in devcontainer.json : Dockerfile or image : Add the containerEnv property to devcontainer.json to set variables that should apply to the entire container or remoteEnv to set variables for VS Code and related sub-processes (terminals, tasks, debugging, etc.): \"containerEnv\": { \"MY_CONTAINER_VAR\": \"some-value-here\", \"MY_CONTAINER_VAR2\": \"${localEnv:SOME_LOCAL_VAR}\" }, \"remoteEnv\": { \"PATH\": \"${containerEnv:PATH}:/some/other/path\", \"MY_REMOTE_VARIABLE\": \"some-other-value-here\", \"MY_REMOTE_VARIABLE2\": \"${localEnv:SOME_LOCAL_VAR}\" } As this example illustrates, containerEnv can reference local variables and remoteEnv can reference both local and existing container variables. Docker Compose : Since Docker Compose has built-in support for updating container-wide variables, only remoteEnv is supported in devcontainer.json : \"remoteEnv\": { \"PATH\": \"${containerEnv:PATH}:/some/other/path\", \"MY_REMOTE_VARIABLE\": \"some-other-value-here\", \"MY_REMOTE_VARIABLE2\": \"${localEnv:SOME_LOCAL_VAR}\" } As this example illustrates, remoteEnv can reference both local and existing container variables. To update variables that apply to the entire container, update (or extend ) your docker-compose.yml with the following for the appropriate service: version: '3' services: your-service-name-here: environment: - YOUR_ENV_VAR_NAME=your-value-goes-here - ANOTHER_VAR=another-value # ... If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Option 2: Use an env file If you have a large number of environment variables that you need to set, you can use a .env file instead. VS Code will automatically pick up a file called .env in your workspace root, but you can also create one in another location. First, create an environment file somewhere in your source tree. Consider this .devcontainer/devcontainer.env file: YOUR_ENV_VAR_NAME=your-value-goes-here ANOTHER_ENV_VAR_NAME=your-value-goes-here Next, depending on what you reference in devcontainer.json : Dockerfile or image : Edit devcontainer.json and add a path to the devcontainer.env : \"runArgs\": [\"--env-file\",\".devcontainer/devcontainer.env\"] Docker Compose: Edit docker-compose.yml and add a path to the devcontainer.env file relative to the Docker Compose file: version: '3' services: your-service-name-here: env_file: devcontainer.env # ... If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Starting a process when the container starts When you are working in a development container, you may want to execute a command or start something each time the container starts. The easiest way to do this is using the postStartCommand property in devcontainer.json . For example, if you wanted to run yarn install every time you connected to the container to keep dependencies up to date, you could add the following: \"postStartCommand\": \"yarn install\" In other cases, you may want to start up a process and leave it running. This can be accomplished by using nohup and putting the process into the background using & . For example: \"postStartCommand\": \"nohup bash -c 'your-command-here &'\" Those familiar with Linux may expect to be able to use the systemctl command to start and stop background services managed by something called systemd . Unfortunately, systemd has overhead and is generally not used in containers as a result. In many cases, there is a command you can run instead (for example, sshd ). And on Debian/Ubuntu, there are often scripts under /etc/init.d that you can run directly. \"postStartCommand\": \"/etc/init.d/ssh start\" These systems also include a service command that will use systemctl or /etc/init.d scripts based on what is installed. \"postStartCommand\": \"service ssh start\" Adding startup commands to the Docker image instead While postStartCommand is convenient and allows you to execute commands in your source tree, you can also add these steps instead to a Dockerfile using a custom ENTRYPOINT or CMD . When referencing a Dockerfile in devcontainer.json , the default entrypoint and command is overridden. First, disable this behavior using the overrrideCommand property. \"overrideCommand\": false The overrideCommand property defaults to true because many images will immediately exit if a command is not specified. Instead, we will need to handle this in our Dockerfile. Next, consider this Dockerfile: FROM mcr.microsoft.com/vscode/devcontainers/base:0-focal COPY docker-entrypoint.sh / RUN chmod +x /docker-entrypoint.sh ENTRYPOINT [ \"/docker-entrypoint.sh\" ] CMD [ \"sleep\", \"infinity\"' ] The CMD here makes sure the container stays running by default. Keeping your startup steps in the ENTRYPOINT allows you to safely override the command when using docker run with your image or using Docker Compose. This resolves to the following: /docker-entrypoint.sh sleep infinity Next, create a docker-entrypoint.sh script: #!/usr/env bash echo \"Hello from our entrypoint!\" exec \"$@\" Anything you execute in this file will then fire each time the container starts. However, it's important to include the last exec \"$@\" line since this is what will cause the command sleep infinity in our example to fire. Finally, if you are using Docker Compose, be sure that neither the entrypoint nor command properties are set for your container. That's it! Adding another local file mount Note: Mounting the local file system is not supported in GitHub Codespaces. See developing inside a container on a remote Docker host for information on mounting remote folders in this scenario. You can add a volume bound to any local folder by using the following appropriate steps, based on what you reference in devcontainer.json : Dockerfile or image : Add the following to the mounts property (VS Code 1.41+) in this same file: \"mounts\": [ \"source=/local/source/path/goes/here,target=/target/path/in/container/goes/here,type=bind,consistency=cached\" ] You can also reference local environment variables or the local path of the workspace. For example, this will bind mount ~ ( $HOME ) on macOS/Linux and the user's folder ( %USERPROFILE% ) on Windows and a sub-folder in the workspace to a different location: \"mounts\": [ \"source=${localEnv:HOME}${localEnv:USERPROFILE},target=/host-home-folder,type=bind,consistency=cached\", \"source=${localWorkspaceFolder}/app-data,target=/data,type=bind,consistency=cached\" ] Docker Compose: Update (or extend ) your docker-compose.yml with the following for the appropriate service: version: '3' services: your-service-name-here: volumes: - /local/source/path/goes/here:/target/path/in/container/goes/here:cached - ~:/host-home-folder:cached - ./data-subfolder:/data:cached # ... If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Persist bash history between runs You can also use a mount to persist your bash command history across sessions / container rebuilds. First, update your Dockerfile so that each time a command is used in bash , the history is updated and stored in a location we will persist. If you have a root user, update your Dockerfile with the following: RUN SNIPPET=\"export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history\" \\ && echo $SNIPPET >> \"/root/.bashrc\" If you have a non-root user, update your Dockerfile with the following. Replace user-name-goes-here with the name of a non-root user in the container. ARG USERNAME=user-name-goes-here RUN SNIPPET=\"export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history\" \\ && mkdir /commandhistory \\ && touch /commandhistory/.bash_history \\ && chown -R $USERNAME /commandhistory \\ && echo $SNIPPET >> \"/home/$USERNAME/.bashrc\" Next, add a local volume to store the command history. This step varies depending on whether or not you are using Docker Compose. Dockerfile or image : Use the mounts property (VS Code 1.41+) in your devcontainer.json file. \"mounts\": [ \"source=projectname-bashhistory,target=/commandhistory,type=volume\" ] Docker Compose: Update (or extend ) your docker-compose.yml with the following for the appropriate service. version: '3' services: your-service-name-here: volumes: - projectname-bashhistory:/commandhistory # ... volumes: projectname-bashhistory: Finally, if you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Changing the default source code mount If you add the image or dockerFile properties to devcontainer.json , VS Code will automatically \"bind\" mount your current workspace folder into the container. If git is present on the host's PATH and the folder containing .devcontainer/devcontainer.json is within a git repository, the current workspace mounted will be the root of the repository. If git is not present on the host's PATH , the current workspace mounted will be the folder containing .devcontainer/devcontainer.json . While this is convenient, you may want to change mount settings , alter the type of mount, location, or run in a remote container . You can use the workspaceMount property in devcontainer.json to change the automatic mounting behavior. It expects the same value as the Docker CLI --mount flag . For example: \"workspaceMount\": \"source=${localWorkspaceFolder}/sub-folder,target=/workspace,type=bind,consistency=delegated\", \"workspaceFolder\": \"/workspace\" This also allows you to do something like a named volume mount instead of a bind mount, which can be useful particularly when using a remote Docker Host or you want to store your entire source tree in a volume . If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Improving container disk performance The Remote - Containers extension uses \"bind mounts\" to source code in your local filesystem by default. While this is the simplest option, on macOS and Windows, you may encounter slower disk performance when running commands like yarn install from inside the container. There are few things you can do to resolve these type of issues. Store your source code in the WSL 2 filesystem on Windows Windows 10 2004 and up includes an improved version of the Windows Subsystem for Linux (WSL 2) that provides a full Linux kernel and has significantly improved performance over WSL 1. Docker Desktop 2.3+ includes a new WSL 2 Engine that runs Docker in WSL rather than in a VM. Therefore, if you store your source code in the WSL 2 filesystem, you will see improved performance along with better compatibility for things like setting permissions. See Open a WSL 2 folder in a container on Windows for details on using this new engine from VS Code. Update the mount consistency to 'delegated' for macOS By default, the Remote - Containers extension uses the Docker cached mount consistency on macOS since this provides a good mix between performance and write guarantees on the host OS. However, you can opt to use the delegated consistency instead if you do not expect to be writing to the same file in both locations very often. When using a Dockerfile or image , update the Remote > Containers: Workspace Mount Consistency property in settings to delegated : When using Docker Compose , update your local bind mount in docker-compose.yml as follows: volumes: # Update this to wherever you want VS Code to mount the folder of your project - .:/workspace:delegated If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Use Clone Repository in Container Volume The Remote-Containers: Clone Repository in Container Volume... command uses an isolated, local Docker named volume instead binding to the local filesystem. In addition to not polluting your file tree, local volumes have the added benefit of improved performance on Windows and macOS. See Open a Git repository or GitHub PR in an isolated container volume for details on using this approach. The next two sections will outline how to use a named volume in other scenarios. Use a targeted named volume Since macOS and Windows run containers in a VM, \"bind\" mounts are not as fast as using the container's filesystem directly. Fortunately, Docker has the concept of a local \"named volume\" that can act like the container's filesystem but survives container rebuilds. This makes it ideal for storing package folders like node_modules , data folders, or output folders like build where write performance is critical. Follow the appropriate steps below based on what you reference in devcontainer.json . Dockerfile or image : Let's use the vscode-remote-try-node repository to illustrate how to speed up yarn install . Follow these steps: Use the workspaceMount property in devcontainer.json to tell VS Code where to bind your source code. Then use the mounts property (VS Code 1.41+) to mount the node_modules sub-folder into a named local volume instead. \"mounts\": [ \"source=try-node-node_modules,target=${containerWorkspaceFolder}/node_modules,type=volume\" ] Since this repository runs VS Code as the non-root \"node\" user , we need to add a postCreateCommand to be sure the user can access the folder. \"remoteUser\": \"node\", \"mounts\": [ \"source=try-node-node_modules,target=${containerWorkspaceFolder}/node_modules,type=volume\" ], \"postCreateCommand\": \"sudo chown node node_modules\" This second step is not required if you will be running in the container as root . If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Two notes on this approach: If you delete the node_modules folder in the container, it may lose the connection to the volume. Delete the contents of the node_modules folder instead when needed ( rm -rf node_modules/* node_modules/.* ). You'll find that an empty node_modules folder gets created locally with this method. This is because the volume mount point in the container is inside the local filesystem bind mount. This is expected and harmless. Docker Compose : While vscode-remote-try-node does not use Docker Compose, the steps are similar, but the volume mount configuration is placed in a different file. In your Docker Compose file (or an extended one ), add a named local volume mount to the node_modules sub-folder for the appropriate service(s). For example: version: '3' services: your-service-name-here: volumes: # Or wherever you've mounted your source code - .:/workspace:cached - try-node-node_modules:/workspace/node_modules # ... volumes: try-node-node_modules: Next, be sure the workspaceFolder property in devcontainer.json matches the place your actual source code is mounted: \"workspaceFolder\": \"/workspace\" If you're running in the container with a user other than root , add a postCreateCommand to update the owner of the folder you mount since it may have been mounted as root. Replace user-name-goes-here with the appropriate user. \"remoteUser\": \"node\", \"workspaceFolder\": \"/workspace\", \"postCreateCommand\": \"sudo chown user-name-goes-here node_modules\" If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Use a named volume for your entire source tree Finally, if none of the above options meet your needs, you can go one step further and clone your entire source tree inside of a named volume rather than locally. You can set up a named volume by taking an existing devcontainer.json configuration and modifying it as follows (updating your-volume-name-here with whatever you want to call the volume). Depending on what you reference in devcontainer.json : Dockerfile or image : Use the following properties in devcontainer.json to mount a local named volume into the container: \"workspaceMount\": \"source=your-volume-name-here,target=/workspace,type=volume\" \"workspaceFolder\": \"/workspace\", Docker Compose : Update (or extend ) your docker-compose.yml with the following for the appropriate service(s): version: '3' services: your-service-name-here: volumes: - your-volume-name-here:/workspace # ... volumes: your-volume-name-here: You'll also want to be sure the workspaceFolder property in devcontainer.json matches the place the volume is mounted (or a sub-folder inside the volume): \"workspaceFolder\": \"/workspace\" If you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Next, either use the Git: Clone command from the Command Palette or start an integrated terminal ( kb(workbench.action.terminal.new) ) and use the git clone command to clone your source code into the /workspace folder. Finally, use the File > Open... / Open Folder... command to open the cloned repository in the container. Avoiding extension reinstalls on container rebuild By default, VS Code will install extensions and VS Code Server inside the container's filesystem. While this has performance benefits over a locally mounted filesystem, the disadvantage is that VS Code will have to reinstall them on a container rebuild. If you find yourself rebuilding frequently, you can use a local \"named volume\" mount so that the extensions and VS Code Server survive a container rebuild. There are a two side effects of doing this you should be aware of: Deleting the container will not automatically delete the named volume. Sharing the volume across multiple containers can have unintended consequences, so to be safe we will pick a unique name for each. To create the named local volume, follow these steps: If you are running as a non-root user , you'll need to ensure your Dockerfile creates ~/.vscode-server/extensions and/or ~/.vscode-server-insiders/extensions in the container with this non-root user as the owner. If you do not do this, the folder will be owned by root and your connection will fail with a permissions issue. See Adding a non-root user to your dev container for full details, but you can use this snippet in your Dockerfile to create the folders. Replace user-name-goes-here with the actual user name: ARG USERNAME=user-name-goes-here RUN mkdir -p /home/$USERNAME/.vscode-server/extensions \\ /home/$USERNAME/.vscode-server-insiders/extensions \\ && chown -R $USERNAME \\ /home/$USERNAME/.vscode-server \\ /home/$USERNAME/.vscode-server-insiders Next, we'll configure a named volume mount for ~/.vscode-server/extensions and ~/.vscode-server-insiders/extensions in the container. The configuration will depend on whether you specify an image, Dockerfile, or Docker Compose file in your devcontainer.json file. Dockerfile or image : Add the following to devcontainer.json , replacing /root with the home directory in the container if not root (for example /home/user-name-goes-here ) and unique-vol-name-here with a unique name for the volume: \"mounts\": [ \"source=unique-vol-name-here,target=/root/.vscode-server/extensions,type=volume\", // And/or for VS Code Insiders \"source=unique-vol-name-here-insiders,target=/root/.vscode-server-insiders/extensions,type=volume\", ] Docker Compose : Update (or extend ) your docker-compose.yml with the following for the appropriate service. Replacing /root with the home directory in the container if not root (for example /home/user-name-goes-here ) and unique-vol-name-here with a unique name for the volume. services: your-service-name-here: volumes: - unique-vol-name-here:/root/.vscode-server/extensions # And/or for VS Code Insiders - unique-vol-name-here-insiders:/root/.vscode-server-insiders/extensions # ... volumes: unique-vol-name-here: unique-vol-name-here-insiders: Finally, if you've already built the container and connected to it, you'll need to run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Reopen Folder in Container to connect to the container for the first time. After the container is up and running, subsequent rebuilds will not reacquire any extensions or the VS Code server. The build will also not use the latest extensions list from devcontainer.json . However, if you want to completely reset, you can delete the volume and everything will be reinstalled on restart. docker volume rm unique-vol-name-here Adding a non-root user to your dev container Many Docker images use root as the default user, but there are cases where you may prefer to use a non-root user instead. If you do so, there are some quirks with local filesystem (bind) mounts that you should know about. Specifically: Docker Desktop for Mac : Inside the container, any mounted files/folders will act as if they are owned by the container user you specify. Locally, all filesystem operations will use the permissions of your local user instead. Docker Desktop for Windows : Inside the container, any mounted files/folders will appear as if they are owned by root but the user you specify will still be able to read/write them and all files will be executable. Locally, all filesystem operations will use the permissions of your local user instead. This is because there is fundamentally no way to directly map Windows-style file permissions to Linux. Docker CE/EE on Linux : Inside the container, any mounted files/folders will have the exact same permissions as outside the container - including the owner user ID (UID) and group ID (GID). Because of this, your container user will either need to have the same UID or be in a group with the same GID. The actual name of the user / group does not matter. The first user on a machine typically gets a UID of 1000, so most containers use this as the ID of the user to try to avoid this problem. Specifying a user for VS Code If the image or Dockerfile you are using already provides an optional non-root user (like the node image) but still defaults to root, you can opt into having VS Code (server) and any sub-processes (terminals, tasks, debugging) use it by specifying the remoteUser property in devcontainer.json : \"remoteUser\": \"user-name-goes-here\" On Linux, if you are referencing a Dockerfile or image in devcontainer.json , this will also automatically update the container user's UID/GID to match your local user to avoid the bind mount permissions problem that exists in this environment (unless you set \"updateRemoteUserUID\": false ). In the Docker Compose case, the container user's UID/GID will not be updated but you can manually change these values in a Dockerfile . Since this setting only affects VS Code and related sub-processes, VS Code needs to be restarted (or the window reloaded) for it to take effect. However, UID/GID updates are only applied when the container is created and requires a rebuild to change. Specifying the default container user In some cases, you may need all processes in the container to run as a different user (for example, due to startup requirements) rather than just VS Code. How you do this varies slightly depending on whether or not you are using Docker Compose. Dockerfile and image : Add the containerUser property to this same file. \"containerUser\": \"user-name-goes-here\" On Linux, like remoteUser , this will also automatically update the container user's UID/GID to match your local user to avoid the bind mount permissions problem that exists in this environment (unless you set \"updateRemoteUserUID\": false ). Docker Compose : Update (or extend ) your docker-compose.yml with the following for the appropriate service: user: user-name-or-UID-goes-here Creating a non-root user While any images or Dockerfiles that come from the Remote - Containers extension will include a non-root user with a UID/GID of 1000 (typically either called vscode or node ), many base images and Dockerfiles do not. Fortunately, you can update or create a Dockerfile that adds a non-root user into your container. Running your application as a non-root user is recommended even in production (since it is more secure), so this is a good idea even if you're reusing an existing Dockerfile. For example, this snippet for a Debian/Ubuntu container will create a user called user-name-goes-here , give it the ability to use sudo , and set it as the default: ARG USERNAME=user-name-goes-here ARG USER_UID=1000 ARG USER_GID=$USER_UID # Create the user RUN groupadd --gid $USER_GID $USERNAME \\ && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \\ # # [Optional] Add sudo support. Omit if you don't need to install software after connecting. && apt-get update \\ && apt-get install -y sudo \\ && echo $USERNAME ALL=\\(root\\) NOPASSWD:ALL > /etc/sudoers.d/$USERNAME \\ && chmod 0440 /etc/sudoers.d/$USERNAME # ******************************************************** # * Anything else you want to do like clean up goes here * # ******************************************************** # [Optional] Set the default user. Omit if you want to keep the default as root. USER $USERNAME Tip: If you hit an error when building about the GID or UID already existing, the image you selected likely already has a non-root user you can take advantage of directly. In either case, if you've already built the container and connected to it, run Remote-Containers: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Otherwise run Remote-Containers: Open Folder in Container... to connect to the container. Change the UID/GID of an existing container user While the remoteUser property tries to automatically update the UID/GID as appropriate on Linux when using a Dockerfile or image , you can use this snippet in your Dockerfile to manually change the UID/GID of a user instead. Update the ARG values as appropriate. ARG USERNAME=user-name-goes-here ARG USER_UID=1000 ARG USER_GID=$USER_UID RUN groupmod --gid $USER_GID $USERNAME \\ && usermod --uid $USER_UID --gid $USER_GID $USERNAME \\ && chown -R $USER_UID:$USER_GID /home/$USERNAME Note that on Alpine Linux, you'll need to install the shadow package first. RUN apk add --no-cache shadow Setting the project name for Docker Compose VS Code will respect the value of the COMPOSE_PROJECT_NAME environment variable if set for the VS Code process or in a .env file in the root of the project. For example, after shutting down all VS Code windows, you can start VS Code from the command line as follows: # from bash COMPOSE_PROJECT_NAME=foo code . # from PowerShell $env:COMPOSE_PROJECT_NAME=foo code . Or add the following to a .env file in the root of the project ( not in the .devcontainer folder): COMPOSE_PROJECT_NAME=foo Using Docker or Kubernetes from a container While you can build, deploy, and debug your application inside a dev container, you may also need to test it by running it inside a set of production-like containers. Fortunately, by installing the needed Docker or Kubernetes CLIs and mounting your local Docker socket, you can build and deploy your app's container images from inside your dev container. Once the needed CLIs are in place, you can also work with the appropriate container cluster using the Docker extension or the Kubernetes extension. See the following example dev container definitions for additional information on a specific scenario: Running Docker or Minikube in a development container Docker-in-Docker - Illustrates how to run Docker (or Moby) entirely inside a container. Provides support for bind mounting all folders inside the development container, but cannot reuse your local machine's cache. Kubernetes - Minikube-in-Docker - Illustrates how to run Minikube entirely inside a container with similar benefits and limitations as Docker-in-Docker. Accessing an existing Docker or Minikube instance from a container Docker-from-Docker - Also known as \"Docker-outside-of-Docker\", this illustrates how you can use the Docker (or Moby) CLI in your dev container to connect to your host's Docker daemon by bind mounting the Docker Unix socket. Lower overhead and can reuse your machine's cache, but has bind mounting limitations . Docker-from-Docker Compose - Variation of Docker-from-Docker for situations where you are using Docker Compose instead of a single Dockerfile. Kubernetes - Local Configuration - Takes the Docker-from-Docker model and adds kubectl and Helm to illustrate how you can access a local Minikube or Docker provided Kubernetes cluster. There is also documentation on the Docker-in-Docker , Docker-from-Docker , and Kubernetes install scripts that you can reuse and are referenced by the samples above. Mounting host volumes with Docker from inside a container When following the Docker-in-Docker model, using the Docker CLI from inside a dev container will cause it to interact with a Docker daemon running in the same place. This means that you can \"bind\" mount anything inside the dev container into the \"inner\" containers you create. For example, this will \"just work\": docker run -v /workspace/examplefile.txt:/incontainer/path debian However, if you want to bind mount a host folder available into this inner container, you need to mount it into your dev container first. With Docker-from-Docker , the type of bind mounting that works by default is reversed. Here, the Docker CLI inside the container interacts with the host's Docker daemon instead. This affects mounting directories from inside the container as the path inside the container may not match the path of the directory on the host. The same example above will fail since the path on the host, outside the container isn't /workspace/... . In addition, some folders simply cannot be mounted because they only exist in the container. If you need to do this, you may find the Docker-in-Docker model fits your needs better. If you are opening a folder in a container, you can pass the host directory into the container as an environment variable to allow you to mount the workspace folder. (This does not, however, work if you used a volume - Docker-in-Docker is the best choice there.) To do so, add the following to devcontainer.json : \"remoteEnv\": { // Pass in the host directory for Docker mount commands from inside the container \"HOST_PROJECT_PATH\": \"${localWorkspaceFolder}\" } The example below is from a makefile and mounts the KUBECONFIG file from the development container into the new Docker container it starts: docker run -p 8089:8089 -p 9090:9090 -v $(shell echo ${KUBECONFIG} | sed s#/workspace#${HOST_PROJECT_PATH}#):/kubeconfig.json -e KUBECONFIG=/kubeconfig.json ${IMG} -f behaviours/run_submit_locust.py Connecting to multiple containers at once Currently you can only connect to one container per VS Code window. However, you can spin up multiple VS Code windows to attach to them . If you'd prefer to use devcontainer.json instead and are using Docker Compose, you can create separate devcontainer.json files for each service in your source tree that point to a common docker-compose.yml . To see how this works, consider this example source tree: 📁 project-root 📁 .git 📁 container1-src 📄 .devcontainer.json 📄 hello.go 📁 container2-src 📄 .devcontainer.json 📄 hello.js 📄 docker-compose.yml The location of the .git folder is important, since we will need to ensure the containers can see this path for source control to work properly. Next, assume the docker-compose.yml in the root is as follows: version: '3' services: container-1: image: ubuntu:bionic volumes: # Mount the root folder that contains .git - .:/workspace:cached command: /bin/sh -c \"while sleep 1000; do :; done\" links: - container-2 # ... container-2: image: ubuntu:bionic volumes: # Mount the root folder that contains .git - .:/workspace:cached command: /bin/sh -c \"while sleep 1000; do :; done\" # ... You can then set up container1-src/.devcontainer.json for Go development as follows: { \"name\": \"Container 1\", \"dockerComposeFile\": [\"../docker-compose.yml\"], \"service\": \"container-1\", \"shutdownAction\": \"none\", \"extensions\": [\"golang.go\"], // Open the sub-folder with the source code \"workspaceFolder\": \"/workspace/container1-src\", } Next, you can set up container2-src/.devcontainer.json for Node.js development by changing workspaceFolder and installing Node.js extensions: { \"name\": \"Container 2\", \"dockerComposeFile\": [\"../docker-compose.yml\"], \"service\": \"container-2\", \"shutdownAction\": \"none\", \"extensions\": [\"dbaeumer.vscode-eslint\"], \"workspaceFolder\": \"/workspace/container2-src\" } The \"shutdownAction\":\"none\" in the devcontainer.json files is optional, but will leave the containers running when VS Code closes -- which prevents you from accidentally shutting down both containers by closing one window. To connect to both: Run Remote-Containers: Open Folder in Container... from the Command Palette ( kbstyle(F1) ) and select the container1-src folder. VS Code will then start up both containers, connect this window to service container-1 , and install the Go extension. Next, start up a new window using File > New Window . In the new window, run Remote-Containers: Open Folder in Container... from the Command Palette ( kbstyle(F1) ) and select the container2-src folder. Since the services are already running, VS Code will then connect to container-2 and install the ESLint extension. You can now interact with both containers at once from separate windows. Extending a Docker Compose file when connecting to two containers If you want to extend your Docker Compose file for development , you should use a single docker-compose.yml that extends both services (as needed) and is referenced in both .devcontainer.json files. For example, consider this docker-compose.devcontainer.yml file: version: '3' services: container-1: volumes: - ~:~/local-home-folder:cached # Additional bind mount # ... container-2: volumes: - ~/some-folder:~/some-folder:cached # Additional bind mount # ... Both .devcontainer.json files would be updated as follows: \"dockerComposeFile\": [ \"../docker-compose.yml\", \"../docker-compose.devcontainer.yml\", ] This list of compose files is used when starting the containers, so referencing different files in each .devcontainer.json can have unexpected results. Configure a separate container for multiple projects or folders While development containers often are tied to a single folder, repository, or project, they can also be used with multiple folders as a way to simplify setup or separate your tools. Imagine you had your source code across multiple repositories in a single folder for a given toolset. For example: 📁 Repos 📁 node 📁 python 📁 starter-snake-python 📁 vscode-remote-try-python 📁 your-python-project-here 📁 go 📁 dotnet Let's set up a container for use with all of the Python projects in the ./Repos/python folder. Start VS Code, select Remote-Containers: Open Folder in Container... from the Command Palette ( kbstyle(F1) ) or quick actions Status bar item, and select the ./Repos/python folder. Tip: If you want to edit the container's contents or settings before opening the folder, you can run Remote-Containers: Add Development Container Configuration Files... instead. Now pick a starting point for your dev container. You can either select a base dev container definition from a filterable list, or use an existing Dockerfile or Docker Compose file if one exists in the folder you selected. Note: When using Alpine Linux containers, some extensions may not work due to glibc dependencies in native code inside the extension. The list will be automatically sorted based on the contents of the folder you open. Note the dev container definitions displayed come from the vscode-dev-containers repository . You can browse the containers folder of that repository to see the contents of each definition. After picking the starting point for your container, VS Code will add the dev container configuration files to the ./Repos/python/.devcontainer folder. The VS Code window will reload and start building the dev container. A progress notification provides status updates. You only have to build a dev container the first time you open it; opening the folder after the first successful build will be much quicker. After the build completes, VS Code will automatically connect to the container. Once connected use File > Open... / Open Folder... to select one of the folders under ./Repos/python . In a moment, VS Code will open the folder inside the same container. In the future, you can use the Remote Explorer in the Activity Bar to open this sub-folder in the container directly. Tip: Instead of mounting the local filesystem, you can use a similar flow to set up a container with an isolated, more performant volume that you clone your source code into. See the Advanced Containers article for details. Developing inside a container on a remote Docker host Sometimes you may want to use the Remote - Containers extension to develop inside a container that sits on a remote server. Docker does not support mounting (binding) your local filesystem into a remote container, so VS Code's default devcontainer.json behavior to use your local source code will not work. While this is the default behavior, in this section we will cover connecting to a remote host so that you can either attach to any running container , or use a local devcontainer.json file as a way to configure, create, and connect to a remote dev container. However, note that the Docker CLI still needs to be installed locally (along with the Docker Compose CLI if you are using it). A basic remote example Setting up VS Code to attach to a container on a remote Docker host can be as easy as setting the Docker extension docker.host property in settings.json and restarting VS Code (or reloading the window). For example: \"docker.host\":\"ssh://your-remote-user@your-remote-machine-fqdn-or-ip-here\" Using SSH requires a supported SSH client , that you have key based authentication configured for the remote host, and that the key is imported into your local SSH agent . See the article on using SSH Keys with Git for details on configuring the agent and adding your key. At this point, you can attach to containers on the remote host. We'll cover more on information on how you can connect using settings and environment variables or Docker Machine later in this section. For devcontainer.json , there is one additional step: You'll need to update any configured (or auto-configured) bind mounts so they no longer point to the local filesystem. There's two variations of this setup. The first is to create your remote dev container first , and then clone your source code into a named volume since this does not require you to have direct access to the filesystem on the remote host. Here is a basic devcontainer.json example of this setup: { \"image\": \"node\", // Or \"dockerFile\" \"workspaceFolder\": \"/workspace\", \"workspaceMount\": \"source=remote-workspace,target=/workspace,type=volume\" } In fact, the Remote-Containers: Clone Repository in Container Volume... command in the Command Palette ( kbstyle(F1) ) uses this same technique. If you already have a devcontainer.json file in a GitHub repository that references an image or Dockerfile, the command will automatically use a named volume instead of a bind mount - which also works with remote hosts. The second approach is to bind mount a folder on the remote machine into your container. This requires you to have access to the remote filesystem, but also allows you to work with existing source code on the remote machine. Update the workspaceMount property in the example above to use this model instead: \"workspaceMount\": \"source=/absolute/path/on/remote/machine,target=/workspace,type=bind,consistency=cached\" In either case, to try it out, run Remote-Containers: Open Folder in Container... , and select the local folder with the .devcontainer.json file in it. See Converting an existing or pre-defined devcontainer.json for information on other scenarios like Docker Compose. Connect using VS Code settings or local environment variables If you already have a remote Docker host up and running, you can use the following properties in your workspace or user settings.json to specify the host. The SSH protocol Recent versions of Docker (18.06+) have added support for the SSH protocol to connect to remote Docker Host. This is easy to configure as you only need to set one property in settings.json to use it. First, install a supported SSH client , configure key based authentication ), and then import your key into your local SSH agent (which often is not running by default on Windows and Linux). See the article on using SSH Keys with Git for details on configuring the agent and adding the key. Then, add the following Docker extension docker.host property to settings.json (replacing values as appropriate): \"docker.host\":\"ssh://your-remote-user@your-remote-machine-fqdn-or-ip-here\" After restarting VS Code (or reloading the window), you will now be able to attach to any running container on the remote host. You can also use specialized, local devcontainer.json files to create / connect to a remote dev container . Tip: If this is not working for you but you are able to connect to the host using SSH from the command line, be sure you have the SSH agent running with your authentication key . If all else fails, you can use an SSH tunnel as a fallback instead. Using the TCP protocol While the SSH protocol has its own built-in authorization mechanism, using the TCP protocol often requires setting other Docker extension properties. These are: \"docker.host\":\"tcp://your-remote-machine-fqdn-or-ip-here:port\", \"docker.certPath\": \"/optional/path/to/folder/with/certificate/files\", \"docker.tlsVerify\": \"1\" // or \"0\" As with SSH, restart VS Code (or reload the window) for the settings to take effect. Using environment variables instead of settings.json If you'd prefer not to use settings.json , you can set environment variables in a terminal instead. The steps to do so are: Shut down all instances of VS Code. Ensure VS Code is in your operating system PATH . Set the environment variables (for example DOCKER_HOST ) in a terminal / command prompt. Type code in this same terminal / command prompt to launch VS Code with the variables set. Connect using Docker Machine Docker Machine is a CLI that allows you to securely set up remote Docker hosts and connect to them. You should also be aware that drivers like the generic driver shown below will require that any non-root user you specify has passwordless-sudo privileges. Use the following command with the appropriate values to set up Docker on a remote SSH host. Note that you can use alternate Docker Machine drivers instead if you prefer. docker-machine create --driver generic --generic-ip-address your-ip-address-here --generic-ssh-user your-remote-user-here give-it-a-name-here Once you have a machine set up: Shut down all instances of VS Code. Ensure VS Code is in your operating system PATH . Execute one of the following commands for your OS: macOS or Linux : eval $(docker-machine env give-it-a-name-here) code Windows PowerShell : docker-machine env give-it-a-name-here | Invoke-Expression code Converting an existing or pre-defined devcontainer.json To convert an existing or pre-defined, local devcontainer.json into a remote one, follow these steps: Open a local folder in VS Code (not a remote one) where you want to convert the file. If you did not select a folder with a devcontainer.json in it, you can pick a pre-defined one by running Remote-Containers: Add Container Configuration File... from the Command Palette ( kbstyle(F1) ). Follow these steps based on what your .devcontainer/devcontainer.json or .devcontainer.json references to alter the source code mount: Dockerfile or image : If you do not have login access to the remote host, use a Docker \"volume\" for your source code. Update .devcontainer/devcontainer.json as follows (replacing remote-workspace with a unique volume name if desired): \"workspaceMount\": \"source=remote-workspace,target=/workspace,type=volume\" \"workspaceFolder\": \"/workspace\", If you do have login access, you can use a remote filesystem bind mount instead: \"workspaceMount\": \"source=/absolute/path/on/remote/machine,target=/workspace,type=bind,consistency=cached\" \"workspaceFolder\": \"/workspace\", The workspaceMount property supports the same values as the Docker CLI --mount flag if you have a different scenario in mind. Docker Compose : If you do not have login access to the remote host, update (or extend ) your docker-compose.yml . Replace your-service-name-here with the value specified for the \"service\" property in devcontainer.json and appropriate and remote-workspace with a unique volume name: version: '3' services: your-service-name-here: volumes: - remote-workspace:/workspace # ... volumes: remote-workspace: If you do have login access, you can use a remote filesystem bind mount instead: version: '3' services: your-service-name-here: volumes: - /absolute/path/on/remote/machine:/workspace:cached # ... See the Docker Compose documentation on volumes if you need to support a different scenario. Run the Remote-Containers: Reopen Folder in Container command from the Command Palette ( kbstyle(F1) ) or Remote-Containers: Rebuild Container . If you used a volume instead of a bind mount, use kb(workbench.action.terminal.new) to open a terminal inside the container. You can run git clone from here to pull down your source code and use File > Open... / Open Folder... to open the cloned repository. Next time you want to connect to this same container, run Remote-Containers: Open Folder in Container... and select the same local folder in a VS Code window. [Optional] Making the remote source code available locally If you store your source code on the remote host's filesystem instead of inside a Docker volume, there are several ways you can access the files locally: Mount the remote filesystem using SSHFS . Sync files from the remote host to your local machine using rsync . Use the mount command if you are using Docker Machine . Using SSHFS or Docker Machine's mount command are the more convenient options and do not require any file sync'ing. However, performance will be significantly slower than working through VS Code, so they are best used for single file edits and uploading/downloading content. If you need to use an application that bulk reads/write to many files at once (like a local source control tool), rsync is a better choice. Reducing Dockerfile build warnings The following are some tips for eliminating warnings that may be appearing in your Dockerfile builds. debconf: delaying package configuration, since apt-utils is not installed This error can typically be safely ignored and is tricky to get rid of completely. However, you can reduce it to one message in stdout when installing the needed package by adding the following to your Dockerfile: RUN apt-get update \\ && export DEBIAN_FRONTEND=noninteractive \\ && apt-get -y install --no-install-recommends apt-utils dialog 2>&1 Warning: apt-key output should not be parsed (stdout is not a terminal) This non-critical warning tells you not to parse the output of apt-key , so as long as your script doesn't, there's no problem. You can safely ignore it. This occurs in Dockerfiles because the apt-key command is not running from a terminal. Unfortunately, this error cannot be eliminated completely, but can be hidden unless the apt-key command returns a non-zero exit code (indicating a failure). For example: # (OUT=$(apt-key add - 2>&1) || echo $OUT) will only print the output with non-zero exit code is hit curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | (OUT=$(apt-key add - 2>&1) || echo $OUT) You can also set the APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE environment variable to suppress the warning, but it looks a bit scary so be sure to add comments in your Dockerfile if you use it: # Suppress an apt-key warning about standard out not being a terminal. Use in this script is safe. ENV APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=DontWarn Information messages appearing in red Some CLIs output certain information (like debug details) to standard error instead of standard out. These will appear in red in VS Code's terminal and output logs. If the messages are harmless, you can pipe the output of the command from standard error to standard out instead by appending 2>&1 to the end of the command. For example: RUN apt-get -y install --no-install-recommends apt-utils dialog 2>&1 If the command fails, you will still be able to see the errors but they won't be in red. Questions or feedback See Tips and Tricks or the FAQ . Search on Stack Overflow . Add a feature request or report a problem . Create a development container definition for others to use. Contribute to our documentation or VS Code itself . See our CONTRIBUTING guide for details."
  },
  "guides/vscode/remote/containers-tutorial.html": {
    "href": "guides/vscode/remote/containers-tutorial.html",
    "title": "Remote development in Containers | Fountain of Knowledge",
    "keywords": "Remote development in Containers This tutorial walks you through running Visual Studio Code in a Docker container using the Remote - Containers extension. You need no prior knowledge of Docker to complete this tutorial. Running VS Code inside a Docker container can be useful for many reasons, but in this walkthrough we'll focus on using a Docker container to set up a development environment that is isolated from your local environment. Prerequisites You need Visual Studio Code installed. Install Docker Docker is needed to create and manage your containers. Docker Desktop Download and install Docker Desktop . Start Docker Run the Docker Desktop application to start Docker. You will know it's running if you look in the activity tray and see the Docker whale icon. Docker might take a few minutes to start. If the whale icon is animated, it is probably still in the process of starting. You can click on the icon to see the status. Check Docker Once Docker is running, you can confirm that everything is working by opening a new terminal window and typing the command: docker --version # Docker version 18.09.2, build 6247962 Install the extension The Remote - Containers extension lets you run Visual Studio Code inside a Docker container. Install the Remote - Containers extension Check installation With the Remote - Containers extension installed, you will see a new Status bar item at the far left. The Remote Status bar item can quickly show you in which context VS Code is running (local or remote) and clicking on the item will bring up the Remote - Containers commands. Get the sample To create a Docker container, we are going to open a GitHub repository with a Node.js project. Select Remote-Containers: Try a Sample... from the command list that appears and select the Node sample from the list. Note : There are other remote container samples such as vscode-remote-try-python or vscode-remote-try-java , but this tutorial will use vscode-remote-try-node . Wait for the container to build The window will then reload, but since the container does not exist yet, VS Code will create one and clone the sample repository into an isolated container volume . This may take some time, and a progress notification will provide status updates. Fortunately, this step isn't necessary the next time you open the folder since the container will already exist. After the container is built, VS Code automatically connects to it and maps the project folder from your local file system into the container. Check the container Once the container is running and you're connected, you should see your remote context change in the bottom left of the Status bar: Check your environment One of the useful things about developing in a container is that you can use specific versions of dependencies that your application needs without impacting your local development environment. The specific container for this tutorial has Node.js v12 installed, which you can check by opening a new terminal Terminal > New Terminal ( kb(workbench.action.terminal.new) ) and entering: node --version; npm --version This should show the following versions: Run the application We can now hit kb(workbench.action.debug.start) , which will run the application inside the container. Once the process starts, navigate to http://localhost:3000 and you should see the simple Node.js server running! Ending your container connection You can end your session in the container and go back to running VS Code locally with File > Close Remote Connection . How it works This next section describes in more detail how the Remote - Containers extension sets up and configures your containers. The remote container extension uses the files in the .devcontainer folder, namely devcontainer.json , and an optional Dockerfile or docker-compose.yml , to create your dev containers. First your image is built from the supplied Docker file or image name. Then a container is created and started using some of the settings in the devcontainer.json . Finally your Visual Studio Code environment is installed and configured again according to settings in the devcontainer.json . Once all of this is done, your local copy of Visual Studio Code connects to the Visual Studio Code Server running inside of your new dev container. devcontainer.json The devcontainer.json is basically a config file that determines how your dev container gets built and started. //devcontainer.json { \"name\": \"Node.js Sample\", \"dockerFile\": \"Dockerfile\", \"settings\": { \"terminal.integrated.shell.linux\": \"/bin/bash\" }, \"extensions\": [ \"dbaeumer.vscode-eslint\" ], \"forwardPorts\": [3000], \"postCreateCommand\": \"yarn install\", \"remoteUser\": \"node\" } The above example is taken from the vscode-remote-try-node repo we used in the tutorial. Option Description dockerfile Relative path to a Dockerfile that you want to use as your image. settings Adds default settings.json values into a container/machine specific settings file. extensions An array of extension IDs that specify the extensions that should be installed inside the container when it is created. forwardPorts Make a list of ports inside the container available locally. postCreateCommand A command string or list of command arguments to run after the container is created. remoteUser Overrides the user that VS Code runs as in the container (along with sub-processes). Defaults to the containerUser . Full list of devcontainer.json options. Congratulations! Congratulations, you've successfully completed this tutorial! This has been a brief overview of what is possible using dev containers. As a next step, we recommend checking out how you can open an existing folder from your machine in a container or opening a GitHub repository or PR in a container . Check out the other Remote Development extensions. Remote - SSH Remote - WSL Or get them all by installing the Remote Development Extension Pack. Troubleshooting Verify Docker context If you are not using a fresh Docker install and the Remote-Containers: Try a Sample... sample encounters issues with the current context, you should check your Docker context. Fresh installs will have a 'default' context and you can set it back as the current context. # Displays the list of contexts, '*' denotes the current context docker context list # Switches the list to the 'default' context docker context use default"
  },
  "guides/vscode/remote/create-dev-container.html": {
    "href": "guides/vscode/remote/create-dev-container.html",
    "title": "Create a development container | Fountain of Knowledge",
    "keywords": "Create a development container The Visual Studio Code Remote - Containers extension lets you use a Docker container as a full-featured development environment. It allows you to open any folder or repository inside a container and take advantage of Visual Studio Code's full feature set. A devcontainer.json file in your project tells VS Code how to access (or create) a development container with a well-defined tool and runtime stack. This container can be used to run an application or to separate tools, libraries, or runtimes needed for working with a codebase. Path to creating a dev container In this document, we'll go through the steps for creating a development (dev) container in VS Code: Create a devcontainer.json , which describes how VS Code should start the container and what to do after it connects. Make and persist changes to the dev container, such as installation of new software, through use of a Dockerfile. Configure multiple containers through Docker Compose. As you make changes, build your dev container to ensure changes take effect. After any of the steps above, you'll have a fully functioning dev container, and you can either continue to the next step of this tutorial to add more features, or stop and begin working in the dev environment you currently have. Note: The Remote - Containers extension has a Remote-Containers: Add Development Container Configuration Files... command that lets you pick a pre-defined container configuration from a list. If you'd prefer to have a complete dev container immediately rather than building up the devcontainer.json and Dockerfile step-by-step, you can skip ahead to Automate dev container creation . Create a devcontainer.json file VS Code's container configuration is stored in a devcontainer.json file. This file is similar to the launch.json file for debugging configurations, but is used for launching (or attaching to) your development container instead. The dev container configuration is either located under .devcontainer/devcontainer.json or stored as a .devcontainer.json file (note the dot-prefix) in the root of your project. You can use an image as a starting point for your devcontainer.json . An image is like a mini-disk drive with various tools and an operating system pre-installed. You can pull images from a container registry, which is a collection of repositories that store images. Here is a simple example devcontainer.json that uses a pre-built TypeScript and Node.js VS Code Development Container image from the popular container registry Docker Hub : { \"image\": \"mcr.microsoft.com/vscode/devcontainers/typescript-node:0-12\" } You can alter your configuration to do things such as: Install additional tools such as Git in the container. Automatically install extensions. Forward or publish additional ports. Set runtime arguments. Reuse or extend your existing Docker Compose setup . Add more advanced container configurations . For this example, if you'd like to install the ESLint extension into your container and automatically forward port 3000, your devcontainer.json would look like: { \"image\": \"mcr.microsoft.com/vscode/devcontainers/typescript-node:0-12\", \"extensions\": [ \"dbaeumer.vscode-eslint\" ], \"forwardPorts\": [ 3000 ] } With the above devcontainer.json , your dev container is functional, and you can connect to and start developing within it. Try it out with the Remote-Containers: Reopen in Container command: After running this command, when VS Code restarts, you're now within a Node.js and TypeScript dev container with port 3000 forwarded and the ESLint extension installed. Once you're connected, notice the green remote indicator on the left of the Status bar to show you are connected to your dev container: Additional dev container scenarios Through a devcontainer.json file, you can: Spin up a stand-alone container to isolate your toolchain or speed up setup. Work with a container deployed application defined by an image, Dockerfile , or Docker Compose . Use Docker or Kubernetes from inside a dev container to build and deploy your app. If devcontainer.json 's supported workflows do not meet your needs, you can also attach to an already running container instead . Tip: Want to use a remote Docker host? See the Advanced Containers article for details on setup. Install additional software You may want to install additional software in your dev container. Once VS Code is connected to the container, you can open a VS Code terminal and execute any command against the OS inside the container. This allows you to install new command-line utilities and spin up databases or application services from inside the Linux container. Most container images are based on Debian or Ubuntu, where the apt or apt-get command is used to install new packages. You can learn more about the command in Ubuntu's documentation . Alpine images include a similar apk command while CentOS / RHEL / Oracle SE / Fedora images use yum or more recently dnf . Documentation for the software you want to install will usually provide specific instructions, but you may not need to prefix commands with sudo if you are running as root in the container. For example: # If running as root apt-get update apt-get install <package> If you are running as root, you can install software as long as sudo is configured in your container. All predefined containers have sudo set up, but the Advanced Container Configuration article can help you set this up for your own containers. Regardless, if you install and configure sudo , you'll be able to use it when running as any user including root. # If sudo is installed and configured sudo apt-get update sudo apt-get install <package> Let's say you want to install Git. You could run the following commands in the integrated terminal in VS Code: # If sudo is installed and configured sudo apt-get update # Install Git sudo apt-get install git Rebuild When editing the contents of the .devcontainer folder, you'll need to rebuild for changes to take effect. Use the Remote-Containers: Rebuild Container command for your container to update. However, if you rebuild the container, you will have to reinstall anything you've installed manually. To avoid this problem, you can use the postCreateCommand property in devcontainer.json . The postCreateCommand is run once the container is running, so you can also use the property to run commands like npm install or to execute a shell script in your source tree (if you have mounted it). \"postCreateCommand\": \"bash scripts/install-dev-tools.sh\" You can also use an interactive bash shell so that your .bashrc is picked up, automatically customizing your shell for your environment: \"postCreateCommand\": \"bash -i scripts/install-dev-tools.sh\" Tools like NVM won't work without using -i to put the shell in interactive mode: \"postCreateCommand\": \"bash -i -c 'nvm install --lts'\" The command needs to exit or the container won't start. For instance, if you add an application start to postCreateCommand , the command wouldn't exit. There is also a postStartCommand that executes every time the container starts. The parameters behave exactly like postCreateCommand , but the commands execute on start rather than create. Rather than referencing an image directly in devcontainer.json or installing software via the postCreateCommand or postStartCommand , an even more efficient practice is to use a Dockerfile. Dockerfile A Dockerfile will also live in the .devcontainer folder. You can replace the image property in devcontainer.json with dockerFile : { \"build\": { \"dockerfile\": \"Dockerfile\" }, \"extensions\": [ \"dbaeumer.vscode-eslint\" ], \"forwardPorts\": [ 3000 ] } When you make changes like installing new software, changes made in the Dockerfile will persist even upon a rebuild of the dev container. In your Dockerfile, use FROM to designate the image, and the RUN instruction to install any software. You can use && to string together multiple commands. FROM mcr.microsoft.com/vscode/devcontainers/typescript-node:0-12 RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \\ && apt-get install git Note: The DEBIAN_FRONTEND export avoids warnings when you go on to work with your container. Automate dev container creation Rather than creating a .devcontainer by hand, selecting the Remote-Containers: Add Development Container Configuration Files... command from the Command Palette ( kbstyle(F1) ) will add the needed files to your project as a starting point, which you can further customize for your needs. The command lets you pick a pre-defined container configuration from a list based on your folder's contents: All of the predefined container configurations you can pick from come from the vscode-dev-containers repository , which has examples of devcontainer.json and Dockerfiles for different scenarios. You can also reuse an existing Dockerfile: Now that you have a devcontainer.json and Dockerfile, let's see the general process for editing container configuration files. Full configuration edit loop Editing your container configuration is easy. Since rebuilding a container will \"reset\" the container to its starting contents (with the exception of your local source code), VS Code does not automatically rebuild if you edit a container configuration file ( devcontainer.json , Dockerfile , and docker-compose.yml ). Instead, there are several commands that can be used to make editing your configuration easier. Here is the typical edit loop using these commands: Start with Remote-Containers: Add Development Container Configuration Files... in the Command Palette ( kbstyle(F1) ). Edit the contents of the .devcontainer folder as required. Try it with Remote-Containers: Reopen in Container . If you see an error, select Open Folder Locally in the dialog that appears. After the window reloads, a copy of the build log will appear in the console so you can investigate the problem. Edit the contents of the .devcontainer folder as required. (You can also use the Remote-Containers: Open Log File... command to see the log again if you close it.) Run Remote-Containers: Rebuild and Reopen in Container and jump to step 4 if needed. If you already have a successful build, you can still edit the contents of the .devcontainer folder as required when connected to the container and then select Remote-Containers: Rebuild Container in the Command Palette ( kbstyle(F1) ) so the changes take effect. You can also iterate on your container when using the Remote-Containers: Clone Repository in Container Volume command. Start with Remote-Containers: Clone Repository in Container Volume in the Command Palette ( kbstyle(F1) ). If the repository you enter does not have a devcontainer.json in it, you'll be asked to select a starting point. Edit the contents of the .devcontainer folder as required. Try it with Remote-Containers: Rebuild Container . If you see an error, select Open in Recovery Container in the dialog that appears. Edit the contents of the .devcontainer folder as required in this \"recovery container.\" Use Remote-Containers: Reopen in Container and jump to step 4 if you still hit problems. Use Docker Compose In some cases, a single container environment isn't sufficient. Let's say you'd like to add another complex component to your configuration, like a database. You could attempt to add it to the Dockerfile directly, or you could add it through an additional container. Fortunately, Remote - Containers supports Docker Compose managed multi-container configurations. You can either: Work with a service defined in an existing, unmodified docker-compose.yml . Create a new docker-compose.yml (or make a copy of an existing one) that you use to develop a service. Extend your existing Docker Compose configuration to develop the service. Use separate VS Code windows to work with multiple Docker Compose-defined services at once. Note: When using Alpine Linux containers, some extensions may not work due to glibc dependencies in native code inside the extension. VS Code can be configured to automatically start any needed containers for a particular service in a Docker Compose file. If you've already started the configured containers using the command line, VS Code will attach to the running service you've specified instead. This gives your multi-container workflow the same quick setup advantages described for the Docker image and Dockerfile workflows above, while still allowing you to use the command line if you prefer. To get started quickly, open the folder you want to work with in VS Code and run the Remote-Containers: Add Development Container Configuration Files... command in the Command Palette ( kbstyle(F1) ). You'll be asked to either select an existing Docker Compose file (if one exists), or pick a pre-defined container configuration from the vscode-dev-containers repository in a filterable list sorted based on your folder's contents. Many of these \"dev container definitions\" use a Dockerfile, so select one of the following definitions as a starting point for Docker Compose: Existing Docker Compose Node.js & MongoDB Python & PostgreSQL Docker-from-Docker Compose . After you make your selection, VS Code will add the appropriate .devcontainer/devcontainer.json (or .devcontainer.json ) file to the folder. You can also create your configuration manually. To reuse a Docker Compose file unmodified, you can use the dockerComposeFile and service properties in .devcontainer/devcontainer.json . For example: { \"name\": \"[Optional] Your project name here\", \"dockerComposeFile\": \"../docker-compose.yml\", \"service\": \"the-name-of-the-service-you-want-to-work-with-in-vscode\", \"workspaceFolder\": \"/default/workspace/path/in/container/to/open\", \"shutdownAction\": \"stopCompose\" } See the devcontainer.json reference for information other available properties such as the workspaceFolder and shutdownAction . Once you have added a .devcontainer/devcontainer.json file to your folder, run the Remote-Containers: Reopen in Container command (or Remote-Containers: Open Folder in Container... if you are not yet in a container) from the Command Palette ( kbstyle(F1) ). If the containers are not already running, VS Code will call docker-compose -f ../docker-compose.yml up in this example. The service property indicates which service in your Docker Compose file VS Code should connect to, not which service should be started. If you started them by hand, VS Code will attach to the service you specified. You can also create a development copy of your Docker Compose file. For example, if you had .devcontainer/docker-compose.devcontainer.yml , you would just change the following line in devcontainer.json : \"dockerComposeFile\": \"docker-compose.devcontainer.yml\" However, a better approach is often to avoid making a copy of your Docker Compose file by extending it with another one . We'll cover extend a Docker Compose file in the next section. To avoid having the container shut down if the default container command fails or exits, you can modify your Docker Compose file for the service you have specified in devcontainer.json as follows: # Overrides default command so things don't shut down after the process ends. command: /bin/sh -c \"while sleep 1000; do :; done\" If you have not done so already, you can \"bind\" mount your local source code into the container using the volumes list in your Docker Compose file . For example: volumes: # Mounts the project folder to '/workspace'. The target path inside the container # should match what your application expects. In this case, the compose file is # in a sub-folder, so you will mount '..'. You would then reference this path as the # 'workspaceFolder' in '.devcontainer/devcontainer.json' so VS Code starts here. - ..:/workspace:cached However, on Linux you may need to set up and specify a non-root user when using a bind mount or any files you create will be root. See Adding a non-root user to your dev container for details. To have VS Code run as a different user, add this to devcontainer.json : \"remoteUser\": \"your-user-name-here\" If you want all processes to run as a different user, add this to the appropriate service in your Docker Compose file: user: your-user-name-here If you aren't creating a custom Dockerfile for development, you may want to install additional developer tools such as curl inside the service's container. While less efficient than adding these tools to the container image, you can also use the postCreateCommand property for this purpose. See install additional software for more information on installing software and the devcontainer.json reference for more information about the postCreateCommand property. If your application was built using C++, Go, or Rust, or another language that uses a ptrace-based debugger, you will also need to add the following settings to your Docker Compose file: # Required for ptrace-based debuggers like C++, Go, and Rust cap_add: - SYS_PTRACE security_opt: - seccomp:unconfined After you create your container for the first time, you will need to run the Remote-Containers: Rebuild Container command for updates to devcontainer.json , your Docker Compose files, or related Dockerfiles to take effect. Using localhost in Docker Compose You can add other services to your docker-compose.yml file as described in Docker's documentation . However, if you want anything running in this service to be available in the container on localhost, or want to forward the service locally, be sure to add this line to the service config: # Runs the service on the same network as the database container, allows \"forwardPorts\" in devcontainer.json function. network_mode: service:db You can see an example of network_mode: service:db in the Node.js and Mongo DB example dev container . Extend your Docker Compose file for development Referencing an existing deployment / non-development focused docker-compose.yml has some potential downsides. For example: Docker Compose will shut down a container if its entry point shuts down. This is problematic for situations where you are debugging and need to restart your app on a repeated basis. You also may not be mapping the local filesystem into the container or exposing ports to other resources like databases you want to access. You may want to copy the contents of your local .ssh folder into the container or set the ptrace options described above in Use Docker Compose . You can solve these and other issues like them by extending your entire Docker Compose configuration with multiple docker-compose.yml files that override or supplement your primary one. For example, consider this additional .devcontainer/docker-compose.extend.yml file: version: '3' services: your-service-name-here: volumes: # Mounts the project folder to '/workspace'. While this file is in .devcontainer, # mounts are relative to the first file in the list, which is a level up. - .:/workspace:cached # [Optional] Required for ptrace-based debuggers like C++, Go, and Rust cap_add: - SYS_PTRACE security_opt: - seccomp:unconfined # Overrides default command so things don't shut down after the process ends. command: /bin/sh -c \"while sleep 1000; do :; done\" This same file can provide additional settings, such as port mappings, as needed. To use it, reference your original docker-compose.yml file in addition to .devcontainer/devcontainer.extend.yml in a specific order: { \"name\": \"[Optional] Your project name here\", // The order of the files is important since later files override previous ones \"dockerComposeFile\": [ \"../docker-compose.yml\", \"docker-compose.extend.yml\" ], \"service\": \"your-service-name-here\", \"workspaceFolder\": \"/workspace\", \"shutdownAction\": \"stopCompose\" } VS Code will then automatically use both files when starting up any containers. You can also start them yourself from the command line as follows: docker-compose -f docker-compose.yml -f .devcontainer/docker-compose.extend.yml up While the postCreateCommand property allows you to install additional tools inside your container, in some cases you may want to have a specific Dockerfile for development. You can also use this same approach to reference a custom Dockerfile specifically for development without modifying your existing Docker Compose file. For example, you can update .devcontainer/devcontainer.extend.yml as follows: version: '3' services: your-service-name-here: # Note that the path of the Dockerfile and context is relative to the *primary* # docker-compose.yml file (the first in the devcontainer.json \"dockerComposeFile\" # array). The sample below assumes your primary file is in the root of your project. build: context: . dockerfile: .devcontainer/Dockerfile volumes: - .:/workspace:cached command: /bin/sh -c \"while sleep 1000; do :; done\" For example: { \"name\": \"[Optional] Your project name here\", \"dockerComposeFile\": \"../docker-compose.yml\", \"service\": \"the-name-of-the-service-you-want-to-work-with-in-vscode\", \"workspaceFolder\": \"/default/workspace/path/in/container/to/open\", \"shutdownAction\": \"stopCompose\" } Once you have added a .devcontainer/devcontainer.json file to your folder, run the Remote-Containers: Reopen in Container command (or Remote-Containers: Open Folder in Container... if you are not yet in a container) from the Command Palette ( kbstyle(F1) ). Docker Compose dev container definitions The following are dev container definitions that use Docker Compose: Existing Docker Compose - Includes a set of files that you can drop into an existing project that will reuse a docker-compose.yml file in the root of your project. Node.js & MongoDB - A Node.js container that connects to a Mongo DB in a different container. Python & PostgreSQL - A Python container that connects to PostGreSQL in a different container. Docker-from-Docker Compose - Includes the Docker CLI and illustrates how you can use it to access your local Docker install from inside a dev container by volume mounting the Docker Unix socket. Congratulations! You've now configured a dev container in Visual Studio Code. Continue reading to learn how to share container configurations among teammates and various projects. Add configuration files to a repository You can easily share a customized dev container definition for your project by adding devcontainer.json files to source control. By including these files in your repository, anyone that opens a local copy of your repo in VS Code will be automatically prompted to reopen the folder in a container, provided they have the Remote - Containers extension installed. Beyond the advantages of having your team use a consistent environment and tool-chain, this also makes it easier for new contributors or team members to be productive quickly. First-time contributors will require less guidance and hit fewer issues related to environment setup. Alternative: Repository configuration folders In some cases, you may want to create a configuration for a repository that you do not control or that you would prefer didn't have a configuration included in the repository itself. To handle this situation, you can configure a location on your local filesystem to store configuration files that will be picked up automatically based on the repository. First, update the Remote > Containers: Repository Configuration Paths User setting with the local folder you want to use to store your repository container configuration files. In the Settings editor: Next, place your .devcontainer/devcontainer.json (and related files) in a sub folder that mirrors the remote location of the repository. For example, if you wanted to create a configuration for github.com/microsoft/vscode-dev-containers , you would create the following folder structure: 📁 github.com 📁 microsoft 📁 vscode-dev-containers 📁 .devcontainer Once in place, the configuration will be automatically picked up when using any of the remote containers commands. Once in the container, you can also select Remote-Containers: Open Container Configuration File from the Command Palette ( kbstyle(F1) ) to open the related devcontainer.json file and make further edits. Next steps Attach to a Running Container - Attach to an already running Docker container. Advanced Containers - Find solutions to advanced container scenarios. devcontainer.json reference - Review the devcontainer.json schema."
  },
  "guides/vscode/remote/devcontainer-cli.html": {
    "href": "guides/vscode/remote/devcontainer-cli.html",
    "title": "devcontainer command line interface | Fountain of Knowledge",
    "keywords": "devcontainer command line interface The Remote-Containers extension has a devcontainer command line interface (CLI) which allows you to interact with a dev container from your terminal. Installing the devcontainer CLI To install the devcontainer CLI: Ensure you have the latest version of the Remote-Containers extension installed (must be at least v0.188.0 ). Launch Visual Studio Code and select Remote-Containers: Install devcontainer CLI from the Command Palette ( kbstyle(F1) ). Windows : You will be prompted to automatically add the devcontainer CLI to your PATH or to copy the devcontainer CLI path to your clipboard for you to add to your PATH . macOS/Linux : If the extension detects a bin folder (or .local/bin folder) in your user home folder and in your PATH , then you will have the option of adding a symlink to the devcontainer CLI to this location. You will also have the option to copy the devcontainer CLI path to your clipboard for you to add to your PATH . From an external terminal (one not inside Visual Studio Code), run devcontainer --help to test the installation and see the CLI's built-in help. Note that you may need to restart your shell for PATH changes to take effect. $ devcontainer --help devcontainer <command> : devcontainer open [path] Open a dev container in VS Code devcontainer build [path] [options] Build a dev container image Options: -h, --help Show help [boolean] Opening a folder directly within a dev container Visual Studio Code has many command line options , including code . that opens Visual Studio Code with the current folder. When you do this with a folder containing a dev container, Visual Studio Code will prompt you to reopen the folder within a dev container. With the devcontainer CLI, you can use the devcontainer open command to open the current folder straight into dev container mode, skipping the prompt. You can optionally specify the path to the folder to open, for example devcontainer open ~/source/my-folder to open the ~/source/my-folder folder within a dev container. Building a dev container image The devcontainer build command allows you to build the dev container image for a folder. As with the open command, build accepts a path to the folder to build the image for and defaults to the current working folder in your shell. For example, devcontainer build will build the dev container image for the current folder and devcontainer build ~/source/my-folder will build the container image for the ~/source/my-folder folder. devcontainer CLI build options The following options can be used with the build command: --no-cache : By default, building a Docker container image reuses layers from previous image builds. The --no-cache option prevents the cache being used and forces the image to be rebuilt. --image-name : The Remote-Containers extension typically determines its own name for the images it builds. You can specify the name to use for the built image using the --image-name option. Visual Studio Code Insiders You can install the CLI for the Stable and Insiders builds of Visual Studio Code side-by-side. The Insiders CLI will be devcontainer-insiders , so use this in place of devcontainer in the steps above. Next steps Create a Development Container - Create a custom container for your work environment. Advanced Containers - Find solutions to advanced container scenarios. devcontainer.json reference - Review the devcontainer.json schema."
  },
  "guides/vscode/remote/devcontainerjson-reference.html": {
    "href": "guides/vscode/remote/devcontainerjson-reference.html",
    "title": "devcontainer.json reference | Fountain of Knowledge",
    "keywords": "devcontainer.json reference A devcontainer.json file in your project tells Visual Studio Code how to access (or create) a development container with a well-defined tool and runtime stack. This container can be used to run an application or to separate tools, libraries, or runtimes needed for working with a codebase. It can be used with the Remote - Containers extension or GitHub Codespaces . Set up a folder to run in a container has more information on configuring a dev container or use the Remote-Containers: Add Development Container Configuration Files... or Codespaces: Add DevelopmentContainer Configuration Files... commands from the Command Palette ( kbstyle(F1) ) to add a wide variety of base configurations from the vscode-dev-containers repository . devcontainer.json properties While some devcontainer.json properties apply generally, others are only used in specific scenarios. The following table will outline the properties that apply in each situation. You may need different commands to be run at different points in the container's lifecycle. The lifecycle scripts section later in this doc describes how some of the below properties may shape the container over time. Property Type Description Dockerfile or image image string Required when using an image . The name of an image in a container registry ( DockerHub , GitHub Container Registry , Azure Container Registry ) that VS Code should use to create the dev container. build.dockerfile / dockerFile string Required when using a Dockerfile . The location of a Dockerfile that defines the contents of the container. The path is relative to the devcontainer.json file. You can find Dockerfiles for different runtimes in the vscode-dev-containers repository . build.context / context string Path that the Docker build should be run from relative to devcontainer.json . For example, a value of \"..\" would allow you to reference content in sibling directories. Defaults to \".\" . build.args Object A set of name-value pairs containing Docker image build arguments that should be passed when building a Dockerfile. Environment and pre-defined variables may be referenced in the values. Defaults to not set. For example: \"build\": { \"args\": { \"MYARG\": \"MYVALUE\", \"MYARGFROMENVVAR\": \"${localEnv:VARIABLE_NAME}\" } } build.target string A string that specifies a Docker image build target that should be passed when building a Dockerfile. Defaults to not set. For example: \"build\": { \"target\": \"development\" } build.cacheFrom string, array A string or array of strings that specify one or more images to use as caches when building the image. Cached image identifiers are passed to the docker build command with --cache-from . appPort integer, string, array In most cases, we recommend using the new forwardPorts property . This property accepts a port or array of ports that should be published locally when the container is running. Unlike forwardPorts , your application may need to listen on all interfaces ( 0.0.0.0 ) not just localhost for it to be available externally. Defaults to [] . containerEnv object A set of name-value pairs that sets or overrides environment variables for the container. Environment and pre-defined variables may be referenced in the values. For example: \"containerEnv\": { \"MY_VARIABLE\": \"${localEnv:MY_VARIABLE}\" } Requires the container be recreated / rebuilt to change. remoteEnv object A set of name-value pairs that sets or overrides environment variables for VS Code (or sub-processes like terminals) but not the container as a whole. Environment and pre-defined variables may be referenced in the values. Be sure Terminal > Integrated: Inherit Env is checked in settings or the variables will not appear in the terminal. For example: \"remoteEnv\": { \"PATH\": \"${containerEnv:PATH}:/some/other/path\", \"MY_VARIABLE\": \"${localEnv:MY_VARIABLE}\" } Updates are applied when VS Code is restarted (or the window is reloaded). containerUser string Overrides the user all operations run as inside the container. Defaults to either root or the last USER instruction in the related Dockerfile used to create the image. On Linux, the specified container user's UID/GID will be updated to match the local user's UID/GID to avoid permission problems with bind mounts (unless disabled using updateRemoteUserUID ). Requires the container be recreated / rebuilt for updates to take effect. remoteUser string Overrides the user that VS Code runs as in the container (along with sub-processes like terminals, tasks, or debugging). Defaults to the containerUser . On Linux, the specified container user's UID/GID will be updated to match the local user's UID/GID to avoid permission problems with bind mounts (unless disabled using updateRemoteUserUID ). Updates are applied when VS Code is restarted (or the window is reloaded), but UID/GID updates are only applied when the container is created and requires a rebuild to change. updateRemoteUserUID boolean On Linux, if containerUser or remoteUser is specified, the container user's UID/GID will be updated to match the local user's UID/GID to avoid permission problems with bind mounts. Defaults to true . Requires the container be recreated / rebuilt for updates to take effect. mounts array An array of additional mount points to add to the container when created. Each value is a string that accepts the same values as the Docker CLI --mount flag . Environment and pre-defined variables may be referenced in the value. For example: \"mounts\": [\"source=${localWorkspaceFolder}/app-scripts,target=/usr/local/share/app-scripts,type=bind,consistency=cached\"] ⚠️ Codespaces ignores \"bind\" mounts with the exception of the Docker socket. workspaceMount string Overrides the default local mount point for the workspace when the container is created. Supports the same values as the Docker CLI --mount flag . Primarily useful for configuring remote containers or improving disk performance . Environment and pre-defined variables may be referenced in the value. For example: \"workspaceMount\": \"source=${localWorkspaceFolder}/sub-folder,target=/workspace,type=bind,consistency=cached\" ⚠️ Not yet supported in Codespaces or when using Clone Repository in Container Volume. workspaceFolder string Sets the default path that VS Code should open when connecting to the container. Typically used with workspaceMount . Defaults to the automatic source code mount location. ⚠️ Only supported for Docker Compose in Codespaces and when using Clone Repository in Container Volume. runArgs array An array of Docker CLI arguments that should be used when running the container. Defaults to [] . For example, this allows ptrace based debuggers like C++ to work in the container: \"runArgs\": [ \"--cap-add=SYS_PTRACE\", \"--security-opt\", \"seccomp=unconfined\" ] . overrideCommand boolean Tells VS Code whether it should run /bin/sh -c \"while sleep 1000; do :; done\" when starting the container instead of the container's default command. Defaults to true since the container can shut down if the default command fails. Set to false if the default command must run for the container to function properly. shutdownAction enum Indicates whether VS Code should stop the container when the VS Code window is closed / shut down. Values are none and stopContainer (default). ⚠️ Does not apply to Codespaces. Docker Compose dockerComposeFile string, array Required. Path or an ordered list of paths to Docker Compose files relative to the devcontainer.json file. Using an array is useful when extending your Docker Compose configuration . The order of the array matters since the contents of later files can override values set in previous ones. The default .env file is picked up from the root of the project, but you can use env_file in your Docker Compose file to specify an alternate location. service string Required. The name of the service VS Code should connect to once running. runServices array An array of services in your Docker Compose configuration that should be started by VS Code. These will also be stopped when you disconnect unless \"shutdownAction\" is \"none\" . Defaults to all services. workspaceFolder string Sets the default path that VS Code should open when connecting to the container (which is often the path to a volume mount where the source code can be found in the container). Defaults to \"/\" . remoteEnv object A set of name-value pairs that sets or overrides environment variables for VS Code (or sub-processes like terminals) but not the container as a whole. Environment and pre-defined variables may be referenced in the values. Be sure Terminal > Integrated: Inherit Env is checked in settings or the variables will not appear in the terminal. For example: \"remoteEnv\": { \"PATH\": \"${containerEnv:PATH}:/some/other/path\", \"MY_VARIABLE\": \"${localEnv:MY_VARIABLE}\" } Updates are applied when VS Code is restarted (or the window is reloaded) remoteUser string Overrides the user that VS Code runs as in the container (along with sub-processes like terminals, tasks, or debugging). Does not change the user the container as a whole runs as (which can be set in your Docker Compose file ). Defaults to the user the container as a whole is running as (often root ). Updates are applied when VS Code is restarted (or the window is reloaded). shutdownAction enum Indicates whether VS Code should stop the containers when the VS Code window is closed / shut down. Values are none and stopCompose (default). ⚠️ Does not apply to Codespaces. General name string A display name for the container. extensions array An array of extension IDs that specify the extensions that should be installed inside the container when it is created. Defaults to [] . settings object Adds default settings.json values into a container/machine specific settings file. forwardPorts array An array of ports that should be forwarded from inside the container to the local machine. portsAttributes object Sets default properties for specific forwarded ports. Can use a port number, range, or a regular expression. otherPortsAttributes object Configure the behavior of any ports that aren't configured using portsAttributes . postCreateCommand string, array A command string or list of command arguments to run inside the container after it is created. The commands execute from the workspaceFolder in the container. Use && in a string to execute multiple commands. For example, \"yarn install\" or \"apt-get update && apt-get install -y curl\" . The array syntax [\"yarn\", \"install\"] will invoke the command (in this case yarn ) directly without using a shell. It fires after your source code has been mounted, so you can also run shell scripts from your source tree. For example: bash scripts/install-dev-tools.sh . Not set by default. postStartCommand string, array A command string or list of command arguments to run when the container starts (in all cases). The parameters behave exactly like postCreateCommand , but the commands execute on start rather than create. Not set by default. postAttachCommand string, array A command string or list of command arguments to run after VS Code has attached to a running container (in all cases). The parameters behave exactly like postCreateCommand , but the commands execute on attach rather than create. Not set by default. waitFor string, array The user command to wait for before continuing execution in the background while the UI is starting up. initializeCommand string, array A command string or list of command arguments to run on the host machine before the container is created. The command executes from the workspaceFolder locally. The array syntax [\"yarn\", \"install\"] will invoke the command (in this case yarn ) directly without using a shell, but supports Windows/macOS/Linux path translation . The string syntax ( \"yarn install\" ) is better for simple commands. ⚠️ The command is run wherever the source code is located on the host. For Codespaces, this is in the cloud. onCreateCommand string, array A command to run when creating the container. If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell. userEnvProbe enum Indicates the type of shell VS Code should use to \"probe\" for user environment variables to use by default while debugging or running a task: none (default), interactiveShell , loginShell , or loginInteractiveShell . Interactive shells will typically include variables set in /etc/bash.bashrc and .bashrc while login shells usually include variables from these \"rc\" files, /etc/profile , and .profile . The default is none , since the other modes can slow startup. devPort integer Allows you to force a specific port that the VS Code Server should use in the container. Defaults to a random, available port. If you've already built the container and connected to it, be sure to run Remote-Containers: Rebuild Container or Codespaces: Rebuild Container from the Command Palette ( kbstyle(F1) ) to pick up the change. Formatting string vs. array properties The format of certain properties will vary depending on the involvement of a shell. postCreateCommand , postStartCommand , postAttachCommand , and initializeCommand all have an array and a string type, while runArgs only has the array type. An array is passed to the OS for execution without going through a shell, whereas a string goes through a shell (it needs to be parsed into command and arguments). Using runArgs via a typical command line, you'll need single quotes if the shell runs into parameters with spaces. However, these single quotes aren't passed on to the executable. Thus, in your devcontainer.json , you'd follow the array format and leave out the single quotes: \"runArgs\": [\"--device-cgroup-rule=my rule here\"] Rather than: \"runArgs\": [\"--device-cgroup-rule='my rule here'\"] We can compare the string and the array versions of postAttachCommand as well. You can use the following string format, which will remove the single quotes as part of the shell's parsing: \"postAttachCommand\": \"echo foo='bar'\" By contrast, the array format will keep the single quotes and write them to standard out (you can see the output in the dev container log): \"postAttachCommand\": [\"echo\", \"foo='bar'\"] Variables in devcontainer.json Variables can be referenced in certain string values in devcontainer.json in the following format: ${variableName} . The following is a list of available variables you can use. Variable Properties Description ${localEnv:VARIABLE_NAME} Any Value of an environment variable on the host machine (in this case, called VARIABLE_NAME ). Unset variables are left blank. To for example, this would set a variable to your local home folder on Linux / macOS or the user folder on Windows: \"remoteEnv\": { \"LOCAL_USER_PATH\": \"${localEnv:HOME}${localEnv:USERPROFILE}\" } ⚠️ For Codespaces, the host is in the cloud rather than your local machine. ${containerEnv:VARIABLE_NAME} remoteEnv Value of an existing environment variable inside the container once it is up and running (in this case, called VARIABLE_NAME ). For example: \"remoteEnv\": { \"PATH\": \"${containerEnv:PATH}:/some/other/path\" } ${localWorkspaceFolder} Any Path of the local folder that was opened in VS Code (that contains .devcontainer/devcontainer.json ). ⚠️ Not yet supported when using Clone Repository in Container Volume. ${containerWorkspaceFolder} Any The path that the workspaces files can be found in the container. ${localWorkspaceFolderBasename} Any Name of the local folder that was opened in VS Code (that contains .devcontainer/devcontainer.json ). ⚠️ Not yet supported when using Clone Repository in Container Volume. ${containerWorkspaceFolderBasename} Any Name of the folder where the workspace files can be found in the container. Lifecycle scripts When creating and working with a dev container, you may need different commands to be run at different points in the container's lifecycle. The table below has the properties that determine how the container is created and takes shape over time, in the order in which they are run (for example, onCreateCommand will run after initializeCommand ). Property Description initializeCommand A command to run locally before anything else. If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell. onCreateCommand A command to run when creating the container. If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell. updateContentCommand Reserved for future scenarios where the source code may be updated sometime during the create process. postCreateCommand A command to run after creating the container. If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell. postStartCommand A command to run after starting the container. If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell. postAttachCommand A command to run when attaching to the container. If this is a single string, it will be run in a shell. If this is an array of strings, it will be run as a single command without shell. The waitFor property allows you to configure when the VS Code UI may connect to the dev container. By default, the waitFor property is set to updateContentCommand . This allows you to use onCreateCommand or updateContentCommand for steps that must happen before VS Code connects while still using postCreateCommand for steps that can happen behind the scenes afterwards. Attached container configuration reference Attached container configuration files are similar to devcontainer.json and supports a subset of its properties. Property Type Description workspaceFolder string Sets the default path that VS Code should open when connecting to the container (which is often the path to a volume mount where the source code can be found in the container). Not set by default (an empty window is opened). extensions array An array of extension IDs that specify the extensions that should be installed inside the container when it is created. Defaults to [] . settings object Adds default settings.json values into a container/machine specific settings file. forwardPorts array A list of ports that should be forwarded from inside the container to the local machine. remoteEnv object A set of name-value pairs that sets or overrides environment variables for VS Code (or sub-processes like terminals) but not the container as a whole. Environment and pre-defined variables may be referenced in the values. For example: \"remoteEnv\": { \"PATH\": \"${containerEnv:PATH}:/some/other/path\" } remoteUser string Overrides the user that VS Code runs as in the container (along with sub-processes like terminals, tasks, or debugging). Defaults to the user the container as a whole is running as (often root ). postAttachCommand string, array A command string or list of command arguments to run after VS Code attaches to the container. Use && in a string to execute multiple commands. For example, \"yarn install\" or \"apt-get update && apt-get install -y curl\" . The array syntax [\"yarn\", \"install\"] will invoke the command (in this case yarn ) directly without using a shell. Not set by default. Variables in attached container configuration files Variables can be referenced in certain string values in attached configuration files in the following format: ${variableName} . The following table is a list of available variables you can use. Variable Properties Description ${containerEnv:VAR_NAME} remoteEnv Value of an existing environment variable inside the container (in this case, VAR_NAME ) once it is up and running. For example: \"remoteEnv\": { \"PATH\": \"${containerEnv:PATH}:/some/other/path\" }"
  },
  "guides/vscode/remote/faq.html": {
    "href": "guides/vscode/remote/faq.html",
    "title": "Remote Development FAQ | Fountain of Knowledge",
    "keywords": "Remote Development FAQ This article covers frequently asked questions for each of the Visual Studio Code Remote Development extensions. See the SSH , Containers , and WSL articles for more details on setting up and working with each of their respective capabilities. Or try the introductory Tutorials to help get you running quickly in a remote environment. For questions about GitHub Codespaces , see the GitHub Codespaces documentation . General What is Visual Studio Code Remote Development? The Visual Studio Code Remote Development extension pack allows you to open any folder in a container, on a remote machine (via SSH), or in the Windows Subsystem for Linux and take advantage of VS Code's full feature set. This means that VS Code can provide a local-quality development experience — including full IntelliSense (completions), debugging, and more — regardless of where your code is located or hosted. What advantages does VS Code Remote Development provide over local editing? Some benefits of remote development include: Being able to edit, build, or debug on a different OS than you are running locally. Being able to develop in an environment that matches the target deployment environment. Using larger or more specialized hardware than your local machine for development. The ability to edit code stored in another location, such as in the cloud or at a customer site. Separating developer environments to avoid conflicts, improve security, and speed up on-boarding. Compared to using a network share or synchronizing files, VS Code Remote Development provides dramatically better performance along with better control over your development environment and tools. How do the Remote Development extensions relate to GitHub Codespaces? GitHub Codespaces is a service that provides managed cloud-hosted development environments accessible from both VS Code and a new browser-based editor. The service also allows VS Code and the browser-based editor to access self-hosted environments (desktop or server) without requiring an SSH server or even a direct network route. You can read more in the GitHub Codespaces documentation . While the Remote Development and Codespaces extensions share technology and features, the Remote Development extensions are released separately and can operate independently from GitHub Codespaces. How do the Remote Development extensions work? Visual Studio Code Remote Development allows your local VS Code installation to transparently interact with source code and runtime environments on other machines (whether virtual or physical) by moving the execution of certain commands to a \"remote server\". The VS Code Server is quickly installed by VS Code when you connect to a remote endpoint and can host extensions that interact directly with the remote workspace, machine, and file system. See Supporting Remote Development for additional details about extensions. How do the Remote Development extensions secure access to a remote machine, VM, or container? Visual Studio Code Remote Development uses existing, well known transports like secure shell to authenticate and secure traffic. No ports need to be publicly opened beyond those used by these well-known, secure transports. The VS Code Server that is injected runs as the same user you used to sign in to the machine, ensuring that VS Code and its extensions are not given improper elevated access without permission. The server is started and stopped by VS Code and is not wired into any user or global login or startup scripts. VS Code manages the server's lifecycle so you do not need to worry about whether or not it is running. Can VS Code Server be installed or used on its own? No. The VS Code Server is a component of the Remote Development extensions and is managed by a VS Code client. It is installed and updated automatically by VS Code when it connects to an endpoint and if installed separately could become quickly out of date. It is not intended or licensed for use by other clients. What are the connectivity requirements for VS Code Server? Installation of VS Code Server requires that your local machine have outbound HTTPS (port 443) connectivity to: update.code.visualstudio.com *.vo.msecnd.net (Azure CDN) By default, the Remote - SSH will attempt to download on the remote host, but if you enable remote.SSH.allowLocalServerDownload , the extension will fall back to downloading VS Code Server locally and transferring it remotely once a connection is established. The Remote - Containers extension always downloads locally and transfers into the container. You can install extensions manually without an internet connection using the Extensions: Install from VSIX... command, but if you use the extension panel or devcontainer.json to install extensions, your local machine and VS Code Server will need outbound HTTPS (port 443) access to: marketplace.visualstudio.com vscode.blob.core.windows.net *.vo.msecnd.net (Azure CDN) *.gallerycdn.vsassets.io (Azure CDN) Finally, some extensions (like C#) download secondary dependencies from download.microsoft.com or download.visualstudio.microsoft.com . Others (like Visual Studio Live Share ) may have additional connectivity requirements. Consult the extension's documentation for details if you run into trouble. All other communication between the server and the VS Code client is accomplished through the following transport channels depending on the extension: SSH: An authenticated, secure SSH tunnel. Containers: Docker's configured communication channel (via docker exec ). WSL: A random local port. You can find a list of locations VS Code itself needs access to in the network connections article . Why can't I see my local containers in the Docker extension when using the Remote - extensions? By default, the Docker extension will run remotely. While this is a sensible default in some cases, it means the extension may not show local containers when VS Code is connected to a remote SSH host, container, or WSL. You can use one of the following solutions to resolve this problem: Open a new local window ( File > New Window ) and use it to work with local containers. Install the Remote - Containers extension and use the Remote Explorer in situations when you need to see your local containers. Remote - WSL only : Use the Docker Technical Preview for WSL 2 or configure Docker Desktop for use in WSL 1 . Remote - Containers only : Forward the Docker socket and install the Docker CLI (only) in the container. Use the extensionKind property to force the extension to be ui . However, this will prevent some commands from working. What Linux packages or libraries need to be installed on a host to use Remote Development? Remote Development requires kernel >= 3.10, glibc >=2.17, and libstdc++ >= 3.4.18. Recent x86_64 glibc-based distributions have the best support, but exact requirements can vary by distribution. Support for musl-based Alpine Linux is available for Remote - Containers and Remote - WSL and ARMv7l (AArch32) / ARMv8l (AArch64) is available in Remote - SSH. However, native dependencies in certain extensions may cause them not to function on non-x86_64 glibc distributions. Note that experimental ARMv8l (AArch64) is available in VS Code Insiders only. See Remote Development with Linux for additional details. Can I install individual extensions instead of the extension pack? Yes. The Remote Development extension pack provides a convenient way for you to access all of the latest remote capabilities as they are released. However, you can always install the individual extensions from the Marketplace or VS Code Extensions view. Remote - SSH Remote - Containers Remote - WSL Remote - WSL What is the advantage of the extension over using WSL as the terminal? You can think of WSL as a Linux machine running on Windows, where you can install Linux specific frameworks/tools (for example Python, Go, Rust, etc.) without impacting your Windows setup. You can then use VS Code and the Remote - WSL extension to develop in the context of what is installed in WSL, isolated from what is installed on Windows. For example, you might install the Go stack in WSL (compiler, debugger, linters, etc.). If you run VS Code only on Windows, you must also install the same Go stack there to get features like smart completions, debugging, Go to Definition navigation. And because the language services are running on Windows, they don't know what is in WSL. It's true that you can run binaries in WSL from Windows and vice-versa, but regular VS Code extensions don't know how to do this. This is how we started out supporting debugging in WSL, but quickly realized we would have to update all extensions to know about WSL. We decided instead to make parts of VS Code run in WSL and let the UI running on Windows talk to the VS Code server running in WSL. This is what the Remote - WSL extension enables and with it, the Go extension runs in WSL along with the rest of the Go tools (compiler, debugger, linters), while VS Code runs on Windows. With this approach, language features like smart completions just work against what is in WSL without having to set up anything on Windows. You don't have to worry about path issues or set up different versions of development stacks on Windows. If you are deploying applications to Linux, you can set up your WSL instances to look like your runtime environment while still getting a rich editing experience on Windows. Remote - Containers Do \"dev container definitions\" define how an application is deployed? No. A development container defines an environment in which you develop your application before you are ready to deploy. While deployment and development containers may resemble one another, you may not want to include tools in a deployment image that you use during development. The vscode-dev-containers repository includes a set of dev container definitions for some common development environments. You can also attach to a running container without setting up a dev container definition, if you prefer to use an alternate container build or deployment workflow. Do \"dev containers definitions\" define how an application is built? Like Buildpacks? No. The Buildpacks concept focuses on taking source code and generating deployable container images through a series of defined steps. A dev container is an environment in which you can develop your application before you are ready to build. They are therefore complementary concepts. Extensions authors As an extension author, what do I need to do? The VS Code extension API abstracts away local/remote details so most extensions will work without modification. However, given extensions can use any node module or runtime they want, there are situations where adjustments may need to be made. We recommend you should test your extension (particularly in a container) to be sure that no updates are required. See Supporting Remote Development for details. Can an extension access local resources or APIs when a user is connected remotely? When VS Code connects to a remote environment, extensions are classified as either UI or Workspace extensions. UI Extensions run in a local extension host , can contribute UI or personalization features (for example themes), and have access to local files or APIs. Workspace extensions run in a remote extension host with the workspace and have full access to the source code, remote filesystem, and remote APIs. While Workspace extensions do not focus on UI customization, they can contribute explorers, views, and other UI elements as well. When a user installs an extension, VS Code attempts to infer the correct location and install it based on its type. Extensions that do not need to run remotely like themes and other UI customizations are automatically installed on the UI side. All others are treated as Workspace extensions since they are the most full-featured. However, extension authors can also override this location with an extensionKind property in package.json . If your extension is not functioning as expected, there are steps to check if it is running in the correct location or should perhaps have a different extensionKind . Also see Supporting Remote Development for additional details on what extension authors need to know about Remote Development and Codespaces. License and privacy Location You can find the licenses for the VS Code Remote Development extensions here: Remote-SSH License Remote-WSL License Remote-Containers License Why aren't the Remote Development extensions or their components open source? The Visual Studio Code Remote Development extensions and their related components use an open planning, issue, and feature request process , but are not currently open source. The extensions share source code which is also used in fully managed remote development services like GitHub Codespaces and their related extensions. Given that these services also will support other proprietary products (for example Visual Studio IDE), the extensions are available under a Microsoft pre-release license like other service-based, cross-product extensions such as Visual Studio IntelliCode and Visual Studio Live Share were during their preview periods. See the Visual Studio Code and 'Code - OSS' Differences and Microsoft Extension Licenses articles for more information. Will you charge for the Remote Development extensions once they exit \"Preview\"? No, they will remain free of charge. In the future, we may provide additional \"premium\" developer services like GitHub Codespaces , which provide additional functionality, but the extensions will be free. Are there any restrictions on where the Remote Development extensions can connect? You are free to use the extensions for both personal or corporate use to connect to your own physical machines, virtual machines, or containers. These can be on-premise, in your own private cloud or datacenter, in Azure, or other cloud/non-cloud hosting providers. You cannot build public products or services on top of the extensions or their related components (see next question). Can I use the VS Code Remote Development extensions to build my own product or service? You can use the extensions with your own internal or private services. You cannot build a public or commercial service on top of the VS Code Remote Development extensions or their related components (for example VS Code Server). You cannot create other extensions that extend or manipulate the Remote Development extensions. While the license states you may not \"provide the software as a stand-alone or integrated offering or combine it with any of your applications for others to use\", you can document how to use the extensions in conjunction with your service. Can I repackage or reuse VS Code Server in my own public service offering? No. The license states that you may not \"provide the software as a stand-alone or integrated offering or combine it with any of your applications for others to use\" which means you may not build public products or services on top of the VS Code Server. I have a question about whether I can use the extensions for X, who can I ask? Please email us at VSCode@microsoft.com with any questions you may have. GDPR and VS Code Remote Development The VS Code Remote Development extensions follow the GDPR policies as Visual Studio Code itself. See the general FAQ for more details. Questions or feedback Have a question or feedback? See Tips and Tricks . Search on Stack Overflow . Add a feature request or report a problem ."
  },
  "guides/vscode/remote/linux.html": {
    "href": "guides/vscode/remote/linux.html",
    "title": "Remote Development with Linux | Fountain of Knowledge",
    "keywords": "Remote Development with Linux Linux is a highly variable environment and the large number of server, container, and desktop distributions can make it difficult to know what is supported. Visual Studio Code Remote Development has prerequisites for the specific host / container / WSL distribution you will be connecting to. The extensions are known to work when connecting to recent stable/LTS version of: Ubuntu 64-bit x86, ARMv8l (AArch64) (16.04+, IoT 18.04+) Debian 64-bit x86, ARMv8l (AArch64) (Stretch/9+) Raspbian ARMv7l (AArch32) 32-bit (Stretch/9+) CentOS / RHEL 64-bit x86 (7+) Alpine Linux 64-bit x86 containers or WSL hosts (3.9+) in Remote - Containers, Remote - WSL The following non-Linux SSH hosts are also supported: Windows 10 / Server 2016/2019 SSH hosts (1803+) using the official OpenSSH Server and enabling remote.SSH.useLocalServer in VS Code settings . macOS 10.14+ (Mojave) SSH hosts with Remote Login enabled . However, if you are using a non-standard configuration or downstream distribution of Linux, you may run into issues. This document provides information on requirements as well as tips to help you get up and running even if your configuration is only community-supported. Note that other extensions may have dependencies beyond those listed here. Some extensions also contain compiled native code that may not work on Alpine Linux, or ARMv7 (AArch32), or ARMv8 (AArch64) . These platforms are considered in \"preview\" for this reason. If you encounter an issue that only occurs with a particular extension, contact the extension authors for information on their native dependencies. Local Linux prerequisites If you are running Linux locally, the VS Code prerequisites drive most of the requirements. In addition, specific Remote Development extensions have further requirements: Remote - SSH: ssh needs to be in the path. The shell binary is typically in the openssh-client package. Remote - Containers : Docker CE/EE 18.06+ and Docker Compose 1.21+. Follow the official install instructions for Docker CE/EE for your distribution . If you are using Docker Compose, follow the Install Docker Compose directions as well. (Note that the Ubuntu Snap package is not supported and packages in distributions may be out of date.) docker and docker-compose must also be in the path. However, Docker does not need to be running if you are using a remote host . Remote host / container / WSL Linux prerequisites Platform prerequisites are primarily driven by the version of the Node.js runtime (and by extension the V8 JavaScript engine ) shipped in the server component automatically installed on each remote endpoint. This server also has a set of related native node modules that need to be compiled and tested for each target. 64-bit x86 glibc-based Linux distributions currently provide the best support given these requirements. You may encounter issues with certain extensions with native dependencies with ARMv7l (AArch32) / ARMv8l (AArch64) glibc-based hosts, containers, or WSL and 64-bit x86 musl-based Alpine Linux . For ARMv7l/ARMv8l, extensions may only include x86_64 versions of native modules or runtimes in the extension. For Alpine Linux, included native code or runtimes may not work due to fundamental differences between how libc is implemented in Alpine Linux ( musl ) and other distributions ( glibc ). In both these cases, extensions will need to opt-in to supporting these platforms by compiling / including binaries for these additional targets. Please raise an issue with the appropriate extension author requesting support if you encounter an extension that does not work as expected. Distribution Base Requirements Remote - SSH Requirements Notes General kernel >= 3.10, glibc >=2.17, libstdc++ >= 3.4.18, Python 2.6 or 2.7, tar OpenSSH server, bash , and curl or wget Run ldd --version to check the glibc version. Run strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX to see if libstdc++ 3.4.18 is available. Ubuntu 16.04+, Debian 8+, Raspbian Stretch/9+ and downstream distributions libc6 libstdc++6 python-minimal ca-certificates tar openssh-server bash and curl or wget Requires kernel >= 3.10, glibc >= 2.17, libstdc++ >= 3.4.18. Debian < 8 (Jessie) and Ubuntu < 14.04 do not meet this requirement. RHEL / CentOS 7+ glibc libgcc libstdc++ python ca-certificates tar openssh-server bash and curl or wget Requires kernel >= 3.10, glibc >= 2.17, libstdc++ >= 3.4.18. RHEL / CentOS < 7 does not meet this requirement without using a workaround to upgrade . Alpine Linux 3.9+ musl libgcc libstdc++ . musl >= 1.1.18, glibc not required. Not yet supported. Supported in Remote - Containers and Remote - WSL. Extensions installed in the container may not work due to glibc dependencies in extension native code. openSUSE Leap / SUSE Linux Enterprise 15+ glibc libgcc_s1 libstdc++6 python ca-certificates gzip tar curl or wget Requires kernel >= 3.10, glibc, libstdc++6 Tips by Linux distribution The following is a list of distributions and any base requirements that may be missing. End-of-life versions of distributions are not included. ✅ = Working ⚠️ = Working, but see note for limitations 🔬 = Experimental 🛑 = Unsupported, but has workaround ❌ = Unsupported Server Distribution Docker Image Missing libraries Notes / additional steps ⚠️ Alpine Linux 3.10 (64-bit) alpine:3.10 libgcc libstdc++ Supported in Remote - Containers and Remote - WSL only. Some extensions installed in the container may not work due to glibc dependencies in extension native code. ✅ CentOS 7 Server (64-bit) centos:7 <none> <none> 🛑 CentOS 6 Server (64-bit) centos:6 glibc >= 2.17, libstdc++ >= 3.4.18 Requires a workaround . ✅ Debian 10 Server (64-bit) debian:10 <none> <none> ✅ Debian 9 Server (64-bit) debian:9 <none> <none> ✅ openSUSE Leap Server 15 (64-bit) opensuse/leap:15 Docker image is missing tar and gzip . <none> ✅ openSUSE Leap Server 42.3 (64-bit) opensuse/leap:42.3 Docker image is missing tar and gzip . <none> ✅ Oracle Linux 7 (64-bit) oraclelinux:7 <none> <none> 🛑️ Oracle Linux 6 (64-bit) oraclelinux:6 glibc >= 2.17, libstdc++ >= 3.4.18. Docker image is missing tar . Requires a workaround . ⚠️ Raspbian Stretch/9 (ARMv7l 32-bit) <n/a> <none> Some extensions may not work when installed on an ARMv7l host due to extension x86 native code. Remote - Containers does support connecting to containers on an ARM host. ✅ RedHat Enterprise Linux 7 (64-bit) <none> <none> 🛑 RedHat Enterprise Linux 6 (64-bit) glibc >= 2.17, libstdc++ >= 3.4.18 Requires a workaround . ✅ SUSE Linux Enterprise Server 15 (64-bit) Docker image is missing tar and gzip . <none> ✅ SUSE Linux Enterprise Server 12 (64-bit) Docker image is missing tar and gzip . <none> ❌ SUSE Linux Enterprise Server 11 (64-bit) glibc >= 2.17, libstdc++ >= 3.4.18 Might work compiling glibc from source, but untested. ⚠️ Ubuntu 18.04 IoT (ARMv8l 64-bit) <n/a> Some extensions may not work when installed on an ARMv8l host due to extension x86 native code. Remote - Containers does support connecting to containers on an ARM host. ✅ Ubuntu Server 20.04 (64-bit) ubuntu:20.04 <none> <none> ✅ Ubuntu Server 19.04 (64-bit) ubuntu:19.04 <none> <none> ✅ Ubuntu Server 18.04 (64-bit) ubuntu:18.04 <none> <none> ✅ Ubuntu Server 16.04 (64-bit) ubuntu:16.04 <none> <none> ✅ Ubuntu Server 14.04 (64-bit) ubuntu:14.04 <none> <none> Updating glibc and libstdc++ on RHEL / CentOS 6 RHEL / CentOS 6 ships with glibc 2.12 and libstdc++ 3.4.13. Unfortunately, this does not meet the requirements for Remote Development. RHEL / CentOS 6 goes out of support in 2020 , so we strongly recommend upgrading to RHEL / CentOS 7 or higher. However, as a workaround, you can either build glibc manually or use the following script to install updated binaries. The bash script below will upgrade these libraries without having to build them. It is adapted from information in this article , this gist , and this Fedora copr project . The article also includes instructions for manually building glibc if you would prefer not to use the binaries from the article. Do not run this script on anything mission critical without a rollback strategy since it does update libraries that other applications depend on. For servers, run the following script and restart the server so the updates take effect. # Update glibc and static libs wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm wget https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm wget https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm sudo rpm -Uh --force --nodeps \\ glibc-2.17-55.el6.x86_64.rpm \\ glibc-common-2.17-55.el6.x86_64.rpm \\ glibc-devel-2.17-55.el6.x86_64.rpm \\ glibc-headers-2.17-55.el6.x86_64.rpm \\ glibc-static-2.17-55.el6.x86_64.rpm \\ glibc-utils-2.17-55.el6.x86_64.rpm # Update libstdc++ wget https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/gcc-4.8.2-16.3.fc20/libstdc++-4.8.2-16.3.el6.x86_64.rpm wget https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/gcc-4.8.2-16.3.fc20/libstdc++-devel-4.8.2-16.3.el6.x86_64.rpm wget https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/gcc-4.8.2-16.3.fc20/libstdc++-static-4.8.2-16.3.el6.x86_64.rpm sudo rpm -Uh \\ libstdc++-4.8.2-16.3.el6.x86_64.rpm \\ libstdc++-devel-4.8.2-16.3.el6.x86_64.rpm \\ libstdc++-static-4.8.2-16.3.el6.x86_64.rpm In a container environment, you can add similar contents to a Dockerfile: FROM centos:6 RUN yum -y install wget tar # Update glibc RUN wget -q http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm \\ && wget -q http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm \\ && wget -q http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm \\ && wget -q http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm \\ && wget -q https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm \\ && wget -q https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm \\ && rpm -Uh --force --nodeps \\ glibc-2.17-55.el6.x86_64.rpm \\ glibc-common-2.17-55.el6.x86_64.rpm \\ glibc-devel-2.17-55.el6.x86_64.rpm \\ glibc-headers-2.17-55.el6.x86_64.rpm \\ glibc-static-2.17-55.el6.x86_64.rpm \\ glibc-utils-2.17-55.el6.x86_64.rpm \\ && rm *.rpm # Update libstdc++ RUN wget -q https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/gcc-4.8.2-16.3.fc20/libstdc++-4.8.2-16.3.el6.x86_64.rpm \\ && wget -q https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/gcc-4.8.2-16.3.fc20/libstdc++-devel-4.8.2-16.3.el6.x86_64.rpm \\ && wget -q https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/gcc-4.8.2-16.3.fc20/libstdc++-static-4.8.2-16.3.el6.x86_64.rpm \\ && rpm -Uh \\ libstdc++-4.8.2-16.3.el6.x86_64.rpm \\ libstdc++-devel-4.8.2-16.3.el6.x86_64.rpm \\ libstdc++-static-4.8.2-16.3.el6.x86_64.rpm \\ && rm *.rpm Questions or feedback See Tips and Tricks or the FAQ . Search on Stack Overflow . Add a feature request or report a problem . Create a development container definition for others to use. Contribute to our documentation or VS Code itself . See our CONTRIBUTING guide for details."
  },
  "guides/vscode/remote/remote-overview.html": {
    "href": "guides/vscode/remote/remote-overview.html",
    "title": "VS Code Remote Development | Fountain of Knowledge",
    "keywords": "VS Code Remote Development Visual Studio Code Remote Development allows you to use a container, remote machine, or the Windows Subsystem for Linux (WSL) as a full-featured development environment. You can: Develop on the same operating system you deploy to or use larger or more specialized hardware. Separate your development environment to avoid impacting your local machine configuration . Make it easy for new contributors to get started and keep everyone on a consistent environment . Use tools or runtimes not available on your local OS or manage multiple versions of them. Develop your Linux-deployed applications using the Windows Subsystem for Linux . Access an existing development environment from multiple machines or locations . Debug an application running somewhere else such as a customer site or in the cloud. No source code needs to be on your local machine to get these benefits. Each extension in the Remote Development extension pack can run commands and other extensions directly inside a container, in WSL, or on a remote machine so that everything feels like it does when you run locally. Getting started Remote Development extension pack The Remote Development extension pack includes three extensions. See the following articles to get started with each of them: Remote - SSH - Connect to any location by opening folders on a remote machine/VM using SSH. Remote - Containers - Work with a separate toolchain or container-based application inside (or mounted into) a container. Remote - WSL - Get a Linux-powered development experience in the Windows Subsystem for Linux. While most VS Code extensions should work unmodified in a remote environment, extension authors can learn more at Supporting Remote Development . Remote tutorials The tutorials below will walk you through running Visual Studio Code with the Remote Development extensions. Tutorial Description Remote via SSH Connect to remote and virtual machines with Visual Studio Code via SSH. Work in WSL Run Visual Studio Code in Windows Subsystem for Linux. Develop in Containers Run Visual Studio Code in a Docker Container. GitHub Codespaces Connect to a codespace with Visual Studio Code. GitHub Codespaces GitHub Codespaces provides remote development environments that are managed for you. You can configure and create a development environment hosted in the cloud, which is spun up and available when you need it. Questions or feedback See Tips and Tricks or the FAQ . Search on Stack Overflow . Add a feature request or report a problem ."
  },
  "guides/vscode/remote/remote-tutorials.html": {
    "href": "guides/vscode/remote/remote-tutorials.html",
    "title": "Remote Development tutorials | Fountain of Knowledge",
    "keywords": "Remote Development tutorials Visual Studio Code Remote Development allows you to use a container, remote machine, or the Windows Subsystem for Linux (WSL) as a full-featured development environment. Remote tutorials The tutorials below will walk you through running Visual Studio Code with the Remote Development extensions. Tutorial Description Remote via SSH Connect to remote and virtual machines with Visual Studio Code via SSH. Working in WSL Run Visual Studio Code in Windows Subsystem for Linux. Containers Run Visual Studio Code in a Docker Container. GitHub Codespaces Connect to a codespace with Visual Studio Code. Remote extensions Remote - SSH Remote - WSL Remote - Containers GitHub Codespaces Install all three Remote extensions with the Remote Development extension pack ."
  },
  "guides/vscode/remote/ssh.html": {
    "href": "guides/vscode/remote/ssh.html",
    "title": "Remote Development using SSH | Fountain of Knowledge",
    "keywords": "Remote Development using SSH The Visual Studio Code Remote - SSH extension allows you to open a remote folder on any remote machine, virtual machine, or container with a running SSH server and take full advantage of VS Code's feature set. Once connected to a server, you can interact with files and folders anywhere on the remote filesystem. No source code needs to be on your local machine to gain these benefits since the extension runs commands and other extensions directly on the remote machine. This lets VS Code provide a local-quality development experience — including full IntelliSense (completions), code navigation, and debugging — regardless of where your code is hosted . Getting started Note : After reviewing this topic, you can get started with the introductory SSH tutorial . System requirements Local: A supported OpenSSH compatible SSH client must also be installed. Remote SSH host : A running SSH server on: x86_64 Debian 8+, Ubuntu 16.04+, CentOS / RHEL 7+. ARMv7l (AArch32) Raspbian Stretch/9+ (32-bit). ARMv8l (AArch64) Ubuntu 18.04+ (64-bit). Windows 10 / Server 2016/2019 (1803+) using the official OpenSSH Server . macOS 10.14+ (Mojave) SSH hosts with Remote Login enabled . Other glibc based Linux distributions for x86_64, ARMv7l (AArch32), and ARMv8l (AArch64) should work if they have the needed prerequisites. See the Remote Development with Linux article for information prerequisites and tips for getting community supported distributions up and running. While ARMv7l (AArch32) and ARMv8l (AArch64) support is available, some extensions installed on these devices may not work due to the use of x86 native code in the extension. Installation To get started, you need to: Install an OpenSSH compatible SSH client if one is not already present. Install Visual Studio Code or Visual Studio Code Insiders . Install the Remote Development extension pack . SSH host setup If you do not have an SSH host set up, follow the directions for Linux , Windows 10 / Server (1803+) , or macOS SSH host or create a VM on Azure . [Optional] If your Linux or macOS SSH host will be accessed by multiple users at the same time, consider enabling Remote.SSH: Remote Server Listen On Socket in VS Code User settings for improved security. In the Settings editor: See the Tips and Tricks article for details. [Optional] While password-based authentication is supported, we recommend setting up key based authentication for your host. See the Tips and Tricks article for details. Connect to a remote host To connect to a remote host for the first time, follow these steps: Verify you can connect to the SSH host by running the following command from a terminal / PowerShell window replacing user@hostname as appropriate. ssh user@hostname # Or for Windows when using a domain / AAD account ssh user@domain@hostname In VS Code, select Remote-SSH: Connect to Host... from the Command Palette ( kbstyle(F1) ) and use the same user@hostname as in step 1. If VS Code cannot automatically detect the type of server you are connecting to, you will be asked to select the type manually. Once you select a platform, it will be stored in VS Code settings under the remote.SSH.remotePlatform property so you can change it at any time. After a moment, VS Code will connect to the SSH server and set itself up. VS Code will keep you up-to-date using a progress notification and you can see a detailed log in the Remote - SSH output channel. Tip: Connection hanging or failing? See troubleshooting tips for information on resolving common problems. If you see errors about SSH file permissions, see the section on Fixing SSH file permission errors . After you are connected, you'll be in an empty window. You can always refer to the Status bar to see which host you are connected to. Clicking on the Status bar item will provide a list of remote commands while you are connected. You can then open any folder or workspace on the remote machine using File > Open... or File > Open Workspace... just as you would locally! From here, install any extensions you want to use when connected to the host and start editing! Note: On ARMv7l / ARMv8l glibc SSH hosts, some extensions may not work due to x86 compiled native code inside the extension. Disconnect from a remote host To close the connection when you finish editing files on the remote host, choose File > Close Remote Connection to disconnect from the host. The default configuration does not include a keyboard shortcut for this command. You can also simply exit VS Code to close the remote connection. Remember hosts and advanced settings If you have a set of hosts you use frequently or you need to connect to a host using some additional options, you can add them to a local file that follows the SSH config file format . To make setup easy, the extension can guide you through adding a host without having to hand edit this file. Start by selecting Remote-SSH: Add New SSH Host... from the Command Palette ( kbstyle(F1) ) or clicking on the Add New icon in the SSH Remote Explorer in the Activity Bar. You'll then be asked to enter the SSH connection information. You can either enter a host name: Or the full ssh command you would use to connect to the host from the command line: Finally, you'll be asked to pick a config file to use. You can also set the \"remote.SSH.configFile\" property in your User settings.json file if you want to use a different config file than those listed. The extension takes care of the rest! For example, entering ssh -i ~/.ssh/id_rsa-remote-ssh yourname@remotehost.yourcompany.com in the input box would generate this entry: Host remotehost.yourcompany.com User yourname HostName another-host-fqdn-or-ip-goes-here IdentityFile ~/.ssh/id_rsa-remote-ssh See Tips and Tricks for details on generating the key shown here. You can manually edit this file with anything the SSH config file format supports, so this is just one example. From this point forward, the host will appear in the list of hosts when you select Remote-SSH: Connect to Host... from the Command Palette ( kbstyle(F1) ) or in the SSH Targets section of the Remote Explorer . The Remote Explorer allows you to both open a new empty window on the remote host or directly open a folder you previously opened. Expand the host and click on the Open Folder icon next to the folder you want to open on the host. Managing extensions VS Code runs extensions in one of two places: locally on the UI / client side, or remotely on the SSH host. While extensions that affect the VS Code UI, like themes and snippets, are installed locally, most extensions will reside on the SSH host. This ensures you have smooth experience and allows you to install any needed extensions for a given workspace on an SSH host from your local machine. This way, you can pick up exactly where you left off, from a different machine complete with your extensions. If you install an extension from the Extensions view, it will automatically be installed in the correct location. Once installed, you can tell where an extension is installed based on the category grouping. There will be a category for your remote SSH host: And also a Local - Installed category: Note: If you are an extension author and find that your extension is not working properly or installs in the wrong place, see Supporting Remote Development for details. Local extensions that actually need to run remotely will appear dimmed and disabled in the Local - Installed category. Select Install to install an extension on your remote host. You can also install all locally installed extensions on the SSH host by going to the Extensions view and selecting Install Local Extensions in SSH: [Hostname] using the cloud button at the right of the Local - Installed title bar. This will display a dropdown where you can select which locally installed extensions to install on your SSH host. \"Always installed\" extensions If there are extensions that you would like to always have installed on any SSH host, you can specify which ones using the remote.SSH.defaultExtensions property in settings.json . For example, if you wanted to install the GitLens and Resource Monitor extensions, specify their extension IDs as follows: \"remote.SSH.defaultExtensions\": [ \"eamodio.gitlens\", \"mutantdino.resourcemonitor\" ] Advanced: Forcing an extension to run locally / remotely Extensions are typically designed and tested to either run locally or remotely, not both. However, if an extension supports it, you can force it to run in a particular location in your settings.json file. For example, the setting below will force the Docker extension to run locally and Debugger for Chrome extension to run remotely instead of their defaults: \"remote.extensionKind\": { \"ms-azuretools.vscode-docker\": [ \"ui\" ], \"msjsdiag.debugger-for-chrome\": [ \"workspace\" ] } A value of \"ui\" instead of \"workspace\" will force the extension to run on the local UI/client side instead. Typically, this should only be used for testing unless otherwise noted in the extension's documentation since it can break extensions . See the article on Supporting Remote Development for details. Forwarding a port / creating SSH tunnel Sometimes when developing, you may need to access a port on a remote machine that is not publicly exposed. There are two ways to do this using an SSH tunnel that \"forwards\" the desired remote port to your local machine. Temporarily forwarding a port Once you are connected to a host, if you want to temporarily forward a new port for the duration of the session, select Forward a Port from the Command Palette ( kbstyle(F1) ) or click on the Forward New Port icon in the Remote Explorer after selecting it from the Activity Bar. You'll be asked to enter the port you would like to forward and you can give it a name. A notification will tell you the localhost port you should use to access the remote port. For example, if you forwarded an HTTP server listening on port 3000, the notification may tell you that it was mapped to port 4123 on localhost since 3000 was already in use. You can then connect to this remote HTTP server using http://localhost:4123 . This same information is available in the Forwarded Ports section of the Remote Explorer if you need to access it later. If you would like VS Code to remember any ports you have forwarded, check Remote: Restore Forwarded Ports in the Settings editor ( kb(workbench.action.openSettings) ) or set \"remote.restoreForwardedPorts\": true in settings.json . Change local port on tunnel If you would like the local port of the tunnel to be different than the remote server's, you can change this via the Forwarded Ports panel. Right-click the tunnel you want to modify, and select Change Local Port in the context menu. Always forwarding a port If you have ports that you always want to forward , you can use the LocalForward directive in the same SSH config file you use to remember hosts and advanced settings . For example, if you wanted to forward ports 3000 and 27017, you could update the file as follows: Host remote-linux-machine User myuser HostName remote-linux-machine.mydomain LocalForward 127.0.0.1:3000 127.0.0.1:3000 LocalForward 127.0.0.1:27017 127.0.0.1:27017 Opening a terminal on a remote host Opening a terminal on the remote host from VS Code is simple. Once connected, any terminal window you open in VS Code ( Terminal > New Terminal ) will automatically run on the remote host rather than locally. You can also use the code command line from this same terminal window to perform a number of operations such as opening a new file or folder on the remote host. Type code --help to see all the options available from the command line. Debugging on the SSH host Once you are connected to a remote host, you can use VS Code's debugger in the same way you would when running the application locally. For example, if you select a launch configuration in launch.json and start debugging ( kb(workbench.action.debug.start) ), the application will start on remote host and attach the debugger to it. See the debugging documentation for details on configuring VS Code's debugging features in .vscode/launch.json . SSH host-specific settings VS Code's local User settings are also reused when you are connected to an SSH host. While this keeps your user experience consistent, you may want to vary some of these settings between your local machine and each host. Fortunately, once you have connected to a host, you can also set host-specific settings by running the Preferences: Open Remote Settings command from the Command Palette ( kbstyle(F1) ) or by selecting on the Remote tab in the Settings editor. These will override any User settings you have in place whenever you connect to the host. And Workspace settings will override Remote and User settings. Working with local tools The Remote - SSH extension does not provide direct support for sync'ing source code or using local tools with content on a remote host. However, there are two ways to do this using common tools that will work with most Linux hosts. Specifically, you can: Mount the remote filesystem using SSHFS . Sync files to/from the remote host to your local machine using rsync . SSHFS is the most convenient option and does not require any file sync'ing. However, performance will be significantly slower than working through VS Code, so it is best used for single file edits and uploading/downloading content. If you need to use an application that bulk reads/write to many files at once (like a local source control tool), rsync is a better choice. Known limitations Remote - SSH limitations Using key based authentication is strongly recommended. Passwords and other tokens entered for alternate authentication methods are not saved. Alpine Linux and non-glibc based Linux SSH hosts are not supported. Older (community supported) Linux distributions require workarounds to install the needed prerequisites . PuTTY is not supported on Windows. If you clone a Git repository using SSH and your SSH key has a passphrase, VS Code's pull and sync features may hang when running remotely. Either use an SSH key without a passphrase, clone using HTTPS, or run git push from the command line to work around the issue. Local proxy settings are not reused on the remote host, which can prevent extensions from working unless the appropriate proxy information is configured on the remote host (for example global HTTP_PROXY or HTTPS_PROXY environment variables with the appropriate proxy information). See here for a list of active issues related to SSH. Docker Extension limitations While the Docker extension can run both remotely and locally, if it is already installed locally, you will be unable to install on a remote SSH host without first uninstalling it locally. We will address this problem in a future VS Code release. Extension limitations Many extensions will work on remote SSH hosts without modification. However, in some cases, certain features may require changes. If you run into an extension issue, there is a summary of common problems and solutions that you can mention to the extension author when reporting the issue. In addition, some extensions installed on ARMv7l (AArch322) / ARMv8l (AArch64) devices may not work due to native modules or runtimes in the extension that only support x86_64. In these cases, the extensions would need to opt-in to supporting these platforms by compiling / including binaries for ARMv7l / ARMv8l. Common questions How do I set up an SSH client on ...? See Installing a supported SSH client for details. How do I set up an SSH server on ...? See Installing a supported SSH server for details on setting up an SSH server for your host. Can I sign in to my SSH server with another/additional authentication mechanism like a password? Yes, you should be prompted to enter your token or password automatically. However, passwords are not saved, so using key based authentication is typically more convenient. How do I fix SSH errors about \"bad permissions\"? See Fixing SSH file permission errors for details on resolving these types of errors. What Linux packages / libraries need to be installed on remote SSH hosts? Most Linux distributions will not require additional dependency installation steps. For SSH, Linux hosts need to have Bash ( /bin/bash ), tar , and either curl or wget installed and those utilities could be missing from certain stripped down distributions. Remote Development also requires kernel >= 3.10, glibc >=2.17, libstdc++ >= 3.4.18. Only glibc-based distributions are supported currently, so by extension Alpine Linux is not supported. See Linux Prerequisites for details. What are the connectivity requirements for the VS Code Server when it is running on a remote machine / VM? Installation of VS Code Server requires that your local machine has outbound HTTPS (port 443) connectivity to: update.code.visualstudio.com vscode.blob.core.windows.net *.vo.msecnd.net (Azure CDN) By default, the Remote - SSH will attempt to download on the remote host, but if you enable remote.SSH.allowLocalServerDownload , the extension will fall back to downloading VS Code Server locally and transferring it remotely once a connection is established. You can install extensions manually without an internet connection using the Extensions: Install from VSIX... command, but if you use the extension panel to install extensions, your local machine and VS Code Server server will need outbound HTTPS (port 443) access to: marketplace.visualstudio.com *.vo.msecnd.net (Azure CDN) *.gallerycdn.vsassets.io (Azure CDN) Finally, some extensions (like C#) download secondary dependencies from download.microsoft.com or download.visualstudio.microsoft.com . Others (like Visual Studio Live Share ) may have additional connectivity requirements. Consult the extension's documentation for details if you run into trouble. All other communication between the server and the VS Code client is accomplished through the authenticated, secure SSH tunnel. Can I use local tools on source code sitting on the remote SSH host? Yes. Typically this is done using SSHFS or by using rsync to get a copy of the files on your local machine. SSHFS mounts the remote filesystem is ideal for scenarios where you need to edit individual files or browse the source tree and requires no sync step to use. However, it is not ideal for using something like a source control tool that bulk manages files. In this case, the rsync approach is better since you get a complete copy of the remote source code on your local machine. See Tips and Tricks for details. Can I use VS Code when I only have SFTP/FTP filesystem access to my remote host (no shell access)? Some cloud platforms only provide remote filesystem access for developers rather than direct shell access. VS Code Remote Development was not designed with this use case in mind since it negates the performance and user experience benefits. However, this use case can typically be handled by combining extensions like SFTP with remote debugging features for Node.js , Python , C# , or others. As an extension author, what do I need to do? The VS Code extension API abstracts away local/remote details so most extensions will work without modification. However, given extensions can use any node module or runtime they want, there are situations where adjustments may need to be made. We recommend you test your extension to be sure that no updates are required. See Supporting Remote Development for details. Questions or feedback See Tips and Tricks or the FAQ . Search on Stack Overflow . Add a feature request or report a problem . Contribute to our documentation or VS Code itself . See our CONTRIBUTING guide for details."
  },
  "guides/vscode/remote/ssh-tutorial.html": {
    "href": "guides/vscode/remote/ssh-tutorial.html",
    "title": "Remote development over SSH | Fountain of Knowledge",
    "keywords": "Remote development over SSH This tutorial walks you through creating and connecting to a virtual machine (VM) on Azure using the Visual Studio Code Remote - SSH extension. You'll create a Node.js Express web app to show how you can edit and debug on a remote machine with VS Code just like you could if the source code was local. Note : Your Linux VM can be hosted anywhere - on your local host, on premise, in Azure, or in any other cloud, as long as the chosen Linux distribution meets these prerequisites . Prerequisites To get started, you need to have done the following steps: Install an OpenSSH compatible SSH client (PuTTY is not supported). Install Visual Studio Code . Have an Azure subscription (If you don't have an Azure subscription, create a free account before you begin). Install the extension The Remote - SSH extension is used to connect to SSH hosts. Install the Remote - SSH extension Remote - SSH With the Remote - SSH extension installed, you will see a new Status bar item at the far left. The Remote Status bar item can quickly show you in which context VS Code is running (local or remote) and clicking on the item will bring up the Remote - SSH commands. Create a virtual machine If you don't have an existing Linux virtual machine, you can create a new VM through the Azure portal . In the Azure portal, search for \"Virtual Machines\", and choose Add . From there, you can select your Azure subscription and create a new resource group, if you don't already have one. Note : In this tutorial, we are using Azure, but your Linux VM can be hosted anywhere, as long as the Linux distribution meets these prerequisites . Now you can specify details of your VM, such as the name, the size, and the base image. Choose Ubuntu Server 18.04 LTS for this example, but you can choose recent versions of other Linux distros and look at VS Code's supported SSH servers . Set up SSH There are several authentication methods into a VM, including an SSH public/private key pair or a username and password. We strongly recommend using key-based authentication (if you use a username/password, you'll be prompted to enter your credentials more than once by the extension). If you're on Windows and have already created keys using PuttyGen, you can reuse them . Create an SSH key If you don't have an SSH key pair, open a bash shell or the command line and type in: ssh-keygen -t rsa -b 2048 This will generate the SSH key. Press kbstyle(Enter) at the following prompt to save the key in the default location (under your user directory as a folder named .ssh ). You will then be prompted to enter a secure passphrase, but you can leave that blank. You should now have a id_rsa.pub file which contains your new public SSH key. Add SSH key to your VM In the previous step, you generated an SSH key pair. Select Use existing public key in the dropdown for SSH public key source so that you can use the public key you just generated. Take the public key and paste it into your VM setup, by copying the entire contents of the id_rsa.pub in the SSH public key . You also want to allow your VM to accept inbound SSH traffic by selecting Allow selected ports and choosing SSH (22) from the Select inbound ports dropdown list. Auto shutdown A cool feature of using Azure VMs is the ability to enable auto shutdown (because let's face it, we all forget to turn off our VMs…). If you go to the Management tab, you can set the time you want to shut down the VM daily. Select Review and Create , then Create , and Azure will deploy your VM for you! Once the deployment is finished (it may take several minutes), go to the new resource view for your virtual machine. Connect using SSH Now that you've created an SSH host, let's connect to it! You'll have noticed an indicator on the bottom-left corner of the Status bar. This indicator tells you in which context VS Code is running (local or remote). Click on the indicator to bring up a list of Remote extension commands. Choose the Remote-SSH: Connect to Host command and connect to the host by entering connection information for your VM in the following format: user@hostname . The user is the username you set when adding the SSH public key to your VM. For the hostname , go back to the Azure portal and in the Overview pane of the VM you created, copy the Public IP address . Before connecting in Remote - SSH, you can verify you're able to connect to your VM via a command prompt using ssh user@hostname . Note: If you run into an error ssh: connect to host <host ip> port 22: Connection timed out , you may need to delete NRMS-Rule-106 from the Networking tab of your VM: Set the user and hostname in the connection information text box. VS Code will now open a new window (instance). You'll then see a notification that the \"VS Code Server\" is initializing on the SSH Host. Once the VS Code Server is installed on the remote host, it can run extensions and talk to your local instance of VS Code. You'll know you're connected to your VM by looking at the indicator in the Status bar. It shows the hostname of your VM. The Remote - SSH extension also contributes a new icon on your Activity bar, and clicking on it will open the Remote explorer. From the dropdown, select SSH Targets , where you can configure your SSH connections. For instance, you can save the hosts you connect to the most and access them from here instead of entering the user and hostname. Once you're connected to your SSH host, you can interact with files and open folders on the remote machine. If you open the integrated terminal ( kb(workbench.action.terminal.toggleTerminal) ), you'll see you're working inside a bash shell while you're on Windows . You can use the bash shell to browse the file system on the VM. You can also browse and open folders on the remote home directory with File > Open Folder . Create your Node.js application In this step, you will create a simple Node.js application. You will use an application generator to quickly scaffold out the application from a terminal. Install Node.js and npm From the integrated terminal ( kb(workbench.action.terminal.toggleTerminal) ), update the packages in your Linux VM, then install Node.js, which includes npm, the Node.js package manager. sudo apt-get update curl -sL https://deb.nodesource.com/setup_lts.x | sudo -E bash - sudo apt-get install -y nodejs You can verify the installations by running: node --version npm --version Install the Express generator Express is a popular framework for building and running Node.js applications. You can scaffold (create) a new Express application using the Express Generator tool. The Express Generator is shipped as an npm module and installed by using the npm command-line tool npm . sudo npm install -g express-generator The -g switch installs the Express Generator globally on your machine so that you can run it from anywhere. Create a new application You can now create a new Express application called myExpressApp by running: express myExpressApp --view pug The --view pug parameters tell the generator to use the pug template engine. To install all of the application's dependencies, go to the new folder and run npm install . cd myExpressApp npm install Run the application Last, let's ensure that the application runs. From the terminal, start the application using the npm start command to start the server. npm start The Express app by default runs on http://localhost:3000 . You won't see anything in your local browser on localhost:3000 because the web app is running on your virtual machine. Port forwarding To be able to browse to the web app on your local machine, you can leverage another feature called Port forwarding . To be able to access a port on the remote machine that may not be publicly exposed, you need to establish a connection or a tunnel between a port on your local machine and the server. With the app still running, open the SSH Explorer and find the Forwarded Ports view. Click on the Forward a port link and indicate that you want to forward port 3000: Name the connection \"browser\": The server will now forward traffic on port 3000 to your local machine. When you browse to http://localhost:3000 , you see the running web app. Edit and debug From the Visual Studio Code File Explorer ( kb(workbench.view.explorer) ), navigate to your new myExpressApp folder and double-click the app.js file to open it in the editor. IntelliSense You have syntax highlighting for the JavaScript file as well as IntelliSense with hovers, just like you would see if the source code was on your local machine. When you start typing, you'll get smart completions for the object methods and properties. Debugging Set a breakpoint on line 10 of app.js by clicking in the gutter to the left of the line number or by putting the cursor on the line and pressing kb(editor.debug.action.toggleBreakpoint) . The breakpoint will be displayed as a red circle. Now, press kb(workbench.action.debug.start) to run your application. If you are asked how to run the application, choose Node.js . The app will start, and you'll hit the breakpoint. You can inspect variables, create watches, and navigate the call stack. Press kb(workbench.action.debug.stepOver) to step or kb(workbench.action.debug.start) again to finish your debugging session. You get the full development experience of Visual Studio Code connected over SSH. Ending your SSH connection You can end your session over SSH and go back to running VS Code locally with File > Close Remote Connection . Congratulations! Congratulations, you've successfully completed this tutorial! Next, check out the other Remote Development extensions. Remote - WSL Remote - Containers Or get them all by installing the Remote Development Extension Pack."
  },
  "guides/vscode/remote/troubleshooting.html": {
    "href": "guides/vscode/remote/troubleshooting.html",
    "title": "Remote Development Tips and Tricks | Fountain of Knowledge",
    "keywords": "Remote Development Tips and Tricks This article covers troubleshooting tips and tricks for each of the Visual Studio Code Remote Development extensions. See the SSH , Containers , and WSL articles for details on setting up and working with each specific extension. Or try the introductory Tutorials to help get you running quickly in a remote environment. For tips and questions about GitHub Codespaces , see the GitHub Codespaces documentation . SSH tips SSH is powerful and flexible, but this also adds some setup complexity. This section includes some tips and tricks for getting the Remote - SSH extension up and running in different environments. Configuring key based authentication SSH public key authentication is a convenient, high security authentication method that combines a local \"private\" key with a \"public\" key that you associate with your user account on an SSH host. This section will walk you through how to generate these keys and add them to a host. Tip: PuTTY for Windows is not a supported client , but you can convert your PuTTYGen keys . Quick start: Using SSH keys To set up SSH key based authentication for your remote host. First we'll create a key pair and then copy the public key to the host. Create your local SSH key pair Check to see if you already have an SSH key on your local machine. This is typically located at ~/.ssh/id_rsa.pub on macOS / Linux, and the .ssh directory in your user profile folder on Windows (for example C:\\Users\\your-user\\.ssh\\id_rsa.pub ). If you do not have a key, run the following command in a local terminal / PowerShell to generate an SSH key pair: ssh-keygen -t rsa -b 4096 Tip: Don't have ssh-keygen ? Install a supported SSH client . Authorize your macOS or Linux machine to connect Run one of the following commands, in a local terminal window replacing user and host name as appropriate to copy your local public key to the SSH host. Connecting to a macOS or Linux SSH host: export USER_AT_HOST=\"your-user-name-on-host@hostname\" export PUBKEYPATH=\"$HOME/.ssh/id_rsa.pub\" ssh-copy-id -i \"$PUBKEYPATH\" \"$USER_AT_HOST\" Connecting to a Windows SSH host: export USER_AT_HOST=\"your-user-name-on-host@hostname\" export PUBKEYPATH=\"$HOME/.ssh/id_rsa.pub\" ssh $USER_AT_HOST \"powershell New-Item -Force -ItemType Directory -Path \\\"\\$HOME\\\\.ssh\\\"; Add-Content -Force -Path \\\"\\$HOME\\\\.ssh\\\\authorized_keys\\\" -Value '$(tr -d '\\n\\r' < \"$PUBKEYPATH\")'\" You may want to validate that the authorized_key file in the .ssh folder for your remote user on the SSH host is owned by you and no other user has permission to access it. See the OpenSSH wiki for details. Authorize your Windows machine to connect Run one of the following commands, in a local PowerShell window replacing user and host name as appropriate to copy your local public key to the SSH host. Connecting to a macOS or Linux SSH host: $USER_AT_HOST=\"your-user-name-on-host@hostname\" $PUBKEYPATH=\"$HOME\\.ssh\\id_rsa.pub\" $pubKey=(Get-Content \"$PUBKEYPATH\" | Out-String); ssh \"$USER_AT_HOST\" \"mkdir -p ~/.ssh && chmod 700 ~/.ssh && echo '${pubKey}' >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys\" Connecting to a Windows SSH host: $USER_AT_HOST=\"your-user-name-on-host@hostname\" $PUBKEYPATH=\"$HOME\\.ssh\\id_rsa.pub\" Get-Content \"$PUBKEYPATH\" | Out-String | ssh $USER_AT_HOST \"powershell `\"New-Item -Force -ItemType Directory -Path `\"`$HOME\\.ssh`\"; Add-Content -Force -Path `\"`$HOME\\.ssh\\authorized_keys`\" `\"\" Validate that the authorized_key file in the .ssh folder for your remote user on the SSH host is owned by you and no other user has permission to access it. See the OpenSSH wiki for details. Improving your security with a dedicated key While using a single SSH key across all your SSH hosts can be convenient, if anyone gains access to your private key, they will have access to all of your hosts as well. You can prevent this by creating a separate SSH key for your development hosts. Just follow these steps: Generate a separate SSH key in a different file. macOS / Linux : Run the following command in a local terminal : ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa-remote-ssh Windows : Run the following command in a local PowerShell : ssh-keygen -t rsa -b 4096 -f \"$HOME\\.ssh\\id_rsa-remote-ssh\" Follow the same steps in the quick start to authorize the key on the SSH host, but set the PUBKEYPATH to the id_rsa-remote-ssh.pub file instead. In VS Code, run Remote-SSH: Open Configuration File... in the Command Palette ( kbstyle(F1) ), select an SSH config file, and add (or modify) a host entry as follows: Host name-of-ssh-host-here User your-user-name-on-host HostName host-fqdn-or-ip-goes-here IdentityFile ~/.ssh/id_rsa-remote-ssh Tip: You can use / for Windows paths as well. If you use \\ you will need to use two slashes. For example, C:\\\\path\\\\to\\\\my\\\\id_rsa . Reusing a key generated in PuTTYGen If you used PuTTYGen to set up SSH public key authentication for the host you are connecting to, you need to convert your private key so that other SSH clients can use it. To do this: Open PuTTYGen locally and load the private key you want to convert. Select Conversions > Export OpenSSH key from the application menu. Save the converted key to a local location under the .ssh directory in your user profile folder (for example C:\\Users\\youruser\\.ssh ). Validate that this new local file is owned by you and no other user has permissions to access it. In VS Code, run Remote-SSH: Open Configuration File... in the Command Palette ( kbstyle(F1) ), select the SSH config file you want to change, and add (or modify) a host entry in the config file as follows to point to the file: Host name-of-ssh-host-here User your-user-name-on-host HostName host-fqdn-or-ip-goes-here IdentityFile ~/.ssh/exported-keyfile-from-putty Improving security on multi-user servers By default, the \"VS Code Server\" is installed and maintained by the Remote - Containers extension when it connects to localhost on a random TCP port that is then forwarded to your local machine. This means only those users on the machine can access the port. However, if the host is being used by many users at once, you may want to further lock down access to reduce the chances of one user discovering the port number and attempting to access another user's VS Code Server instance. If you are connecting to a Linux or macOS host, you can switch to using Unix sockets that are locked down to a particular user. This socket is then forwarded instead of the port. Note: This setting disables connection multiplexing so configuring public key authentication is strongly recommended. To configure it: Ensure you have a local OpenSSH 6.7+ SSH client on Windows, macOS, or Linux and an OpenSSH 6.7+ Linux or macOS Host (Windows does not support this mode). Switch Remote - SSH into socket mode by enabling Remote.SSH: Remote Server Listen On Socket in your local VS Code User settings . If you've already connected to the SSH Host, select Remote-SSH: Kill VS Code Server on Host... from the Command Palette ( kbstyle(F1) ) so the setting takes effect. If you encounter an error when connecting, you may need to enable socket forwarding on your SSH Host's sshd config . To do so: Open /etc/ssh/sshd_config in a text editor (like vi, nano, or pico) on the SSH host (not locally). Add the setting AllowStreamLocalForwarding yes . Restart the SSH server. (On Ubuntu, run sudo systemctl restart sshd .). Retry. Troubleshooting hanging or failing connections If you are running into problems with VS Code hanging while trying to connect (and potentially timing out), there are a few things you can do to try to resolve the issue. General troubleshooting: Remove the server One command helpful to troubleshoot a variety of Remote-SSH issues is Remote-SSH: Kill VS Code Server on Host . This will remove the server, which can fix a wide range of issues and error messages you may see, such as \"Could not establish connection to server_name : The VS Code Server failed to start.\" See if VS Code is waiting on a prompt Enable the remote.SSH.showLoginTerminal setting in VS Code and retry. If you are prompted to input a password or token, see Enabling alternate SSH authentication methods for details on reducing the frequency of prompts. If you are still having trouble, set the following properties in settings.json and retry: \"remote.SSH.showLoginTerminal\": true, \"remote.SSH.useLocalServer\": false Work around a bug with some versions of Windows OpenSSH server Due to a bug in certain versions of OpenSSH server for Windows, the default check to determine if the host is running Windows may not work properly. This does not occur with OpenSSH server that ships with Windows 1909 and below. Fortunately, you can work around this problem by specifically telling VS Code if your SSH host is running Windows by adding the following to settings.json : \"remote.SSH.useLocalServer\": false You can also force VS Code to identify a particular host as Windows using the following property: \"remote.SSH.remotePlatform\": { \"host-in-ssh-config-or-fqdn\": \"windows\" } A fix has been merged so this problem should be resolved in a version of the server greater than 8.1.0.0. Enable TCP Forwarding on the remote host Remote - SSH extension makes use of an SSH tunnel to facilitate communication with the host. In some cases, this may be disabled on your SSH server. To see if this is the problem, open the Remote - SSH category in the output window and check for the following message: open failed: administratively prohibited: open failed If you do see that message, follow these steps to update your SSH server's sshd config : Open /etc/ssh/sshd_config or C:\\ProgramData\\ssh\\sshd_config in a text editor (like Vim, nano, Pico, or Notepad) on the SSH host (not locally). Add the setting AllowTcpForwarding yes . Restart the SSH server. (On Ubuntu, run sudo systemctl restart sshd . On Windows, in an admin PowerShell run, Restart-Service sshd ). Retry. Set the ProxyCommand parameter in your SSH config file If you are behind a proxy and are unable to connect to your SSH host, you may need to use the ProxyCommand parameter for your host in a local SSH config file . You can read this SSH ProxyCommand article for an example of its use. Ensure the remote machine has internet access The remote machine must have internet access to be able to download the VS Code Server and extensions from the Marketplace. See the FAQ for details on connectivity requirements. Set HTTP_PROXY / HTTPS_PROXY on the remote host If your remote host is behind a proxy, you may need to set the HTTP_PROXY or HTTPS_PROXY environment variable on the SSH host . Open your ~/.bashrc file add the following (replacing proxy.fqdn.or.ip:3128 with the appropriate hostname / IP and port): export HTTP_PROXY=http://proxy.fqdn.or.ip:3128 export HTTPS_PROXY=$HTTP_PROXY # Or if an authenticated proxy export HTTP_PROXY=http://username:password@proxy.fqdn.or.ip:3128 export HTTPS_PROXY=$HTTP_PROXY Work around /tmp mounted with noexec Some remote servers are set up to disallow executing scripts from /tmp . VS Code writes its install script to the system temp directory and tries to execute it from there. You can work with your system administrator to determine whether this can be worked around. Check whether a different shell is launched during install Some users launch a different shell from their .bash_profile or other startup script on their SSH host because they want to use a different shell than the default. This can break VS Code's remote server install script and isn't recommended. Instead, use chsh to change your default shell on the remote machine. Connecting to systems that dynamically assign machines per connection Some systems will dynamically route an SSH connection to one node from a cluster each time an SSH connection is made. This is an issue for VS Code because it makes two connections to open a remote window: the first to install or start the VS Code Server (or find an already running instance) and the second to create the SSH port tunnel that VS Code uses to talk to the server. If VS Code is routed to a different machine when it creates the second connection, it won't be able to talk to the VS Code server. One workaround for this is to use the ControlMaster option in OpenSSH (macOS/Linux clients only), described in Enabling alternate SSH authentication methods , so that VS Code's two connections will be multiplexed through a single SSH connection to the same node. Contact your system administrator for configuration help SSH is a very flexible protocol and supports many configurations. If you see other errors, in either the login terminal or the Remote-SSH output window, they could be due to a missing setting. Contact your system administrator for information about the required settings for your SSH host and client. Specific command-line arguments for connecting to your SSH host can be added to an SSH config file . To access your config file, run Remote-SSH: Open Configuration File... in the Command Palette ( kbstyle(F1) ). You can then work with your admin to add the necessary settings. Enabling alternate SSH authentication methods If you are connecting to an SSH remote host and are either: Connecting with two-factor authentication Using password authentication Using an SSH key with a passphrase when the SSH Agent is not running or accessible then VS Code should automatically prompt you to enter needed information. If you do not see the prompt, enable the remote.SSH.showLoginTerminal setting in VS Code. This setting displays the terminal whenever VS Code runs an SSH command. You can then enter your authentication code, password, or passphrase when the terminal appears. If you are still having trouble, you may need to the following properties in settings.json and retry: \"remote.SSH.showLoginTerminal\": true, \"remote.SSH.useLocalServer\": false If you are on macOS and Linux and want to reduce how often you have to enter a password or token, you can enable the ControlMaster feature on your local machine so that OpenSSH runs multiple SSH sessions over a single connection. To enable ControlMaster : Add an entry like this to your SSH config file: Host * ControlMaster auto ControlPath ~/.ssh/sockets/%r@%h-%p ControlPersist 600 Then run mkdir -p ~/.ssh/sockets to create the sockets folder. Setting up the SSH Agent If you are connecting to an SSH host using a key with a passphrase, you should ensure that the SSH Agent is running locally . VS Code will automatically add your key to the agent so you don't have to enter your passphrase every time you open a remote VS Code window. To verify that the agent is running and is reachable from VS Code's environment, run ssh-add -l in the terminal of a local VS Code window. You should see a listing of the keys in the agent (or a message that it has no keys). If the agent is not running, follow these instructions to start it. After starting the agent, be sure to restart VS Code. Windows: To enable SSH Agent automatically on Windows, start a local Administrator PowerShell and run the following commands: # Make sure you're running as an Administrator Set-Service ssh-agent -StartupType Automatic Start-Service ssh-agent Get-Service ssh-agent Now the agent will be started automatically on login. Linux: To start the SSH Agent in the background, run: eval \"$(ssh-agent -s)\" To start the SSH Agent automatically on login, add these lines to your ~/.bash_profile : if [ -z \"$SSH_AUTH_SOCK\" ]; then # Check for a currently running instance of the agent RUNNING_AGENT=\"`ps -ax | grep 'ssh-agent -s' | grep -v grep | wc -l | tr -d '[:space:]'`\" if [ \"$RUNNING_AGENT\" = \"0\" ]; then # Launch a new instance of the agent ssh-agent -s &> .ssh/ssh-agent fi eval `cat .ssh/ssh-agent` fi macOS: The agent should be running by default on macOS. Fixing SSH file permission errors SSH can be strict about file permissions and if they are set incorrectly, you may see errors such as \"WARNING: UNPROTECTED PRIVATE KEY FILE!\". There are several ways to update file permissions in order to fix this, which are described in the sections below. Local SSH file and folder permissions macOS / Linux: On your local machine, make sure the following permissions are set: Folder / File Permissions .ssh in your user folder chmod 700 ~/.ssh .ssh/config in your user folder chmod 600 ~/.ssh/config .ssh/id_rsa.pub in your user folder chmod 600 ~/.ssh/id_rsa.pub Any other key file chmod 600 /path/to/key/file Windows: The specific expected permissions can vary depending on the exact SSH implementation you are using. We strongly recommend using the out of box Windows 10 OpenSSH Client . In this case, make sure that all of the files in the .ssh folder for your remote user on the SSH host is owned by you and no other user has permissions to access it. See the Windows OpenSSH wiki for details. For all other clients, consult your client's documentation for what the implementation expects. Server SSH file and folder permissions macOS / Linux: On the remote machine you are connecting to, make sure the following permissions are set: Folder / File Linux / macOS Permissions .ssh in your user folder on the server chmod 700 ~/.ssh .ssh/authorized_keys in your user folder on the server chmod 600 ~/.ssh/authorized_keys Note that only Linux hosts are currently supported, which is why permissions for macOS and Windows 10 have been omitted. Windows: See the Windows OpenSSH wiki for details on setting the appropriate file permissions for the Windows OpenSSH server. Installing a supported SSH client OS Instructions Windows 10 1803+ / Server 2016/2019 1803+ Install the Windows OpenSSH Client . Earlier Windows Install Git for Windows . macOS Comes pre-installed. Debian/Ubuntu Run sudo apt-get install openssh-client RHEL / Fedora / CentOS Run sudo yum install openssh-clients VS Code will look for the ssh command in the PATH. Failing that, on Windows it will attempt to find ssh.exe in the default Git for Windows install path. You can also specifically tell VS Code where to find the SSH client by adding the remote.SSH.path property to settings.json . Installing a supported SSH server OS Instructions Details Debian 8+ / Ubuntu 16.04+ Run sudo apt-get install openssh-server See the Ubuntu SSH documentation for details. RHEL / CentOS 7+ Run sudo yum install openssh-server && sudo systemctl start sshd.service && sudo systemctl enable sshd.service See the RedHat SSH documentation for details. SuSE 12+ / openSUSE 42.3+ In Yast, go to Services Manager, select \"sshd\" in the list, and click Enable . Next go to Firewall, select the Permanent configuration, and under services check sshd . See the SuSE SSH documentation for details. Windows 10 1803+ / Server 2016/2019 1803+ Install the Windows OpenSSH Server . macOS 10.14+ (Mojave) Enable Remote Login . Resolving hangs when doing a Git push or sync on an SSH host If you clone a Git repository using SSH and your SSH key has a passphrase, VS Code's pull and sync features may hang when running remotely. Either use an SSH key without a passphrase, clone using HTTPS, or run git push from the command line to work around the issue. Using SSHFS to access files on your remote host SSHFS is a secure remote filesystem access protocol that builds up from SFTP. It provides advantages over something like a CIFS / Samba share in that all that is required is SSH access to the machine. Note: For performance reasons, SSHFS is best used for single file edits and uploading/downloading content. If you need to use an application that bulk reads/write to many files at once (like a local source control tool), rsync is a better choice. macOS / Linux : On Linux, you can use your distribution's package manager to install SSHFS. For Debian/Ubuntu: sudo apt-get install sshfs Note: WSL 1 does not support FUSE or SSHFS, so the instructions differ for Windows currently. WSL 2 does include FUSE and SSHFS support , so this will change soon. On macOS, you can install SSHFS using Homebrew : brew install sshfs In addition, if you would prefer not to use the command line to mount the remote filesystem, you can also install SSHFS GUI . To use the command line, run the following commands from a local terminal (replacing user@hostname with the remote user and hostname / IP): export USER_AT_HOST=user@hostname # Make the directory where the remote filesystem will be mounted mkdir -p \"$HOME/sshfs/$USER_AT_HOST\" # Mount the remote filesystem sshfs \"$USER_AT_HOST:\" \"$HOME/sshfs/$USER_AT_HOST\" -ovolname=\"$USER_AT_HOST\" -p 22 \\ -o workaround=nonodelay -o transform_symlinks -o idmap=user -C This will make your home folder on the remote machine available under the ~/sshfs . When you are done, you can unmount it using your OS's Finder / file explorer or by using the command line: umount \"$HOME/sshfs/$USER_AT_HOST\" Windows: Follow these steps: On Linux, add .gitattributes file to your project to force consistent line endings between Linux and Windows to avoid unexpected issues due to CRLF/LF differences between the two operating systems. See Resolving Git line ending issues for details. Next, install SSHFS-Win using Chocolatey : choco install sshfs Once you've installed SSHFS for Windows, you can use the File Explorer's Map Network Drive... option with the path \\\\sshfs\\user@hostname , where user@hostname is your remote user and hostname / IP. You can script this using the command prompt as follows: net use /PERSISTENT:NO X: \\\\sshfs\\user@hostname Once done, disconnect by right-clicking on the drive in the File Explorer and selecting Disconnect . Connect to a remote host from the terminal Once a host has been configured, you can connect to it directly from the terminal by passing a remote URI. For example, to connect to remote_server and open the /code/my_project folder, run: code --remote ssh-remote+remote_server /code/my_project We need to do some guessing on whether the input path is a file or a folder. If it has a file extension, it is considered a file. To force that a folder is opened, add slash to the path or use: code --folder-uri vscode-remote://ssh-remote+remote_server/code/folder.with.dot To force that a file is opened, add --goto or use: code --file-uri vscode-remote://ssh-remote+remote_server/code/fileWithoutExtension Using rsync to maintain a local copy of your source code An alternative to using SSHFS to access remote files is to use rsync to copy the entire contents of a folder on remote host to your local machine. The rsync command will determine which files need to be updated each time it is run, which is far more efficient and convenient than using something like scp or sftp . This is primarily something to consider if you really need to use multi-file or performance intensive local tools. The rsync command is available out of box on macOS and can be installed using Linux package managers (for example sudo apt-get install rsync on Debian/Ubuntu). For Windows, you'll need to either use WSL or Cygwin to access the command. To use the command, navigate to the folder you want to store the synched contents and run the following replacing user@hostname with the remote user and hostname / IP and /remote/source/code/path with the remote source code location. On macOS, Linux, or inside WSL : rsync -rlptzv --progress --delete --exclude=.git \"user@hostname:/remote/source/code/path\" . Or using WSL from PowerShell on Windows : wsl rsync -rlptzv --progress --delete --exclude=.git \"user@hostname:/remote/source/code/path\" \"`$(wslpath -a '$PWD')\" You can rerun this command each time you want to get the latest copy of your files and only updates will be transferred. The .git folder is intentionally excluded both for performance reasons and so you can use local Git tools without worrying about the state on the remote host. To push content, reverse the source and target parameters in the command. However, on Windows you should add a .gitattributes file to your project to force consistent line endings before doing so. See Resolving Git line ending issues for details. rsync -rlptzv --progress --delete --exclude=.git . \"user@hostname:/remote/source/code/path\" Cleaning up the VS Code Server on the remote The SSH extension provides a command for cleaning up the VS Code Server from the remote machine, Remote-SSH: Uninstall VS Code Server from Host... . The command does two things: it kills any running VS Code Server processes and it deletes the folder where the server was installed. If you want to run these steps manually, or if the command isn't working for you, you can run a script like this: kill -9 `ps ax | grep \"remoteExtensionHostAgent.js\" | grep -v grep | awk '{print $1}'` kill -9 `ps ax | grep \"watcherService\" | grep -v grep | awk '{print $1}'` rm -rf ~/.vscode-server # Or ~/.vscode-server-insiders The VS Code Server was previously installed under ~/.vscode-remote so you can check that location too. SSH into a remote WSL 2 host You may want to use SSH to connect to a WSL distro running on your remote machine. Check out this guide to learn how to SSH into Bash and WSL 2 on Windows 10 from an external machine. Container tips This section includes some tips and tricks for getting the Remote - Containers extension up and running in different environments. If you are running into Docker issues or would prefer not to run Docker locally, you may want to try the preview of GitHub Codespaces managed cloud-based environments . Over time this service will support an increasing number of devcontainer.json properties and you can also use its browser-based editor in addition to VS Code. Docker Desktop for Windows tips Docker Desktop for Windows works well in most setups, but there are a few \"gotchas\" that can cause problems. Here are some tips on avoiding them: Consider using the new Docker WSL 2 back-end on Windows 10 (2004+). If you are using Docker Desktop's WSL 2 back-end , you can you to open folders inside WSL as well as locally. Containers are also shared between Windows and inside WSL and this new engine is less susceptible to file sharing issues. See the quick start for details. Switch out of \"Linux Containers on Windows (LCOW)\" mode. While disabled by default, recent versions of Docker support Linux Containers on Windows (LCOW) that can allow you to use both Windows and Linux containers at the same time. However, this is a new feature, so you may encounter issues and the Remote - Containers extension only supports Linux containers currently. You can switch out of LCOW mode at any time by right-clicking on the Docker task bar item and selecting Switch to Linux Containers... from the context menu. Make sure your firewall allows Docker to set up a shared drive. Docker only needs to connect between two machine local IPs, but some firewall software may still block any drive sharing or the needed ports. See this Docker KB article for next steps on resolving this problem. Here are some tips that applied to older versions of Docker for Windows but should now be resolved. If you run into strage behaviors due to a possible regression, these tips have solved problems in the past. Use an AD domain account or local administrator account when sharing drives. Do not use an AAD (email-based) account. AAD (email-based) accounts have well-known issues, as documented in Docker issue #132 and issue #1352 . If you must use an AAD account, create a separate local administrator account on your machine that you use purely for the purpose of sharing drives. Follow the steps in this blog post to get everything set up. Stick with alphanumeric passwords to avoid drive sharing problems. When asked to share your drives on Windows, you will be prompted for the username and password of an account with admin privileges on the machine. If you are warned about an incorrect username or password, this may be due to special characters in the password. For example, ! , [ and ] are known to cause issues. Change your password to alphanumeric characters to resolve. See this issue about Docker volume mounting problems for details. Use your Docker ID to sign in to Docker (not your email). The Docker CLI only supports using your Docker ID, so using your email can cause problems. See Docker issue #935 for details. If you are still having trouble, see the Docker Desktop for Windows troubleshooting guide . Enabling file sharing in Docker Desktop The VS Code Remote - Containers extension can only automatically mount your source code into a container if your code is in a folder or drive shared with Docker. If you open a dev container from a non-shared location, the container will successfully start but the workspace will be empty. Note that this step is not required with Docker Desktop's WSL 2 engine . To change Docker's drive and folder sharing settings: Windows: Right-click on the Docker task bar item and select Settings . Go to Resources > File Sharing and check the drive(s) where your source code is located. If you see a message about your local firewall blocking the sharing action, see this Docker KB article for next steps. macOS: Click on the Docker menu bar item and select Preferences . Go to Resources > File Sharing . Confirm that the folder containing your source code is under one of the shared folders listed. Resolving Git line ending issues in containers (resulting in many modified files) Since Windows and Linux use different default line endings, Git may report a large number of modified files that have no differences aside from their line endings. To prevent this from happening, you can disable line ending conversion using a .gitattributes file or globally on the Windows side. Typically adding or modifying a .gitattributes file in your repository is the most reliable way to solve this problem. Committing this file to source control will help others and allows you to vary behaviors by repository as appropriate. For example, adding the following to .gitattributes file to the root of your repository will force everything to be LF, except for Windows batch files that require CRLF: * text=auto eol=lf *.{cmd,[cC][mM][dD]} text eol=crlf *.{bat,[bB][aA][tT]} text eol=crlf Note that this works in Git v2.10+ , so if you are running into problems, be sure you've got a recent Git client installed. You can add other file types in your repository that require CRLF to this same file. If you would prefer to still always upload Unix-style line endings (LF), you can use the input option. git config --global core.autocrlf input If you'd prefer to disable line-ending conversion entirely, run the following instead: git config --global core.autocrlf false Finally, you may need to clone the repository again for these settings to take effect. Avoid setting up Git in a container when using Docker Compose See Sharing Git credentials with your container in the main containers article for information on resolving this issue. Resolving hangs when doing a Git push or sync from a Container If you clone a Git repository using SSH and your SSH key has a passphrase, VS Code's pull and sync features may hang when running remotely. Either use an SSH key without a passphrase, clone using HTTPS, or run git push from the command line to work around the issue. Resolving errors about missing Linux dependencies Some extensions rely on libraries not found in the certain Docker images. See the Containers article for a few options on resolving this issue. Speeding up containers in Docker Desktop By default, Docker Desktop only gives containers a fraction of your machine capacity. In most cases, this is enough, but if you are doing something that requires more capacity, you can increase memory, CPU, or disk use. First, try stopping any running containers you are no longer using. If this doesn't solve your problem, you may want to see if CPU usage is actually the issue or if there is something else going on. An easy way to check this is to install the Resource Monitor extension . When installed in a container, it provides information about capacity for your containers in the Status bar. If you'd like this extension to always be installed, add this to your settings.json : \"remote.containers.defaultExtensions\": [ \"mutantdino.resourcemonitor\" ] If you determine that you need to give your container more of your machine's capacity, follow these steps: Right-click on the Docker task bar item and select Settings / Preferences . Go to Advanced to increase CPU, Memory, or Swap. On macOS, go to Disk to increase the amount of disk Docker is allowed to consume on your machine. On Windows, this is located under Advanced with the other settings. Finally, if your container is doing disk intensive operations or you are just looking for faster response times, see Improving container disk performance for tips. VS Code's defaults optimize for convenience and universal support, but can be optimized. Cleaning out unused containers and images If you see an error from Docker reporting that you are out of disk space, you can typically resolve this by cleaning out unused containers and images. There are a few ways to do this: Option 1: Use the Remote Explorer You can delete containers by selecting the Remote Explorer , right-click on the container you want to remove, and select Remove Container . However, this does not clean up any images you may have downloaded, which can clutter up your system. Option 2: Use the Docker extension Open a local window in VS Code ( File > New Window ). Install the Docker extension from the Extensions view if not already present. You can then go to the Docker view and expand the Containers or Images node, right-click, and select Remove Container / Image . Option 3: Use the Docker CLI to pick containers to delete Open a local terminal/command prompt (or use a local window in VS Code). Type docker ps -a to see a list of all containers. Type docker rm <Container ID> from this list to remove a container. Type docker image prune to remove any unused images. If docker ps does not provide enough information to identify the container you want to delete, the following command will list all development containers managed by VS Code and the folder used to generate them. docker ps -a --filter=\"label=vsch.quality\" --format \"table \\{{.ID}}\\t\\{{.Status}}\\t\\{{.Image}}\\tvscode-\\{{.Label \\\"vsch.quality\\\"}}\\t\\{{.Label \\\"vsch.local.folder\\\"}}\" Option 4: Use Docker Compose Open a local terminal/command prompt (or use a local window in VS Code). Go to the directory with your docker-compose.yml file. Type docker-compose down to stop and delete the containers. If you have more than one Docker Compose file, you can specify additional Docker Compose files with the -f argument. Option 4: Delete all containers and images that are not running: Open a local terminal/command prompt (or use a local window in VS Code). Type docker system prune --all . Resolving Dockerfile build failures for images using Debian 8 When building containers that use images based on Debian 8/Jessie — such as older versions of the node:8 image — you may encounter the following error: ... W: Failed to fetch http://deb.debian.org/debian/dists/jessie-updates/InRelease Unable to find expected entry 'main/binary-amd64/Packages' in Release file (Wrong sources.list entry or malformed file) E: Some index files failed to download. They have been ignored, or old ones used instead. ... This is a well known issue caused by the Debian 8 being \"archived\". More recent versions of images typically resolve this problem, often by upgrading to Debian 9/Stretch. There are two ways to resolve this error: Option 1 : Remove any containers that depend on the image, remove the image, and then try building again. This should download an updated image that is not affected by the problem. See cleaning out unused containers and images for details. Option 2 : If you don't want to delete your containers or images, add this line into your Dockerfile before any apt or apt-get command. It adds the needed source lists for Jessie: # Add archived sources to source list if base image uses Debian 8 / Jessie RUN cat /etc/*-release | grep -q jessie && printf \"deb http://archive.debian.org/debian/ jessie main\\ndeb-src http://archive.debian.org/debian/ jessie main\\ndeb http://security.debian.org jessie/updates main\\ndeb-src http://security.debian.org jessie/updates main\" > /etc/apt/sources.list Resolving Docker Hub sign in errors when an email is used The Docker CLI only supports using your Docker ID, so using your email to sign in can cause problems. See Docker issue #935 for details. As a workaround, use your Docker ID to sign in to Docker rather than your email. High CPU utilization of Hyperkit on macOS There is known issue with Docker for Mac that can drive high CPU spikes. In particular, high CPU usage occurring when watching files and building. If you see high CPU usage for com.docker.hyperkit in Activity Monitor while very little is going on in your dev container, you are likely hitting this issue. Follow the Docker issue for updates and fixes. Using an SSH tunnel to connect to a remote Docker host The Developing inside a container on a remote Docker Machine or SSH host article covers how to setup VS Code when working with a remote Docker host. This is often as simple as setting the Docker extension docker.host property in settings.json or the DOCKER_HOST environment variable to a ssh:// or tcp:// URI. However, you may run into situations where this does not work in your environment due to SSH configuration complexity or other limitations. In this case, an SSH tunnel can be used as a fallback. Using an SSH tunnel as a fallback option You can set up an SSH tunnel and forward the Docker socket from your remote host to your local machine. Follow these steps: Install an OpenSSH compatible SSH client . Update the Docker extension docker.host property in your user or workspace settings.json as follows: \"docker.host\":\"tcp://localhost:23750\" Run the following command from a local terminal / PowerShell (replacing user@hostname with the remote user and hostname / IP for your server): ssh -NL localhost:23750:/var/run/docker.sock user@hostname VS Code will now be able to attach to any running container on the remote host. You can also use specialized, local devcontainer.json files to create / connect to a remote dev container . Once you are done, press kbstyle(Ctrl+C) in the terminal / PowerShell to close the tunnel. Note: If the ssh command fails, you may need to AllowStreamLocalForwarding on your SSH host. Open /etc/ssh/sshd_config in an editor (like Vim, nano, or Pico) on the SSH host (not locally). Add the setting AllowStreamLocalForwarding yes . Restart the SSH server (on Ubuntu, run sudo systemctl restart sshd ). Retry. Advanced container configuration tips See the Advanced Container Configuration article for information on the following topics: Adding environment variables Adding another volume mount Changing or removing the default source code mount Adding a non-root user to your dev container Improving container disk performance Avoiding extension reinstalls on container rebuild Setting the project name for Docker Compose Using Docker or Kubernetes from inside a container Connecting to multiple containers at once Developing inside a container on a remote Docker Machine or SSH host Reducing Dockerfile build warnings WSL tips First time start: VS Code Server prerequisites Some WSL Linux distributions are lacking libraries that are required by the VS Code server to start up. You can add additional libraries into your Linux distribution by using its package manager. Debian and Ubuntu Open the Debian or Ubuntu WSL shell to add wget and ca-certificates : sudo apt-get update && sudo apt-get install wget ca-certificates Alpine Open the Alpine WSL shell as root ( wsl -d Alpine -u root ) to add libstdc++ : apk update && apk add libstdc++ On Windows 10 April 2018 Update (build 1803) and older, /bin/bash is required: apk update && apk add bash Selecting the distribution used by Remote - WSL Remote-WSL: New Window will open the WSL distro registered as default. To open a non-default distro, run code . from the WSL shell of the distro to use or use Remote-WSL: New Window using Distro . With WSL versions older than Windows 10, May 2019 Update (version 1903), the WSL command can only use the default distro . For this reason, the Remote- WSL might prompt you if you agree to change the default distro. You can always use wslconfig.exe to change your default. For example: wslconfig /setdefault Ubuntu You can see which distributions you have installed by running: wslconfig /l Configure the environment for the server startup When the Remote WSL extension starts the VS Code server in WSL, it does not run any shell configuration scripts. This was done to avoid that custom configuration scripts can prevent the startup. If you need to configure the startup environment, you can use the environment setup script as described here . Configure the environment for the remote extension host The environment for the remote extension host and terminal are based on the default shell's configuration scripts. To evaluate the environment variables for the remote extension host process, the server creates an instance of the default shell as an interactive login shell . It probes the environment variables from it and uses them as the initial environment for the remote extension host process. The values of environment variables therefore depend on what shell is configured as the default and the content of the configuration scripts for that shell. See Unix shell initialization for an overview of each shell's configuration scripts. Most WSL distributions have /bin/bash configured as the default shell. /bin/bash will look for startup files under /etc/profile first and for any startup files under ~/.bash_profile , ~/.bash_login , ~/.profile . To change the default shell of a WSL distro, follow the instructions of this blog post . Fixing problems with the code command not working If typing code from a WSL terminal on Window does not work because code cannot be found, you may be missing some key locations from your PATH in WSL. Check by opening a WSL terminal and typing echo $PATH . You should see VS Code install path listed. By default, this would be: /mnt/c/Users/Your Username/AppData/Local/Programs/Microsoft VS Code/bin But, if you used the System Installer , the install path is: /mnt/c/Program Files/Microsoft VS Code/bin ...or... /mnt/c/Program Files (x86)/Microsoft VS Code/bin It's a feature of WSL that paths are inherited from the PATH variable in Windows. To change the Windows PATH variable, use the Edit environment variables for your account command from the start menu in Windows. If you have disabled the path sharing feature, edit your .bashrc , add the following, and start a new terminal: WINDOWS_USERNAME=\"Your Windows Alias\" export PATH=\"$PATH:/mnt/c/Windows/System32:/mnt/c/Users/${WINDOWS_USERNAME}/AppData/Local/Programs/Microsoft VS Code/bin\" # or... # export PATH=\"$PATH:/mnt/c/Program Files/Microsoft VS Code/bin\" # or... # export PATH=\"$PATH:/mnt/c/Program Files (x86)/Microsoft VS Code/bin\" Note: Be sure to quote or escape space characters in the directory names. Finding problems with the 'code' command If typing code from a Windows command prompt does not launch VS Code, you can help us diagnose the problem by running VSCODE_WSL_DEBUG_INFO=true code . . Please file an issue and attach the full output. Finding problems starting or connected to the server When the WSL window fails to connect to the remote server, you can get more information in the WSL log. When filing an issue, it is important to always send the full content of the WSL log. Open the WSL log by running the command Remote-WSL: Open Log . The log will show in the terminal view under the WSL tab. To get even more verbose logging, enable the setting remote.WSL.debug in the user settings. The server fails to start with a segmentation fault You can help us investigate this problem by sending us the core dump file. To get the core dump file, follow these steps: In a Windows command prompt: Run code --locate-extension ms-vscode-remote.remote-wsl to determine the Remote-WSL extension folder. cd to the path that is returned. Open the wslServer.sh script with VS Code, code .\\scripts\\wslServer.sh . On the 3rd last line (before export VSCODE_AGENT_FOLDER=\"$HOME/$DATAFOLDER\" ), add ulimit -C unlimited . Start the Remote-WSL window running the remote server and wait for the segmentation fault. The core file will be in the Remote-WSL extension folder from above. I see EACCESS: permission denied error trying to rename a folder in the open workspace This is a known problem with the WSL file system implementation ( Microsoft/WSL#3395 , Microsoft/WSL#1956 ) caused by the file watcher active by VS Code. The issue will only be fixed in WSL 2. To avoid the issue, set remote.WSL.fileWatcher.polling to true. However, polling based has a performance impact for large workspaces. For large workspace you may want to increase the polling interval, remote.WSL.fileWatcher.pollingInterval , and control the folders that are watched with files.watcherExclude . WSL 2 does not have that file watcher problem and is not affected by the new setting. Resolving Git line ending issues in WSL (resulting in many modified files) Since Windows and Linux use different default line endings, Git may report a large number of modified files that have no differences aside from their line endings. To prevent this from happening, you can disable line-ending conversion using a .gitattributes file or globally on the Windows side. Typically adding or modifying a .gitattributes file in your repository is the most reliable way to solve this problem. Committing this file to source control will help others and allows you to vary behaviors by repository as appropriate. For example, adding the following to .gitattributes file to the root of your repository will force everything to be LF, except for Windows batch files that require CRLF: * text=auto eol=lf *.{cmd,[cC][mM][dD]} text eol=crlf *.{bat,[bB][aA][tT]} text eol=crlf Note that this works in Git v2.10+ , so if you are running into problems, be sure you've got a recent Git client installed. You can add other file types in your repository that require CRLF to this same file. If you would prefer to still always upload Unix-style line endings (LF), you can use the input option. git config --global core.autocrlf input If you'd prefer to disable line-ending conversion entirely, run the following instead: git config --global core.autocrlf false Finally, you may need to clone the repository again for these settings to take effect. Sharing Git credentials between Windows and WSL If you use HTTPS to clone your repositories and have a credential helper configured in Windows , you can share this with WSL so that passwords you enter are persisted on both sides. (Note that this does not apply to using SSH keys.) Just follow these steps: Configure the credential manager on Windows by running the following in a Windows command prompt or PowerShell : git config --global credential.helper wincred Configure WSL to use the same credential helper, but running the following in a WSL terminal : git config --global credential.helper \"/mnt/c/Program\\ Files/Git/mingw64/libexec/git-core/git-credential-wincred.exe\" Any password you enter when working with Git on the Windows side will now be available to WSL and vice versa. Resolving hangs when doing a Git push or sync from WSL If you clone a Git repository using SSH and your SSH key has a passphrase, VS Code's pull and sync features may hang when running remotely. Either use an SSH key without a passphrase, clone using HTTPS, or run git push from the command line to work around the issue. GitHub Codespaces tips For tips and questions about GitHub Codespaces , see the GitHub Codespaces documentation . You can also check out the known web limitations and adaptations that may impact your Codespaces. Extension tips While many extensions will work unmodified, there are a few issues that can prevent certain features from working as expected. In some cases, you can use another command to work around the issue, while in others, the extension may need to be modified. This section provides a quick reference for common issues and tips on resolving them. You can also refer to the main extension article on Supporting Remote Development for an in-depth guide on modifying extensions to support remote extension hosts. Resolving errors about missing dependencies Some extensions rely on libraries not found in the basic install of certain WSL Linux distributions. You can add additional libraries into your Linux distribution by using its package manager. For Ubuntu and Debian based distributions, run sudo apt-get install <package> to install the needed libraries. Check the documentation for your extension or the runtime that is mentioned in the error message for additional installation details. Local absolute path settings fail when applied remotely VS Code's local user settings are reused when you connect to a remote endpoint. While this keeps your user experience consistent, you may need to vary absolute path settings between your local machine and each host / container / WSL since the target locations are different. Resolution: You can set endpoint-specific settings after you connect to a remote endpoint by running the Preferences: Open Remote Settings command from the Command Palette ( kbstyle(F1) ) or by selecting the Remote tab in the Settings editor. These settings will override any local settings you have in place whenever you connect. Need to install local VSIX on remote endpoint Sometimes you want to install a local VSIX on a remote machine, either during development or when an extension author asks you to try out a fix. Resolution: Once you have connected to an SSH host, container, or WSL, you can install the VSIX the same way you would locally. Run the Extensions: Install from VSIX... command from the Command Palette ( kbstyle(F1) ). You may also want to add \"extensions.autoUpdate\": false to settings.json to prevent auto-updating to the latest Marketplace version. See Supporting Remote Development for more information on developing and testing extensions in a remote environment. Browser does not open locally Some extensions use external node modules or custom code to launch a browser window. Unfortunately, this may cause the extension to launch the browser remotely instead of locally. Resolution: The extension can use the vscode.env.openExternal API to resolve this problem. See the extension author's guide for details. Clipboard does not work Some extensions use node modules like clipboardy to integrate with the clipboard. Unfortunately, this may cause the extension to incorrectly integrate with the clipboard on the remote side. Resolution: The extension can switch to the VS Code clipboard API to resolve the problem. See the extension author's guide for details. Cannot access local web server from browser or application When working inside a container, SSH host, or through GitHub Codespaces, the port the browser is connecting to may be blocked. Resolution: Extensions can use the vscode.env.openExternal or vscode.env.asExternalUri APIs (which automatically forwards localhost ports) to resolve this problem. See the extension author's guide for details. As a workaround, use the Forward a Port command to do so manually. Webview contents do not appear If the extension's webview content uses an iframe to connect to a local web server, the port the webview is connecting to may be blocked. In addition, if the extension hard codes vscode-resource:// URIs instead of using asWebviewUri , content may not appear in the Codespaces browser editor. Resolution: The extension can use the webview.asWebviewUri to resolve issues with vscode-resource:// URIs. If ports are being blocked, the best approach is to instead use the webview message passing API. As a workaround, vscode.env.asExternalUri can be used allow the webview to connect to spawned localhost web servers from VS Code. However, this is currently blocked for the Codespaces browser-based editor (only) by MicrosoftDocs/vscodespaces#11 . See the extension author's guide for details on the workaround. Blocked localhost ports If you are trying to connect to a localhost port from an external application, the port may be blocked. Resolution: VS Code 1.40 introduced a new vscode.env.asExternalUri API for extensions to programmatically forward arbitrary ports. See the extension author's guide for details. As a workaround, you can use the Forward a Port command to do so manually. Errors storing extension data Extensions may try to persist global data by looking for the ~/.config/Code folder on Linux. This folder may not exist, which can cause the extension to throw errors like ENOENT: no such file or directory, open '/root/.config/Code/User/filename-goes-here . Resolution: Extensions can use the context.globalStoragePath or context.storagePath property to resolve this problem. See the extension author's guide for details. Cannot sign in / have to sign in each time I connect to a new endpoint Extensions that require sign in may persist secrets using their own code. This code can fail due to missing dependencies. Even if it succeeds, the secrets will be stored remotely, which means you have to sign in for every new endpoint. Resolution: Extensions can use the keytar node module to solve this problem. See the extension author's guide for details. An incompatible extension prevents VS Code from connecting If an incompatible extension has been installed on a remote host, container, or in WSL, we have seen instances where the VS Code Server hangs or crashes due to the incompatibility. If the extension activates right away, this can prevent you from connecting and being able to uninstall the extension. Resolution: Manually delete the remote extensions folder by following these steps: For containers, ensure your devcontainer.json no longer includes a reference to the faulty extension. Next, use a separate terminal / command prompt to connect to the remote host, container, or WSL. If SSH or WSL, connect to the environment accordingly (run ssh to connect to the server or open WSL terminal). If using a container, identify the container ID by calling docker ps -a and looking through the list for an image with the correct name. If the container is stopped, run docker run -it <id> /bin/sh . If it is running, run docker exec -it <id> /bin/sh . Once you are connected, run rm -rf ~/.vscode-server/extensions for VS Code stable and/or rm -rf ~/.vscode-server-insiders/extensions for VS Code Insiders to remove all extensions. Extensions that ship or acquire pre-built native modules fail Native modules bundled with (or dynamically acquired for) a VS Code extension must be recompiled using Electron's electron-rebuild . However, VS Code Server runs a standard (non-Electron) version of Node.js, which can cause binaries to fail when used remotely. Resolution: Extensions need to be modified to solve this problem. They will need to include (or dynamically acquire) both sets of binaries (Electron and standard Node.js) for the \"modules\" version in Node.js that VS Code ships and then check to see if context.executionContext === vscode.ExtensionExecutionContext.Remote in their activation function to set up the correct binaries. See the extension author's guide for details. Extension only fails on non-x86_64 hosts or Alpine Linux If an extension works on Debian 9+, Ubuntu 16.04+, or RHEL / CentOS 7+ remote SSH hosts, containers, or WSL, but fails on supported non-x86_64 hosts (for example, ARMv7l) or Alpine Linux containers, the extension may only include native code or runtimes that do not support these platforms. For example, the extensions may only include x86_64 compiled versions of native modules or runtimes. For Alpine Linux, the included native code or runtimes may not work due to fundamental differences between how libc is implemented in Alpine Linux ( musl ) and other distributions ( glibc ). Resolution: Extensions will need to opt-in to supporting these platforms by compiling / including binaries for these additional targets. It is important to note that some third-party npm modules may also include native code that can cause this problem. So, in some cases you may need to work with the npm module author to add additional compilation targets. See the extension author's guide for details. Extensions fail due to missing modules Extensions that rely on Electron or VS Code base modules (not exposed by the extension API) without providing a fallback can fail when running remotely. You may see errors in the Developer Tools console like original-fs not being found. Resolution: Remove the dependency on an Electron module or provide a fallback. See the extension author's guide for details. Cannot access / transfer remote workspace files to local machines Extensions that open workspace files in external applications may encounter errors because the external application cannot directly access the remote files. Resolution: If you create a \"UI\" extension designed to run locally, you can use the vscode.workspace.fs API to interact with the remote workspace filesystem. You can then make this a dependency of your \"Workspace\" extension and invoke it using a command as needed. See the extension author's guide for details on different types of extensions and how to use commands to communicate between them. Cannot access attached device from extension Extensions that access locally attached devices will be unable to connect to them when running remotely. Resolution: None currently. We are investigating the best approach to solve this problem. Questions and feedback Reporting issues If you run into an issue with one of the remote development extensions, it's important to collect the correct logs so that we'll be able to help diagnose your issue . Each remote extension has a command to view its logs. You can get the Remote - SSH extension logs with Remote-SSH: Show Log from the Command Palette ( kbstyle(F1) ). When reporting Remote - SSH issues, please also verify if you're able to SSH into your machine from an external terminal (not using Remote - SSH). Similarly, you can get the Remote - Containers extension logs with Remote-Containers: Show Log . Like the two above, you can get the Remote - WSL logs with Remote WSL: Show Log . Also check whether your issue is being tracked upstream in the WSL repo (and is not due to the Remote - WSL extension). If you're experiencing issues using other extensions remotely (for example, other extensions aren't loading or installing properly in a remote context), it's helpful to grab the log from the Remote Extension Host output channel ( Output: Focus on Output View ), and select Log (Remote Extension Host) from the dropdown. Note : If you only see Log (Extension Host) , this is the local extension host, and the remote extension host didn't launch. This is because the log channel is created only after the log file is created, so if the remote extension host does not launch, the remote extension host log file was not created and is not shown in the Output view. This is still helpful information to include in your issue. Remote question and feedback resources We have a variety of other remote resources: See Remote Development FAQ . Search on Stack Overflow . Add a feature request or report a problem ."
  },
  "guides/vscode/remote/wsl.html": {
    "href": "guides/vscode/remote/wsl.html",
    "title": "Developing in WSL | Fountain of Knowledge",
    "keywords": "Developing in WSL The Visual Studio Code Remote - WSL extension lets you use the Windows Subsystem for Linux (WSL) as your full-time development environment right from VS Code. You can develop in a Linux-based environment, use Linux-specific toolchains and utilities, and run and debug your Linux-based applications all from the comfort of Windows. The extension runs commands and other extensions directly in WSL so you can edit files located in WSL or the mounted Windows filesystem (for example /mnt/c ) without worrying about pathing issues, binary compatibility, or other cross-OS challenges. This lets VS Code provide a local-quality development experience — including full IntelliSense (completions), code navigation, and debugging — regardless of where your code is hosted . Getting started Note : After reviewing this topic, you can get started with the introductory WSL tutorial . Installation To get started, you need to: Install the Windows Subsystem for Linux along with your preferred Linux distribution. Note: WSL 1 does have some known limitations for certain types of development. Also, extensions installed in Alpine Linux may not work due to glibc dependencies in native source code inside the extension. See the Remote Development and Linux article for details. Install Visual Studio Code on the Windows side (not in WSL). Note: When prompted to Select Additional Tasks during installation, be sure to check the Add to PATH option so you can easily open a folder in WSL using the code command. Install the Remote Development extension pack . Open a remote folder or workspace From the WSL terminal Opening a folder inside the Windows Subsystem for Linux in VS Code is very similar to opening up a Windows folder from the command prompt or PowerShell. Open a WSL terminal window (using the start menu item or by typing wsl from a command prompt / PowerShell). Navigate to a folder you'd like to open in VS Code (including, but not limited to, Windows filesystem mounts like /mnt/c ) Type code . in the terminal. When doing this for the first time, you should see VS Code fetching components needed to run in WSL. This should only take a short while, and is only needed once. Note: If this command does not work, you may need to restart your terminal or you may not have added VS Code to your path when it was installed. After a moment, a new VS Code window will appear, and you'll see a notification that VS Code is opening the folder in WSL. VS Code will now continue to configure itself in WSL and keep you up to date as it makes progress. Once finished, you now see a WSL indicator in the bottom left corner, and you'll be able to use VS Code as you would normally! That's it! Any VS Code operations you perform in this window will be executed in the WSL environment, everything from editing and file operations, to debugging, using terminals, and more. From VS Code Alternatively, you can open a Remote WSL window directly from VS Code: Start VS Code. Press kbstyle(F1) , select Remote-WSL: New Window for the default distro or Remote-WSL: New Window using Distro for a specific distro. Use the File menu to open your folder. If you already have a folder open, you can also use the Remote-WSL: Reopen in WSL command. You will be prompted which distro to use. If you are in a WSL window and want to open the current input in a local window, use Remote-WSL: Reopen in Windows . From the Windows command prompt To open a WSL window directly from a Windows prompt use the --remote command line parameter: code --remote wsl+<distro name> <path in WSL> for example: code --remote wsl+Ubuntu /home/jim/projects/c We need to do some guessing on whether the input path is a file or a folder. If it has a file extension, it is considered a file. To force that a folder is opened, add slash to the path or use: code --folder-uri vscode-remote://wsl+Ubuntu/home/ubuntu/folder.with.dot To force that a file is opened add --goto or use: code --file-uri vscode-remote://wsl+Ubuntu/home/ubuntu/fileWithoutExtension Working with Git If you are working with the same repository in WSL and Windows, be sure to set up consistent line endings. See tips and tricks for details. You can also avoid passwords by configuring WSL to use the Windows Git credential manager. See tips and tricks for details. Managing extensions VS Code runs extensions in one of two places: locally on the UI / client side, or in WSL. While extensions that affect the VS Code UI, like themes and snippets, are installed locally, most extensions will reside inside WSL. If you install an extension from the Extensions view, it will automatically be installed in the correct location. Once installed, you can tell where an extension is installed based on the category grouping. There will be Local - Installed category and one for WSL. Note: If you are an extension author and your extension is not working properly or installs in the wrong place, see Supporting Remote Development for details. Local extensions that actually need to run remotely will appear dimmed and disabled in the Local - Installed category. Select Install to install an extension on your remote host. You can also install all locally installed extensions inside WSL by going to the Extensions view and selecting Install Local Extensions in WSL: [Name] using the cloud button at the right of the Local - Installed title bar. This will display a dropdown where you can select which locally installed extensions to install in your WSL instance. Opening a terminal in WSL Opening a terminal in WSL from VS Code is simple. Once folder is opened in WSL, any terminal window you open in VS Code ( Terminal > New Terminal ) will automatically run in WSL rather than locally. You can also use the code command line from this same terminal window to perform a number of operations such as opening a new file or folder in WSL. Type code --help to see what options are available from the command line. Debugging in WSL Once you've opened a folder in WSL, you can use VS Code's debugger in the same way you would when running the application locally. For example, if you select a launch configuration in launch.json and start debugging ( kb(workbench.action.debug.start) ), the application will start on remote host and attach the debugger to it. See the debugging documentation for details on configuring VS Code's debugging features in .vscode/launch.json . WSL specific settings VS Code's local user settings are also reused when you have opened a folder in WSL. While this keeps your user experience consistent, you may want to vary some of these settings between your local machine and WSL. Fortunately, once you have connected to WSL, you can also set WSL specific settings by running the Preferences: Open Remote Settings command from the Command Palette ( kbstyle(F1) ) or by selecting the Remote tab in the Settings editor. These will override any local settings you have in place whenever you open a folder in WSL. Advanced: Environment setup script When VS Code Remote is started in WSL, no shell startup scripts are run. This was done to avoid issues with startup scripts that are tuned for shells. If you want to run additional commands or modify the environment this can be done in a setup script ~/.vscode-server/server-env-setup (Insiders: ~/.vscode-server-insiders/server-env-setup ). If present, the script is processed before the server is started. The script needs to be a valid Bourne shell script. Be aware that an invalid script will prevent the server from starting up. If you end up with a script that prevents the server from starting, you will have to use a regular WSL shell and delete or rename the setup script. Check the WSL log (Remote WSL: Open WSL Log) for output and errors. Advanced: Opening a WSL 2 folder in a container If you are using WSL 2 and Docker Desktop's WSL 2 back-end , you can use the Remote - Containers extension to work with source code stored inside WSL! Just follow these steps: If you have not already, install and setup Docker Desktop's WSL 2 support. Tip: Go to Settings > Resources > WSL Integration and enable Docker integration with the WSL distribution you will be using. If you have not already, install the Remote - Containers extension along with the WSL extension. Next, open your source code folder in WSL as you would normally. Once your folder is open in WSL, select Remote-Containers: Reopen Folder in Container from the Command Palette ( kbstyle(F1) ). If the folder does not have a .devcontainer/devcontainer.json file in it, you'll be asked to pick a starting point from a filterable list or an existing Dockerfile or Docker Compose file (if one exists). The VS Code window (instance) will reload and start building the dev container. A progress notification provides status updates. After the build completes, VS Code will automatically connect to the container. You can now work with the your source code from inside the container. See the Remote - Containers documentation for more information. Known limitations This section contains a list of common know issues with WSL. The intent is not to provide a complete list of issues but to highlight some of the common problems seen with WSL. See here for a list of active issues related to WSL. I see EACCESS: permission denied error trying to rename a folder in the open workspace in WSL 1 That's a known problem with the WSL file system implementation ( Microsoft/WSL#3395 , Microsoft/WSL#1956 ) caused by the file watcher active by VSCode. The issue will only be fixed in WSL 2. To avoid the issue, set remote.WSL.fileWatcher.polling to true. However, polling based file watching has a performance impact for large workspaces. For large workspace you want to increase the polling interval: remote.WSL.fileWatcher.pollingInterval and control the folders that are watched: files.watcherExclude . WSL 2 does not have that file watcher problem is also not affected by the new setting. Golang in WSL 1 Issue Existing issues Delve debugger doesn't work under WSL go-delve/delve#810 , Microsoft/vscode-go#926 Node.js in WSL 1 Issue Existing issues NodeJS Error: spawn EACCES (different variants of this error) Microsoft/WSL#3886 Webpack HMR not working Microsoft/WSL#2709 Firebase via node unusably slow only on WSL Microsoft/WSL#2657 Git limitations If you clone a Git repository using SSH and your SSH key has a passphrase, VS Code's pull and sync features may hang when running remotely. Either use an SSH key without a passphrase, clone using HTTPS, or run git push from the command line to work around the issue. Docker Extension limitations While the Docker extension can run both remotely and locally, if it is already installed locally, you will be unable to install on a remote SSH host without first uninstalling it locally. We will address this problem in a future VS Code release. Extension limitations Many extensions will work in WSL without modification. However, in some cases, certain features may require changes. If you run into an extension issue, see here for a summary of common problems and solutions that you can mention to the extension author when reporting the issue. In addition, some extensions installed in an WSL when using an Alpine Linux-based distribution may not work due to glibc dependencies in native code inside the extension. See the Remote Development with Linux article for details. Common questions Why am I asked to change the default distro? When using Remote-WSL: New Window using Distro and running on WSL older than Windows 10, May 2019 Update (version 1903) you will be asked to switch the default distribution as the WSL command can only work on the default distro as it does not support the -d option yet. You can always manually switch the default distro by using wslconfig.exe . For example: wslconfig /setdefault Ubuntu You can see which distributions you have installed using: wslconfig /l I'm seeing an error about a missing library or dependency Some extensions rely on libraries not found in the vanilla install of certain WSL Linux distributions. You can add additional libraries into your Linux distribution by using its package manager. For Ubuntu and Debian based distributions, run sudo apt-get install <package> to install the needed libraries. Check the documentation for your extension or the runtime that is mentioned for additional installation details. What are the connectivity requirements for the Remote - WSL extension? The Remote - WSL extension and VS Code Server require outbound HTTPS (port 443) connectivity to: update.code.visualstudio.com marketplace.visualstudio.com vscode.blob.core.windows.net *.vo.msecnd.net (Azure CDN) *.gallerycdn.vsassets.io (Azure CDN) Some extensions (like C#) download secondary dependencies from download.microsoft.com or download.visualstudio.microsoft.com . Others (like Visual Studio Live Share ) may have additional connectivity requirements. Consult the extension's documentation for details if you run into trouble. All other communication between the server and the VS Code client is accomplished through an random local TCP port. You can find a list of locations VS Code itself needs access to in the network connections article . I'm behind a proxy and have connectivity issues Proxy settings might be missing on either the Windows or the WSL side. When a remote window is opened out of VSCode, the Remote - WSL extension tries to download the VSCode server on the Windows side. It therefore uses the Window side proxy configuration: inherited from the OS settings as described in Network Connections in Visual Studio Code When the remote VSCode is started from a WSL terminal, the download is done using wget in the WSL distro. Proxy settings can be configured in: wget proxy settings: https://stackoverflow.com/questions/11211705/how-to-set-proxy-for-wget manually in the server setup script Once the server is up and running the proxy settings on the Remote tab are used. Can I force an extension to run locally / remotely ? Extensions are typically designed and tested to either run locally or remotely, not both. However, if an extension supports it, you can force it to run in a particular location in your settings.json file. For example, the setting below will force the Docker extension to run locally and Debugger for Chrome extension to run remotely instead of their defaults: \"remote.extensionKind\": { \"ms-azuretools.vscode-docker\": [ \"ui\" ], \"msjsdiag.debugger-for-chrome\": [ \"workspace\" ] } A value of \"ui\" instead of \"workspace\" will force the extension to run on the local UI/client side instead. Typically, this should only be used for testing unless otherwise noted in the extension's documentation since it can break extensions . See the article on Supporting Remote Development for details. As an extension author, what do I need to do? The VS Code extension API abstracts away local/remote details so most extensions will work without modification. However, given extensions can use any node module or runtime they want, there are situations where adjustments may need to be made. We recommend you test your extension to be sure that no updates are required. See Supporting Remote Development for details. Questions or feedback See Tips and Tricks or the FAQ . Search on Stack Overflow . Add a feature requests or report a problem . Contribute to our documentation or VS Code itself . See our CONTRIBUTING guide for details."
  },
  "guides/vscode/remote/wsl-tutorial.html": {
    "href": "guides/vscode/remote/wsl-tutorial.html",
    "title": "Remote development in WSL | Fountain of Knowledge",
    "keywords": "Remote development in WSL This tutorial walks you through enabling Windows Subsystem for Linux (WSL) and running Visual Studio Code in WSL using the Remote - WSL extension. Prerequisites You need Visual Studio Code installed. Install the extension The Remote - WSL extension enables you to run Visual Studio Code within the Windows Subsystem for Linux (WSL). Install the Remote - WSL extension Prerequisite check With the Remote - WSL extension installed, you will see a new Status bar item at the far left. The Remote Status bar item can quickly show you in which context VS Code is running (local or remote) and clicking on the item will bring up the Remote - WSL commands. Enable WSL Windows Subsystem for Linux (WSL) is an optional feature on Windows 10. You can enable it through the Windows Features dialog or PowerShell. Windows Features dialog In the Windows search bar, type 'features' to bring up the Turn Windows Features on and off dialog. Scroll down and check Windows Subsystem for Linux . Select OK and you will be prompted to restart Windows. PowerShell If you prefer, you can open PowerShell as an Administrator and type: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux After the command runs, you will be prompted to restart Windows. Check WSL After restarting Windows, you can check that you have WSL enabled by opening a Command Prompt and typing 'wsl'. WSL is enabled, but you haven't installed a Linux distribution yet. Install a Linux distro You install Linux distributions for WSL from the Microsoft Store. You can use the store app, or search for a Linux distro in the Windows search bar. Choose the Linux distribution you want to install (for example Ubuntu) and follow the prompts. Select Install . And when done, select Launch to get started. This will open a Linux terminal and complete the installation. You'll need to create a user ID and password since you are setting up a full Linux instance. You are now running Linux on Windows. Python development If you don't have Python already installed, run the following commands to install Python3 and pip, the package manager for Python, into your Linux installation. sudo apt update sudo apt install python3 python3-pip And to verify, run: python3 --version Start with the canonical \"Hello World\" app. Create a new folder called \"helloWorld\" and then add a Python file that will print a message when run: mkdir helloWorld && cd helloWorld echo 'print(\"hello from python on ubuntu on windows!\")' >> hello.py python3 hello.py In a remote Linux environment (this WSL distro is technically another machine without UI, that just happens to be running locally on your computer), your development tools and experiences are pretty limited. You can run Vim in the terminal to edit your file, or you can edit the sources on the Windows side through the \\\\wsl$ mount: The problem with this model is that the Python runtime, pip, or any conda packages for that matter, are not installed on Windows. Remember, Python is installed in the Linux distro, which means if you're editing Python files on the Windows side, you can't run or debug them unless you install the same Python development stack on Windows. And that defeats the purpose of having an isolated Linux instance set up with all your Python tools and runtimes! Run in WSL In the WSL terminal, make sure you are in the helloWorld folder, and type in 'code .' to launch Visual Studio Code. The '.' argument tells VS Code to open the current folder. Note: If this command does not work, you may need to restart your terminal, or you may not have added VS Code to your path when it was installed. The first thing you'll see is a message about \"Installing VS Code Server\" (the c7d83e57… number is the version of the VS Code Server that matches the client-side tools you just installed). VS Code is installing a small server on the Linux side that the desktop VS Code will then talk to. That server will then install and host extensions in WSL, so that they run in the context of the tools and frameworks installed in WSL. In other words, your language extensions will run against the tools and frameworks installed in WSL, not against what is installed on the Windows side, as it should for the proper development experience. The next thing that happens is VS Code will start and open the helloWorld folder. You may see a quick notification telling you that VS Code is connecting to WSL, and you may be prompted to allow access to the Node.js-based server. Now, when you hover over hello.py , you get the proper Linux path. Integrated Terminal Run Terminal > New Terminal ( kb(workbench.action.terminal.toggleTerminal) ) to open a new terminal instance. You'll start a new instance of the bash shell in WSL, again from VS Code running on Windows. Tip : In the lower left corner of the Status Bar, you can see that you're connected to your WSL: Ubuntu instance. Edit and debug Installing the Python extension (and additional tools) Click on hello.py to open it for editing. You will be prompted with an extension recommendation, in this case to install the Microsoft Python extension, which will give you rich editing and debugging experiences. Go ahead and select Install and reload if prompted. To prove that the extension is installed in WSL, open the Extensions view again ( kb(workbench.view.extensions) ). You will see a section titled WSL: Ubuntu – Installed , and you can see any extensions that are installed on the WSL side. Upon reload, you'll also get prompted telling you that the pylint linter is not installed. Linters are used to show errors and warnings in source code. Go ahead and select Install . Now, when you edit your code, you get rich colorization and completions. And when you save your file ( kb(workbench.action.files.save) ), you'll get linting errors and warnings on the file. Debugging With your tools set up, let's take this one step further. Set a breakpoint on line 1 of hello.py by clicking in the gutter to the left of the line number or by putting the cursor on the line and pressing kb(editor.debug.action.toggleBreakpoint) . Now, press kb(workbench.action.debug.start) to run your application. You will be asked how to run the application, and since this is a simple file, just choose Python File . The app will start, and you'll hit the breakpoint. You can inspect variables, create watches, and navigate the call stack. Press kb(workbench.action.debug.stepOver) to step and you'll see the output of the print statement in the debug console. You get the full development experience of Visual Studio Code, using the Linux instance installed in WSL. If you want to open another folder in WSL, open the File menu and choose Open Folder . You'll get a minimal file and folder navigator for the Linux file system, not the Windows file system. If you want to switch back to the Windows, select the Show Local option and you'll get the standard Windows File Open dialog. Ending your WSL connection You can end your session in WSL and go back to running VS Code locally with File > Close Remote Connection . Congratulations! Congratulations, you've successfully completed this tutorial! Next, check out the other Remote Development extensions. Remote - SSH Remote - Containers Or get them all by installing the Remote Development Extension Pack."
  },
  "guides/vscode/setup/additional-components.html": {
    "href": "guides/vscode/setup/additional-components.html",
    "title": "Additional components and tools | Fountain of Knowledge",
    "keywords": "Additional components and tools Visual Studio Code is a small download by design and only includes the minimum number of components shared across most development workflows. Basic functionality like the editor, file management, window management, and preference settings are included. A JavaScript/TypeScript language service and Node.js debugger are also part of the base install. If you are used to working with larger, monolithic development tools (IDEs), you may be surprised that your scenarios aren't completely supported out of the box. For example, there isn't a File > New Project dialog with pre-installed project templates. Most VS Code users will need to install additional components depending on their specific needs. Commonly used components Here are a few commonly installed components: Git - VS Code has built-in support for source code control using Git but requires Git to be installed separately. Node.js (includes npm) - A cross platform runtime for building and running JavaScript applications. TypeScript - The TypeScript compiler, tsc , for transpiling TypeScript to JavaScript. You'll find the components above mentioned often in our documentation and walkthroughs. VS Code extensions You can extend the VS Code editor itself through extensions . The VS Code community has built hundreds of useful extensions available on the VS Code Marketplace . The extensions shown above are the current most popular on Marketplace. Click on an extension tile above to read the description and reviews of the extension. Additional tools Visual Studio Code integrates with existing tool chains. We think the following tools will enhance your development experiences. Yeoman - An application scaffolding tool, a command line version of File > New Project . generator-hottowel - A Yeoman generator for quickly creating AngularJS applications. Express - An application framework for Node.js applications using the Pug template engine. Gulp - A streaming task runner system which integrates easily with VS Code tasks. Mocha - A JavaScript test framework that runs on Node.js. Yarn - A dependency manager and alternative to npm. Note: Most of these tools require Node.js and the npm package manager to install and use. Next steps User Interface - A quick orientation around VS Code. User/Workspace Settings - Learn how to configure VS Code to your preferences through settings. Languages - VS Code supports many programming languages out-of-the-box as well as many more through community created extensions."
  },
  "guides/vscode/setup/index.html": {
    "href": "guides/vscode/setup/index.html",
    "title": "Setup | Fountain of Knowledge",
    "keywords": "Setup"
  },
  "guides/vscode/setup/linux.html": {
    "href": "guides/vscode/setup/linux.html",
    "title": "Visual Studio Code on Linux | Fountain of Knowledge",
    "keywords": "Visual Studio Code on Linux Installation See the Download Visual Studio Code page for a complete list of available installation options. By downloading and using Visual Studio Code, you agree to the license terms and privacy statement . Snap Visual Studio Code is officially distributed as a Snap package in the Snap Store : You can install it by running: sudo snap install --classic code # or code-insiders Once installed, the Snap daemon will take care of automatically updating VS Code in the background. You will get an in-product update notification whenever a new update is available. Note: If snap isn't available in your Linux distribution, please check the following Installing snapd guide , which can help you get that set up. Learn more about snaps from the official Snap Documentation . Debian and Ubuntu based distributions The easiest way to install Visual Studio Code for Debian/Ubuntu based distributions is to download and install the .deb package (64-bit) , either through the graphical software center if it's available, or through the command line with: sudo apt install ./<file>.deb # If you're on an older Linux distribution, you will need to run this instead: # sudo dpkg -i <file>.deb # sudo apt-get install -f # Install dependencies Note that other binaries are also available on the VS Code download page . Installing the .deb package will automatically install the apt repository and signing key to enable auto-updating using the system's package manager. Alternatively, the repository and key can also be installed manually with the following script: wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor > packages.microsoft.gpg sudo install -o root -g root -m 644 packages.microsoft.gpg /etc/apt/trusted.gpg.d/ sudo sh -c 'echo \"deb [arch=amd64,arm64,armhf signed-by=/etc/apt/trusted.gpg.d/packages.microsoft.gpg] https://packages.microsoft.com/repos/code stable main\" > /etc/apt/sources.list.d/vscode.list' rm -f packages.microsoft.gpg Then update the package cache and install the package using: sudo apt install apt-transport-https sudo apt update sudo apt install code # or code-insiders RHEL, Fedora, and CentOS based distributions We currently ship the stable 64-bit VS Code in a yum repository, the following script will install the key and repository: sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc sudo sh -c 'echo -e \"[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" > /etc/yum.repos.d/vscode.repo' Then update the package cache and install the package using dnf (Fedora 22 and above): dnf check-update sudo dnf install code Or on older versions using yum : yum check-update sudo yum install code Due to the manual signing process and the system we use to publish, the yum repo may lag behind and not get the latest version of VS Code immediately. openSUSE and SLE-based distributions The yum repository above also works for openSUSE and SLE-based systems, the following script will install the key and repository: sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc sudo sh -c 'echo -e \"[code]\\nname=Visual Studio Code\\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\\nenabled=1\\ntype=rpm-md\\ngpgcheck=1\\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc\" > /etc/zypp/repos.d/vscode.repo' Then update the package cache and install the package using: sudo zypper refresh sudo zypper install code AUR package for Arch Linux There is a community-maintained Arch User Repository package for VS Code . To get more information about the installation from the AUR, please consult the following wiki entry: Install AUR Packages . Nix package for NixOS (or any Linux distribution using Nix package manager) There is a community maintained VS Code Nix package in the nixpkgs repository. In order to install it using Nix, set allowUnfree option to true in your config.nix and execute: nix-env -i vscode Installing .rpm package manually The VS Code .rpm package (64-bit) can also be manually downloaded and installed, however, auto-updating won't work unless the repository above is installed. Once downloaded it can be installed using your package manager, for example with dnf : sudo dnf install <file>.rpm Note that other binaries are also available on the VS Code download page . Updates VS Code ships monthly and you can see when a new release is available by checking the release notes . If the VS Code repository was installed correctly, then your system package manager should handle auto-updating in the same way as other packages on the system. Note: Updates are automatic and run in the background for the Snap package . Node.js Node.js is a popular platform and runtime for easily building and running JavaScript applications. It also includes npm , a Package Manager for Node.js modules. You'll see Node.js and npm mentioned frequently in our documentation and some optional VS Code tooling requires Node.js (for example, the VS Code extension generator ). If you'd like to install Node.js on Linux, see Installing Node.js via package manager to find the Node.js package and installation instructions tailored to your Linux distribution. You can also install and support multiple versions of Node.js by using the Node Version Manager . To learn more about JavaScript and Node.js, see our Node.js tutorial , where you'll learn about running and debugging Node.js applications with VS Code. Setting VS Code as the default text editor xdg-open You can set the default text editor for text files ( text/plain ) that is used by xdg-open with the following command: xdg-mime default code.desktop text/plain Debian alternatives system Debian-based distributions allow setting a default editor using the Debian alternatives system , without concern for the MIME type. You can set this by running the following and selecting code: sudo update-alternatives --set editor /usr/bin/code If Visual Studio Code doesn't show up as an alternative to editor , you need to register it: sudo update-alternatives --install editor /usr/bin/editor $(which code) Windows as a Linux developer machine Another option for Linux development with VS Code is to use a Windows machine with the Windows Subsystem for Linux (WSL). Windows Subsystem for Linux With WSL, you can install and run Linux distributions on Windows. This enables you to develop and test your source code on Linux while still working locally on a Windows machine. WSL supports Linux distributions such as Ubuntu, Debian, SUSE, and Alpine available from the Microsoft Store. When coupled with the Remote - WSL extension, you get full VS Code editing and debugging support while running in the context of a Linux distro on WSL. See the Developing in WSL documentation to learn more or try the Working in WSL introductory tutorial. Next steps Once you have installed VS Code, these topics will help you learn more about it: Additional Components - Learn how to install Git, Node.js, TypeScript, and tools like Yeoman. User Interface - A quick orientation to VS Code. User/Workspace Settings - Learn how to configure VS Code to your preferences through settings. Common questions Azure VM Issues I'm getting a \"Running without the SUID sandbox\" error? You can safely ignore this error. Debian and moving files to trash If you see an error when deleting files from the VS Code Explorer on the Debian operating system, it might be because the trash implementation that VS Code is using is not there. Run these commands to solve this issue: sudo apt-get install gvfs-bin Conflicts with VS Code packages from other repositories Some distributions, for example Pop!_OS provide their own code package. To ensure the official VS Code repository is used, create a file named /etc/apt/preferences.d/code with the following content: Package: code Pin: origin \"packages.microsoft.com\" Pin-Priority: 9999 \"Visual Studio Code is unable to watch for file changes in this large workspace\" (error ENOSPC) When you see this notification, it indicates that the VS Code file watcher is running out of handles because the workspace is large and contains many files. Before adjusting platform limits, make sure that potentially large folders, such as Python .venv , are added to the files.watcherExclude setting (more details below). The current limit can be viewed by running: cat /proc/sys/fs/inotify/max_user_watches The limit can be increased to its maximum by editing /etc/sysctl.conf (except on Arch Linux, read below) and adding this line to the end of the file: fs.inotify.max_user_watches=524288 The new value can then be loaded in by running sudo sysctl -p . While 524,288 is the maximum number of files that can be watched, if you're in an environment that is particularly memory constrained, you may want to lower the number. Each file watch takes up 1080 bytes , so assuming that all 524,288 watches are consumed, that results in an upper bound of around 540 MiB. Arch -based distros (including Manjaro) require you to change a different file; follow these steps instead. Another option is to exclude specific workspace directories from the VS Code file watcher with the files.watcherExclude setting . The default for files.watcherExclude excludes node_modules and some folders under .git , but you can add other directories that you don't want VS Code to track. \"files.watcherExclude\": { \"**/.git/objects/**\": true, \"**/.git/subtree-cache/**\": true, \"**/node_modules/*/**\": true } I can't see Chinese characters in Ubuntu We're working on a fix. In the meantime, open the application menu, then choose File > Preferences > Settings . In the Text Editor > Font section, set \"Font Family\" to Droid Sans Mono, Droid Sans Fallback . If you'd rather edit the settings.json file directly, set editor.fontFamily as shown: \"editor.fontFamily\": \"Droid Sans Mono, Droid Sans Fallback\" Package git is not installed This error can appear during installation and is typically caused by the package manager's lists being out of date. Try updating them and installing again: # For .deb sudo apt-get update # For .rpm (Fedora 21 and below) sudo yum check-update # For .rpm (Fedora 22 and above) sudo dnf check-update The code bin command does not bring the window to the foreground on Ubuntu Running code . on Ubuntu when VS Code is already open in the current directory will not bring VS Code into the foreground. This is a feature of the OS which can be disabled using ccsm . # Install sudo apt-get update sudo apt-get install compizconfig-settings-manager # Run ccsm Under General > General Options > Focus & Raise Behaviour , set \"Focus Prevention Level\" to \"Off\". Remember this is an OS-level setting that will apply to all applications, not just VS Code. Cannot install .deb package due to \"/etc/apt/sources.list.d/vscode.list: No such file or directory\" This can happen when sources.list.d doesn't exist or you don't have access to create the file. To fix this, try manually creating the folder and an empty vscode.list file: sudo mkdir /etc/apt/sources.list.d sudo touch /etc/apt/sources.list.d/vscode.list Cannot move or resize the window while X forwarding a remote window If you are using X forwarding to use VS Code remotely, you will need to use the native title bar to ensure you can properly manipulate the window. You can switch to using it by setting window.titleBarStyle to native . Using the custom title bar The custom title bar and menus were enabled by default on Linux for several months. The custom title bar has been a success on Windows, but the customer response on Linux suggests otherwise. Based on feedback, we have decided to make this setting opt-in on Linux and leave the native title bar as the default. The custom title bar provides many benefits including great theming support and better accessibility through keyboard navigation and screen readers. Unfortunately, these benefits do not translate as well to the Linux platform. Linux has a variety of desktop environments and window managers that can make the VS Code theming look foreign to users. For users needing the accessibility improvements, we recommend enabling the custom title bar when running in accessibility mode using a screen reader. You can still manually set the title bar with the Window: Title Bar Style ( window.titleBarStyle ) setting. Broken cursor in editor with display scaling enabled Due to an upstream issue #14787 with Electron, the mouse cursor may render incorrectly with scaling enabled. If you notice that the usual text cursor is not being rendered inside the editor as you would expect, try falling back to the native menu bar by configuring the setting window.titleBarStyle to native . Repository changed its origin value If you receive an error similar to the following: E: Repository '...' changed its 'Origin' value from '...' to '...' N: This must be accepted explicitly before updates for this repository can be applied. See apt-secure(8) manpage for details. Use apt instead of apt-get and you will be prompted to accept the origin change: sudo apt update"
  },
  "guides/vscode/setup/mac.html": {
    "href": "guides/vscode/setup/mac.html",
    "title": "Visual Studio Code on macOS | Fountain of Knowledge",
    "keywords": "Visual Studio Code on macOS Installation Download Visual Studio Code for macOS. Open the browser's download list and locate the downloaded archive. Extract the archive contents. Use double-click for some browsers or select the 'magnifying glass' icon with Safari. Drag Visual Studio Code.app to the Applications folder, making it available in the macOS Launchpad. Add VS Code to your Dock by right-clicking on the icon to bring up the context menu and choosing Options , Keep in Dock . Launching from the command line You can also run VS Code from the terminal by typing 'code' after adding it to the path: Launch VS Code. Open the Command Palette ( kbstyle(Cmd+Shift+P) ) and type 'shell command' to find the Shell Command: Install 'code' command in PATH command. Restart the terminal for the new $PATH value to take effect. You'll be able to type 'code .' in any folder to start editing files in that folder. Note: If you still have the old code alias in your .bash_profile (or equivalent) from an early VS Code version, remove it and replace it by executing the Shell Command: Install 'code' command in PATH command. Alternative manual instructions Instead of running the command above, you can manually add VS Code to your path, to do so run the following commands: cat << EOF >> ~/.bash_profile # Add Visual Studio Code (code) export PATH=\"\\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\" EOF Start a new terminal to pick up your .bash_profile changes. Note : The leading slash \\ is required to prevent $PATH from expanding during the concatenation. Remove the leading slash if you want to run the export command directly in a terminal. Note : Since zsh became the default shell in macOS Catalina, run the following commands to add VS Code to your path: cat << EOF >> ~/.zprofile # Add Visual Studio Code (code) export PATH=\"\\$PATH:/Applications/Visual Studio Code.app/Contents/Resources/app/bin\" EOF Touch Bar support Out of the box VS Code adds actions to navigate in editor history as well as the full Debug tool bar to control the debugger on your Touch Bar: Mojave privacy protections After upgrading to macOS Mojave version, you may see dialogs saying \"Visual Studio Code would like to access your {calendar/contacts/photos}.\" This is due to the new privacy protections in Mojave and is not specific to VS Code. The same dialogs may be displayed when running other applications as well. The dialog is shown once for each type of personal data and it is fine to choose Don't Allow since VS Code does not need access to those folders. You can read a more detailed explanation in this blog post . Updates VS Code ships monthly releases and supports auto-update when a new release is available. If you're prompted by VS Code, accept the newest update and it will get installed (you won't need to do anything else to get the latest bits). Note: You can disable auto-update if you prefer to update VS Code on your own schedule. Preferences menu You can configure VS Code through settings , color themes , and custom keybindings available through the Code > Preferences menu group. You may see mention of File > Preferences in documentation, which is the Preferences menu group location on Windows and Linux. On a macOS, the Preferences menu group is under Code , not File . Next steps Once you have installed VS Code, these topics will help you learn more about VS Code: Additional Components - Learn how to install Git, Node.js, TypeScript, and tools like Yeoman. User Interface - A quick orientation around VS Code. User/Workspace Settings - Learn how to configure VS Code to your preferences settings. Common questions Why do I see \"Visual Studio Code would like access to your calendar.\" If you are running macOS Mojave version, you may see dialogs saying \"Visual Studio Code would like to access your {calendar/contacts/photos}.\" This is due to the new privacy protections in Mojave discussed above . It is fine to choose Don't Allow since VS Code does not need access to those folders. VS Code fails to update If VS Code doesn't update once it restarts, it might be set under quarantine by macOS. Follow the steps in this issue for resolution. Does VS Code run on Mac M1 machines? Yes, VS Code supports macOS ARM64 builds that can run on Macs with the Apple M1 chip. You can install the Universal build, which includes both Intel and Apple Silicon builds, or one of the platform specific builds."
  },
  "guides/vscode/setup/network.html": {
    "href": "guides/vscode/setup/network.html",
    "title": "Network Connections in Visual Studio Code | Fountain of Knowledge",
    "keywords": "Network Connections in Visual Studio Code Visual Studio Code is built on top of Electron and benefits from all the networking stack capabilities of Chromium . This also means that VS Code users get much of the networking support available in Google Chrome . Common hostnames A handful of features within VS Code require network communication to work, such as the auto-update mechanism, querying and installing extensions, and telemetry. For these features to work properly in a proxy environment, you must have the product correctly configured. If you are behind a firewall that needs to allow specific domains used by VS Code, here's the list of hostnames you should allow communication to go through: update.code.visualstudio.com - Visual Studio Code download and update server code.visualstudio.com - Visual Studio Code documentation go.microsoft.com - Microsoft link forwarding service vscode.blob.core.windows.net - Visual Studio Code blob storage, used for remote server marketplace.visualstudio.com - Visual Studio Marketplace *.gallery.vsassets.io - Visual Studio Marketplace *.gallerycdn.vsassets.io - Visual Studio Marketplace rink.hockeyapp.net - Crash reporting service bingsettingssearch.trafficmanager.net - In-product settings search vscode.search.windows.net - In-product settings search raw.githubusercontent.com - GitHub repository raw file access vsmarketplacebadge.apphb.com - Visual Studio Marketplace badge service az764295.vo.msecnd.net - Visual Studio Code download CDN download.visualstudio.microsoft.com - Visual Studio download server, provides dependencies for some VS Code extensions (C++, C#) vscode-sync.trafficmanager.net - Visual Studio Code Settings Sync service vscode-sync-insiders.trafficmanager.net - Visual Studio Code Settings Sync service (Insiders) Proxy server support VS Code has exactly the same proxy server support as Google Chromium. Here's a snippet from Chromium's documentation : \"The Chromium network stack uses the system network settings so that users and administrators can control the network settings of all applications easily. The network settings include: - proxy settings - SSL/TLS settings - certificate revocation check settings - certificate and private key stores\" This means that your proxy settings should be picked up automatically. Otherwise, you can use the following command-line arguments to control your proxy settings: # Disable proxy --no-proxy-server # Manual proxy address --proxy-server=<scheme>=<uri>[:<port>][;...] | <uri>[:<port>] | \"direct://\" # Manual PAC address --proxy-pac-url=<pac-file-url> # Disable proxy per host --proxy-bypass-list=(<trailing_domain>|<ip-address>)[:<port>][;...] To learn more about these command-line arguments, see Chromium Network Settings . Authenticated proxies Authenticated proxies should work seamlessly within VS Code with the addition of PR #22369 . The authentication methods supported are: Basic Digest NTLM Negotiate When using VS Code behind an authenticated HTTP proxy, the following authentication popup should appear: Note that SOCKS5 proxy authentication support isn't implemented yet; you can follow the issue in Chromium's issue tracker . See Chromium HTTP authentication to read more about HTTP proxy authentication within VS Code. SSL certificates Often HTTPS proxies rewrite SSL certificates of the incoming requests. Chromium was designed to reject responses which are signed by certificates which it doesn't trust. If you hit any SSL trust issues, there are a few options available for you: Since Chromium uses the OS's certificate trust infrastructure, the preferred option is to add your proxy's certificate to your OS's trust chain. See the Chromium Root Certificate Policy documentation to learn more. If your proxy runs in localhost , you can always try the --allow-insecure-localhost command-line flag. If all else fails, you can tell VS Code to ignore all certificate errors using the --ignore-certificate-errors command-line flag. Warning: This is dangerous and not recommended , since it opens the door to security issues. Legacy proxy server support Extensions don't benefit yet from the same proxy support that VS Code supports. You can follow this issue's development in GitHub . Similarly to extensions, a few other VS Code features don't yet fully support proxy networking, namely the CLI interface. The CLI interface is what you get when running code --install-extension vscodevim.vim from a command prompt or terminal. You can follow this issue's development in GitHub . Due to both of these constraints, the http.proxy , http.proxyStrictSSL and http.proxyAuthorization variables are still part of VS Code's settings, yet they are only respected in these two scenarios. Troubleshooting Here are some helpful links that might help you troubleshoot networking issues in VS Code: Network Settings Debugging problems with the network proxy Configuring a SOCKS proxy server in Chrome Proxy settings and fallback (Windows)"
  },
  "guides/vscode/setup/raspberry-pi.html": {
    "href": "guides/vscode/setup/raspberry-pi.html",
    "title": "Visual Studio Code on Raspberry Pi | Fountain of Knowledge",
    "keywords": "Visual Studio Code on Raspberry Pi You can run Visual Studio Code on Raspberry Pi devices. By downloading and using Visual Studio Code, you agree to the license terms and privacy statement . Installation Visual Studio Code is officially distributed via the Raspberry Pi OS (previously called Raspbian) APT repository, in both 32-bit and 64-bit variants. You can install it by running: sudo apt update sudo apt install code Running VS Code After installing the VS Code package, you can run VS Code by typing code in a terminal or launching it via the Programming menu. Updates Your Raspberry Pi should handle updating VS Code in the same way as other packages on the system: sudo apt update sudo apt upgrade code You can always check when a new release is available in our Updates page. System requirements VS Code is supported on these Raspberry Pi models running a 32-bit or 64-bit version of Raspberry Pi OS: Raspberry Pi 3 Model B/B+ Raspberry Pi 4 Model B Raspberry Pi 400 While 1 GB of memory (RAM) meets the minimum system requirements, users will benefit from installing VS Code on a Raspberry Pi 4 with more memory. First-generation Raspberry Pi modules and Raspberry Pi Zero are not supported as they only include an ARMv6 CPU. Next steps Once you have installed VS Code, these topics will help you learn more about it: Additional Components - Learn how to install Git, Node.js, TypeScript, and tools like Yeoman. User Interface - A quick orientation to VS Code. User/Workspace Settings - Learn how to configure VS Code to your preferences through settings."
  },
  "guides/vscode/setup/setup-overview.html": {
    "href": "guides/vscode/setup/setup-overview.html",
    "title": "Setting up Visual Studio Code | Fountain of Knowledge",
    "keywords": "Setting up Visual Studio Code Getting up and running with Visual Studio Code is quick and easy. It is a small download so you can install in a matter of minutes and give VS Code a try. Cross platform VS Code is a free code editor, which runs on the macOS, Linux, and Windows operating systems. Follow the platform-specific guides below: macOS Linux Windows VS Code is lightweight and should run on most available hardware and platform versions. You can review the System Requirements to check if your computer configuration is supported. Update cadence VS Code releases a new version each month with new features and important bug fixes. Most platforms support auto updating and you will be prompted to install the new release when it becomes available. You can also manually check for updates by running Help > Check for Updates on Linux and Windows or running Code > Check for Updates on macOS. Note: You can disable auto-update if you prefer to update VS Code on your own schedule. Insiders nightly build If you'd like to try our nightly builds to see new features early or verify bug fixes, you can install our Insiders build . The Insiders build installs side-by-side with the monthly Stable build and you can freely work with either on the same machine. The Insiders build is the same one the VS Code development team uses on a daily basis and we really appreciate people trying out new features and providing feedback. Portable mode Visual Studio Code supports Portable mode installation. This mode enables all data created and maintained by VS Code to live near itself, so it can be moved around across environments, for example, on a USB drive. See the VS Code Portable Mode documentation for details. Additional components VS Code is an editor, first and foremost, and prides itself on a small footprint. Unlike traditional IDEs that tend to include everything but the kitchen sink, you can tune your installation to the development technologies you care about. Be sure to read the Additional Components topic after reading the platform guides to learn about customizing your VS Code installation. Extensions VS Code extensions let third parties add support for additional: Languages - C++ , C# , Go , Java , Python Tools - ESLint , JSHint , PowerShell Debuggers - PHP XDebug . Keymaps - Vim , Sublime Text , IntelliJ , Emacs , Atom , Brackets , Visual Studio , Eclipse Extensions integrate into VS Code's UI, commands, and task running systems so you'll find it easy to work with different technologies through VS Code's shared interface. Check out the VS Code extension Marketplace to see what's available. Next steps Once you have installed and set up VS Code, these topics will help you learn more about VS Code: Additional Components - Learn how to install Git, Node.js, TypeScript, and tools like Yeoman. User Interface - A quick orientation to VS Code. Basic Editing - Learn about the powerful VS Code editor. Code Navigation - Move quickly through your source code. Debugging - Debug your source code directly in the VS Code editor. Proxy Server Support - Configure your proxy settings. If you'd like to get something running quickly, try the Node.js tutorial walkthrough that will have you debugging a Node.js web application with VS Code in minutes. Common questions What are the system requirements for VS Code? We have a list of System Requirements . How big is VS Code? VS Code is a small download (< 100 MB) and has a disk footprint of less than 200 MB, so you can quickly install VS Code and try it out. How do I create and run a new project? VS Code doesn't include a traditional File > New Project dialog or pre-installed project templates. You'll need to add additional components and scaffolders depending on your development interests. With scaffolding tools like Yeoman and the multitude of modules available through the npm package manager, you're sure to find appropriate templates and tools to create your projects. How do I know which version I'm running? On Linux and Windows, choose Help > About . On macOS, use Code > About Visual Studio Code . Why is VS Code saying my installation is Unsupported? VS Code has detected that some installation files have been modified, perhaps by an extension. Reinstalling VS Code will replace the affected files. See our FAQ topic for more details. How can I do a 'clean' uninstall of VS Code? If you want to remove all user data after uninstalling VS Code, you can delete the user data folders Code and .vscode . This will return you to the state before you installed VS Code. This can also be used to reset all settings if you don't want to uninstall VS Code. The folder locations will vary depending on your platform: Windows - Delete %APPDATA%\\Code and %USERPROFILE%\\.vscode . macOS - Delete $HOME/Library/Application Support/Code and ~/.vscode . Linux - Delete $HOME/.config/Code and ~/.vscode ."
  },
  "guides/vscode/setup/windows.html": {
    "href": "guides/vscode/setup/windows.html",
    "title": "Visual Studio Code on Windows | Fountain of Knowledge",
    "keywords": "Visual Studio Code on Windows Installation Download the Visual Studio Code installer for Windows. Once it is downloaded, run the installer (VSCodeUserSetup-{version}.exe). This will only take a minute. By default, VS Code is installed under C:\\users\\{username}\\AppData\\Local\\Programs\\Microsoft VS Code . Alternatively, you can also download a Zip archive , extract it and run Code from there. Note: .NET Framework 4.5.2 or higher is required for VS Code. If you are using Windows 7, make sure you have at least .NET Framework 4.5.2 installed. You can check your version of .NET Framework using this command, reg query \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\full\" /v version from a command prompt. Tip: Setup will add Visual Studio Code to your %PATH% , so from the console you can type 'code .' to open VS Code on that folder. You will need to restart your console after the installation for the change to the %PATH% environmental variable to take effect. User setup versus system setup VS Code provides both Windows user and system level setups. Installing the user setup does not require Administrator privileges as the location will be under your user Local AppData (LOCALAPPDATA) folder. User setup also provides a smoother background update experience. The system setup requires elevation to Administrator privileges and will place the installation under Program Files. This also means that VS Code will be available to all users in the system. See the Download Visual Studio Code page for a complete list of available installation options. 32-bit versions If you need to run a 32-bit version of VS Code, both a 32-bit Installer and Zip archive are available. Updates VS Code ships monthly releases and supports auto-update when a new release is available. If you're prompted by VS Code, accept the newest update and it will be installed (you won't need to do anything else to get the latest bits). Note: You can disable auto-update if you prefer to update VS Code on your own schedule. Windows Subsystem for Linux Windows is a popular operating system and it can be a great cross-platform development environment. This section describes cross-platform features such as the Windows Subsystem for Linux (WSL) and the new Windows Terminal. Recent Windows build Make sure you are on a recent Windows 10 build. Check Settings > Windows Update to see if you are up-to-date. Windows as a developer machine With WSL, you can install and run Linux distributions on Windows. This enables you to develop and test your source code on Linux while still working locally on your Windows machine. When coupled with the Remote - WSL extension, you get full VS Code editing and debugging support while running in the context of WSL. See the Developing in WSL documentation to learn more or try the Working in WSL introductory tutorial. New Windows Terminal Available from the Microsoft Store, the Windows Terminal (Preview) lets you easily open PowerShell, Command Prompt, and WSL terminals in a multiple tab shell. Next steps Once you have installed VS Code, these topics will help you learn more about VS Code: Additional Components - Learn how to install Git, Node.js, TypeScript, and tools like Yeoman. User Interface - A quick orientation to VS Code. User/Workspace Settings - Learn how to configure VS Code to your preferences through settings. Tips and Tricks - Lets you jump right in and learn how to be productive with VS Code. Common questions What command-line arguments are supported by the Windows Setup? VS Code uses Inno Setup to create its setup package for Windows. Thus, all the Inno Setup command-line switches are available for use. Additionally, you can prevent the Setup from launching VS Code after completion with /mergetasks=!runcode . Scrolling is laggy and not smooth On certain devices, editor scrolling is not smooth but laggy for an unpleasant experience. If you notice this issue, make sure you install the Windows 10 October 2018 update where this issue is fixed. I'm having trouble with the installer Try using the zip file instead of the installer. To use this, unzip VS Code in your AppData\\Local\\Programs folder. Note: When VS Code is installed via a Zip file, you will need to manually update it for each release . Icons are missing I installed Visual Studio Code on my Windows 7 or 8 machine. Why are some icons not appearing in the workbench and editor? VS Code uses SVG icons and we have found instances where the .SVG file extension is associated with something other than image/svg+xml . We're considering options to fix it, but for now here's a workaround: Using the Command Prompt: Open an Administrator Command Prompt. Type REG ADD HKCR\\.svg /f /v \"Content Type\" /t REG_SZ /d image/svg+xml . Using the Registry Editor (regedit): Start regedit . Open the HKEY_CLASSES_ROOT key. Find the .svg key. Set its Content Type Data value to image/svg+xml . Exit regedit ."
  },
  "guides/vscode/supporting/errors.html": {
    "href": "guides/vscode/supporting/errors.html",
    "title": "Common Error Cases | Fountain of Knowledge",
    "keywords": "Common Error Cases Some errors that occur when using Visual Studio Code can be worked around or resolved by you. This topic describes several common error conditions, listed by error code number, and what you can do to resolve them. 20002 Error: Cannot find '/usr/bin/gnome-terminal' for launching your Node.js program On Linux, the VS Code Node.js debugger requires the gnome-terminal emulator for launching the Node.js program. If gnome-terminal is not installed, the VS Code debugger cannot launch your program for debugging. There are two options for solving this problem: Install the gnome-terminal by running the command sudo apt-get install gnome-terminal (or the equivalent of your Linux distribution). Manually launch your program in debug mode by passing a --inspect or --inspect-brk option to Node.js and then attach the VS Code debugger to port 9229 on 'localhost'. 20003 Error: Attribute 'program' is not absolute; consider adding '${workspaceFolder}/' as a prefix to make it absolute. This error occurs when you have a relative path in your debug configuration launch.json file (located in your workspace .vscode directory). In the example below, the program attribute has a relative path to app.js at the root of the workspace (project folder). { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"./app.js\" } ] } The fix is to use an absolute path or better use the ${workspaceFolder} variable which will resolve to the absolute path of the project folder. { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/app.js\" } ] } By using the ${workspaceFolder} variable, you won't need to update the absolute path if the project is moved or shared with other developers. In previous versions of VS Code, you were allowed to use relative paths in your launch configurations but this was problematic. VS Code now warns you about relative paths when you start a debugging session and recommends prefixing the relative path with ${workspaceFolder}/ . VS Code also checks other path attributes, such as cwd (current working directory), outFiles (location of other JavaScript files), and runtimeExecutable . Tip: See the VS Code debugging documentation for more information about launch.json , debugger configuration , and variable substitution . Didn't find a solution? GitHub issues If the steps above don't help you, you may have hit a bug. You can check our reported issues to see if others have reported the same issue. Online search You can also search the rest of our online documentation for answers in our main topics and Common questions sections. The online Search control is located in the upper right of the code.visualstudio.com website. Stack Overflow There is also an active VS Code Stack Overflow channel where you can browse answers or ask a question."
  },
  "guides/vscode/supporting/faq.html": {
    "href": "guides/vscode/supporting/faq.html",
    "title": "Visual Studio Code FAQ | Fountain of Knowledge",
    "keywords": "Visual Studio Code FAQ Our docs contain a Common questions section as needed for specific topics. We've captured items here that don't fit in the other topics. If you don't see an answer to your question here, check our previously reported issues on GitHub and our release notes . What is the difference between Visual Studio Code and Visual Studio IDE? Visual Studio Code is a streamlined code editor with support for development operations like debugging, task running, and version control. It aims to provide just the tools a developer needs for a quick code-build-debug cycle and leaves more complex workflows to fuller featured IDEs, such as Visual Studio IDE . Which OSs are supported? VS Code runs on macOS, Linux, and Windows. See the Requirements documentation for the supported versions. You can find more platform specific details in the Setup overview . Is VS Code free? Yes, VS Code is free for private or commercial use. See the product license for details. How to disable telemetry reporting VS Code collects usage data and sends it to Microsoft to help improve our products and services. Read our privacy statement and telemetry documentation to learn more. If you don't want to send usage data to Microsoft, you can set the telemetry.enableTelemetry user setting to false . From File > Preferences > Settings (macOS: Code > Preferences > Settings ), search for telemetry , and uncheck the Telemetry: Enable Telemetry setting. This will silence all telemetry events from VS Code going forward. Important Notice : VS Code gives you the option to install Microsoft and third party extensions. These extensions may be collecting their own usage data and are not controlled by the telemetry.enableTelemetry setting. Consult the specific extension's documentation to learn about its telemetry reporting. How to disable experiments VS Code uses experiments to try out new features or progressively roll them out. Our experimentation framework calls out to a Microsoft-owned service and is therefore disabled when telemetry is disabled. However, if you want to disable experiments regardless of your telemetry preferences, you may set the workbench.enableExperiments user setting to false . From File > Preferences > Settings (macOS: Code > Preferences > Settings ), search for experiments , and uncheck the Workbench: Enable Experiments setting. This will prevent VS Code from calling out to the service and opt out of any ongoing experiments. How to disable crash reporting VS Code collects data about any crashes that occur and sends it to Microsoft to help improve our products and services. Read our privacy statement and telemetry documentation to learn more. If you don't want to send crash data to Microsoft, you can change the enable-crash-reporter runtime argument to false Open the Command Palette ( kb(workbench.action.showCommands) ). Run the Preferences: Configure Runtime Arguments command. This command will open a argv.json file to configure runtime arguments. Edit \"enable-crash-reporter\": false . Restart VS Code. GDPR and VS Code Now that the General Data Protection Regulation (GDPR) is in effect, we want to take this opportunity to reiterate that we take privacy very seriously. That's both for Microsoft as a company and specifically within the VS Code team. To support GDPR: The VS Code product notifies all users that they can opt out of telemetry collection. The team actively reviews and classifies all telemetry sent (documented in our OSS codebase ). There are valid data retention policies in place for any data collected, for example crash dumps. You can learn more about VS Code's GDPR compliance in the telemetry documentation . What online services does VS Code use? Beyond crash reporting and telemetry, VS Code uses online services for various other purposes such as downloading product updates, finding, installing, and updating extensions, or providing Natural Language Search within the Settings editor. You can learn more in Managing online services . You can choose to turn on/off features that use these services. From File > Preferences > Settings (macOS: Code > Preferences > Settings ), and type the tag @tag:usesOnlineServices . This will display all settings that control the usage of online services and you can individually switch them on or off. How do I opt out of VS Code auto-updates? By default, VS Code is set up to auto-update for macOS and Windows users when we release new updates. If you do not want to get automatic updates, you can set the Update: Mode setting from default to none . To modify the update mode, go to File > Preferences > Settings (macOS: Code > Preferences > Settings ), search for update mode and change the setting to none . If you use the JSON editor for your settings, add the following line: \"update.mode\": \"none\" You can install a previous release of VS Code by uninstalling your current version and then installing the download provided at the top of a specific release notes page. Note: On Linux: If the VS Code repository was installed correctly then your system package manager should handle auto-updating in the same way as other packages on the system. See Installing VS Code on Linux . Opt out of extension updates By default, VS Code will also auto-update extensions as new versions become available. If you do not want extensions to automatically update, you can clear the Extensions: Auto Update check box in the Settings editor ( kb(workbench.action.openSettings) ). If you use the JSON editor to modify your settings, add the following line: \"extensions.autoUpdate\": false Licensing Location You can find the VS Code licenses, third party notices and Chromium Open Source credit list under your VS Code installation location resources\\app folder. VS Code's ThirdPartyNotices.txt , Chromium's Credits_*.html , and VS Code's English language LICENSE.txt are available under resources\\app . Localized versions of LICENSE.txt by Language ID are under resources\\app\\licenses . Why does Visual Studio Code have a different license than the vscode GitHub repository? To learn why Visual Studio Code, the product, has a different license than the open-source vscode GitHub repository , see issue #60 for a detailed explanation. What is the difference between the vscode repository and the Microsoft Visual Studio Code distribution? The github.com/microsoft/vscode repository ( Code - OSS ) is where we develop the Visual Studio Code product. Not only do we write code and work on issues there, we also publish our roadmap and monthly iteration and endgame plans. The source code is available to everyone under a standard MIT license . Visual Studio Code is a distribution of the Code - OSS repository with Microsoft specific customizations (including source code), released under a traditional Microsoft product license . See the Visual Studio Code and 'Code - OSS' Differences article for more details. What does \"Built on Open Source\" mean? Microsoft Visual Studio Code is a Microsoft licensed distribution of 'Code - OSS' that includes Microsoft proprietary assets (such as icons) and features (Visual Studio Marketplace integration, small aspects of enabling Remote Development). While these additions make up a very small percentage of the overall distribution code base, it is more accurate to say that Visual Studio Code is \"built\" on open source, rather than \"is\" open source, because of these differences. More information on what each distribution includes can be found in the Visual Studio Code and 'Code - OSS' Differences article. How do I find the license for an extension? Most extensions link to their license on their Marketplace page or in the overview section, when you select an extension in the Extensions view. For example: If you don't find a link to the license, you may find a license in the extension's repository if it is public, or you can contact the extension author through the Q & A section of the Marketplace. Are all VS Code extensions open source? Extension authors are free to choose a license that fits their business needs. While many extension authors have opted to release their source code under an open-source license, some extensions like Wallaby.js , Google Cloud Code , and the VS Code Remote Development extensions use proprietary licenses. At Microsoft, we open source our extensions whenever possible. However, reliance on existing proprietary source code or libraries, source code that crosses into Microsoft licensed tools or services (for example Visual Studio), and business model differences across the entirety of Microsoft will result in some extensions using a proprietary license. You can find a list of Microsoft contributed Visual Studio Code extensions and their licenses in the Microsoft Extension Licenses article. How do I find the version? You can find the VS Code version information in the About dialog box. On macOS, go to Code > About Visual Studio Code . On Windows and Linux, go to Help > About . The VS Code version is the first Version number listed and has the version format 'major.minor.release', for example '1.27.0'. Previous release versions You can find links to some release downloads at the top of a version's release notes: If you need a type of installation not listed there, you can manually download via the following URLs: Download type URL Windows 64 bit System installer https://update.code.visualstudio.com/{version}/win32-x64/stable Windows 64 bit User installer https://update.code.visualstudio.com/{version}/win32-x64-user/stable Windows 64 bit zip https://update.code.visualstudio.com/{version}/win32-x64-archive/stable Windows 64 bit ARM System installer https://update.code.visualstudio.com/{version}/win32-arm64/stable Windows 64 bit ARM User installer https://update.code.visualstudio.com/{version}/win32-arm64-user/stable Windows 64 bit ARM zip https://update.code.visualstudio.com/{version}/win32-arm64-archive/stable Windows 32 bit System installer https://update.code.visualstudio.com/{version}/win32/stable Windows 32 bit User installer https://update.code.visualstudio.com/{version}/win32-user/stable Windows 32 bit zip https://update.code.visualstudio.com/{version}/win32-archive/stable macOS https://update.code.visualstudio.com/{version}/darwin/stable Linux 64 bit https://update.code.visualstudio.com/{version}/linux-x64/stable Linux 64 bit debian https://update.code.visualstudio.com/{version}/linux-deb-x64/stable Linux 64 bit rpm https://update.code.visualstudio.com/{version}/linux-rpm-x64/stable Linux 64 bit snap https://update.code.visualstudio.com/{version}/linux-snap-x64/stable Linux ARM https://update.code.visualstudio.com/{version}/linux-armhf/stable Linux ARM debian https://update.code.visualstudio.com/{version}/linux-deb-armhf/stable Linux ARM rpm https://update.code.visualstudio.com/{version}/linux-rpm-armhf/stable Linux 64 bit ARM https://update.code.visualstudio.com/{version}/linux-arm64/stable Linux 64 bit ARM debian https://update.code.visualstudio.com/{version}/linux-deb-arm64/stable Linux 64 bit ARM rpm https://update.code.visualstudio.com/{version}/linux-rpm-arm64/stable Substitute the specific release you want in the {version} placeholder. For example, to download the Linux ARM debian version for 1.50.1, you would use https://update.code.visualstudio.com/1.50.1/linux-deb-armhf/stable You can use the version string latest , if you'd like to always download the latest VS Code stable version. Prerelease versions Want an early peek at new VS Code features? You can try prerelease versions of VS Code by installing the \"Insiders\" build. The Insiders build installs side by side to your stable VS Code install and has isolated settings, configurations, and extensions. The Insiders build is updated nightly so you'll get the latest bug fixes and feature updates from the day before. To install the Insiders build, go to the Insiders download page . Where can I find the Visual Studio Code icons? Are there guidelines for using the icons and names? You can download the official Visual Studio Code icons and read the usage guidelines at Icons and names usage guidelines . What is a VS Code \"workspace\"? A VS Code \"workspace\" is usually just your project root folder. VS Code uses the \"workspace\" concept in order to scope project configurations such as project-specific settings as well as config files for debugging and tasks . Workspace files are stored at the project root in a .vscode folder. You can also have more than one root folder in a VS Code workspace through a feature called Multi-root workspaces . You can learn more in the What is a VS Code \"workspace\"? article. Can I run a portable version of VS Code? Yes, VS Code has a Portable Mode that lets you keep settings and data in the same location as your installation, for example, on a USB drive. Report an issue with a VS Code extension For bugs, feature requests or to contact an extension author, you should use the links available in the Visual Studio Code Marketplace or use Help: Report Issue from the Command Palette. However, if there is an issue where an extension does not follow our code of conduct, for example it includes profanity, pornography or presents a risk to the user, then we have an email alias to report the issue . Once the mail is received, our Marketplace team will look into an appropriate course of action, up to and including unpublishing the extension. VS Code gets unresponsive right after opening a folder When you open a folder, VS Code will search for typical project files to offer you additional tooling (for example, the solution picker in the Status bar to open a solution). If you open a folder with lots of files, the search can take a large amount of time and CPU resources during which VS Code might be slow to respond. We plan to improve this in the future but for now you can exclude folders from the explorer via the files.exclude setting and they will not be searched for project files: \"files.exclude\": { \"**/largeFolder\": true } VS Code is blank? The Electron shell used by Visual Studio Code has trouble with some GPU (graphics processing unit) hardware acceleration. If VS Code is displaying a blank (empty) main window, you can try disabling GPU acceleration when launching VS Code by adding the Electron --disable-gpu command-line switch. code --disable-gpu Installation appears to be corrupt [Unsupported] VS Code does a background check to detect if the installation has been changed on disk and if so, you will see the text [Unsupported] in the title bar. This is done since some extensions directly modify (patch) the VS Code product in such a way that is semi-permanent (until the next update) and this can cause hard to reproduce issues. We are not trying to block VS Code patching, but we want to raise awareness that patching VS Code means you are running an unsupported version. Reinstalling VS Code will replace the modified files and silence the warning. You may also see the [Unsupported] message if VS Code files have been mistakenly quarantined or removed by anti-virus software (see issue #94858 for an example). Check your anti-virus software settings and reinstall VS Code to repair the missing files. Resolving Shell Environment is Slow (Error, Warning) This section applies to macOS and Linux environments only. When VS Code is launched from a terminal (for example, via code . ), it has access to environment settings defined in your .bashrc or .zshrc files. This means features like tasks or debug targets also have access to those settings. However, when launching from your platform's user interface (for example, the VS Code icon in the macOS dock), you normally are not running in the context of a shell and you don't have access to those environment settings. This means that depending on how you launch VS Code, you may not have the same environment. To work around this, when launched via a UI gesture, VS Code will start a small process to run (or \"resolve\") the shell environment defined in your .bashrc or .zshrc files. If your startup file takes a long time to process (more than 3 seconds), you will see the following warning: If, after 10 seconds, the shell environment has still not been resolved, VS Code will abort the \"resolve\" process, launch without your shell's environment settings, and you will see the following error: The easiest way to investigate delays in your startup file is to: Open your shell's startup file (for example, in VS Code by typing ~/.bashrc or ~/.zshrc in quick open). Selectively comment out potentially long running operations. Save and fully restart VS Code until the warning or error disappears. Technical Support You can ask questions and search for answers on Stack Overflow and enter issues and feature requests directly in our GitHub repository . If you'd like to contact a professional support engineer, you can open a ticket with the Microsoft assisted support team ."
  },
  "guides/vscode/supporting/oss-extensions.html": {
    "href": "guides/vscode/supporting/oss-extensions.html",
    "title": "Microsoft Extension Licenses | Fountain of Knowledge",
    "keywords": "Microsoft Extension Licenses Microsoft follows a policy of open sourcing its extensions whenever possible. However, reliance on existing proprietary source code or libraries, source code that crosses into Microsoft licensed tools or services (for example Visual Studio), and business model differences across the entirety of Microsoft results in some extensions using a proprietary license. We continue to have a heavy investment and commitment to open source, but we also believe that transparency is important to the health of the Visual Studio Code community. As more and more teams in Microsoft contribute extensions, we realize that it can be difficult to keep track of which extensions are open source and which are not. To help, the following table is a list of Microsoft contributed extensions in the Marketplace, their published licenses, and whether their source code is available. Given the rate new extensions are being released from an increasing number of teams, this list may not be complete. The list does not include contributions published by individual Microsoft employees to the community on their own time. Microsoft Extensions (as of May 2019) Extension Source Code Available License Ansible ✔ MIT Arduino ✔ MIT Atom Keymap ✔ MIT AutoRest ✔ MIT Azure Account ✔ MIT Azure App Service ✔ MIT Azure Application Insights Microsoft Azure Blockchain Development Kit for Ethereum ✔ MIT Azure Cache ✔ MIT Azure CLI Tools ✔ MIT Azure Databases ✔ MIT Azure Data Lake Tools Microsoft Azure Data Studio Debugger ✔ MIT Azure Dev Spaces Microsoft Azure Event Grid ✔ MIT Azure Functions ✔ MIT Azure HDInsight Tools Microsoft Azure IoT Edge ✔ MIT Azure IoT Hub Toolkit ✔ MIT Azure IoT Workbench ✔ MIT Azure Logic Apps ✔ MIT Azure Machine Learning Microsoft Azure Pipelines ✔ MIT Azure Repos ✔ MIT Azure Resource Manager ✔ MIT Azure Storage ✔ MIT Azure Stream Analytics Tools Microsoft Azure Terraform ✔ MIT C++ Microsoft C# ✔ ( Repo ) Microsoft Cordova Tools ✔ ( Repo ) Microsoft Debugger for Chrome ✔ MIT Debugger for Edge ✔ MIT Docker ✔ MIT docs-article-template ✔ MIT docs-markdown ✔ MIT docs-preview ✔ MIT docs-yaml ✔ MIT Duffle ✔ MIT Duffle Coat ✔ MIT Dynamics AL Language Microsoft GitHub Issues ✔ MIT IntelliCode Microsoft Java Debugger ✔ MIT Project Manager for Java ✔ MIT Java for Dev Spaces Microsoft Java Test Runner ✔ MIT JavaScript Atom Grammar ✔ ( Repo ) Microsoft JSCS Linting ✔ MIT Kubernetes ✔ MIT Latest TypeScript and Javascript Grammar ✔ MIT Live Share Microsoft Live Share Audio Microsoft Markdown Theme Kit ✔ MIT Maven for Java ✔ MIT Mezzurite ✔ MIT Mono Debug ✔ MIT Node Debug ✔ MIT Node Debug (legacy) ✔ MIT Nodepad++ Keymap ✔ MIT OpenAPI Code Client ✔ MIT PostgreSQL ✔ MIT PowerShell ✔ MIT Predawn Theme ✔ MIT Pyright ✔ MIT Python ✔ MIT React Native Tools ✔ ( Repo ) Microsoft Remote - Containers Microsoft Remote - SSH Microsoft Remote - WSL Microsoft Reference Search View ✔ MIT Resharper 9 Keybindings ✔ MIT Service Fabric Reliable Services ✔ MIT Spring Boot Dashboard ✔ MIT Spring Initializr Java Support ✔ MIT SQL Server ✔ MIT Sublime Text Keymapping ✔ MIT Tomorrow and Tomorrow Night Theme ✔ MIT TSLint ✔ MIT Visual Studio Keymap ✔ MIT Word Count ✔ MIT 1337 Theme ✔ MIT 3024 Theme ✔ MIT"
  },
  "guides/vscode/supporting/requirements.html": {
    "href": "guides/vscode/supporting/requirements.html",
    "title": "Requirements for Visual Studio Code | Fountain of Knowledge",
    "keywords": "Requirements for Visual Studio Code Hardware Visual Studio Code is a small download (< 200 MB) and has a disk footprint of < 500 MB. VS Code is lightweight and should easily run on today's hardware. We recommend: 1.6 GHz or faster processor 1 GB of RAM Platforms VS Code has been tested on the following platforms: OS X El Capitan (10.11+) Windows 7 (with .NET Framework 4.5.2), 8.0, 8.1 and 10 (32-bit and 64-bit) Linux (Debian): Ubuntu Desktop 16.04, Debian 9 Linux (Red Hat): Red Hat Enterprise Linux 7, CentOS 8, Fedora 24 Additional Windows requirements Microsoft .NET Framework 4.5.2 is required for VS Code. If you are using Windows 7, please make sure .NET Framework 4.5.2 is installed. Additional Linux requirements GLIBCXX version 3.4.21 or later GLIBC version 2.15 or later For a list of currently known issues, see our FAQ ."
  },
  "guides/vscode/supporting/troubleshoot-terminal-launch.html": {
    "href": "guides/vscode/supporting/troubleshoot-terminal-launch.html",
    "title": "Troubleshoot Terminal launch failures | Fountain of Knowledge",
    "keywords": "Troubleshoot Terminal launch failures If you are new to using the Visual Studio Code Integrated Terminal, you can learn more in the Integrated Terminal user guide. There you can read how to configure the terminal, as well as review answers to common questions . Below are specific troubleshooting steps, if the user guide hasn't helped you diagnose the launch failure. The troubleshooting steps, such as checking your settings and enabling logging, apply to all platforms that support VS Code; macOS, Linux, and Windows. Note : If you're on Windows, review the common issues on Windows section first. Troubleshooting steps To troubleshoot Integrated Terminal launch failures in Visual Studio Code, follow these steps to diagnose issues: Check your user settings. Review these terminal.integrated settings that could affect the launch: terminal.integrated.shell.{platform} - The path of the shell that the terminal uses. terminal.integrated.shellArgs.{platform} - The command-line arguments when launching the shell process. terminal.integrated.cwd - The current working directory (cwd) for the shell process. terminal.integrated.env.{platform} - Environment variables that will be added to the shell process. terminal.integrated.inheritEnv - Whether new shells should inherit their environment from VS Code. terminal.integrated.automationShell.{platform} - Shell path for automation-related terminal usage like tasks and debug. terminal.integrated.splitCwd - Controls the current working directory a split terminal starts with. terminal.integrated.windowsEnableConpty - Whether to use ConPTY for Windows terminal process communication. You can review settings in the Settings editor ( File > Preferences > Settings ) and search for specific settings by the setting ID. A quick way to check if you have changed settings that you might not be aware of, is to use the @modified filter in the Settings editor. Most Integrated Terminal settings will need to be modified directly in your user settings.json JSON file. You can open settings.json via the Edit in settings.json link in the Settings editor or with the Preferences: Open Settings (JSON) command from the Command Palette ( kb(workbench.action.showCommands) ). Test your shell directly. Try running your designated integrated terminal shell outside VS Code from an external terminal or command prompt. Some terminal launch failures may be due to your shell installation and are not specific to VS Code. The exit codes displayed come from the shell and you may be able to diagnose shell issues by searching on the internet for the specific shell and exit code. Use the most recent version of VS Code. Each VS Code monthly release has many updates and fixes and may include integrated terminal improvements. You can check your VS Code version via Help > About (on macOS Code > About Visual Studio Code ). To find the latest version of VS Code, go to the VS Code release notes . You may also want to check that you have installed the latest version of your shell. Enable trace logging. You can enable trace logging and capture a log when launching the terminal. Logging often reveals what is wrong as all arguments used to create the terminal process/pty are recorded. Bad shell names, arguments, or environment variables can cause the terminal to not launch. Keep this log for later if your problem isn't solved. Additional troubleshooting steps If none of these steps helped solve the issue, you can also try: Ask about it on Stack Overflow , often launch issues are related to environment setup and not a problem with VS Code. If the terminal is being launched from an extension, report the issue to the extension by opening the issue reporter (Help > Report Issue) and set File On = \"An Extension\" If you believe it to be a bug with VS Code, report the issue using the issue reporter ( Help > Report Issue ). The issue reporter will autofill relevant information, see Creating great terminal issues for what else to include in the report. If you're on Windows 10 1809 (build 17763) or below, the issue is related to the legacy \"winpty\" backend. Upgrading to Windows 1903 (build 18362) will move you onto the new \"conpty\" backend that is built by Microsoft and could fix your problem. Exit codes The exit codes displayed in the terminal launch failure notification are returned from the shell process and are not generated by VS Code. There are many available shells that can be used in the terminal and hundreds of possible exit codes. Try searching on the internet for your specific shell and exit code (for example, \"PowerShell 4294901760\") and you may find specific suggestions or known issues related to your terminal launch failure. Common issues on Windows Make sure compatibility mode is disabled When upgrading to Windows 10, some apps may have compatibility mode turned on automatically. When this happens with VS Code, the terminal breaks as it does some low level things to enable the emulation it uses. You can check and disable compatibility mode by right-clicking on the VS Code executable and selecting properties, then uncheck the Run this program in compatibility mode option in the compatibility tab. The terminal exited with code 1 on Windows 10 (with WSL as the default shell) This can happen if Windows Subsystem for Linux (WSL) is not set up with a valid default Linux distribution. Note: 'docker-desktop-data' is not a valid distribution. Open PowerShell and enter wslconfig.exe /l to confirm WSL is installed correctly and list the currently available Linux distributions within your system. Confirm a valid distribution has (default) next to it. To change the default distribution, enter wslconfig.exe /setdefault \"distributionNameAsShownInList\" The terminal not working when running the 32-bit Windows client on 64-bit Windows? The easy fix for this issue is to use the 64-bit version. If you must use the 32-bit version, you need to use the sysnative path when configuring your shell path instead of System32. Adding this setting should fix the issue: \"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\Sysnative\\\\cmd.exe\" A native exception occurred Typically this error occurs due to anti-virus software intercepting and blocking the winpty/conpty components from creating the terminal process. To work around this error, you can exclude the following file from your anti-virus scanning: {install_path}\\resources\\app\\node_modules.asar.unpacked\\node-pty\\build\\Release\\winpty.dll {install_path}\\resources\\app\\node_modules.asar.unpacked\\node-pty\\build\\Release\\winpty-agent.exe {install_path}\\resources\\app\\node_modules.asar.unpacked\\node-pty\\build\\Release\\conpty.node {install_path}\\resources\\app\\node_modules.asar.unpacked\\node-pty\\build\\Release\\conpty_console_list.node Reporting this issue to the Anti-virus team can also help stamp out the issue all together. Terminal exits with code 3221225786 (or similar) This can happen when you have legacy console mode enabled in conhost's properties. To change this, open cmd.exe from the start menu, right-click the title bar, go to Properties and under the Options tab, uncheck Use legacy console ."
  },
  "guides/vscode/typescript/typescript-compiling.html": {
    "href": "guides/vscode/typescript/typescript-compiling.html",
    "title": "Compiling TypeScript | Fountain of Knowledge",
    "keywords": "Compiling TypeScript TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It offers classes, modules, and interfaces to help you build robust components. The TypeScript language specification has full details about the language. Install the TypeScript compiler Visual Studio Code includes TypeScript language support but does not include the TypeScript compiler, tsc . You will need to install the TypeScript compiler either globally or in your workspace to transpile TypeScript source code to JavaScript ( tsc HelloWorld.ts ). The easiest way to install TypeScript is through npm, the Node.js Package Manager . If you have npm installed, you can install TypeScript globally ( -g ) on your computer by: npm install -g typescript You can test your install by checking the version or help. tsc --version tsc --help Another option is to install the TypeScript compiler locally in your project ( npm install --save-dev typescript ) and has the benefit of avoiding possible interactions with other TypeScript projects you may have. Compiler versus language service It is important to keep in mind that VS Code's TypeScript language service is separate from your installed TypeScript compiler. You can see the VS Code's TypeScript version in the Status Bar when you open a TypeScript file. Later in the article, we'll discuss how you can change the version of TypeScript language service that VS Code uses. tsconfig.json Typically the first step in any new TypeScript project is to add a tsconfig.json file. A tsconfig.json file defines the TypeScript project settings , such as the compiler options and the files that should be included. To do this, open up the folder where you want to store your source and add a new file named tsconfig.json . Once in this file, IntelliSense ( kb(editor.action.triggerSuggest) ) will help you along the way. A simple tsconfig.json looks like this for ES5, CommonJS modules and source maps: { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"sourceMap\": true } } Now when you create a .ts file as part of the project we will offer up rich editing experiences and syntax validation. Transpile TypeScript into JavaScript VS Code integrates with tsc through our integrated task runner . We can use this to transpile .ts files into .js files. Another benefit of using VS Code tasks is that you get integrated error and warning detection displayed in the Problems panel. Let's walk through transpiling a simple TypeScript Hello World program. Step 1: Create a simple TS file Open VS Code on an empty folder and create a helloworld.ts file, place the following code in that file... let message : string = \"Hello World\"; console.log(message); To test that you have the TypeScript compiler tsc installed correctly and a working Hello World program, open a terminal and type tsc helloworld.ts . You can use the Integrated Terminal ( kb(workbench.action.terminal.toggleTerminal) ) directly in VS Code. You should now see the transpiled helloworld.js JavaScript file, which you can run if you have Node.js installed, by typing node helloworld.js . Step 2: Run the TypeScript build Execute Run Build Task ( kb(workbench.action.tasks.build) ) from the global Terminal menu. If you created a tsconfig.json file in the earlier section, this should present the following picker: Select the tsc: build entry. This will produce a HelloWorld.js and HelloWorld.js.map file in the workspace. If you selected tsc: watch , the TypeScript compiler watches for changes to your TypeScript files and runs the transpiler on each change. Under the covers, we run the TypeScript compiler as a task. The command we use is: tsc -p . Step 3: Make the TypeScript Build the default You can also define the TypeScript build task as the default build task so that it is executed directly when triggering Run Build Task ( kb(workbench.action.tasks.build) ). To do so, select Configure Default Build Task from the global Terminal menu. This shows you a picker with the available build tasks. Select TypeScript tsc: build , which generates the following tasks.json file in a .vscode folder: { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"typescript\", \"tsconfig\": \"tsconfig.json\", \"problemMatcher\": [ \"$tsc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } Notice that the task has a group JSON object that sets the task kind to build and makes it the default. Now when you select the Run Build Task command or press ( kb(workbench.action.tasks.build) ), you are not prompted to select a task and your compilation starts. Tip: You can also run the program using VS Code's Run/Debug feature. Details about running and debugging Node.js applications in VS Code can be found in the Node.js tutorial Step 4: Reviewing build issues The VS Code task system can also detect build issues through a problem matcher . A problem matcher parses build output based on the specific build tool and provides integrated issue display and navigation. VS Code ships with many problem matchers and $tsc seen above in tasks.json is the problem matcher for TypeScript compiler output. As an example, if there was a simple error (extra 'g' in console.log ) in our TypeScript file, we may get the following output from tsc : HelloWorld.ts(3,17): error TS2339: Property 'logg' does not exist on type 'Console'. This would show up in the terminal panel ( kb(workbench.action.terminal.toggleTerminal) ) and selecting the Tasks - build tsconfig.json in the terminal view dropdown. You can see the error and warning counts in the Status Bar. Click on the error and warnings icon to get a list of the problems and navigate to them. You can also use the keyboard to open the list kb(workbench.actions.view.problems) . Tip: Tasks offer rich support for many actions. Check the Tasks topic for more information on how to configure them. JavaScript source map support TypeScript debugging supports JavaScript source maps. To generate source maps for your TypeScript files, compile with the --sourcemap option or set the sourceMap property in the tsconfig.json file to true . In-lined source maps (a source map where the content is stored as a data URL instead of a separate file) are also supported, although in-lined source is not yet supported. Output location for generated files Having the generated JavaScript file in the same folder at the TypeScript source will quickly get cluttered on larger projects. You can specify the output directory for the compiler with the outDir attribute. { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"outDir\": \"out\" } } Hiding derived JavaScript files When you are working with TypeScript, you often don't want to see generated JavaScript files in the File Explorer or in Search results. VS Code offers filtering capabilities with a files.exclude workspace setting and you can easily create an expression to hide those derived files: **/*.js: { \"when\": \"$(basename).ts\" } This pattern will match on any JavaScript file ( **/*.js ) but only if a sibling TypeScript file with the same name is present. The File Explorer will no longer show derived resources for JavaScript if they are compiled to the same location. Add the files.exclude setting with a filter in the workspace settings.json file, located in the .vscode folder at the root of the workspace. You can open the workspace settings.json via the Preferences: Open Workspace Settings (JSON) command from the Command Palette ( kb(workbench.action.showCommands) ). To exclude JavaScript files generated from both .ts and .tsx source files, use this expression: \"files.exclude\": { \"**/*.js\": { \"when\": \"$(basename).ts\" }, \"**/**.js\": { \"when\": \"$(basename).tsx\" } } This is a bit of a trick. The search glob pattern is used as a key. The settings above use two different glob patterns to provide two unique keys but the search will still match the same files. Using newer TypeScript versions VS Code ships with a recent stable version of the TypeScript language service and uses this by default to provide IntelliSense in your workspace. The workspace version of TypeScript is independent of the version of TypeScript you use to compile your *.ts files. You can just use VS Code's built-in TypeScript version for IntelliSense without worry for most common cases, but sometimes you may need to change the version of TypeScript VS Code uses for IntelliSense. Reasons for doing this include: Trying out the latest TypeScript features by switching to the TypeScript nightly build ( typescript@next ). Making sure you are using the same version of TypeScript for IntelliSense that you use to compile your code. The active TypeScript version and its install location are displayed in the Status Bar when viewing a TypeScript file: You have a few options if you want to change the default version of TypeScript in your workspace: Using the workspace version of TypeScript If your workspace has a specific TypeScript version, you can switch between the workspace version of TypeScript and the version that VS Code uses by default by opening a TypeScript or JavaScript file and clicking on the TypeScript version number in the Status Bar. A message box will appear asking you which version of TypeScript VS Code should use: Use this to switch between the version of TypeScript that comes with VS Code and the version of TypeScript in your workspace. You can also trigger the TypeScript version selector with the TypeScript: Select TypeScript Version command. VS Code will automatically detect workspace versions of TypeScript that are installed under node_modules in the root of your workspace. You can also explicitly tell VS Code which version of TypeScript to use by configuring the typescript.tsdk in your user or workspace settings . The typescript.tsdk setting should point to a directory containing the TypeScript tsserver.js file. You can find the TypeScript installation location using npm list -g typescript . The tsserver.js file is usually in the lib folder. For example: { \"typescript.tsdk\": \"/usr/local/lib/node_modules/typescript/lib\" } Tip: To get a specific TypeScript version, specify @version during npm install. For example, for TypeScript 3.6.0, you would use npm install --save-dev typescript@3.6.0 . To preview the next version of TypeScript, run npm install --save-dev typescript@next . Note that while typescript.tsdk points to the lib directory inside of typescript in these examples, the typescript directory must be a full TypeScript install that contains the TypeScript package.json file. You can also tell VS Code to use a specific version of TypeScript in a particular workspace by adding a typescript.tsdk workspace setting pointing to the directory of the tsserver.js file: { \"typescript.tsdk\": \"./node_modules/typescript/lib\" } The typescript.tsdk workspace setting only tells VS Code that a workspace version of TypeScript exists. To actually start using the workspace version for IntelliSense, you must run the TypeScript: Select TypeScript Version command and select the workspace version. Using TypeScript nightly builds The simplest way to try out the latest TypeScript features in VS Code is to install the JavaScript and TypeScript Nightly extension . This extension automatically replaces VS Code's built-in TypeScript version with the latest TypeScript nightly build. Just make sure you switch back to using VS Code's TypeScript version if you've configured your TypeScript version with the TypeScript: Select TypeScript Version command. Mixed TypeScript and JavaScript projects It is possible to have mixed TypeScript and JavaScript projects. To enable JavaScript inside a TypeScript project, you can set the allowJs property to true in the tsconfig.json . Tip: The tsc compiler does not detect the presence of a jsconfig.json file automatically. Use the –p argument to make tsc use your jsconfig.json file, e.g. tsc -p jsconfig.json . Working with large projects If you are working in a codebase with hundreds or thousands of TypeScript files, here are some steps you can take to improve both the editing experience in VS Code as well as compile times on the command line. Make sure your tsconfig only includes files you care about Use include or files in your project's tsconfig.json to make sure the project only includes the files that should be part of the project. More information on configuring your project's tsconfig.json . Break up your project using project references Instead of structuring your source code as a single large project, you can improve performance by breaking it up into smaller projects using project references . This allows TypeScript to load just a subset of your codebase at a time, instead of loading the entire thing. See the TypeScript documentation for details on how to use project references and best practices for working with them. Next steps Read on to find out about: Debugging TypeScript - Configure the debugger for your TypeScript project. Common questions How do I resolve a TypeScript \"Cannot compile external module\" error? If you get that error, resolve it by creating a tsconfig.json file in the root folder of your project. The tsconfig.json file lets you control how Visual Studio Code compiles your TypeScript code. For more information, see the tsconfig.json overview . Why do I get different errors and warnings with VS Code than when I compile my TypeScript project? VS Code ships with a recent stable version of the TypeScript language service and it may not match the version of TypeScript installed globally on your computer or locally in your workspace. For that reason, you may see differences between your compiler output and errors detected by the active TypeScript language service. See Using newer TypeScript versions for details on installing a matching TypeScript version. Can I use the version of TypeScript that ships with VS 2015? No, the TypeScript language service that ships with Visual Studio 2015 and 2017 isn't compatible with VS Code. You will need to install a separate version of TypeScript from npm . Why are some errors reported as warnings? By default, VS Code TypeScript displays code style issues as warnings instead of errors. This applies to: Variable is declared but never used Property is declared but its value is never read Unreachable code detected Unused label Fall through case in switch Not all code paths return a value Treating these as warnings is consistent with other tools, such as TSLint. These will still be displayed as errors when you run tsc from the command line. You can disable this behavior by setting \"typescript.reportStyleChecksAsWarnings\": false in your User settings ."
  },
  "guides/vscode/typescript/typescript-debugging.html": {
    "href": "guides/vscode/typescript/typescript-debugging.html",
    "title": "Debugging TypeScript | Fountain of Knowledge",
    "keywords": "Debugging TypeScript Visual Studio Code supports TypeScript debugging through its built-in Node.js debugger and Edge and Chrome debugger . JavaScript source map support TypeScript debugging supports JavaScript source maps. To generate source maps for your TypeScript files, compile with the --sourcemap option or set the sourceMap property in the tsconfig.json file to true . In-lined source maps (a source map where the content is stored as a data URL instead of a separate file) are also supported, although in-lined source is not yet supported. For a simple example of source maps in action, see the TypeScript tutorial , which shows debugging a simple \"Hello World\" Node.js application using the following tsconfig.json and VS Code default Node.js debugging configuration. { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"outDir\": \"out\", \"sourceMap\": true } } For more advanced debugging scenarios, you can create your own debug configuration launch.json file. To see the default configuration, go to the Run view ( kb(workbench.view.debug) ) and press the gear icon or Create a launch.json link to Configure or Fix 'launch.json' . This will create a launch.json file in a .vscode folder with default values detected in your project. { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"${workspaceFolder}/helloworld.ts\", \"preLaunchTask\": \"tsc: build - tsconfig.json\", \"outFiles\": [ \"${workspaceFolder}/out/**/*.js\" ] } ] } VS Code has determined the program to launch, helloworld.ts , included the build as a preLaunchTask , and told the debugger where to find the generated JavaScript files. There is full IntelliSense with suggestions and information for launch.json to help you learn about other debug configuration options. You can also add new debug configurations to launch.json with the Add Configuration button in the lower right. Also see Node.js Debugging for examples and further explanations. Mapping the output location If generated (transpiled) JavaScript files do not live next to their source, you can help the VS Code debugger locate them by setting the outFiles attribute in the launch configuration. Whenever you set a breakpoint in the original source, VS Code tries to find the generated source by searching the files specified by glob patterns in outFiles . Client-side debugging TypeScript is great for writing client-side code as well as Node.js applications and you can debug client-side source code with the built-in Edge and Chrome debugger . We'll create a tiny web application to show client-side debugging in action. Create a new folder HelloWeb and add three files: helloweb.ts , helloweb.html , and tsconfig.json with the following content\" helloweb.ts let message : string = \"Hello Web\"; document.body.innerHTML = message; helloweb.html <!DOCTYPE html> <html> <head><title>TypeScript Hello Web</title></head> <body> <script src=\"out/helloweb.js\"></script> </body> </html> tsconfig.json { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"outDir\": \"out\", \"sourceMap\": true } } Run tsc to build the app and then test by opening helloweb.html in your browser (you can right-click helloweb.html in the File Explorer and select Copy Path to paste into your browser). In the Run view, press the gear icon to create a launch.json file selecting Edge: launch as the debugger, or Chrome if you prefer. Update the launch.json to specify the local file URL to helloweb.html : { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"pwa-msedge\", \"request\": \"launch\", \"name\": \"Launch Edge against localhost\", \"url\": \"file:///C:/Users/username/deleteMe/HelloWeb/helloweb.html\", \"webRoot\": \"${workspaceFolder}\" } ] } The Run view configuration dropdown will now show the new configuration Launch Edge against localhost . If you run that configuration, your browser will launch with your web page. Open helloweb.ts in the editor and click the left gutter to add a breakpoint (it will be displayed as a red circle). Press kb(workbench.action.debug.start) to start the debug session, which launches the browser and hits your breakpoint in helloweb.ts . Common questions Cannot launch program because corresponding JavaScript cannot be found You've likely not set \"sourceMap\": true in your tsconfig.json or outFiles in your launch.json and the VS Code Node.js debugger can't map your TypeScript source code to the running JavaScript. Turn on source maps and rebuild your project."
  },
  "guides/vscode/typescript/typescript-tutorial.html": {
    "href": "guides/vscode/typescript/typescript-tutorial.html",
    "title": "TypeScript tutorial in Visual Studio Code | Fountain of Knowledge",
    "keywords": "TypeScript tutorial in Visual Studio Code TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It offers classes, modules, and interfaces to help you build robust components. The TypeScript language specification has full details about the language. Install the TypeScript compiler Visual Studio Code includes TypeScript language support but does not include the TypeScript compiler, tsc . You will need to install the TypeScript compiler either globally or in your workspace to transpile TypeScript source code to JavaScript ( tsc HelloWorld.ts ). The easiest way to install TypeScript is through npm, the Node.js Package Manager . If you have npm installed, you can install TypeScript globally ( -g ) on your computer by: npm install -g typescript You can test your install by checking the version. tsc --version Hello World Let's start with a simple Hello World Node.js example. Create a new folder HelloWorld and launch VS Code. mkdir HelloWorld cd HelloWorld code . From the File Explorer, create a new file called helloworld.ts . Now add the following TypeScript code. You'll notice the TypeScript keyword let and the string type declaration. let message : string = \"Hello World\"; console.log(message); To compile your TypeScript code, you can open the Integrated Terminal ( kb(workbench.action.terminal.toggleTerminal) ) and type tsc helloworld.ts . This will compile and create a new helloworld.js JavaScript file. If you have Node.js installed, you can run node helloworld.js . If you open helloworld.js , you'll see that it doesn't look very different from helloworld.ts . The type information has been removed and let is now var . var message = \"Hello World\"; console.log(message); IntelliSense In VS Code, you can see that you get language features such as syntax highlighting and bracket matching. When you were typing in the editor, you may have noticed IntelliSense, the smart code completions and suggestions provided by VS Code and the TypeScript language server. Below you can see the methods of console When you select a method, you then get parameter help and can always get hover information. tsconfig.json So far in this tutorial, you have been relying on the TypeScript compiler's default behavior to compile your TypeScript source code. You can modify the TypeScript compiler options by adding a tsconfig.json file that defines the TypeScript project settings such as the compiler options and the files that should be included. Add a simple tsconfig.json which set the options to compile to ES5 and use CommonJS modules . { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\" } } When editing tsconfig.json , IntelliSense ( kb(editor.action.triggerSuggest) ) will help you along the way. By default, TypeScript includes all the .ts files in the current folder and subfolders if the files attribute isn't included, so we don't need to list helloworld.ts explicitly. Now to build from the terminal, you can just type tsc and the TypeScript compiler knows to look at your tsconfig.json for project settings and compiler options. Change the build output Having the generated JavaScript file in the same folder as the TypeScript source will quickly get cluttered on larger projects, so you can specify the output directory for the compiler with the outDir attribute. { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"outDir\": \"out\" } } Delete helloworld.js and run the command tsc with no options. You will see that helloworld.js is now placed in the out directory. See Compiling TypeScript to learn about other features of the TypeScript language service and how to use tasks to run your builds directly from VS Code. Error checking TypeScript helps you avoid common programming mistakes through strong type checking. For example, if you assign a number to message , the TypeScript compiler will complain with 'error TS2322: Type '2' is not assignable to type 'string' . You can see type checking errors in VS Code both in the editor (red squiggles with hover information) and the Problems panel ( kb(workbench.actions.view.problems) ). The [ts] prefix lets you know this error is coming from the TypeScript language service. Quick Fixes The TypeScript language service has a powerful set of diagnostics to find common coding issues. For example, it can analyze your source code and detect unreachable code which is displayed as dimmed in the editor. If you hover over the line of source code, you'll see a hover explaining and if you place your cursor on the line, you'll get a Quick Fix lightbulb. Clicking on the lightbulb or pressing kb(editor.action.quickFix) brings up the Quick Fix menu where you can select the Remove unreachable code fix. Debugging VS Code has built-in support for TypeScript debugging. To support debugging TypeScript in combination with the executing JavaScript code, VS Code relies on source maps for the debugger to map between the original TypeScript source code and the running JavaScript. You can create source maps during the build by setting \"sourceMap\": true in your tsconfig.json . { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"outDir\": \"out\", \"sourceMap\": true } } Rebuild by running tsc and you should now have a helloworld.js.map in the out directory next to helloworld.js . With helloworld.ts open in the editor, press kb(workbench.action.debug.start) . If you have other debugger extensions installed, you need to select Node.js from the dropdown. The debugger will start a session, run your code, and display the \"Hello World\" message in the Debug console panel. In helloworld.ts , set a breakpoint by clicking on the left gutter of the editor. You will see a red circle if the breakpoint is set. Press kb(workbench.action.debug.start) again. Execution will stop when the breakpoint is hit and you'll be able to see debugging information such as variable values and the call stack in the Run view ( kb(workbench.view.debug) ). See Debugging TypeScript to learn more about VS Code's built-in debugging support for TypeScript and how you can configure the debugger for your project scenarios. Next steps This tutorial was a quick introduction to using VS Code for TypeScript development. Read on to learn more about using VS Code's compiling and debugging support for TypeScript: Compiling TypeScript - Use VS Code's powerful task system for compiling TypeScript. Debugging TypeScript - Configure the debugger for your TypeScript project. Common questions Cannot launch program because corresponding JavaScript cannot be found You've likely not set \"sourceMap\": true in your tsconfig.json and the VS Code Node.js debugger can't map your TypeScript source code to the running JavaScript. Turn on source maps and rebuild your project."
  },
  "index.html": {
    "href": "index.html",
    "title": "Fountain of Knowledge | Fountain of Knowledge",
    "keywords": "Fountain of Knowledge"
  },
  "README.html": {
    "href": "README.html",
    "title": "Fountain of Knowledge | Fountain of Knowledge",
    "keywords": "Fountain of Knowledge"
  }
}